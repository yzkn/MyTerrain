var U2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, K0 = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v4.7.1/LICENSE.txt
 */
(function(a, d) {
  (function(l, m) {
    a.exports = m();
  })(U2, function() {
    var l = {}, m = {};
    function w(g, s, D) {
      if (m[g] = D, g === "index") {
        var k = "var sharedModule = {}; (" + m.shared + ")(sharedModule); (" + m.worker + ")(sharedModule);", M = {};
        return m.shared(M), m.index(l, M), typeof window < "u" && l.setWorkerUrl(window.URL.createObjectURL(new Blob([k], { type: "text/javascript" }))), l;
      }
    }
    w("shared", ["exports"], function(g) {
      function s(i, t, n, u) {
        return new (n || (n = Promise))(function(f, _) {
          function b(L) {
            try {
              C(u.next(L));
            } catch (R) {
              _(R);
            }
          }
          function E(L) {
            try {
              C(u.throw(L));
            } catch (R) {
              _(R);
            }
          }
          function C(L) {
            var R;
            L.done ? f(L.value) : (R = L.value, R instanceof n ? R : new n(function(U) {
              U(R);
            })).then(b, E);
          }
          C((u = u.apply(i, t || [])).next());
        });
      }
      function D(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var k = M;
      function M(i, t) {
        this.x = i, this.y = t;
      }
      M.prototype = { clone: function() {
        return new M(this.x, this.y);
      }, add: function(i) {
        return this.clone()._add(i);
      }, sub: function(i) {
        return this.clone()._sub(i);
      }, multByPoint: function(i) {
        return this.clone()._multByPoint(i);
      }, divByPoint: function(i) {
        return this.clone()._divByPoint(i);
      }, mult: function(i) {
        return this.clone()._mult(i);
      }, div: function(i) {
        return this.clone()._div(i);
      }, rotate: function(i) {
        return this.clone()._rotate(i);
      }, rotateAround: function(i, t) {
        return this.clone()._rotateAround(i, t);
      }, matMult: function(i) {
        return this.clone()._matMult(i);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(i) {
        return this.x === i.x && this.y === i.y;
      }, dist: function(i) {
        return Math.sqrt(this.distSqr(i));
      }, distSqr: function(i) {
        var t = i.x - this.x, n = i.y - this.y;
        return t * t + n * n;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(i) {
        return Math.atan2(this.y - i.y, this.x - i.x);
      }, angleWith: function(i) {
        return this.angleWithSep(i.x, i.y);
      }, angleWithSep: function(i, t) {
        return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t);
      }, _matMult: function(i) {
        var t = i[2] * this.x + i[3] * this.y;
        return this.x = i[0] * this.x + i[1] * this.y, this.y = t, this;
      }, _add: function(i) {
        return this.x += i.x, this.y += i.y, this;
      }, _sub: function(i) {
        return this.x -= i.x, this.y -= i.y, this;
      }, _mult: function(i) {
        return this.x *= i, this.y *= i, this;
      }, _div: function(i) {
        return this.x /= i, this.y /= i, this;
      }, _multByPoint: function(i) {
        return this.x *= i.x, this.y *= i.y, this;
      }, _divByPoint: function(i) {
        return this.x /= i.x, this.y /= i.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var i = this.y;
        return this.y = this.x, this.x = -i, this;
      }, _rotate: function(i) {
        var t = Math.cos(i), n = Math.sin(i), u = n * this.x + t * this.y;
        return this.x = t * this.x - n * this.y, this.y = u, this;
      }, _rotateAround: function(i, t) {
        var n = Math.cos(i), u = Math.sin(i), f = t.y + u * (this.x - t.x) + n * (this.y - t.y);
        return this.x = t.x + n * (this.x - t.x) - u * (this.y - t.y), this.y = f, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, M.convert = function(i) {
        return i instanceof M ? i : Array.isArray(i) ? new M(i[0], i[1]) : i;
      };
      var q = D(k), O = z;
      function z(i, t, n, u) {
        this.cx = 3 * i, this.bx = 3 * (n - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (u - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = t, this.p2x = n, this.p2y = u;
      }
      z.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, t) {
        if (t === void 0 && (t = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var n = i, u = 0; u < 8; u++) {
          var f = this.sampleCurveX(n) - i;
          if (Math.abs(f) < t) return n;
          var _ = this.sampleCurveDerivativeX(n);
          if (Math.abs(_) < 1e-6) break;
          n -= f / _;
        }
        var b = 0, E = 1;
        for (n = i, u = 0; u < 20 && (f = this.sampleCurveX(n), !(Math.abs(f - i) < t)); u++) i > f ? b = n : E = n, n = 0.5 * (E - b) + b;
        return n;
      }, solve: function(i, t) {
        return this.sampleCurveY(this.solveCurveX(i, t));
      } };
      var pe = D(O);
      let le, se;
      function ee() {
        return le == null && (le = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), le;
      }
      function fe() {
        if (se == null && (se = !1, ee())) {
          const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
          if (t) {
            for (let u = 0; u < 5 * 5; u++) {
              const f = 4 * u;
              t.fillStyle = `rgb(${f},${f + 1},${f + 2})`, t.fillRect(u % 5, Math.floor(u / 5), 1, 1);
            }
            const n = t.getImageData(0, 0, 5, 5).data;
            for (let u = 0; u < 5 * 5 * 4; u++) if (u % 4 != 3 && n[u] !== u) {
              se = !0;
              break;
            }
          }
        }
        return se || !1;
      }
      function Te(i, t, n, u) {
        const f = new pe(i, t, n, u);
        return (_) => f.solve(_);
      }
      const ze = Te(0.25, 0.1, 0.25, 1);
      function qe(i, t, n) {
        return Math.min(n, Math.max(t, i));
      }
      function at(i, t, n) {
        const u = n - t, f = ((i - t) % u + u) % u + t;
        return f === t ? n : f;
      }
      function Ie(i, ...t) {
        for (const n of t) for (const u in n) i[u] = n[u];
        return i;
      }
      let Ae = 1;
      function me(i, t, n) {
        const u = {};
        for (const f in i) u[f] = t.call(this, i[f], f, i);
        return u;
      }
      function ve(i, t, n) {
        const u = {};
        for (const f in i) t.call(this, i[f], f, i) && (u[f] = i[f]);
        return u;
      }
      function X(i) {
        return Array.isArray(i) ? i.map(X) : typeof i == "object" && i ? me(i, X) : i;
      }
      const re = {};
      function xe(i) {
        re[i] || (typeof console < "u" && console.warn(i), re[i] = !0);
      }
      function ye(i, t, n) {
        return (n.y - i.y) * (t.x - i.x) > (t.y - i.y) * (n.x - i.x);
      }
      function Ve(i) {
        return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope;
      }
      let He = null;
      function Ze(i) {
        return typeof ImageBitmap < "u" && i instanceof ImageBitmap;
      }
      const je = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function Je(i, t, n, u, f) {
        return s(this, void 0, void 0, function* () {
          if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
          const _ = new VideoFrame(i, { timestamp: 0 });
          try {
            const b = _ == null ? void 0 : _.format;
            if (!b || !b.startsWith("BGR") && !b.startsWith("RGB")) throw new Error(`Unrecognized format ${b}`);
            const E = b.startsWith("BGR"), C = new Uint8ClampedArray(u * f * 4);
            if (yield _.copyTo(C, function(L, R, U, H, J) {
              const ne = 4 * Math.max(-R, 0), he = (Math.max(0, U) - U) * H * 4 + ne, Se = 4 * H, Pe = Math.max(0, R), Xe = Math.max(0, U);
              return { rect: { x: Pe, y: Xe, width: Math.min(L.width, R + H) - Pe, height: Math.min(L.height, U + J) - Xe }, layout: [{ offset: he, stride: Se }] };
            }(i, t, n, u, f)), E) for (let L = 0; L < C.length; L += 4) {
              const R = C[L];
              C[L] = C[L + 2], C[L + 2] = R;
            }
            return C;
          } finally {
            _.close();
          }
        });
      }
      let Qe, nt;
      const Q = "AbortError";
      function _e() {
        return new Error(Q);
      }
      const be = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function Ce(i) {
        return be.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))];
      }
      const Oe = "global-dispatcher";
      class $e extends Error {
        constructor(t, n, u, f) {
          super(`AJAXError: ${n} (${t}): ${u}`), this.status = t, this.statusText = n, this.url = u, this.body = f;
        }
      }
      const Ue = () => Ve(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Ke = function(i, t) {
        if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
          const u = Ce(i.url);
          if (u) return u(i, t);
          if (Ve(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, targetMapId: Oe }, t);
        }
        if (!(/^file:/.test(n = i.url) || /^file:/.test(Ue()) && !/^\w+:/.test(n))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(u, f) {
            return s(this, void 0, void 0, function* () {
              const _ = new Request(u.url, { method: u.method || "GET", body: u.body, credentials: u.credentials, headers: u.headers, cache: u.cache, referrer: Ue(), signal: f.signal });
              u.type !== "json" || _.headers.has("Accept") || _.headers.set("Accept", "application/json");
              const b = yield fetch(_);
              if (!b.ok) {
                const L = yield b.blob();
                throw new $e(b.status, b.statusText, u.url, L);
              }
              let E;
              E = u.type === "arrayBuffer" || u.type === "image" ? b.arrayBuffer() : u.type === "json" ? b.json() : b.text();
              const C = yield E;
              if (f.signal.aborted) throw _e();
              return { data: C, cacheControl: b.headers.get("Cache-Control"), expires: b.headers.get("Expires") };
            });
          }(i, t);
          if (Ve(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, mustQueue: !0, targetMapId: Oe }, t);
        }
        var n;
        return function(u, f) {
          return new Promise((_, b) => {
            var E;
            const C = new XMLHttpRequest();
            C.open(u.method || "GET", u.url, !0), u.type !== "arrayBuffer" && u.type !== "image" || (C.responseType = "arraybuffer");
            for (const L in u.headers) C.setRequestHeader(L, u.headers[L]);
            u.type === "json" && (C.responseType = "text", !((E = u.headers) === null || E === void 0) && E.Accept || C.setRequestHeader("Accept", "application/json")), C.withCredentials = u.credentials === "include", C.onerror = () => {
              b(new Error(C.statusText));
            }, C.onload = () => {
              if (!f.signal.aborted) if ((C.status >= 200 && C.status < 300 || C.status === 0) && C.response !== null) {
                let L = C.response;
                if (u.type === "json") try {
                  L = JSON.parse(C.response);
                } catch (R) {
                  return void b(R);
                }
                _({ data: L, cacheControl: C.getResponseHeader("Cache-Control"), expires: C.getResponseHeader("Expires") });
              } else {
                const L = new Blob([C.response], { type: C.getResponseHeader("Content-Type") });
                b(new $e(C.status, C.statusText, u.url, L));
              }
            }, f.signal.addEventListener("abort", () => {
              C.abort(), b(_e());
            }), C.send(u.body);
          });
        }(i, t);
      };
      function rt(i) {
        if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
        const t = new URL(i), n = window.location;
        return t.protocol === n.protocol && t.host === n.host;
      }
      function ot(i, t, n) {
        n[i] && n[i].indexOf(t) !== -1 || (n[i] = n[i] || [], n[i].push(t));
      }
      function vt(i, t, n) {
        if (n && n[i]) {
          const u = n[i].indexOf(t);
          u !== -1 && n[i].splice(u, 1);
        }
      }
      class mt {
        constructor(t, n = {}) {
          Ie(this, n), this.type = t;
        }
      }
      class Pt extends mt {
        constructor(t, n = {}) {
          super("error", Ie({ error: t }, n));
        }
      }
      class it {
        on(t, n) {
          return this._listeners = this._listeners || {}, ot(t, n, this._listeners), this;
        }
        off(t, n) {
          return vt(t, n, this._listeners), vt(t, n, this._oneTimeListeners), this;
        }
        once(t, n) {
          return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, ot(t, n, this._oneTimeListeners), this) : new Promise((u) => this.once(t, u));
        }
        fire(t, n) {
          typeof t == "string" && (t = new mt(t, n || {}));
          const u = t.type;
          if (this.listens(u)) {
            t.target = this;
            const f = this._listeners && this._listeners[u] ? this._listeners[u].slice() : [];
            for (const E of f) E.call(this, t);
            const _ = this._oneTimeListeners && this._oneTimeListeners[u] ? this._oneTimeListeners[u].slice() : [];
            for (const E of _) vt(u, E, this._oneTimeListeners), E.call(this, t);
            const b = this._eventedParent;
            b && (Ie(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), b.fire(t));
          } else t instanceof Pt && console.error(t.error);
          return this;
        }
        listens(t) {
          return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
        }
        setEventedParent(t, n) {
          return this._eventedParent = t, this._eventedParentData = n, this;
        }
      }
      var Y = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const Kt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function Rt(i, t) {
        const n = {};
        for (const u in i) u !== "ref" && (n[u] = i[u]);
        return Kt.forEach((u) => {
          u in t && (n[u] = t[u]);
        }), n;
      }
      function lt(i, t) {
        if (Array.isArray(i)) {
          if (!Array.isArray(t) || i.length !== t.length) return !1;
          for (let n = 0; n < i.length; n++) if (!lt(i[n], t[n])) return !1;
          return !0;
        }
        if (typeof i == "object" && i !== null && t !== null) {
          if (typeof t != "object" || Object.keys(i).length !== Object.keys(t).length) return !1;
          for (const n in i) if (!lt(i[n], t[n])) return !1;
          return !0;
        }
        return i === t;
      }
      function xt(i, t) {
        i.push(t);
      }
      function At(i, t, n) {
        xt(n, { command: "addSource", args: [i, t[i]] });
      }
      function Et(i, t, n) {
        xt(t, { command: "removeSource", args: [i] }), n[i] = !0;
      }
      function jt(i, t, n, u) {
        Et(i, n, u), At(i, t, n);
      }
      function ni(i, t, n) {
        let u;
        for (u in i[n]) if (Object.prototype.hasOwnProperty.call(i[n], u) && u !== "data" && !lt(i[n][u], t[n][u])) return !1;
        for (u in t[n]) if (Object.prototype.hasOwnProperty.call(t[n], u) && u !== "data" && !lt(i[n][u], t[n][u])) return !1;
        return !0;
      }
      function ii(i, t, n, u, f, _) {
        i = i || {}, t = t || {};
        for (const b in i) Object.prototype.hasOwnProperty.call(i, b) && (lt(i[b], t[b]) || n.push({ command: _, args: [u, b, t[b], f] }));
        for (const b in t) Object.prototype.hasOwnProperty.call(t, b) && !Object.prototype.hasOwnProperty.call(i, b) && (lt(i[b], t[b]) || n.push({ command: _, args: [u, b, t[b], f] }));
      }
      function yi(i) {
        return i.id;
      }
      function xi(i, t) {
        return i[t.id] = t, i;
      }
      class pt {
        constructor(t, n, u, f) {
          this.message = (t ? `${t}: ` : "") + u, f && (this.identifier = f), n != null && n.__line__ && (this.line = n.__line__);
        }
      }
      function Jt(i, ...t) {
        for (const n of t) for (const u in n) i[u] = n[u];
        return i;
      }
      class ai extends Error {
        constructor(t, n) {
          super(n), this.message = n, this.key = t;
        }
      }
      class kt {
        constructor(t, n = []) {
          this.parent = t, this.bindings = {};
          for (const [u, f] of n) this.bindings[u] = f;
        }
        concat(t) {
          return new kt(this, t);
        }
        get(t) {
          if (this.bindings[t]) return this.bindings[t];
          if (this.parent) return this.parent.get(t);
          throw new Error(`${t} not found in scope.`);
        }
        has(t) {
          return !!this.bindings[t] || !!this.parent && this.parent.has(t);
        }
      }
      const Zi = { kind: "null" }, ft = { kind: "number" }, ri = { kind: "string" }, Lt = { kind: "boolean" }, Si = { kind: "color" }, Gi = { kind: "object" }, zt = { kind: "value" }, cr = { kind: "collator" }, Ni = { kind: "formatted" }, ie = { kind: "padding" }, ue = { kind: "resolvedImage" }, $ = { kind: "variableAnchorOffsetCollection" };
      function B(i, t) {
        return { kind: "array", itemType: i, N: t };
      }
      function j(i) {
        if (i.kind === "array") {
          const t = j(i.itemType);
          return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`;
        }
        return i.kind;
      }
      const te = [Zi, ft, ri, Lt, Si, Ni, Gi, B(zt), ie, ue, $];
      function ge(i, t) {
        if (t.kind === "error") return null;
        if (i.kind === "array") {
          if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !ge(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N)) return null;
        } else {
          if (i.kind === t.kind) return null;
          if (i.kind === "value") {
            for (const n of te) if (!ge(n, t)) return null;
          }
        }
        return `Expected ${j(i)} but found ${j(t)} instead.`;
      }
      function Me(i, t) {
        return t.some((n) => n.kind === i.kind);
      }
      function Fe(i, t) {
        return t.some((n) => n === "null" ? i === null : n === "array" ? Array.isArray(i) : n === "object" ? i && !Array.isArray(i) && typeof i == "object" : n === typeof i);
      }
      function Ne(i, t) {
        return i.kind === "array" && t.kind === "array" ? i.itemType.kind === t.itemType.kind && typeof i.N == "number" : i.kind === t.kind;
      }
      const De = 0.96422, et = 0.82521, ut = 4 / 29, We = 6 / 29, gt = 3 * We * We, Mt = We * We * We, $t = Math.PI / 180, Qt = 180 / Math.PI;
      function ei(i) {
        return (i %= 360) < 0 && (i += 360), i;
      }
      function pi([i, t, n, u]) {
        let f, _;
        const b = Wi((0.2225045 * (i = fi(i)) + 0.7168786 * (t = fi(t)) + 0.0606169 * (n = fi(n))) / 1);
        i === t && t === n ? f = _ = b : (f = Wi((0.4360747 * i + 0.3850649 * t + 0.1430804 * n) / De), _ = Wi((0.0139322 * i + 0.0971045 * t + 0.7141733 * n) / et));
        const E = 116 * b - 16;
        return [E < 0 ? 0 : E, 500 * (f - b), 200 * (b - _), u];
      }
      function fi(i) {
        return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
      }
      function Wi(i) {
        return i > Mt ? Math.pow(i, 1 / 3) : i / gt + ut;
      }
      function Oi([i, t, n, u]) {
        let f = (i + 16) / 116, _ = isNaN(t) ? f : f + t / 500, b = isNaN(n) ? f : f - n / 200;
        return f = 1 * Bi(f), _ = De * Bi(_), b = et * Bi(b), [mi(3.1338561 * _ - 1.6168667 * f - 0.4906146 * b), mi(-0.9787684 * _ + 1.9161415 * f + 0.033454 * b), mi(0.0719453 * _ - 0.2289914 * f + 1.4052427 * b), u];
      }
      function mi(i) {
        return (i = i <= 304e-5 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - 0.055) < 0 ? 0 : i > 1 ? 1 : i;
      }
      function Bi(i) {
        return i > We ? i * i * i : gt * (i - ut);
      }
      function Hi(i) {
        return parseInt(i.padEnd(2, i), 16) / 255;
      }
      function mr(i, t) {
        return vr(t ? i / 100 : i, 0, 1);
      }
      function vr(i, t, n) {
        return Math.min(Math.max(t, i), n);
      }
      function kr(i) {
        return !i.some(Number.isNaN);
      }
      const Oa = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      class ji {
        constructor(t, n, u, f = 1, _ = !0) {
          this.r = t, this.g = n, this.b = u, this.a = f, _ || (this.r *= f, this.g *= f, this.b *= f, f || this.overwriteGetter("rgb", [t, n, u, f]));
        }
        static parse(t) {
          if (t instanceof ji) return t;
          if (typeof t != "string") return;
          const n = function(u) {
            if ((u = u.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
            const f = Oa[u];
            if (f) {
              const [b, E, C] = f;
              return [b / 255, E / 255, C / 255, 1];
            }
            if (u.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(u)) {
              const b = u.length < 6 ? 1 : 2;
              let E = 1;
              return [Hi(u.slice(E, E += b)), Hi(u.slice(E, E += b)), Hi(u.slice(E, E += b)), Hi(u.slice(E, E + b) || "ff")];
            }
            if (u.startsWith("rgb")) {
              const b = u.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (b) {
                const [E, C, L, R, U, H, J, ne, he, Se, Pe, Xe] = b, Be = [R || " ", J || " ", Se].join("");
                if (Be === "  " || Be === "  /" || Be === ",," || Be === ",,,") {
                  const Ge = [L, H, he].join(""), st = Ge === "%%%" ? 100 : Ge === "" ? 255 : 0;
                  if (st) {
                    const Tt = [vr(+C / st, 0, 1), vr(+U / st, 0, 1), vr(+ne / st, 0, 1), Pe ? mr(+Pe, Xe) : 1];
                    if (kr(Tt)) return Tt;
                  }
                }
                return;
              }
            }
            const _ = u.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (_) {
              const [b, E, C, L, R, U, H, J, ne] = _, he = [C || " ", R || " ", H].join("");
              if (he === "  " || he === "  /" || he === ",," || he === ",,,") {
                const Se = [+E, vr(+L, 0, 100), vr(+U, 0, 100), J ? mr(+J, ne) : 1];
                if (kr(Se)) return function([Pe, Xe, Be, Ge]) {
                  function st(Tt) {
                    const Bt = (Tt + Pe / 30) % 12, hi = Xe * Math.min(Be, 1 - Be);
                    return Be - hi * Math.max(-1, Math.min(Bt - 3, 9 - Bt, 1));
                  }
                  return Pe = ei(Pe), Xe /= 100, Be /= 100, [st(0), st(8), st(4), Ge];
                }(Se);
              }
            }
          }(t);
          return n ? new ji(...n, !1) : void 0;
        }
        get rgb() {
          const { r: t, g: n, b: u, a: f } = this, _ = f || 1 / 0;
          return this.overwriteGetter("rgb", [t / _, n / _, u / _, f]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(t) {
            const [n, u, f, _] = pi(t), b = Math.sqrt(u * u + f * f);
            return [Math.round(1e4 * b) ? ei(Math.atan2(f, u) * Qt) : NaN, b, n, _];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", pi(this.rgb));
        }
        overwriteGetter(t, n) {
          return Object.defineProperty(this, t, { value: n }), n;
        }
        toString() {
          const [t, n, u, f] = this.rgb;
          return `rgba(${[t, n, u].map((_) => Math.round(255 * _)).join(",")},${f})`;
        }
      }
      ji.black = new ji(0, 0, 0, 1), ji.white = new ji(1, 1, 1, 1), ji.transparent = new ji(0, 0, 0, 0), ji.red = new ji(1, 0, 0, 1);
      class Zo {
        constructor(t, n, u) {
          this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = u, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t, n) {
          return this.collator.compare(t, n);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class ss {
        constructor(t, n, u, f, _) {
          this.text = t, this.image = n, this.scale = u, this.fontStack = f, this.textColor = _;
        }
      }
      class Hr {
        constructor(t) {
          this.sections = t;
        }
        static fromString(t) {
          return new Hr([new ss(t, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0);
        }
        static factory(t) {
          return t instanceof Hr ? t : Hr.fromString(t);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((t) => t.text).join("");
        }
      }
      class sn {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof sn) return t;
          if (typeof t == "number") return new sn([t, t, t, t]);
          if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
            for (const n of t) if (typeof n != "number") return;
            switch (t.length) {
              case 1:
                t = [t[0], t[0], t[0], t[0]];
                break;
              case 2:
                t = [t[0], t[1], t[0], t[1]];
                break;
              case 3:
                t = [t[0], t[1], t[2], t[1]];
            }
            return new sn(t);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const Go = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      class mn {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof mn) return t;
          if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
            for (let n = 0; n < t.length; n += 2) {
              const u = t[n], f = t[n + 1];
              if (typeof u != "string" || !Go.has(u) || !Array.isArray(f) || f.length !== 2 || typeof f[0] != "number" || typeof f[1] != "number") return;
            }
            return new mn(t);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      class Wr {
        constructor(t) {
          this.name = t.name, this.available = t.available;
        }
        toString() {
          return this.name;
        }
        static fromString(t) {
          return t ? new Wr({ name: t, available: !1 }) : null;
        }
      }
      function os(i, t, n, u) {
        return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? u === void 0 || typeof u == "number" && u >= 0 && u <= 1 ? null : `Invalid rgba value [${[i, t, n, u].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof u == "number" ? [i, t, n, u] : [i, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Rn(i) {
        if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof ji || i instanceof Zo || i instanceof Hr || i instanceof sn || i instanceof mn || i instanceof Wr) return !0;
        if (Array.isArray(i)) {
          for (const t of i) if (!Rn(t)) return !1;
          return !0;
        }
        if (typeof i == "object") {
          for (const t in i) if (!Rn(i[t])) return !1;
          return !0;
        }
        return !1;
      }
      function br(i) {
        if (i === null) return Zi;
        if (typeof i == "string") return ri;
        if (typeof i == "boolean") return Lt;
        if (typeof i == "number") return ft;
        if (i instanceof ji) return Si;
        if (i instanceof Zo) return cr;
        if (i instanceof Hr) return Ni;
        if (i instanceof sn) return ie;
        if (i instanceof mn) return $;
        if (i instanceof Wr) return ue;
        if (Array.isArray(i)) {
          const t = i.length;
          let n;
          for (const u of i) {
            const f = br(u);
            if (n) {
              if (n === f) continue;
              n = zt;
              break;
            }
            n = f;
          }
          return B(n || zt, t);
        }
        return Gi;
      }
      function rr(i) {
        const t = typeof i;
        return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof ji || i instanceof Hr || i instanceof sn || i instanceof mn || i instanceof Wr ? i.toString() : JSON.stringify(i);
      }
      class gn {
        constructor(t, n) {
          this.type = t, this.value = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
          if (!Rn(t[1])) return n.error("invalid value");
          const u = t[1];
          let f = br(u);
          const _ = n.expectedType;
          return f.kind !== "array" || f.N !== 0 || !_ || _.kind !== "array" || typeof _.N == "number" && _.N !== 0 || (f = _), new gn(f, u);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      class hr {
        constructor(t) {
          this.name = "ExpressionEvaluationError", this.message = t;
        }
        toJSON() {
          return this.message;
        }
      }
      const ks = { string: ri, number: ft, boolean: Lt, object: Gi };
      class on {
        constructor(t, n) {
          this.type = t, this.args = n;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expected at least one argument.");
          let u, f = 1;
          const _ = t[0];
          if (_ === "array") {
            let E, C;
            if (t.length > 2) {
              const L = t[1];
              if (typeof L != "string" || !(L in ks) || L === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
              E = ks[L], f++;
            } else E = zt;
            if (t.length > 3) {
              if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
              C = t[2], f++;
            }
            u = B(E, C);
          } else {
            if (!ks[_]) throw new Error(`Types doesn't contain name = ${_}`);
            u = ks[_];
          }
          const b = [];
          for (; f < t.length; f++) {
            const E = n.parse(t[f], f, zt);
            if (!E) return null;
            b.push(E);
          }
          return new on(u, b);
        }
        evaluate(t) {
          for (let n = 0; n < this.args.length; n++) {
            const u = this.args[n].evaluate(t);
            if (!ge(this.type, br(u))) return u;
            if (n === this.args.length - 1) throw new hr(`Expected value to be of type ${j(this.type)}, but found ${j(br(u))} instead.`);
          }
          throw new Error();
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      const Ho = { "to-boolean": Lt, "to-color": Si, "to-number": ft, "to-string": ri };
      class Ar {
        constructor(t, n) {
          this.type = t, this.args = n;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expected at least one argument.");
          const u = t[0];
          if (!Ho[u]) throw new Error(`Can't parse ${u} as it is not part of the known types`);
          if ((u === "to-boolean" || u === "to-string") && t.length !== 2) return n.error("Expected one argument.");
          const f = Ho[u], _ = [];
          for (let b = 1; b < t.length; b++) {
            const E = n.parse(t[b], b, zt);
            if (!E) return null;
            _.push(E);
          }
          return new Ar(f, _);
        }
        evaluate(t) {
          switch (this.type.kind) {
            case "boolean":
              return !!this.args[0].evaluate(t);
            case "color": {
              let n, u;
              for (const f of this.args) {
                if (n = f.evaluate(t), u = null, n instanceof ji) return n;
                if (typeof n == "string") {
                  const _ = t.parseColor(n);
                  if (_) return _;
                } else if (Array.isArray(n) && (u = n.length < 3 || n.length > 4 ? `Invalid rbga value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : os(n[0], n[1], n[2], n[3]), !u)) return new ji(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
              }
              throw new hr(u || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "padding": {
              let n;
              for (const u of this.args) {
                n = u.evaluate(t);
                const f = sn.parse(n);
                if (f) return f;
              }
              throw new hr(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let n;
              for (const u of this.args) {
                n = u.evaluate(t);
                const f = mn.parse(n);
                if (f) return f;
              }
              throw new hr(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "number": {
              let n = null;
              for (const u of this.args) {
                if (n = u.evaluate(t), n === null) return 0;
                const f = Number(n);
                if (!isNaN(f)) return f;
              }
              throw new hr(`Could not convert ${JSON.stringify(n)} to number.`);
            }
            case "formatted":
              return Hr.fromString(rr(this.args[0].evaluate(t)));
            case "resolvedImage":
              return Wr.fromString(rr(this.args[0].evaluate(t)));
            default:
              return rr(this.args[0].evaluate(t));
          }
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      const Qs = ["Unknown", "Point", "LineString", "Polygon"];
      class Or {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Qs[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(t) {
          let n = this._parseColorCache[t];
          return n || (n = this._parseColorCache[t] = ji.parse(t)), n;
        }
      }
      class na {
        constructor(t, n, u = [], f, _ = new kt(), b = []) {
          this.registry = t, this.path = u, this.key = u.map((E) => `[${E}]`).join(""), this.scope = _, this.errors = b, this.expectedType = f, this._isConstant = n;
        }
        parse(t, n, u, f, _ = {}) {
          return n ? this.concat(n, u, f)._parse(t, _) : this._parse(t, _);
        }
        _parse(t, n) {
          function u(f, _, b) {
            return b === "assert" ? new on(_, [f]) : b === "coerce" ? new Ar(_, [f]) : f;
          }
          if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
            if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const f = t[0];
            if (typeof f != "string") return this.error(`Expression name must be a string, but found ${typeof f} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const _ = this.registry[f];
            if (_) {
              let b = _.parse(t, this);
              if (!b) return null;
              if (this.expectedType) {
                const E = this.expectedType, C = b.type;
                if (E.kind !== "string" && E.kind !== "number" && E.kind !== "boolean" && E.kind !== "object" && E.kind !== "array" || C.kind !== "value") if (E.kind !== "color" && E.kind !== "formatted" && E.kind !== "resolvedImage" || C.kind !== "value" && C.kind !== "string") if (E.kind !== "padding" || C.kind !== "value" && C.kind !== "number" && C.kind !== "array") if (E.kind !== "variableAnchorOffsetCollection" || C.kind !== "value" && C.kind !== "array") {
                  if (this.checkSubtype(E, C)) return null;
                } else b = u(b, E, n.typeAnnotation || "coerce");
                else b = u(b, E, n.typeAnnotation || "coerce");
                else b = u(b, E, n.typeAnnotation || "coerce");
                else b = u(b, E, n.typeAnnotation || "assert");
              }
              if (!(b instanceof gn) && b.type.kind !== "resolvedImage" && this._isConstant(b)) {
                const E = new Or();
                try {
                  b = new gn(b.type, b.evaluate(E));
                } catch (C) {
                  return this.error(C.message), null;
                }
              }
              return b;
            }
            return this.error(`Unknown expression "${f}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
        }
        concat(t, n, u) {
          const f = typeof t == "number" ? this.path.concat(t) : this.path, _ = u ? this.scope.concat(u) : this.scope;
          return new na(this.registry, this._isConstant, f, n || null, _, this.errors);
        }
        error(t, ...n) {
          const u = `${this.key}${n.map((f) => `[${f}]`).join("")}`;
          this.errors.push(new ai(u, t));
        }
        checkSubtype(t, n) {
          const u = ge(t, n);
          return u && this.error(u), u;
        }
      }
      class aa {
        constructor(t, n) {
          this.type = n.type, this.bindings = [].concat(t), this.result = n;
        }
        evaluate(t) {
          return this.result.evaluate(t);
        }
        eachChild(t) {
          for (const n of this.bindings) t(n[1]);
          t(this.result);
        }
        static parse(t, n) {
          if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
          const u = [];
          for (let _ = 1; _ < t.length - 1; _ += 2) {
            const b = t[_];
            if (typeof b != "string") return n.error(`Expected string, but found ${typeof b} instead.`, _);
            if (/[^a-zA-Z0-9_]/.test(b)) return n.error("Variable names must contain only alphanumeric characters or '_'.", _);
            const E = n.parse(t[_ + 1], _ + 1);
            if (!E) return null;
            u.push([b, E]);
          }
          const f = n.parse(t[t.length - 1], t.length - 1, n.expectedType, u);
          return f ? new aa(u, f) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Ri {
        constructor(t, n) {
          this.type = n.type, this.name = t, this.boundExpression = n;
        }
        static parse(t, n) {
          if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
          const u = t[1];
          return n.scope.has(u) ? new Ri(u, n.scope.get(u)) : n.error(`Unknown variable "${u}". Make sure "${u}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t) {
          return this.boundExpression.evaluate(t);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
      }
      class eo {
        constructor(t, n, u) {
          this.type = t, this.index = n, this.input = u;
        }
        static parse(t, n) {
          if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
          const u = n.parse(t[1], 1, ft), f = n.parse(t[2], 2, B(n.expectedType || zt));
          return u && f ? new eo(f.type.itemType, u, f) : null;
        }
        evaluate(t) {
          const n = this.index.evaluate(t), u = this.input.evaluate(t);
          if (n < 0) throw new hr(`Array index out of bounds: ${n} < 0.`);
          if (n >= u.length) throw new hr(`Array index out of bounds: ${n} > ${u.length - 1}.`);
          if (n !== Math.floor(n)) throw new hr(`Array index must be an integer, but found ${n} instead.`);
          return u[n];
        }
        eachChild(t) {
          t(this.index), t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Wo {
        constructor(t, n) {
          this.type = Lt, this.needle = t, this.haystack = n;
        }
        static parse(t, n) {
          if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
          const u = n.parse(t[1], 1, zt), f = n.parse(t[2], 2, zt);
          return u && f ? Me(u.type, [Lt, ri, ft, Zi, zt]) ? new Wo(u, f) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${j(u.type)} instead`) : null;
        }
        evaluate(t) {
          const n = this.needle.evaluate(t), u = this.haystack.evaluate(t);
          if (!u) return !1;
          if (!Fe(n, ["boolean", "string", "number", "null"])) throw new hr(`Expected first argument to be of type boolean, string, number or null, but found ${j(br(n))} instead.`);
          if (!Fe(u, ["string", "array"])) throw new hr(`Expected second argument to be of type array or string, but found ${j(br(u))} instead.`);
          return u.indexOf(n) >= 0;
        }
        eachChild(t) {
          t(this.needle), t(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class ja {
        constructor(t, n, u) {
          this.type = ft, this.needle = t, this.haystack = n, this.fromIndex = u;
        }
        static parse(t, n) {
          if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
          const u = n.parse(t[1], 1, zt), f = n.parse(t[2], 2, zt);
          if (!u || !f) return null;
          if (!Me(u.type, [Lt, ri, ft, Zi, zt])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${j(u.type)} instead`);
          if (t.length === 4) {
            const _ = n.parse(t[3], 3, ft);
            return _ ? new ja(u, f, _) : null;
          }
          return new ja(u, f);
        }
        evaluate(t) {
          const n = this.needle.evaluate(t), u = this.haystack.evaluate(t);
          if (!Fe(n, ["boolean", "string", "number", "null"])) throw new hr(`Expected first argument to be of type boolean, string, number or null, but found ${j(br(n))} instead.`);
          let f;
          if (this.fromIndex && (f = this.fromIndex.evaluate(t)), Fe(u, ["string"])) {
            const _ = u.indexOf(n, f);
            return _ === -1 ? -1 : [...u.slice(0, _)].length;
          }
          if (Fe(u, ["array"])) return u.indexOf(n, f);
          throw new hr(`Expected second argument to be of type array or string, but found ${j(br(u))} instead.`);
        }
        eachChild(t) {
          t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class Xo {
        constructor(t, n, u, f, _, b) {
          this.inputType = t, this.type = n, this.input = u, this.cases = f, this.outputs = _, this.otherwise = b;
        }
        static parse(t, n) {
          if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if (t.length % 2 != 1) return n.error("Expected an even number of arguments.");
          let u, f;
          n.expectedType && n.expectedType.kind !== "value" && (f = n.expectedType);
          const _ = {}, b = [];
          for (let L = 2; L < t.length - 1; L += 2) {
            let R = t[L];
            const U = t[L + 1];
            Array.isArray(R) || (R = [R]);
            const H = n.concat(L);
            if (R.length === 0) return H.error("Expected at least one branch label.");
            for (const ne of R) {
              if (typeof ne != "number" && typeof ne != "string") return H.error("Branch labels must be numbers or strings.");
              if (typeof ne == "number" && Math.abs(ne) > Number.MAX_SAFE_INTEGER) return H.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof ne == "number" && Math.floor(ne) !== ne) return H.error("Numeric branch labels must be integer values.");
              if (u) {
                if (H.checkSubtype(u, br(ne))) return null;
              } else u = br(ne);
              if (_[String(ne)] !== void 0) return H.error("Branch labels must be unique.");
              _[String(ne)] = b.length;
            }
            const J = n.parse(U, L, f);
            if (!J) return null;
            f = f || J.type, b.push(J);
          }
          const E = n.parse(t[1], 1, zt);
          if (!E) return null;
          const C = n.parse(t[t.length - 1], t.length - 1, f);
          return C ? E.type.kind !== "value" && n.concat(1).checkSubtype(u, E.type) ? null : new Xo(u, f, E, _, b, C) : null;
        }
        evaluate(t) {
          const n = this.input.evaluate(t);
          return (br(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t);
        }
        eachChild(t) {
          t(this.input), this.outputs.forEach(t), t(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class ls {
        constructor(t, n, u) {
          this.type = t, this.branches = n, this.otherwise = u;
        }
        static parse(t, n) {
          if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
          if (t.length % 2 != 0) return n.error("Expected an odd number of arguments.");
          let u;
          n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
          const f = [];
          for (let b = 1; b < t.length - 1; b += 2) {
            const E = n.parse(t[b], b, Lt);
            if (!E) return null;
            const C = n.parse(t[b + 1], b + 1, u);
            if (!C) return null;
            f.push([E, C]), u = u || C.type;
          }
          const _ = n.parse(t[t.length - 1], t.length - 1, u);
          if (!_) return null;
          if (!u) throw new Error("Can't infer output type");
          return new ls(u, f, _);
        }
        evaluate(t) {
          for (const [n, u] of this.branches) if (n.evaluate(t)) return u.evaluate(t);
          return this.otherwise.evaluate(t);
        }
        eachChild(t) {
          for (const [n, u] of this.branches) t(n), t(u);
          t(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t, n]) => n.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class Ps {
        constructor(t, n, u, f) {
          this.type = t, this.input = n, this.beginIndex = u, this.endIndex = f;
        }
        static parse(t, n) {
          if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
          const u = n.parse(t[1], 1, zt), f = n.parse(t[2], 2, ft);
          if (!u || !f) return null;
          if (!Me(u.type, [B(zt), ri, zt])) return n.error(`Expected first argument to be of type array or string, but found ${j(u.type)} instead`);
          if (t.length === 4) {
            const _ = n.parse(t[3], 3, ft);
            return _ ? new Ps(u.type, u, f, _) : null;
          }
          return new Ps(u.type, u, f);
        }
        evaluate(t) {
          const n = this.input.evaluate(t), u = this.beginIndex.evaluate(t);
          let f;
          if (this.endIndex && (f = this.endIndex.evaluate(t)), Fe(n, ["string"])) return [...n].slice(u, f).join("");
          if (Fe(n, ["array"])) return n.slice(u, f);
          throw new hr(`Expected first argument to be of type array or string, but found ${j(br(n))} instead.`);
        }
        eachChild(t) {
          t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function to(i, t) {
        const n = i.length - 1;
        let u, f, _ = 0, b = n, E = 0;
        for (; _ <= b; ) if (E = Math.floor((_ + b) / 2), u = i[E], f = i[E + 1], u <= t) {
          if (E === n || t < f) return E;
          _ = E + 1;
        } else {
          if (!(u > t)) throw new hr("Input is not a number.");
          b = E - 1;
        }
        return 0;
      }
      class us {
        constructor(t, n, u) {
          this.type = t, this.input = n, this.labels = [], this.outputs = [];
          for (const [f, _] of u) this.labels.push(f), this.outputs.push(_);
        }
        static parse(t, n) {
          if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
          const u = n.parse(t[1], 1, ft);
          if (!u) return null;
          const f = [];
          let _ = null;
          n.expectedType && n.expectedType.kind !== "value" && (_ = n.expectedType);
          for (let b = 1; b < t.length; b += 2) {
            const E = b === 1 ? -1 / 0 : t[b], C = t[b + 1], L = b, R = b + 1;
            if (typeof E != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', L);
            if (f.length && f[f.length - 1][0] >= E) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', L);
            const U = n.parse(C, R, _);
            if (!U) return null;
            _ = _ || U.type, f.push([E, U]);
          }
          return new us(_, u, f);
        }
        evaluate(t) {
          const n = this.labels, u = this.outputs;
          if (n.length === 1) return u[0].evaluate(t);
          const f = this.input.evaluate(t);
          if (f <= n[0]) return u[0].evaluate(t);
          const _ = n.length;
          return f >= n[_ - 1] ? u[_ - 1].evaluate(t) : u[to(n, f)].evaluate(t);
        }
        eachChild(t) {
          t(this.input);
          for (const n of this.outputs) t(n);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
      }
      function xa(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      var io = Ls;
      function Ls(i, t, n, u) {
        this.cx = 3 * i, this.bx = 3 * (n - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (u - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = t, this.p2x = n, this.p2y = u;
      }
      Ls.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, t) {
        if (t === void 0 && (t = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var n = i, u = 0; u < 8; u++) {
          var f = this.sampleCurveX(n) - i;
          if (Math.abs(f) < t) return n;
          var _ = this.sampleCurveDerivativeX(n);
          if (Math.abs(_) < 1e-6) break;
          n -= f / _;
        }
        var b = 0, E = 1;
        for (n = i, u = 0; u < 20 && (f = this.sampleCurveX(n), !(Math.abs(f - i) < t)); u++) i > f ? b = n : E = n, n = 0.5 * (E - b) + b;
        return n;
      }, solve: function(i, t) {
        return this.sampleCurveY(this.solveCurveX(i, t));
      } };
      var El = xa(io);
      function xr(i, t, n) {
        return i + n * (t - i);
      }
      function Ms(i, t, n) {
        return i.map((u, f) => xr(u, t[f], n));
      }
      const jr = { number: xr, color: function(i, t, n, u = "rgb") {
        switch (u) {
          case "rgb": {
            const [f, _, b, E] = Ms(i.rgb, t.rgb, n);
            return new ji(f, _, b, E, !1);
          }
          case "hcl": {
            const [f, _, b, E] = i.hcl, [C, L, R, U] = t.hcl;
            let H, J;
            if (isNaN(f) || isNaN(C)) isNaN(f) ? isNaN(C) ? H = NaN : (H = C, b !== 1 && b !== 0 || (J = L)) : (H = f, R !== 1 && R !== 0 || (J = _));
            else {
              let Xe = C - f;
              C > f && Xe > 180 ? Xe -= 360 : C < f && f - C > 180 && (Xe += 360), H = f + n * Xe;
            }
            const [ne, he, Se, Pe] = function([Xe, Be, Ge, st]) {
              return Xe = isNaN(Xe) ? 0 : Xe * $t, Oi([Ge, Math.cos(Xe) * Be, Math.sin(Xe) * Be, st]);
            }([H, J ?? xr(_, L, n), xr(b, R, n), xr(E, U, n)]);
            return new ji(ne, he, Se, Pe, !1);
          }
          case "lab": {
            const [f, _, b, E] = Oi(Ms(i.lab, t.lab, n));
            return new ji(f, _, b, E, !1);
          }
        }
      }, array: Ms, padding: function(i, t, n) {
        return new sn(Ms(i.values, t.values, n));
      }, variableAnchorOffsetCollection: function(i, t, n) {
        const u = i.values, f = t.values;
        if (u.length !== f.length) throw new hr(`Cannot interpolate values of different length. from: ${i.toString()}, to: ${t.toString()}`);
        const _ = [];
        for (let b = 0; b < u.length; b += 2) {
          if (u[b] !== f[b]) throw new hr(`Cannot interpolate values containing mismatched anchors. from[${b}]: ${u[b]}, to[${b}]: ${f[b]}`);
          _.push(u[b]);
          const [E, C] = u[b + 1], [L, R] = f[b + 1];
          _.push([xr(E, L, n), xr(C, R, n)]);
        }
        return new mn(_);
      } };
      class si {
        constructor(t, n, u, f, _) {
          this.type = t, this.operator = n, this.interpolation = u, this.input = f, this.labels = [], this.outputs = [];
          for (const [b, E] of _) this.labels.push(b), this.outputs.push(E);
        }
        static interpolationFactor(t, n, u, f) {
          let _ = 0;
          if (t.name === "exponential") _ = ro(n, t.base, u, f);
          else if (t.name === "linear") _ = ro(n, 1, u, f);
          else if (t.name === "cubic-bezier") {
            const b = t.controlPoints;
            _ = new El(b[0], b[1], b[2], b[3]).solve(ro(n, 1, u, f));
          }
          return _;
        }
        static parse(t, n) {
          let [u, f, _, ...b] = t;
          if (!Array.isArray(f) || f.length === 0) return n.error("Expected an interpolation type expression.", 1);
          if (f[0] === "linear") f = { name: "linear" };
          else if (f[0] === "exponential") {
            const L = f[1];
            if (typeof L != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
            f = { name: "exponential", base: L };
          } else {
            if (f[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(f[0])}`, 1, 0);
            {
              const L = f.slice(1);
              if (L.length !== 4 || L.some((R) => typeof R != "number" || R < 0 || R > 1)) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              f = { name: "cubic-bezier", controlPoints: L };
            }
          }
          if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
          if (_ = n.parse(_, 2, ft), !_) return null;
          const E = [];
          let C = null;
          u === "interpolate-hcl" || u === "interpolate-lab" ? C = Si : n.expectedType && n.expectedType.kind !== "value" && (C = n.expectedType);
          for (let L = 0; L < b.length; L += 2) {
            const R = b[L], U = b[L + 1], H = L + 3, J = L + 4;
            if (typeof R != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', H);
            if (E.length && E[E.length - 1][0] >= R) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', H);
            const ne = n.parse(U, J, C);
            if (!ne) return null;
            C = C || ne.type, E.push([R, ne]);
          }
          return Ne(C, ft) || Ne(C, Si) || Ne(C, ie) || Ne(C, $) || Ne(C, B(ft)) ? new si(C, u, f, _, E) : n.error(`Type ${j(C)} is not interpolatable.`);
        }
        evaluate(t) {
          const n = this.labels, u = this.outputs;
          if (n.length === 1) return u[0].evaluate(t);
          const f = this.input.evaluate(t);
          if (f <= n[0]) return u[0].evaluate(t);
          const _ = n.length;
          if (f >= n[_ - 1]) return u[_ - 1].evaluate(t);
          const b = to(n, f), E = si.interpolationFactor(this.interpolation, f, n[b], n[b + 1]), C = u[b].evaluate(t), L = u[b + 1].evaluate(t);
          switch (this.operator) {
            case "interpolate":
              return jr[this.type.kind](C, L, E);
            case "interpolate-hcl":
              return jr.color(C, L, E, "hcl");
            case "interpolate-lab":
              return jr.color(C, L, E, "lab");
          }
        }
        eachChild(t) {
          t(this.input);
          for (const n of this.outputs) t(n);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
      }
      function ro(i, t, n, u) {
        const f = u - n, _ = i - n;
        return f === 0 ? 0 : t === 1 ? _ / f : (Math.pow(t, _) - 1) / (Math.pow(t, f) - 1);
      }
      class no {
        constructor(t, n) {
          this.type = t, this.args = n;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expectected at least one argument.");
          let u = null;
          const f = n.expectedType;
          f && f.kind !== "value" && (u = f);
          const _ = [];
          for (const E of t.slice(1)) {
            const C = n.parse(E, 1 + _.length, u, void 0, { typeAnnotation: "omit" });
            if (!C) return null;
            u = u || C.type, _.push(C);
          }
          if (!u) throw new Error("No output type");
          const b = f && _.some((E) => ge(f, E.type));
          return new no(b ? zt : u, _);
        }
        evaluate(t) {
          let n, u = null, f = 0;
          for (const _ of this.args) if (f++, u = _.evaluate(t), u && u instanceof Wr && !u.available && (n || (n = u.name), u = null, f === this.args.length && (u = n)), u !== null) break;
          return u;
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      function Tn(i, t) {
        return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
      }
      function Yo(i, t, n, u) {
        return u.compare(t, n) === 0;
      }
      function qa(i, t, n) {
        const u = i !== "==" && i !== "!=";
        return class Q0 {
          constructor(_, b, E) {
            this.type = Lt, this.lhs = _, this.rhs = b, this.collator = E, this.hasUntypedArgument = _.type.kind === "value" || b.type.kind === "value";
          }
          static parse(_, b) {
            if (_.length !== 3 && _.length !== 4) return b.error("Expected two or three arguments.");
            const E = _[0];
            let C = b.parse(_[1], 1, zt);
            if (!C) return null;
            if (!Tn(E, C.type)) return b.concat(1).error(`"${E}" comparisons are not supported for type '${j(C.type)}'.`);
            let L = b.parse(_[2], 2, zt);
            if (!L) return null;
            if (!Tn(E, L.type)) return b.concat(2).error(`"${E}" comparisons are not supported for type '${j(L.type)}'.`);
            if (C.type.kind !== L.type.kind && C.type.kind !== "value" && L.type.kind !== "value") return b.error(`Cannot compare types '${j(C.type)}' and '${j(L.type)}'.`);
            u && (C.type.kind === "value" && L.type.kind !== "value" ? C = new on(L.type, [C]) : C.type.kind !== "value" && L.type.kind === "value" && (L = new on(C.type, [L])));
            let R = null;
            if (_.length === 4) {
              if (C.type.kind !== "string" && L.type.kind !== "string" && C.type.kind !== "value" && L.type.kind !== "value") return b.error("Cannot use collator to compare non-string types.");
              if (R = b.parse(_[3], 3, cr), !R) return null;
            }
            return new Q0(C, L, R);
          }
          evaluate(_) {
            const b = this.lhs.evaluate(_), E = this.rhs.evaluate(_);
            if (u && this.hasUntypedArgument) {
              const C = br(b), L = br(E);
              if (C.kind !== L.kind || C.kind !== "string" && C.kind !== "number") throw new hr(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${C.kind}, ${L.kind}) instead.`);
            }
            if (this.collator && !u && this.hasUntypedArgument) {
              const C = br(b), L = br(E);
              if (C.kind !== "string" || L.kind !== "string") return t(_, b, E);
            }
            return this.collator ? n(_, b, E, this.collator.evaluate(_)) : t(_, b, E);
          }
          eachChild(_) {
            _(this.lhs), _(this.rhs), this.collator && _(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const ao = qa("==", function(i, t, n) {
        return t === n;
      }, Yo), so = qa("!=", function(i, t, n) {
        return t !== n;
      }, function(i, t, n, u) {
        return !Yo(0, t, n, u);
      }), Tl = qa("<", function(i, t, n) {
        return t < n;
      }, function(i, t, n, u) {
        return u.compare(t, n) < 0;
      }), tu = qa(">", function(i, t, n) {
        return t > n;
      }, function(i, t, n, u) {
        return u.compare(t, n) > 0;
      }), iu = qa("<=", function(i, t, n) {
        return t <= n;
      }, function(i, t, n, u) {
        return u.compare(t, n) <= 0;
      }), oo = qa(">=", function(i, t, n) {
        return t >= n;
      }, function(i, t, n, u) {
        return u.compare(t, n) >= 0;
      });
      class sa {
        constructor(t, n, u) {
          this.type = cr, this.locale = u, this.caseSensitive = t, this.diacriticSensitive = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error("Expected one argument.");
          const u = t[1];
          if (typeof u != "object" || Array.isArray(u)) return n.error("Collator options argument must be an object.");
          const f = n.parse(u["case-sensitive"] !== void 0 && u["case-sensitive"], 1, Lt);
          if (!f) return null;
          const _ = n.parse(u["diacritic-sensitive"] !== void 0 && u["diacritic-sensitive"], 1, Lt);
          if (!_) return null;
          let b = null;
          return u.locale && (b = n.parse(u.locale, 1, ri), !b) ? null : new sa(f, _, b);
        }
        evaluate(t) {
          return new Zo(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
        }
        eachChild(t) {
          t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      class wa {
        constructor(t, n, u, f, _) {
          this.type = ri, this.number = t, this.locale = n, this.currency = u, this.minFractionDigits = f, this.maxFractionDigits = _;
        }
        static parse(t, n) {
          if (t.length !== 3) return n.error("Expected two arguments.");
          const u = n.parse(t[1], 1, ft);
          if (!u) return null;
          const f = t[2];
          if (typeof f != "object" || Array.isArray(f)) return n.error("NumberFormat options argument must be an object.");
          let _ = null;
          if (f.locale && (_ = n.parse(f.locale, 1, ri), !_)) return null;
          let b = null;
          if (f.currency && (b = n.parse(f.currency, 1, ri), !b)) return null;
          let E = null;
          if (f["min-fraction-digits"] && (E = n.parse(f["min-fraction-digits"], 1, ft), !E)) return null;
          let C = null;
          return f["max-fraction-digits"] && (C = n.parse(f["max-fraction-digits"], 1, ft), !C) ? null : new wa(u, _, b, E, C);
        }
        evaluate(t) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
        }
        eachChild(t) {
          t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class lo {
        constructor(t) {
          this.type = Ni, this.sections = t;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expected at least one argument.");
          const u = t[1];
          if (!Array.isArray(u) && typeof u == "object") return n.error("First argument must be an image or text section.");
          const f = [];
          let _ = !1;
          for (let b = 1; b <= t.length - 1; ++b) {
            const E = t[b];
            if (_ && typeof E == "object" && !Array.isArray(E)) {
              _ = !1;
              let C = null;
              if (E["font-scale"] && (C = n.parse(E["font-scale"], 1, ft), !C)) return null;
              let L = null;
              if (E["text-font"] && (L = n.parse(E["text-font"], 1, B(ri)), !L)) return null;
              let R = null;
              if (E["text-color"] && (R = n.parse(E["text-color"], 1, Si), !R)) return null;
              const U = f[f.length - 1];
              U.scale = C, U.font = L, U.textColor = R;
            } else {
              const C = n.parse(t[b], 1, zt);
              if (!C) return null;
              const L = C.type.kind;
              if (L !== "string" && L !== "value" && L !== "null" && L !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              _ = !0, f.push({ content: C, scale: null, font: null, textColor: null });
            }
          }
          return new lo(f);
        }
        evaluate(t) {
          return new Hr(this.sections.map((n) => {
            const u = n.content.evaluate(t);
            return br(u) === ue ? new ss("", u, null, null, null) : new ss(rr(u), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null);
          }));
        }
        eachChild(t) {
          for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ua {
        constructor(t) {
          this.type = ue, this.input = t;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error("Expected two arguments.");
          const u = n.parse(t[1], 1, ri);
          return u ? new Ua(u) : n.error("No image name provided.");
        }
        evaluate(t) {
          const n = this.input.evaluate(t), u = Wr.fromString(n);
          return u && t.availableImages && (u.available = t.availableImages.indexOf(n) > -1), u;
        }
        eachChild(t) {
          t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ns {
        constructor(t) {
          this.type = ft, this.input = t;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
          const u = n.parse(t[1], 1);
          return u ? u.type.kind !== "array" && u.type.kind !== "string" && u.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${j(u.type)} instead.`) : new Ns(u) : null;
        }
        evaluate(t) {
          const n = this.input.evaluate(t);
          if (typeof n == "string") return [...n].length;
          if (Array.isArray(n)) return n.length;
          throw new hr(`Expected value to be of type string or array, but found ${j(br(n))} instead.`);
        }
        eachChild(t) {
          t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const ln = 8192;
      function Cl(i, t) {
        const n = (180 + i[0]) / 360, u = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360, f = Math.pow(2, t.z);
        return [Math.round(n * f * ln), Math.round(u * f * ln)];
      }
      function uo(i, t) {
        const n = Math.pow(2, t.z);
        return [(f = (i[0] / ln + t.x) / n, 360 * f - 180), (u = (i[1] / ln + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * u) * Math.PI / 180)) - 90)];
        var u, f;
      }
      function Aa(i, t) {
        i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.max(i[2], t[0]), i[3] = Math.max(i[3], t[1]);
      }
      function oa(i, t) {
        return !(i[0] <= t[0] || i[2] >= t[2] || i[1] <= t[1] || i[3] >= t[3]);
      }
      function Ii(i, t, n) {
        const u = i[0] - t[0], f = i[1] - t[1], _ = i[0] - n[0], b = i[1] - n[1];
        return u * b - _ * f == 0 && u * _ <= 0 && f * b <= 0;
      }
      function la(i, t, n, u) {
        return (f = [u[0] - n[0], u[1] - n[1]])[0] * (_ = [t[0] - i[0], t[1] - i[1]])[1] - f[1] * _[0] != 0 && !(!Dl(i, t, n, u) || !Dl(n, u, i, t));
        var f, _;
      }
      function ru(i, t, n) {
        for (const u of n) for (let f = 0; f < u.length - 1; ++f) if (la(i, t, u[f], u[f + 1])) return !0;
        return !1;
      }
      function Cn(i, t, n = !1) {
        let u = !1;
        for (const E of t) for (let C = 0; C < E.length - 1; C++) {
          if (Ii(i, E[C], E[C + 1])) return n;
          (_ = E[C])[1] > (f = i)[1] != (b = E[C + 1])[1] > f[1] && f[0] < (b[0] - _[0]) * (f[1] - _[1]) / (b[1] - _[1]) + _[0] && (u = !u);
        }
        var f, _, b;
        return u;
      }
      function ua(i, t) {
        for (const n of t) if (Cn(i, n)) return !0;
        return !1;
      }
      function co(i, t) {
        for (const n of i) if (!Cn(n, t)) return !1;
        for (let n = 0; n < i.length - 1; ++n) if (ru(i[n], i[n + 1], t)) return !1;
        return !0;
      }
      function zs(i, t) {
        for (const n of t) if (co(i, n)) return !0;
        return !1;
      }
      function Dl(i, t, n, u) {
        const f = u[0] - n[0], _ = u[1] - n[1], b = (i[0] - n[0]) * _ - f * (i[1] - n[1]), E = (t[0] - n[0]) * _ - f * (t[1] - n[1]);
        return b > 0 && E < 0 || b < 0 && E > 0;
      }
      function cs(i, t, n) {
        const u = [];
        for (let f = 0; f < i.length; f++) {
          const _ = [];
          for (let b = 0; b < i[f].length; b++) {
            const E = Cl(i[f][b], n);
            Aa(t, E), _.push(E);
          }
          u.push(_);
        }
        return u;
      }
      function Il(i, t, n) {
        const u = [];
        for (let f = 0; f < i.length; f++) {
          const _ = cs(i[f], t, n);
          u.push(_);
        }
        return u;
      }
      function ho(i, t, n, u) {
        if (i[0] < n[0] || i[0] > n[2]) {
          const f = 0.5 * u;
          let _ = i[0] - n[0] > f ? -u : n[0] - i[0] > f ? u : 0;
          _ === 0 && (_ = i[0] - n[2] > f ? -u : n[2] - i[0] > f ? u : 0), i[0] += _;
        }
        Aa(t, i);
      }
      function po(i, t, n, u) {
        const f = Math.pow(2, u.z) * ln, _ = [u.x * ln, u.y * ln], b = [];
        for (const E of i) for (const C of E) {
          const L = [C.x + _[0], C.y + _[1]];
          ho(L, t, n, f), b.push(L);
        }
        return b;
      }
      function Jo(i, t, n, u) {
        const f = Math.pow(2, u.z) * ln, _ = [u.x * ln, u.y * ln], b = [];
        for (const C of i) {
          const L = [];
          for (const R of C) {
            const U = [R.x + _[0], R.y + _[1]];
            Aa(t, U), L.push(U);
          }
          b.push(L);
        }
        if (t[2] - t[0] <= f / 2) {
          (E = t)[0] = E[1] = 1 / 0, E[2] = E[3] = -1 / 0;
          for (const C of b) for (const L of C) ho(L, t, n, f);
        }
        var E;
        return b;
      }
      class On {
        constructor(t, n) {
          this.type = Lt, this.geojson = t, this.geometries = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
          if (Rn(t[1])) {
            const u = t[1];
            if (u.type === "FeatureCollection") {
              const f = [];
              for (const _ of u.features) {
                const { type: b, coordinates: E } = _.geometry;
                b === "Polygon" && f.push(E), b === "MultiPolygon" && f.push(...E);
              }
              if (f.length) return new On(u, { type: "MultiPolygon", coordinates: f });
            } else if (u.type === "Feature") {
              const f = u.geometry.type;
              if (f === "Polygon" || f === "MultiPolygon") return new On(u, u.geometry);
            } else if (u.type === "Polygon" || u.type === "MultiPolygon") return new On(u, u);
          }
          return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t) {
          if (t.geometry() != null && t.canonicalID() != null) {
            if (t.geometryType() === "Point") return function(n, u) {
              const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = n.canonicalID();
              if (u.type === "Polygon") {
                const E = cs(u.coordinates, _, b), C = po(n.geometry(), f, _, b);
                if (!oa(f, _)) return !1;
                for (const L of C) if (!Cn(L, E)) return !1;
              }
              if (u.type === "MultiPolygon") {
                const E = Il(u.coordinates, _, b), C = po(n.geometry(), f, _, b);
                if (!oa(f, _)) return !1;
                for (const L of C) if (!ua(L, E)) return !1;
              }
              return !0;
            }(t, this.geometries);
            if (t.geometryType() === "LineString") return function(n, u) {
              const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = n.canonicalID();
              if (u.type === "Polygon") {
                const E = cs(u.coordinates, _, b), C = Jo(n.geometry(), f, _, b);
                if (!oa(f, _)) return !1;
                for (const L of C) if (!co(L, E)) return !1;
              }
              if (u.type === "MultiPolygon") {
                const E = Il(u.coordinates, _, b), C = Jo(n.geometry(), f, _, b);
                if (!oa(f, _)) return !1;
                for (const L of C) if (!zs(L, E)) return !1;
              }
              return !0;
            }(t, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      let fo = class {
        constructor(i = [], t = (n, u) => n < u ? -1 : n > u ? 1 : 0) {
          if (this.data = i, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
        }
        push(i) {
          this.data.push(i), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const i = this.data[0], t = this.data.pop();
          return --this.length > 0 && (this.data[0] = t, this._down(0)), i;
        }
        peek() {
          return this.data[0];
        }
        _up(i) {
          const { data: t, compare: n } = this, u = t[i];
          for (; i > 0; ) {
            const f = i - 1 >> 1, _ = t[f];
            if (n(u, _) >= 0) break;
            t[i] = _, i = f;
          }
          t[i] = u;
        }
        _down(i) {
          const { data: t, compare: n } = this, u = this.length >> 1, f = t[i];
          for (; i < u; ) {
            let _ = 1 + (i << 1);
            const b = _ + 1;
            if (b < this.length && n(t[b], t[_]) < 0 && (_ = b), n(t[_], f) >= 0) break;
            t[i] = t[_], i = _;
          }
          t[i] = f;
        }
      };
      function Ko(i, t, n, u, f) {
        Qo(i, t, n, u || i.length - 1, f || mo);
      }
      function Qo(i, t, n, u, f) {
        for (; u > n; ) {
          if (u - n > 600) {
            var _ = u - n + 1, b = t - n + 1, E = Math.log(_), C = 0.5 * Math.exp(2 * E / 3), L = 0.5 * Math.sqrt(E * C * (_ - C) / _) * (b - _ / 2 < 0 ? -1 : 1);
            Qo(i, t, Math.max(n, Math.floor(t - b * C / _ + L)), Math.min(u, Math.floor(t + (_ - b) * C / _ + L)), f);
          }
          var R = i[t], U = n, H = u;
          for (Fs(i, n, t), f(i[u], R) > 0 && Fs(i, n, u); U < H; ) {
            for (Fs(i, U, H), U++, H--; f(i[U], R) < 0; ) U++;
            for (; f(i[H], R) > 0; ) H--;
          }
          f(i[n], R) === 0 ? Fs(i, n, H) : Fs(i, ++H, u), H <= t && (n = H + 1), t <= H && (u = H - 1);
        }
      }
      function Fs(i, t, n) {
        var u = i[t];
        i[t] = i[n], i[n] = u;
      }
      function mo(i, t) {
        return i < t ? -1 : i > t ? 1 : 0;
      }
      function Sa(i, t) {
        if (i.length <= 1) return [i];
        const n = [];
        let u, f;
        for (const _ of i) {
          const b = hs(_);
          b !== 0 && (_.area = Math.abs(b), f === void 0 && (f = b < 0), f === b < 0 ? (u && n.push(u), u = [_]) : u.push(_));
        }
        if (u && n.push(u), t > 1) for (let _ = 0; _ < n.length; _++) n[_].length <= t || (Ko(n[_], t, 1, n[_].length - 1, el), n[_] = n[_].slice(0, t));
        return n;
      }
      function el(i, t) {
        return t.area - i.area;
      }
      function hs(i) {
        let t = 0;
        for (let n, u, f = 0, _ = i.length, b = _ - 1; f < _; b = f++) n = i[f], u = i[b], t += (u.x - n.x) * (n.y + u.y);
        return t;
      }
      const go = 1 / 298.257223563, I = go * (2 - go), K = Math.PI / 180;
      class Ee {
        constructor(t) {
          const n = 6378.137 * K * 1e3, u = Math.cos(t * K), f = 1 / (1 - I * (1 - u * u)), _ = Math.sqrt(f);
          this.kx = n * _ * u, this.ky = n * _ * f * (1 - I);
        }
        distance(t, n) {
          const u = this.wrap(t[0] - n[0]) * this.kx, f = (t[1] - n[1]) * this.ky;
          return Math.sqrt(u * u + f * f);
        }
        pointOnLine(t, n) {
          let u, f, _, b, E = 1 / 0;
          for (let C = 0; C < t.length - 1; C++) {
            let L = t[C][0], R = t[C][1], U = this.wrap(t[C + 1][0] - L) * this.kx, H = (t[C + 1][1] - R) * this.ky, J = 0;
            U === 0 && H === 0 || (J = (this.wrap(n[0] - L) * this.kx * U + (n[1] - R) * this.ky * H) / (U * U + H * H), J > 1 ? (L = t[C + 1][0], R = t[C + 1][1]) : J > 0 && (L += U / this.kx * J, R += H / this.ky * J)), U = this.wrap(n[0] - L) * this.kx, H = (n[1] - R) * this.ky;
            const ne = U * U + H * H;
            ne < E && (E = ne, u = L, f = R, _ = C, b = J);
          }
          return { point: [u, f], index: _, t: Math.max(0, Math.min(1, b)) };
        }
        wrap(t) {
          for (; t < -180; ) t += 360;
          for (; t > 180; ) t -= 360;
          return t;
        }
      }
      function Re(i, t) {
        return t[0] - i[0];
      }
      function Ye(i) {
        return i[1] - i[0] + 1;
      }
      function ct(i, t) {
        return i[1] >= i[0] && i[1] < t;
      }
      function It(i, t) {
        if (i[0] > i[1]) return [null, null];
        const n = Ye(i);
        if (t) {
          if (n === 2) return [i, null];
          const f = Math.floor(n / 2);
          return [[i[0], i[0] + f], [i[0] + f, i[1]]];
        }
        if (n === 1) return [i, null];
        const u = Math.floor(n / 2) - 1;
        return [[i[0], i[0] + u], [i[0] + u + 1, i[1]]];
      }
      function Ut(i, t) {
        if (!ct(t, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let u = t[0]; u <= t[1]; ++u) Aa(n, i[u]);
        return n;
      }
      function ui(i) {
        const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const n of i) for (const u of n) Aa(t, u);
        return t;
      }
      function bi(i) {
        return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0;
      }
      function Ti(i, t, n) {
        if (!bi(i) || !bi(t)) return NaN;
        let u = 0, f = 0;
        return i[2] < t[0] && (u = t[0] - i[2]), i[0] > t[2] && (u = i[0] - t[2]), i[1] > t[3] && (f = i[1] - t[3]), i[3] < t[1] && (f = t[1] - i[3]), n.distance([0, 0], [u, f]);
      }
      function ki(i, t, n) {
        const u = n.pointOnLine(t, i);
        return n.distance(i, u.point);
      }
      function nr(i, t, n, u, f) {
        const _ = Math.min(ki(i, [n, u], f), ki(t, [n, u], f)), b = Math.min(ki(n, [i, t], f), ki(u, [i, t], f));
        return Math.min(_, b);
      }
      function Sr(i, t, n, u, f) {
        if (!ct(t, i.length) || !ct(u, n.length)) return 1 / 0;
        let _ = 1 / 0;
        for (let b = t[0]; b < t[1]; ++b) {
          const E = i[b], C = i[b + 1];
          for (let L = u[0]; L < u[1]; ++L) {
            const R = n[L], U = n[L + 1];
            if (la(E, C, R, U)) return 0;
            _ = Math.min(_, nr(E, C, R, U, f));
          }
        }
        return _;
      }
      function Ci(i, t, n, u, f) {
        if (!ct(t, i.length) || !ct(u, n.length)) return NaN;
        let _ = 1 / 0;
        for (let b = t[0]; b <= t[1]; ++b) for (let E = u[0]; E <= u[1]; ++E) if (_ = Math.min(_, f.distance(i[b], n[E])), _ === 0) return _;
        return _;
      }
      function Xr(i, t, n) {
        if (Cn(i, t, !0)) return 0;
        let u = 1 / 0;
        for (const f of t) {
          const _ = f[0], b = f[f.length - 1];
          if (_ !== b && (u = Math.min(u, ki(i, [b, _], n)), u === 0)) return u;
          const E = n.pointOnLine(f, i);
          if (u = Math.min(u, n.distance(i, E.point)), u === 0) return u;
        }
        return u;
      }
      function oi(i, t, n, u) {
        if (!ct(t, i.length)) return NaN;
        for (let _ = t[0]; _ <= t[1]; ++_) if (Cn(i[_], n, !0)) return 0;
        let f = 1 / 0;
        for (let _ = t[0]; _ < t[1]; ++_) {
          const b = i[_], E = i[_ + 1];
          for (const C of n) for (let L = 0, R = C.length, U = R - 1; L < R; U = L++) {
            const H = C[U], J = C[L];
            if (la(b, E, H, J)) return 0;
            f = Math.min(f, nr(b, E, H, J, u));
          }
        }
        return f;
      }
      function _n(i, t) {
        for (const n of i) for (const u of n) if (Cn(u, t, !0)) return !0;
        return !1;
      }
      function Mi(i, t, n, u = 1 / 0) {
        const f = ui(i), _ = ui(t);
        if (u !== 1 / 0 && Ti(f, _, n) >= u) return u;
        if (oa(f, _)) {
          if (_n(i, t)) return 0;
        } else if (_n(t, i)) return 0;
        let b = 1 / 0;
        for (const E of i) for (let C = 0, L = E.length, R = L - 1; C < L; R = C++) {
          const U = E[R], H = E[C];
          for (const J of t) for (let ne = 0, he = J.length, Se = he - 1; ne < he; Se = ne++) {
            const Pe = J[Se], Xe = J[ne];
            if (la(U, H, Pe, Xe)) return 0;
            b = Math.min(b, nr(U, H, Pe, Xe, n));
          }
        }
        return b;
      }
      function zi(i, t, n, u, f, _) {
        if (!_) return;
        const b = Ti(Ut(u, _), f, n);
        b < t && i.push([b, _, [0, 0]]);
      }
      function Ea(i, t, n, u, f, _, b) {
        if (!_ || !b) return;
        const E = Ti(Ut(u, _), Ut(f, b), n);
        E < t && i.push([E, _, b]);
      }
      function Va(i, t, n, u, f = 1 / 0) {
        let _ = Math.min(u.distance(i[0], n[0][0]), f);
        if (_ === 0) return _;
        const b = new fo([[0, [0, i.length - 1], [0, 0]]], Re), E = ui(n);
        for (; b.length > 0; ) {
          const C = b.pop();
          if (C[0] >= _) continue;
          const L = C[1], R = t ? 50 : 100;
          if (Ye(L) <= R) {
            if (!ct(L, i.length)) return NaN;
            if (t) {
              const U = oi(i, L, n, u);
              if (isNaN(U) || U === 0) return U;
              _ = Math.min(_, U);
            } else for (let U = L[0]; U <= L[1]; ++U) {
              const H = Xr(i[U], n, u);
              if (_ = Math.min(_, H), _ === 0) return 0;
            }
          } else {
            const U = It(L, t);
            zi(b, _, u, i, E, U[0]), zi(b, _, u, i, E, U[1]);
          }
        }
        return _;
      }
      function $a(i, t, n, u, f, _ = 1 / 0) {
        let b = Math.min(_, f.distance(i[0], n[0]));
        if (b === 0) return b;
        const E = new fo([[0, [0, i.length - 1], [0, n.length - 1]]], Re);
        for (; E.length > 0; ) {
          const C = E.pop();
          if (C[0] >= b) continue;
          const L = C[1], R = C[2], U = t ? 50 : 100, H = u ? 50 : 100;
          if (Ye(L) <= U && Ye(R) <= H) {
            if (!ct(L, i.length) && ct(R, n.length)) return NaN;
            let J;
            if (t && u) J = Sr(i, L, n, R, f), b = Math.min(b, J);
            else if (t && !u) {
              const ne = i.slice(L[0], L[1] + 1);
              for (let he = R[0]; he <= R[1]; ++he) if (J = ki(n[he], ne, f), b = Math.min(b, J), b === 0) return b;
            } else if (!t && u) {
              const ne = n.slice(R[0], R[1] + 1);
              for (let he = L[0]; he <= L[1]; ++he) if (J = ki(i[he], ne, f), b = Math.min(b, J), b === 0) return b;
            } else J = Ci(i, L, n, R, f), b = Math.min(b, J);
          } else {
            const J = It(L, t), ne = It(R, u);
            Ea(E, b, f, i, n, J[0], ne[0]), Ea(E, b, f, i, n, J[0], ne[1]), Ea(E, b, f, i, n, J[1], ne[0]), Ea(E, b, f, i, n, J[1], ne[1]);
          }
        }
        return b;
      }
      function ds(i) {
        return i.type === "MultiPolygon" ? i.coordinates.map((t) => ({ type: "Polygon", coordinates: t })) : i.type === "MultiLineString" ? i.coordinates.map((t) => ({ type: "LineString", coordinates: t })) : i.type === "MultiPoint" ? i.coordinates.map((t) => ({ type: "Point", coordinates: t })) : [i];
      }
      class ca {
        constructor(t, n) {
          this.type = ft, this.geojson = t, this.geometries = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
          if (Rn(t[1])) {
            const u = t[1];
            if (u.type === "FeatureCollection") return new ca(u, u.features.map((f) => ds(f.geometry)).flat());
            if (u.type === "Feature") return new ca(u, ds(u.geometry));
            if ("type" in u && "coordinates" in u) return new ca(u, ds(u));
          }
          return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t) {
          if (t.geometry() != null && t.canonicalID() != null) {
            if (t.geometryType() === "Point") return function(n, u) {
              const f = n.geometry(), _ = f.flat().map((C) => uo([C.x, C.y], n.canonical));
              if (f.length === 0) return NaN;
              const b = new Ee(_[0][1]);
              let E = 1 / 0;
              for (const C of u) {
                switch (C.type) {
                  case "Point":
                    E = Math.min(E, $a(_, !1, [C.coordinates], !1, b, E));
                    break;
                  case "LineString":
                    E = Math.min(E, $a(_, !1, C.coordinates, !0, b, E));
                    break;
                  case "Polygon":
                    E = Math.min(E, Va(_, !1, C.coordinates, b, E));
                }
                if (E === 0) return E;
              }
              return E;
            }(t, this.geometries);
            if (t.geometryType() === "LineString") return function(n, u) {
              const f = n.geometry(), _ = f.flat().map((C) => uo([C.x, C.y], n.canonical));
              if (f.length === 0) return NaN;
              const b = new Ee(_[0][1]);
              let E = 1 / 0;
              for (const C of u) {
                switch (C.type) {
                  case "Point":
                    E = Math.min(E, $a(_, !0, [C.coordinates], !1, b, E));
                    break;
                  case "LineString":
                    E = Math.min(E, $a(_, !0, C.coordinates, !0, b, E));
                    break;
                  case "Polygon":
                    E = Math.min(E, Va(_, !0, C.coordinates, b, E));
                }
                if (E === 0) return E;
              }
              return E;
            }(t, this.geometries);
            if (t.geometryType() === "Polygon") return function(n, u) {
              const f = n.geometry();
              if (f.length === 0 || f[0].length === 0) return NaN;
              const _ = Sa(f, 0).map((C) => C.map((L) => L.map((R) => uo([R.x, R.y], n.canonical)))), b = new Ee(_[0][0][0][1]);
              let E = 1 / 0;
              for (const C of u) for (const L of _) {
                switch (C.type) {
                  case "Point":
                    E = Math.min(E, Va([C.coordinates], !1, L, b, E));
                    break;
                  case "LineString":
                    E = Math.min(E, Va(C.coordinates, !0, L, b, E));
                    break;
                  case "Polygon":
                    E = Math.min(E, Mi(L, C.coordinates, b, E));
                }
                if (E === 0) return E;
              }
              return E;
            }(t, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      const Ta = { "==": ao, "!=": so, ">": tu, "<": Tl, ">=": oo, "<=": iu, array: on, at: eo, boolean: on, case: ls, coalesce: no, collator: sa, format: lo, image: Ua, in: Wo, "index-of": ja, interpolate: si, "interpolate-hcl": si, "interpolate-lab": si, length: Ns, let: aa, literal: gn, match: Xo, number: on, "number-format": wa, object: on, slice: Ps, step: us, string: on, "to-boolean": Ar, "to-color": Ar, "to-number": Ar, "to-string": Ar, var: Ri, within: On, distance: ca };
      class qr {
        constructor(t, n, u, f) {
          this.name = t, this.type = n, this._evaluate = u, this.args = f;
        }
        evaluate(t) {
          return this._evaluate(t, this.args);
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return !1;
        }
        static parse(t, n) {
          const u = t[0], f = qr.definitions[u];
          if (!f) return n.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const _ = Array.isArray(f) ? f[0] : f.type, b = Array.isArray(f) ? [[f[1], f[2]]] : f.overloads, E = b.filter(([L]) => !Array.isArray(L) || L.length === t.length - 1);
          let C = null;
          for (const [L, R] of E) {
            C = new na(n.registry, Za, n.path, null, n.scope);
            const U = [];
            let H = !1;
            for (let J = 1; J < t.length; J++) {
              const ne = t[J], he = Array.isArray(L) ? L[J - 1] : L.type, Se = C.parse(ne, 1 + U.length, he);
              if (!Se) {
                H = !0;
                break;
              }
              U.push(Se);
            }
            if (!H) if (Array.isArray(L) && L.length !== U.length) C.error(`Expected ${L.length} arguments, but found ${U.length} instead.`);
            else {
              for (let J = 0; J < U.length; J++) {
                const ne = Array.isArray(L) ? L[J] : L.type, he = U[J];
                C.concat(J + 1).checkSubtype(ne, he.type);
              }
              if (C.errors.length === 0) return new qr(u, _, R, U);
            }
          }
          if (E.length === 1) n.errors.push(...C.errors);
          else {
            const L = (E.length ? E : b).map(([U]) => {
              return H = U, Array.isArray(H) ? `(${H.map(j).join(", ")})` : `(${j(H.type)}...)`;
              var H;
            }).join(" | "), R = [];
            for (let U = 1; U < t.length; U++) {
              const H = n.parse(t[U], 1 + R.length);
              if (!H) return null;
              R.push(j(H.type));
            }
            n.error(`Expected arguments of type ${L}, but found (${R.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t, n) {
          qr.definitions = n;
          for (const u in n) t[u] = qr;
        }
      }
      function Yr(i, [t, n, u, f]) {
        t = t.evaluate(i), n = n.evaluate(i), u = u.evaluate(i);
        const _ = f ? f.evaluate(i) : 1, b = os(t, n, u, _);
        if (b) throw new hr(b);
        return new ji(t / 255, n / 255, u / 255, _, !1);
      }
      function ps(i, t) {
        return i in t;
      }
      function fs(i, t) {
        const n = t[i];
        return n === void 0 ? null : n;
      }
      function jn(i) {
        return { type: i };
      }
      function Za(i) {
        if (i instanceof Ri) return Za(i.boundExpression);
        if (i instanceof qr && i.name === "error" || i instanceof sa || i instanceof On || i instanceof ca) return !1;
        const t = i instanceof Ar || i instanceof on;
        let n = !0;
        return i.eachChild((u) => {
          n = t ? n && Za(u) : n && u instanceof gn;
        }), !!n && zr(i) && Ga(i, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function zr(i) {
        if (i instanceof qr && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof On || i instanceof ca) return !1;
        let t = !0;
        return i.eachChild((n) => {
          t && !zr(n) && (t = !1);
        }), t;
      }
      function ms(i) {
        if (i instanceof qr && i.name === "feature-state") return !1;
        let t = !0;
        return i.eachChild((n) => {
          t && !ms(n) && (t = !1);
        }), t;
      }
      function Ga(i, t) {
        if (i instanceof qr && t.indexOf(i.name) >= 0) return !1;
        let n = !0;
        return i.eachChild((u) => {
          n && !Ga(u, t) && (n = !1);
        }), n;
      }
      function Bs(i) {
        return { result: "success", value: i };
      }
      function Jr(i) {
        return { result: "error", value: i };
      }
      function Ca(i) {
        return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven";
      }
      function kl(i) {
        return !!i.expression && i.expression.parameters.indexOf("zoom") > -1;
      }
      function tl(i) {
        return !!i.expression && i.expression.interpolated;
      }
      function Di(i) {
        return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i;
      }
      function un(i) {
        return typeof i == "object" && i !== null && !Array.isArray(i);
      }
      function ha(i) {
        return i;
      }
      function Ha(i, t) {
        const n = t.type === "color", u = i.stops && typeof i.stops[0][0] == "object", f = u || !(u || i.property !== void 0), _ = i.type || (tl(t) ? "exponential" : "interval");
        if (n || t.type === "padding") {
          const R = n ? ji.parse : sn.parse;
          (i = Jt({}, i)).stops && (i.stops = i.stops.map((U) => [U[0], R(U[1])])), i.default = R(i.default ? i.default : t.default);
        }
        if (i.colorSpace && (b = i.colorSpace) !== "rgb" && b !== "hcl" && b !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
        var b;
        let E, C, L;
        if (_ === "exponential") E = qn;
        else if (_ === "interval") E = Wa;
        else if (_ === "categorical") {
          E = Da, C = /* @__PURE__ */ Object.create(null);
          for (const R of i.stops) C[R[0]] = R[1];
          L = typeof i.stops[0][0];
        } else {
          if (_ !== "identity") throw new Error(`Unknown function type "${_}"`);
          E = Rs;
        }
        if (u) {
          const R = {}, U = [];
          for (let ne = 0; ne < i.stops.length; ne++) {
            const he = i.stops[ne], Se = he[0].zoom;
            R[Se] === void 0 && (R[Se] = { zoom: Se, type: i.type, property: i.property, default: i.default, stops: [] }, U.push(Se)), R[Se].stops.push([he[0].value, he[1]]);
          }
          const H = [];
          for (const ne of U) H.push([R[ne].zoom, Ha(R[ne], t)]);
          const J = { name: "linear" };
          return { kind: "composite", interpolationType: J, interpolationFactor: si.interpolationFactor.bind(void 0, J), zoomStops: H.map((ne) => ne[0]), evaluate: ({ zoom: ne }, he) => qn({ stops: H, base: i.base }, t, ne).evaluate(ne, he) };
        }
        if (f) {
          const R = _ === "exponential" ? { name: "exponential", base: i.base !== void 0 ? i.base : 1 } : null;
          return { kind: "camera", interpolationType: R, interpolationFactor: si.interpolationFactor.bind(void 0, R), zoomStops: i.stops.map((U) => U[0]), evaluate: ({ zoom: U }) => E(i, t, U, C, L) };
        }
        return { kind: "source", evaluate(R, U) {
          const H = U && U.properties ? U.properties[i.property] : void 0;
          return H === void 0 ? cn(i.default, t.default) : E(i, t, H, C, L);
        } };
      }
      function cn(i, t, n) {
        return i !== void 0 ? i : t !== void 0 ? t : n !== void 0 ? n : void 0;
      }
      function Da(i, t, n, u, f) {
        return cn(typeof n === f ? u[n] : void 0, i.default, t.default);
      }
      function Wa(i, t, n) {
        if (Di(n) !== "number") return cn(i.default, t.default);
        const u = i.stops.length;
        if (u === 1 || n <= i.stops[0][0]) return i.stops[0][1];
        if (n >= i.stops[u - 1][0]) return i.stops[u - 1][1];
        const f = to(i.stops.map((_) => _[0]), n);
        return i.stops[f][1];
      }
      function qn(i, t, n) {
        const u = i.base !== void 0 ? i.base : 1;
        if (Di(n) !== "number") return cn(i.default, t.default);
        const f = i.stops.length;
        if (f === 1 || n <= i.stops[0][0]) return i.stops[0][1];
        if (n >= i.stops[f - 1][0]) return i.stops[f - 1][1];
        const _ = to(i.stops.map((R) => R[0]), n), b = function(R, U, H, J) {
          const ne = J - H, he = R - H;
          return ne === 0 ? 0 : U === 1 ? he / ne : (Math.pow(U, he) - 1) / (Math.pow(U, ne) - 1);
        }(n, u, i.stops[_][0], i.stops[_ + 1][0]), E = i.stops[_][1], C = i.stops[_ + 1][1], L = jr[t.type] || ha;
        return typeof E.evaluate == "function" ? { evaluate(...R) {
          const U = E.evaluate.apply(void 0, R), H = C.evaluate.apply(void 0, R);
          if (U !== void 0 && H !== void 0) return L(U, H, b, i.colorSpace);
        } } : L(E, C, b, i.colorSpace);
      }
      function Rs(i, t, n) {
        switch (t.type) {
          case "color":
            n = ji.parse(n);
            break;
          case "formatted":
            n = Hr.fromString(n.toString());
            break;
          case "resolvedImage":
            n = Wr.fromString(n.toString());
            break;
          case "padding":
            n = sn.parse(n);
            break;
          default:
            Di(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0);
        }
        return cn(n, i.default, t.default);
      }
      qr.register(Ta, { error: [{ kind: "error" }, [ri], (i, [t]) => {
        throw new hr(t.evaluate(i));
      }], typeof: [ri, [zt], (i, [t]) => j(br(t.evaluate(i)))], "to-rgba": [B(ft, 4), [Si], (i, [t]) => {
        const [n, u, f, _] = t.evaluate(i).rgb;
        return [255 * n, 255 * u, 255 * f, _];
      }], rgb: [Si, [ft, ft, ft], Yr], rgba: [Si, [ft, ft, ft, ft], Yr], has: { type: Lt, overloads: [[[ri], (i, [t]) => ps(t.evaluate(i), i.properties())], [[ri, Gi], (i, [t, n]) => ps(t.evaluate(i), n.evaluate(i))]] }, get: { type: zt, overloads: [[[ri], (i, [t]) => fs(t.evaluate(i), i.properties())], [[ri, Gi], (i, [t, n]) => fs(t.evaluate(i), n.evaluate(i))]] }, "feature-state": [zt, [ri], (i, [t]) => fs(t.evaluate(i), i.featureState || {})], properties: [Gi, [], (i) => i.properties()], "geometry-type": [ri, [], (i) => i.geometryType()], id: [zt, [], (i) => i.id()], zoom: [ft, [], (i) => i.globals.zoom], "heatmap-density": [ft, [], (i) => i.globals.heatmapDensity || 0], "line-progress": [ft, [], (i) => i.globals.lineProgress || 0], accumulated: [zt, [], (i) => i.globals.accumulated === void 0 ? null : i.globals.accumulated], "+": [ft, jn(ft), (i, t) => {
        let n = 0;
        for (const u of t) n += u.evaluate(i);
        return n;
      }], "*": [ft, jn(ft), (i, t) => {
        let n = 1;
        for (const u of t) n *= u.evaluate(i);
        return n;
      }], "-": { type: ft, overloads: [[[ft, ft], (i, [t, n]) => t.evaluate(i) - n.evaluate(i)], [[ft], (i, [t]) => -t.evaluate(i)]] }, "/": [ft, [ft, ft], (i, [t, n]) => t.evaluate(i) / n.evaluate(i)], "%": [ft, [ft, ft], (i, [t, n]) => t.evaluate(i) % n.evaluate(i)], ln2: [ft, [], () => Math.LN2], pi: [ft, [], () => Math.PI], e: [ft, [], () => Math.E], "^": [ft, [ft, ft], (i, [t, n]) => Math.pow(t.evaluate(i), n.evaluate(i))], sqrt: [ft, [ft], (i, [t]) => Math.sqrt(t.evaluate(i))], log10: [ft, [ft], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10], ln: [ft, [ft], (i, [t]) => Math.log(t.evaluate(i))], log2: [ft, [ft], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2], sin: [ft, [ft], (i, [t]) => Math.sin(t.evaluate(i))], cos: [ft, [ft], (i, [t]) => Math.cos(t.evaluate(i))], tan: [ft, [ft], (i, [t]) => Math.tan(t.evaluate(i))], asin: [ft, [ft], (i, [t]) => Math.asin(t.evaluate(i))], acos: [ft, [ft], (i, [t]) => Math.acos(t.evaluate(i))], atan: [ft, [ft], (i, [t]) => Math.atan(t.evaluate(i))], min: [ft, jn(ft), (i, t) => Math.min(...t.map((n) => n.evaluate(i)))], max: [ft, jn(ft), (i, t) => Math.max(...t.map((n) => n.evaluate(i)))], abs: [ft, [ft], (i, [t]) => Math.abs(t.evaluate(i))], round: [ft, [ft], (i, [t]) => {
        const n = t.evaluate(i);
        return n < 0 ? -Math.round(-n) : Math.round(n);
      }], floor: [ft, [ft], (i, [t]) => Math.floor(t.evaluate(i))], ceil: [ft, [ft], (i, [t]) => Math.ceil(t.evaluate(i))], "filter-==": [Lt, [ri, zt], (i, [t, n]) => i.properties()[t.value] === n.value], "filter-id-==": [Lt, [zt], (i, [t]) => i.id() === t.value], "filter-type-==": [Lt, [ri], (i, [t]) => i.geometryType() === t.value], "filter-<": [Lt, [ri, zt], (i, [t, n]) => {
        const u = i.properties()[t.value], f = n.value;
        return typeof u == typeof f && u < f;
      }], "filter-id-<": [Lt, [zt], (i, [t]) => {
        const n = i.id(), u = t.value;
        return typeof n == typeof u && n < u;
      }], "filter->": [Lt, [ri, zt], (i, [t, n]) => {
        const u = i.properties()[t.value], f = n.value;
        return typeof u == typeof f && u > f;
      }], "filter-id->": [Lt, [zt], (i, [t]) => {
        const n = i.id(), u = t.value;
        return typeof n == typeof u && n > u;
      }], "filter-<=": [Lt, [ri, zt], (i, [t, n]) => {
        const u = i.properties()[t.value], f = n.value;
        return typeof u == typeof f && u <= f;
      }], "filter-id-<=": [Lt, [zt], (i, [t]) => {
        const n = i.id(), u = t.value;
        return typeof n == typeof u && n <= u;
      }], "filter->=": [Lt, [ri, zt], (i, [t, n]) => {
        const u = i.properties()[t.value], f = n.value;
        return typeof u == typeof f && u >= f;
      }], "filter-id->=": [Lt, [zt], (i, [t]) => {
        const n = i.id(), u = t.value;
        return typeof n == typeof u && n >= u;
      }], "filter-has": [Lt, [zt], (i, [t]) => t.value in i.properties()], "filter-has-id": [Lt, [], (i) => i.id() !== null && i.id() !== void 0], "filter-type-in": [Lt, [B(ri)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0], "filter-id-in": [Lt, [B(zt)], (i, [t]) => t.value.indexOf(i.id()) >= 0], "filter-in-small": [Lt, [ri, B(zt)], (i, [t, n]) => n.value.indexOf(i.properties()[t.value]) >= 0], "filter-in-large": [Lt, [ri, B(zt)], (i, [t, n]) => function(u, f, _, b) {
        for (; _ <= b; ) {
          const E = _ + b >> 1;
          if (f[E] === u) return !0;
          f[E] > u ? b = E - 1 : _ = E + 1;
        }
        return !1;
      }(i.properties()[t.value], n.value, 0, n.value.length - 1)], all: { type: Lt, overloads: [[[Lt, Lt], (i, [t, n]) => t.evaluate(i) && n.evaluate(i)], [jn(Lt), (i, t) => {
        for (const n of t) if (!n.evaluate(i)) return !1;
        return !0;
      }]] }, any: { type: Lt, overloads: [[[Lt, Lt], (i, [t, n]) => t.evaluate(i) || n.evaluate(i)], [jn(Lt), (i, t) => {
        for (const n of t) if (n.evaluate(i)) return !0;
        return !1;
      }]] }, "!": [Lt, [Lt], (i, [t]) => !t.evaluate(i)], "is-supported-script": [Lt, [ri], (i, [t]) => {
        const n = i.globals && i.globals.isSupportedScript;
        return !n || n(t.evaluate(i));
      }], upcase: [ri, [ri], (i, [t]) => t.evaluate(i).toUpperCase()], downcase: [ri, [ri], (i, [t]) => t.evaluate(i).toLowerCase()], concat: [ri, jn(zt), (i, t) => t.map((n) => rr(n.evaluate(i))).join("")], "resolved-locale": [ri, [cr], (i, [t]) => t.evaluate(i).resolvedLocale()] });
      class gs {
        constructor(t, n) {
          var u;
          this.expression = t, this._warningHistory = {}, this._evaluator = new Or(), this._defaultValue = n ? (u = n).type === "color" && un(u.default) ? new ji(0, 0, 0, 0) : u.type === "color" ? ji.parse(u.default) || null : u.type === "padding" ? sn.parse(u.default) || null : u.type === "variableAnchorOffsetCollection" ? mn.parse(u.default) || null : u.default === void 0 ? null : u.default : null, this._enumValues = n && n.type === "enum" ? n.values : null;
        }
        evaluateWithoutErrorHandling(t, n, u, f, _, b) {
          return this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = u, this._evaluator.canonical = f, this._evaluator.availableImages = _ || null, this._evaluator.formattedSection = b, this.expression.evaluate(this._evaluator);
        }
        evaluate(t, n, u, f, _, b) {
          this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = u || null, this._evaluator.canonical = f, this._evaluator.availableImages = _ || null, this._evaluator.formattedSection = b || null;
          try {
            const E = this.expression.evaluate(this._evaluator);
            if (E == null || typeof E == "number" && E != E) return this._defaultValue;
            if (this._enumValues && !(E in this._enumValues)) throw new hr(`Expected value to be one of ${Object.keys(this._enumValues).map((C) => JSON.stringify(C)).join(", ")}, but found ${JSON.stringify(E)} instead.`);
            return E;
          } catch (E) {
            return this._warningHistory[E.message] || (this._warningHistory[E.message] = !0, typeof console < "u" && console.warn(E.message)), this._defaultValue;
          }
        }
      }
      function da(i) {
        return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in Ta;
      }
      function Kr(i, t) {
        const n = new na(Ta, Za, [], t ? function(f) {
          const _ = { color: Si, string: ri, number: ft, enum: ri, boolean: Lt, formatted: Ni, padding: ie, resolvedImage: ue, variableAnchorOffsetCollection: $ };
          return f.type === "array" ? B(_[f.value] || zt, f.length) : _[f.type];
        }(t) : void 0), u = n.parse(i, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return u ? Bs(new gs(u, t)) : Jr(n.errors);
      }
      class yn {
        constructor(t, n) {
          this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !ms(n.expression);
        }
        evaluateWithoutErrorHandling(t, n, u, f, _, b) {
          return this._styleExpression.evaluateWithoutErrorHandling(t, n, u, f, _, b);
        }
        evaluate(t, n, u, f, _, b) {
          return this._styleExpression.evaluate(t, n, u, f, _, b);
        }
      }
      class Un {
        constructor(t, n, u, f) {
          this.kind = t, this.zoomStops = u, this._styleExpression = n, this.isStateDependent = t !== "camera" && !ms(n.expression), this.interpolationType = f;
        }
        evaluateWithoutErrorHandling(t, n, u, f, _, b) {
          return this._styleExpression.evaluateWithoutErrorHandling(t, n, u, f, _, b);
        }
        evaluate(t, n, u, f, _, b) {
          return this._styleExpression.evaluate(t, n, u, f, _, b);
        }
        interpolationFactor(t, n, u) {
          return this.interpolationType ? si.interpolationFactor(this.interpolationType, t, n, u) : 0;
        }
      }
      function _s(i, t) {
        const n = Kr(i, t);
        if (n.result === "error") return n;
        const u = n.value.expression, f = zr(u);
        if (!f && !Ca(t)) return Jr([new ai("", "data expressions not supported")]);
        const _ = Ga(u, ["zoom"]);
        if (!_ && !kl(t)) return Jr([new ai("", "zoom expressions not supported")]);
        const b = $n(u);
        return b || _ ? b instanceof ai ? Jr([b]) : b instanceof si && !tl(t) ? Jr([new ai("", '"interpolate" expressions cannot be used with this property')]) : Bs(b ? new Un(f ? "camera" : "composite", n.value, b.labels, b instanceof si ? b.interpolation : void 0) : new yn(f ? "constant" : "source", n.value)) : Jr([new ai("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class Vn {
        constructor(t, n) {
          this._parameters = t, this._specification = n, Jt(this, Ha(this._parameters, this._specification));
        }
        static deserialize(t) {
          return new Vn(t._parameters, t._specification);
        }
        static serialize(t) {
          return { _parameters: t._parameters, _specification: t._specification };
        }
      }
      function $n(i) {
        let t = null;
        if (i instanceof aa) t = $n(i.result);
        else if (i instanceof no) {
          for (const n of i.args) if (t = $n(n), t) break;
        } else (i instanceof us || i instanceof si) && i.input instanceof qr && i.input.name === "zoom" && (t = i);
        return t instanceof ai || i.eachChild((n) => {
          const u = $n(n);
          u instanceof ai ? t = u : !t && u ? t = new ai("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && u && t !== u && (t = new ai("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), t;
      }
      function ys(i) {
        if (i === !0 || i === !1) return !0;
        if (!Array.isArray(i) || i.length === 0) return !1;
        switch (i[0]) {
          case "has":
            return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
          case "in":
            return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
          case "any":
          case "all":
            for (const t of i.slice(1)) if (!ys(t) && typeof t != "boolean") return !1;
            return !0;
          default:
            return !0;
        }
      }
      const hn = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function pa(i) {
        if (i == null) return { filter: () => !0, needGeometry: !1 };
        ys(i) || (i = dr(i));
        const t = Kr(i, hn);
        if (t.result === "error") throw new Error(t.value.map((n) => `${n.key}: ${n.message}`).join(", "));
        return { filter: (n, u, f) => t.value.evaluate(n, u, {}, f), needGeometry: Yi(i) };
      }
      function tr(i, t) {
        return i < t ? -1 : i > t ? 1 : 0;
      }
      function Yi(i) {
        if (!Array.isArray(i)) return !1;
        if (i[0] === "within" || i[0] === "distance") return !0;
        for (let t = 1; t < i.length; t++) if (Yi(i[t])) return !0;
        return !1;
      }
      function dr(i) {
        if (!i) return !0;
        const t = i[0];
        return i.length <= 1 ? t !== "any" : t === "==" ? Er(i[1], i[2], "==") : t === "!=" ? Tr(Er(i[1], i[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Er(i[1], i[2], t) : t === "any" ? (n = i.slice(1), ["any"].concat(n.map(dr))) : t === "all" ? ["all"].concat(i.slice(1).map(dr)) : t === "none" ? ["all"].concat(i.slice(1).map(dr).map(Tr)) : t === "in" ? Dn(i[1], i.slice(2)) : t === "!in" ? Tr(Dn(i[1], i.slice(2))) : t === "has" ? Zn(i[1]) : t !== "!has" || Tr(Zn(i[1]));
        var n;
      }
      function Er(i, t, n) {
        switch (i) {
          case "$type":
            return [`filter-type-${n}`, t];
          case "$id":
            return [`filter-id-${n}`, t];
          default:
            return [`filter-${n}`, i, t];
        }
      }
      function Dn(i, t) {
        if (t.length === 0) return !1;
        switch (i) {
          case "$type":
            return ["filter-type-in", ["literal", t]];
          case "$id":
            return ["filter-id-in", ["literal", t]];
          default:
            return t.length > 200 && !t.some((n) => typeof n != typeof t[0]) ? ["filter-in-large", i, ["literal", t.sort(tr)]] : ["filter-in-small", i, ["literal", t]];
        }
      }
      function Zn(i) {
        switch (i) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", i];
        }
      }
      function Tr(i) {
        return ["!", i];
      }
      function Ia(i) {
        const t = typeof i;
        if (t === "number" || t === "boolean" || t === "string" || i == null) return JSON.stringify(i);
        if (Array.isArray(i)) {
          let f = "[";
          for (const _ of i) f += `${Ia(_)},`;
          return `${f}]`;
        }
        const n = Object.keys(i).sort();
        let u = "{";
        for (let f = 0; f < n.length; f++) u += `${JSON.stringify(n[f])}:${Ia(i[n[f]])},`;
        return `${u}}`;
      }
      function nu(i) {
        let t = "";
        for (const n of Kt) t += `/${Ia(i[n])}`;
        return t;
      }
      function au(i) {
        const t = i.value;
        return t ? [new pt(i.key, t, "constants have been deprecated as of v8")] : [];
      }
      function gr(i) {
        return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i;
      }
      function Gn(i) {
        if (Array.isArray(i)) return i.map(Gn);
        if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
          const t = {};
          for (const n in i) t[n] = Gn(i[n]);
          return t;
        }
        return gr(i);
      }
      function vn(i) {
        const t = i.key, n = i.value, u = i.valueSpec || {}, f = i.objectElementValidators || {}, _ = i.style, b = i.styleSpec, E = i.validateSpec;
        let C = [];
        const L = Di(n);
        if (L !== "object") return [new pt(t, n, `object expected, ${L} found`)];
        for (const R in n) {
          const U = R.split(".")[0], H = u[U] || u["*"];
          let J;
          if (f[U]) J = f[U];
          else if (u[U]) J = E;
          else if (f["*"]) J = f["*"];
          else {
            if (!u["*"]) {
              C.push(new pt(t, n[R], `unknown property "${R}"`));
              continue;
            }
            J = E;
          }
          C = C.concat(J({ key: (t && `${t}.`) + R, value: n[R], valueSpec: H, style: _, styleSpec: b, object: n, objectKey: R, validateSpec: E }, n));
        }
        for (const R in u) f[R] || u[R].required && u[R].default === void 0 && n[R] === void 0 && C.push(new pt(t, n, `missing required property "${R}"`));
        return C;
      }
      function _o(i) {
        const t = i.value, n = i.valueSpec, u = i.style, f = i.styleSpec, _ = i.key, b = i.arrayElementValidator || i.validateSpec;
        if (Di(t) !== "array") return [new pt(_, t, `array expected, ${Di(t)} found`)];
        if (n.length && t.length !== n.length) return [new pt(_, t, `array length ${n.length} expected, length ${t.length} found`)];
        if (n["min-length"] && t.length < n["min-length"]) return [new pt(_, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
        let E = { type: n.value, values: n.values };
        f.$version < 7 && (E.function = n.function), Di(n.value) === "object" && (E = n.value);
        let C = [];
        for (let L = 0; L < t.length; L++) C = C.concat(b({ array: t, arrayIndex: L, value: t[L], valueSpec: E, validateSpec: i.validateSpec, style: u, styleSpec: f, key: `${_}[${L}]` }));
        return C;
      }
      function il(i) {
        const t = i.key, n = i.value, u = i.valueSpec;
        let f = Di(n);
        return f === "number" && n != n && (f = "NaN"), f !== "number" ? [new pt(t, n, `number expected, ${f} found`)] : "minimum" in u && n < u.minimum ? [new pt(t, n, `${n} is less than the minimum value ${u.minimum}`)] : "maximum" in u && n > u.maximum ? [new pt(t, n, `${n} is greater than the maximum value ${u.maximum}`)] : [];
      }
      function Os(i) {
        const t = i.valueSpec, n = gr(i.value.type);
        let u, f, _, b = {};
        const E = n !== "categorical" && i.value.property === void 0, C = !E, L = Di(i.value.stops) === "array" && Di(i.value.stops[0]) === "array" && Di(i.value.stops[0][0]) === "object", R = vn({ key: i.key, value: i.value, valueSpec: i.styleSpec.function, validateSpec: i.validateSpec, style: i.style, styleSpec: i.styleSpec, objectElementValidators: { stops: function(J) {
          if (n === "identity") return [new pt(J.key, J.value, 'identity function may not have a "stops" property')];
          let ne = [];
          const he = J.value;
          return ne = ne.concat(_o({ key: J.key, value: he, valueSpec: J.valueSpec, validateSpec: J.validateSpec, style: J.style, styleSpec: J.styleSpec, arrayElementValidator: U })), Di(he) === "array" && he.length === 0 && ne.push(new pt(J.key, he, "array must have at least one stop")), ne;
        }, default: function(J) {
          return J.validateSpec({ key: J.key, value: J.value, valueSpec: t, validateSpec: J.validateSpec, style: J.style, styleSpec: J.styleSpec });
        } } });
        return n === "identity" && E && R.push(new pt(i.key, i.value, 'missing required property "property"')), n === "identity" || i.value.stops || R.push(new pt(i.key, i.value, 'missing required property "stops"')), n === "exponential" && i.valueSpec.expression && !tl(i.valueSpec) && R.push(new pt(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (C && !Ca(i.valueSpec) ? R.push(new pt(i.key, i.value, "property functions not supported")) : E && !kl(i.valueSpec) && R.push(new pt(i.key, i.value, "zoom functions not supported"))), n !== "categorical" && !L || i.value.property !== void 0 || R.push(new pt(i.key, i.value, '"property" property is required')), R;
        function U(J) {
          let ne = [];
          const he = J.value, Se = J.key;
          if (Di(he) !== "array") return [new pt(Se, he, `array expected, ${Di(he)} found`)];
          if (he.length !== 2) return [new pt(Se, he, `array length 2 expected, length ${he.length} found`)];
          if (L) {
            if (Di(he[0]) !== "object") return [new pt(Se, he, `object expected, ${Di(he[0])} found`)];
            if (he[0].zoom === void 0) return [new pt(Se, he, "object stop key must have zoom")];
            if (he[0].value === void 0) return [new pt(Se, he, "object stop key must have value")];
            if (_ && _ > gr(he[0].zoom)) return [new pt(Se, he[0].zoom, "stop zoom values must appear in ascending order")];
            gr(he[0].zoom) !== _ && (_ = gr(he[0].zoom), f = void 0, b = {}), ne = ne.concat(vn({ key: `${Se}[0]`, value: he[0], valueSpec: { zoom: {} }, validateSpec: J.validateSpec, style: J.style, styleSpec: J.styleSpec, objectElementValidators: { zoom: il, value: H } }));
          } else ne = ne.concat(H({ key: `${Se}[0]`, value: he[0], valueSpec: {}, validateSpec: J.validateSpec, style: J.style, styleSpec: J.styleSpec }, he));
          return da(Gn(he[1])) ? ne.concat([new pt(`${Se}[1]`, he[1], "expressions are not allowed in function stops.")]) : ne.concat(J.validateSpec({ key: `${Se}[1]`, value: he[1], valueSpec: t, validateSpec: J.validateSpec, style: J.style, styleSpec: J.styleSpec }));
        }
        function H(J, ne) {
          const he = Di(J.value), Se = gr(J.value), Pe = J.value !== null ? J.value : ne;
          if (u) {
            if (he !== u) return [new pt(J.key, Pe, `${he} stop domain type must match previous stop domain type ${u}`)];
          } else u = he;
          if (he !== "number" && he !== "string" && he !== "boolean") return [new pt(J.key, Pe, "stop domain value must be a number, string, or boolean")];
          if (he !== "number" && n !== "categorical") {
            let Xe = `number expected, ${he} found`;
            return Ca(t) && n === void 0 && (Xe += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new pt(J.key, Pe, Xe)];
          }
          return n !== "categorical" || he !== "number" || isFinite(Se) && Math.floor(Se) === Se ? n !== "categorical" && he === "number" && f !== void 0 && Se < f ? [new pt(J.key, Pe, "stop domain values must appear in ascending order")] : (f = Se, n === "categorical" && Se in b ? [new pt(J.key, Pe, "stop domain values must be unique")] : (b[Se] = !0, [])) : [new pt(J.key, Pe, `integer expected, found ${Se}`)];
        }
      }
      function Fr(i) {
        const t = (i.expressionContext === "property" ? _s : Kr)(Gn(i.value), i.valueSpec);
        if (t.result === "error") return t.value.map((u) => new pt(`${i.key}${u.key}`, i.value, u.message));
        const n = t.value.expression || t.value._styleExpression.expression;
        if (i.expressionContext === "property" && i.propertyKey === "text-font" && !n.outputDefined()) return [new pt(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (i.expressionContext === "property" && i.propertyType === "layout" && !ms(n)) return [new pt(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (i.expressionContext === "filter" && !ms(n)) return [new pt(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
        if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
          if (!Ga(n, ["zoom", "feature-state"])) return [new pt(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (i.expressionContext === "cluster-initial" && !zr(n)) return [new pt(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Pr(i) {
        const t = i.key, n = i.value, u = i.valueSpec, f = [];
        return Array.isArray(u.values) ? u.values.indexOf(gr(n)) === -1 && f.push(new pt(t, n, `expected one of [${u.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(u.values).indexOf(gr(n)) === -1 && f.push(new pt(t, n, `expected one of [${Object.keys(u.values).join(", ")}], ${JSON.stringify(n)} found`)), f;
      }
      function yo(i) {
        return ys(Gn(i.value)) ? Fr(Jt({}, i, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : js(i);
      }
      function js(i) {
        const t = i.value, n = i.key;
        if (Di(t) !== "array") return [new pt(n, t, `array expected, ${Di(t)} found`)];
        const u = i.styleSpec;
        let f, _ = [];
        if (t.length < 1) return [new pt(n, t, "filter array must have at least 1 element")];
        switch (_ = _.concat(Pr({ key: `${n}[0]`, value: t[0], valueSpec: u.filter_operator, style: i.style, styleSpec: i.styleSpec })), gr(t[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            t.length >= 2 && gr(t[1]) === "$type" && _.push(new pt(n, t, `"$type" cannot be use with operator "${t[0]}"`));
          case "==":
          case "!=":
            t.length !== 3 && _.push(new pt(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
          case "in":
          case "!in":
            t.length >= 2 && (f = Di(t[1]), f !== "string" && _.push(new pt(`${n}[1]`, t[1], `string expected, ${f} found`)));
            for (let b = 2; b < t.length; b++) f = Di(t[b]), gr(t[1]) === "$type" ? _ = _.concat(Pr({ key: `${n}[${b}]`, value: t[b], valueSpec: u.geometry_type, style: i.style, styleSpec: i.styleSpec })) : f !== "string" && f !== "number" && f !== "boolean" && _.push(new pt(`${n}[${b}]`, t[b], `string, number, or boolean expected, ${f} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let b = 1; b < t.length; b++) _ = _.concat(js({ key: `${n}[${b}]`, value: t[b], style: i.style, styleSpec: i.styleSpec }));
            break;
          case "has":
          case "!has":
            f = Di(t[1]), t.length !== 2 ? _.push(new pt(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : f !== "string" && _.push(new pt(`${n}[1]`, t[1], `string expected, ${f} found`));
        }
        return _;
      }
      function Pl(i, t) {
        const n = i.key, u = i.validateSpec, f = i.style, _ = i.styleSpec, b = i.value, E = i.objectKey, C = _[`${t}_${i.layerType}`];
        if (!C) return [];
        const L = E.match(/^(.*)-transition$/);
        if (t === "paint" && L && C[L[1]] && C[L[1]].transition) return u({ key: n, value: b, valueSpec: _.transition, style: f, styleSpec: _ });
        const R = i.valueSpec || C[E];
        if (!R) return [new pt(n, b, `unknown property "${E}"`)];
        let U;
        if (Di(b) === "string" && Ca(R) && !R.tokens && (U = /^{([^}]+)}$/.exec(b))) return [new pt(n, b, `"${E}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(U[1])} }\`.`)];
        const H = [];
        return i.layerType === "symbol" && (E === "text-field" && f && !f.glyphs && H.push(new pt(n, b, 'use of "text-field" requires a style "glyphs" property')), E === "text-font" && un(Gn(b)) && gr(b.type) === "identity" && H.push(new pt(n, b, '"text-font" does not support identity functions'))), H.concat(u({ key: i.key, value: b, valueSpec: R, style: f, styleSpec: _, expressionContext: "property", propertyType: t, propertyKey: E }));
      }
      function qs(i) {
        return Pl(i, "paint");
      }
      function vo(i) {
        return Pl(i, "layout");
      }
      function rl(i) {
        let t = [];
        const n = i.value, u = i.key, f = i.style, _ = i.styleSpec;
        n.type || n.ref || t.push(new pt(u, n, 'either "type" or "ref" is required'));
        let b = gr(n.type);
        const E = gr(n.ref);
        if (n.id) {
          const C = gr(n.id);
          for (let L = 0; L < i.arrayIndex; L++) {
            const R = f.layers[L];
            gr(R.id) === C && t.push(new pt(u, n.id, `duplicate layer id "${n.id}", previously used at line ${R.id.__line__}`));
          }
        }
        if ("ref" in n) {
          let C;
          ["type", "source", "source-layer", "filter", "layout"].forEach((L) => {
            L in n && t.push(new pt(u, n[L], `"${L}" is prohibited for ref layers`));
          }), f.layers.forEach((L) => {
            gr(L.id) === E && (C = L);
          }), C ? C.ref ? t.push(new pt(u, n.ref, "ref cannot reference another ref layer")) : b = gr(C.type) : t.push(new pt(u, n.ref, `ref layer "${E}" not found`));
        } else if (b !== "background") if (n.source) {
          const C = f.sources && f.sources[n.source], L = C && gr(C.type);
          C ? L === "vector" && b === "raster" ? t.push(new pt(u, n.source, `layer "${n.id}" requires a raster source`)) : L !== "raster-dem" && b === "hillshade" ? t.push(new pt(u, n.source, `layer "${n.id}" requires a raster-dem source`)) : L === "raster" && b !== "raster" ? t.push(new pt(u, n.source, `layer "${n.id}" requires a vector source`)) : L !== "vector" || n["source-layer"] ? L === "raster-dem" && b !== "hillshade" ? t.push(new pt(u, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : b !== "line" || !n.paint || !n.paint["line-gradient"] || L === "geojson" && C.lineMetrics || t.push(new pt(u, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new pt(u, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new pt(u, n.source, `source "${n.source}" not found`));
        } else t.push(new pt(u, n, 'missing required property "source"'));
        return t = t.concat(vn({ key: u, value: n, valueSpec: _.layer, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, objectElementValidators: { "*": () => [], type: () => i.validateSpec({ key: `${u}.type`, value: n.type, valueSpec: _.layer.type, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, object: n, objectKey: "type" }), filter: yo, layout: (C) => vn({ layer: n, key: C.key, value: C.value, style: C.style, styleSpec: C.styleSpec, validateSpec: C.validateSpec, objectElementValidators: { "*": (L) => vo(Jt({ layerType: b }, L)) } }), paint: (C) => vn({ layer: n, key: C.key, value: C.value, style: C.style, styleSpec: C.styleSpec, validateSpec: C.validateSpec, objectElementValidators: { "*": (L) => qs(Jt({ layerType: b }, L)) } }) } })), t;
      }
      function vs(i) {
        const t = i.value, n = i.key, u = Di(t);
        return u !== "string" ? [new pt(n, t, `string expected, ${u} found`)] : [];
      }
      const bo = { promoteId: function({ key: i, value: t }) {
        if (Di(t) === "string") return vs({ key: i, value: t });
        {
          const n = [];
          for (const u in t) n.push(...vs({ key: `${i}.${u}`, value: t[u] }));
          return n;
        }
      } };
      function Us(i) {
        const t = i.value, n = i.key, u = i.styleSpec, f = i.style, _ = i.validateSpec;
        if (!t.type) return [new pt(n, t, '"type" is required')];
        const b = gr(t.type);
        let E;
        switch (b) {
          case "vector":
          case "raster":
            return E = vn({ key: n, value: t, valueSpec: u[`source_${b.replace("-", "_")}`], style: i.style, styleSpec: u, objectElementValidators: bo, validateSpec: _ }), E;
          case "raster-dem":
            return E = function(C) {
              var L;
              const R = (L = C.sourceName) !== null && L !== void 0 ? L : "", U = C.value, H = C.styleSpec, J = H.source_raster_dem, ne = C.style;
              let he = [];
              const Se = Di(U);
              if (U === void 0) return he;
              if (Se !== "object") return he.push(new pt("source_raster_dem", U, `object expected, ${Se} found`)), he;
              const Pe = gr(U.encoding) === "custom", Xe = ["redFactor", "greenFactor", "blueFactor", "baseShift"], Be = C.value.encoding ? `"${C.value.encoding}"` : "Default";
              for (const Ge in U) !Pe && Xe.includes(Ge) ? he.push(new pt(Ge, U[Ge], `In "${R}": "${Ge}" is only valid when "encoding" is set to "custom". ${Be} encoding found`)) : J[Ge] ? he = he.concat(C.validateSpec({ key: Ge, value: U[Ge], valueSpec: J[Ge], validateSpec: C.validateSpec, style: ne, styleSpec: H })) : he.push(new pt(Ge, U[Ge], `unknown property "${Ge}"`));
              return he;
            }({ sourceName: n, value: t, style: i.style, styleSpec: u, validateSpec: _ }), E;
          case "geojson":
            if (E = vn({ key: n, value: t, valueSpec: u.source_geojson, style: f, styleSpec: u, validateSpec: _, objectElementValidators: bo }), t.cluster) for (const C in t.clusterProperties) {
              const [L, R] = t.clusterProperties[C], U = typeof L == "string" ? [L, ["accumulated"], ["get", C]] : L;
              E.push(...Fr({ key: `${n}.${C}.map`, value: R, validateSpec: _, expressionContext: "cluster-map" })), E.push(...Fr({ key: `${n}.${C}.reduce`, value: U, validateSpec: _, expressionContext: "cluster-reduce" }));
            }
            return E;
          case "video":
            return vn({ key: n, value: t, valueSpec: u.source_video, style: f, validateSpec: _, styleSpec: u });
          case "image":
            return vn({ key: n, value: t, valueSpec: u.source_image, style: f, validateSpec: _, styleSpec: u });
          case "canvas":
            return [new pt(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return Pr({ key: `${n}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: f, validateSpec: _, styleSpec: u });
        }
      }
      function xo(i) {
        const t = i.value, n = i.styleSpec, u = n.light, f = i.style;
        let _ = [];
        const b = Di(t);
        if (t === void 0) return _;
        if (b !== "object") return _ = _.concat([new pt("light", t, `object expected, ${b} found`)]), _;
        for (const E in t) {
          const C = E.match(/^(.*)-transition$/);
          _ = _.concat(C && u[C[1]] && u[C[1]].transition ? i.validateSpec({ key: E, value: t[E], valueSpec: n.transition, validateSpec: i.validateSpec, style: f, styleSpec: n }) : u[E] ? i.validateSpec({ key: E, value: t[E], valueSpec: u[E], validateSpec: i.validateSpec, style: f, styleSpec: n }) : [new pt(E, t[E], `unknown property "${E}"`)]);
        }
        return _;
      }
      function nl(i) {
        const t = i.value, n = i.styleSpec, u = n.sky, f = i.style, _ = Di(t);
        if (t === void 0) return [];
        if (_ !== "object") return [new pt("sky", t, `object expected, ${_} found`)];
        let b = [];
        for (const E in t) b = b.concat(u[E] ? i.validateSpec({ key: E, value: t[E], valueSpec: u[E], style: f, styleSpec: n }) : [new pt(E, t[E], `unknown property "${E}"`)]);
        return b;
      }
      function su(i) {
        const t = i.value, n = i.styleSpec, u = n.terrain, f = i.style;
        let _ = [];
        const b = Di(t);
        if (t === void 0) return _;
        if (b !== "object") return _ = _.concat([new pt("terrain", t, `object expected, ${b} found`)]), _;
        for (const E in t) _ = _.concat(u[E] ? i.validateSpec({ key: E, value: t[E], valueSpec: u[E], validateSpec: i.validateSpec, style: f, styleSpec: n }) : [new pt(E, t[E], `unknown property "${E}"`)]);
        return _;
      }
      function ou(i) {
        let t = [];
        const n = i.value, u = i.key;
        if (Array.isArray(n)) {
          const f = [], _ = [];
          for (const b in n) n[b].id && f.includes(n[b].id) && t.push(new pt(u, n, `all the sprites' ids must be unique, but ${n[b].id} is duplicated`)), f.push(n[b].id), n[b].url && _.includes(n[b].url) && t.push(new pt(u, n, `all the sprites' URLs must be unique, but ${n[b].url} is duplicated`)), _.push(n[b].url), t = t.concat(vn({ key: `${u}[${b}]`, value: n[b], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: i.validateSpec }));
          return t;
        }
        return vs({ key: u, value: n });
      }
      const al = { "*": () => [], array: _o, boolean: function(i) {
        const t = i.value, n = i.key, u = Di(t);
        return u !== "boolean" ? [new pt(n, t, `boolean expected, ${u} found`)] : [];
      }, number: il, color: function(i) {
        const t = i.key, n = i.value, u = Di(n);
        return u !== "string" ? [new pt(t, n, `color expected, ${u} found`)] : ji.parse(String(n)) ? [] : [new pt(t, n, `color expected, "${n}" found`)];
      }, constants: au, enum: Pr, filter: yo, function: Os, layer: rl, object: vn, source: Us, light: xo, sky: nl, terrain: su, projection: function(i) {
        const t = i.value, n = i.styleSpec, u = n.projection, f = i.style, _ = Di(t);
        if (t === void 0) return [];
        if (_ !== "object") return [new pt("projection", t, `object expected, ${_} found`)];
        let b = [];
        for (const E in t) b = b.concat(u[E] ? i.validateSpec({ key: E, value: t[E], valueSpec: u[E], style: f, styleSpec: n }) : [new pt(E, t[E], `unknown property "${E}"`)]);
        return b;
      }, string: vs, formatted: function(i) {
        return vs(i).length === 0 ? [] : Fr(i);
      }, resolvedImage: function(i) {
        return vs(i).length === 0 ? [] : Fr(i);
      }, padding: function(i) {
        const t = i.key, n = i.value;
        if (Di(n) === "array") {
          if (n.length < 1 || n.length > 4) return [new pt(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
          const u = { type: "number" };
          let f = [];
          for (let _ = 0; _ < n.length; _++) f = f.concat(i.validateSpec({ key: `${t}[${_}]`, value: n[_], validateSpec: i.validateSpec, valueSpec: u }));
          return f;
        }
        return il({ key: t, value: n, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(i) {
        const t = i.key, n = i.value, u = Di(n), f = i.styleSpec;
        if (u !== "array" || n.length < 1 || n.length % 2 != 0) return [new pt(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let _ = [];
        for (let b = 0; b < n.length; b += 2) _ = _.concat(Pr({ key: `${t}[${b}]`, value: n[b], valueSpec: f.layout_symbol["text-anchor"] })), _ = _.concat(_o({ key: `${t}[${b + 1}]`, value: n[b + 1], valueSpec: { length: 2, value: "number" }, validateSpec: i.validateSpec, style: i.style, styleSpec: f }));
        return _;
      }, sprite: ou };
      function wo(i) {
        const t = i.value, n = i.valueSpec, u = i.styleSpec;
        return i.validateSpec = wo, n.expression && un(gr(t)) ? Os(i) : n.expression && da(Gn(t)) ? Fr(i) : n.type && al[n.type] ? al[n.type](i) : vn(Jt({}, i, { valueSpec: n.type ? u[n.type] : n }));
      }
      function zu(i) {
        const t = i.value, n = i.key, u = vs(i);
        return u.length || (t.indexOf("{fontstack}") === -1 && u.push(new pt(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && u.push(new pt(n, t, '"glyphs" url must include a "{range}" token'))), u;
      }
      function Hn(i, t = Y) {
        let n = [];
        return n = n.concat(wo({ key: "", value: i, valueSpec: t.$root, styleSpec: t, style: i, validateSpec: wo, objectElementValidators: { glyphs: zu, "*": () => [] } })), i.constants && (n = n.concat(au({ key: "constants", value: i.constants, style: i, styleSpec: t, validateSpec: wo }))), lu(n);
      }
      function ka(i) {
        return function(t) {
          return i({ ...t, validateSpec: wo });
        };
      }
      function lu(i) {
        return [].concat(i).sort((t, n) => t.line - n.line);
      }
      function In(i) {
        return function(...t) {
          return lu(i.apply(this, t));
        };
      }
      Hn.source = In(ka(Us)), Hn.sprite = In(ka(ou)), Hn.glyphs = In(ka(zu)), Hn.light = In(ka(xo)), Hn.sky = In(ka(nl)), Hn.terrain = In(ka(su)), Hn.layer = In(ka(rl)), Hn.filter = In(ka(yo)), Hn.paintProperty = In(ka(qs)), Hn.layoutProperty = In(ka(vo));
      const Xa = Hn, sl = Xa.light, Sc = Xa.sky, Fu = Xa.paintProperty, uu = Xa.layoutProperty;
      function cu(i, t) {
        let n = !1;
        if (t && t.length) for (const u of t) i.fire(new Pt(new Error(u.message))), n = !0;
        return n;
      }
      class Ao {
        constructor(t, n, u) {
          const f = this.cells = [];
          if (t instanceof ArrayBuffer) {
            this.arrayBuffer = t;
            const b = new Int32Array(this.arrayBuffer);
            t = b[0], this.d = (n = b[1]) + 2 * (u = b[2]);
            for (let C = 0; C < this.d * this.d; C++) {
              const L = b[3 + C], R = b[3 + C + 1];
              f.push(L === R ? null : b.subarray(L, R));
            }
            const E = b[3 + f.length + 1];
            this.keys = b.subarray(b[3 + f.length], E), this.bboxes = b.subarray(E), this.insert = this._insertReadonly;
          } else {
            this.d = n + 2 * u;
            for (let b = 0; b < this.d * this.d; b++) f.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = n, this.extent = t, this.padding = u, this.scale = n / t, this.uid = 0;
          const _ = u / n * t;
          this.min = -_, this.max = t + _;
        }
        insert(t, n, u, f, _) {
          this._forEachCell(n, u, f, _, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(u), this.bboxes.push(f), this.bboxes.push(_);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(t, n, u, f, _, b) {
          this.cells[_].push(b);
        }
        query(t, n, u, f, _) {
          const b = this.min, E = this.max;
          if (t <= b && n <= b && E <= u && E <= f && !_) return Array.prototype.slice.call(this.keys);
          {
            const C = [];
            return this._forEachCell(t, n, u, f, this._queryCell, C, {}, _), C;
          }
        }
        _queryCell(t, n, u, f, _, b, E, C) {
          const L = this.cells[_];
          if (L !== null) {
            const R = this.keys, U = this.bboxes;
            for (let H = 0; H < L.length; H++) {
              const J = L[H];
              if (E[J] === void 0) {
                const ne = 4 * J;
                (C ? C(U[ne + 0], U[ne + 1], U[ne + 2], U[ne + 3]) : t <= U[ne + 2] && n <= U[ne + 3] && u >= U[ne + 0] && f >= U[ne + 1]) ? (E[J] = !0, b.push(R[J])) : E[J] = !1;
              }
            }
          }
        }
        _forEachCell(t, n, u, f, _, b, E, C) {
          const L = this._convertToCellCoord(t), R = this._convertToCellCoord(n), U = this._convertToCellCoord(u), H = this._convertToCellCoord(f);
          for (let J = L; J <= U; J++) for (let ne = R; ne <= H; ne++) {
            const he = this.d * ne + J;
            if ((!C || C(this._convertFromCellCoord(J), this._convertFromCellCoord(ne), this._convertFromCellCoord(J + 1), this._convertFromCellCoord(ne + 1))) && _.call(this, t, n, u, f, he, b, E, C)) return;
          }
        }
        _convertFromCellCoord(t) {
          return (t - this.padding) / this.scale;
        }
        _convertToCellCoord(t) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const t = this.cells, n = 3 + this.cells.length + 1 + 1;
          let u = 0;
          for (let b = 0; b < this.cells.length; b++) u += this.cells[b].length;
          const f = new Int32Array(n + u + this.keys.length + this.bboxes.length);
          f[0] = this.extent, f[1] = this.n, f[2] = this.padding;
          let _ = n;
          for (let b = 0; b < t.length; b++) {
            const E = t[b];
            f[3 + b] = _, f.set(E, _), _ += E.length;
          }
          return f[3 + t.length] = _, f.set(this.keys, _), _ += this.keys.length, f[3 + t.length + 1] = _, f.set(this.bboxes, _), _ += this.bboxes.length, f.buffer;
        }
        static serialize(t, n) {
          const u = t.toArrayBuffer();
          return n && n.push(u), { buffer: u };
        }
        static deserialize(t) {
          return new Ao(t.buffer);
        }
      }
      const Wn = {};
      function Ot(i, t, n = {}) {
        if (Wn[i]) throw new Error(`${i} is already registered.`);
        Object.defineProperty(t, "_classRegistryKey", { value: i, writeable: !1 }), Wn[i] = { klass: t, omit: n.omit || [], shallow: n.shallow || [] };
      }
      Ot("Object", Object), Ot("TransferableGridIndex", Ao), Ot("Color", ji), Ot("Error", Error), Ot("AJAXError", $e), Ot("ResolvedImage", Wr), Ot("StylePropertyFunction", Vn), Ot("StyleExpression", gs, { omit: ["_evaluator"] }), Ot("ZoomDependentExpression", Un), Ot("ZoomConstantExpression", yn), Ot("CompoundExpression", qr, { omit: ["_evaluate"] });
      for (const i in Ta) Ta[i]._classRegistryKey || Ot(`Expression_${i}`, Ta[i]);
      function fa(i) {
        return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer");
      }
      function kn(i) {
        return i.$name || i.constructor._classRegistryKey;
      }
      function Pa(i) {
        return !function(t) {
          if (t === null || typeof t != "object") return !1;
          const n = kn(t);
          return !(!n || n === "Object");
        }(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || fa(i) || Ze(i) || ArrayBuffer.isView(i) || i instanceof ImageData);
      }
      function So(i, t) {
        if (Pa(i)) return (fa(i) || Ze(i)) && t && t.push(i), ArrayBuffer.isView(i) && t && t.push(i.buffer), i instanceof ImageData && t && t.push(i.data.buffer), i;
        if (Array.isArray(i)) {
          const _ = [];
          for (const b of i) _.push(So(b, t));
          return _;
        }
        if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
        const n = kn(i);
        if (!n) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
        if (!Wn[n]) throw new Error(`${n} is not registered.`);
        const { klass: u } = Wn[n], f = u.serialize ? u.serialize(i, t) : {};
        if (u.serialize) {
          if (t && f === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const _ in i) {
            if (!i.hasOwnProperty(_) || Wn[n].omit.indexOf(_) >= 0) continue;
            const b = i[_];
            f[_] = Wn[n].shallow.indexOf(_) >= 0 ? b : So(b, t);
          }
          i instanceof Error && (f.message = i.message);
        }
        if (f.$name) throw new Error("$name property is reserved for worker serialization logic.");
        return n !== "Object" && (f.$name = n), f;
      }
      function Vs(i) {
        if (Pa(i)) return i;
        if (Array.isArray(i)) return i.map(Vs);
        if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
        const t = kn(i) || "Object";
        if (!Wn[t]) throw new Error(`can't deserialize unregistered class ${t}`);
        const { klass: n } = Wn[t];
        if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
        if (n.deserialize) return n.deserialize(i);
        const u = Object.create(n.prototype);
        for (const f of Object.keys(i)) {
          if (f === "$name") continue;
          const _ = i[f];
          u[f] = Wn[t].shallow.indexOf(f) >= 0 ? _ : Vs(_);
        }
        return u;
      }
      class La {
        constructor() {
          this.first = !0;
        }
        update(t, n) {
          const u = Math.floor(t);
          return this.first ? (this.first = !1, this.lastIntegerZoom = u, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = u, !0) : (this.lastFloorZoom > u ? (this.lastIntegerZoom = u + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < u && (this.lastIntegerZoom = u, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = u, !0));
        }
      }
      const vi = { "Latin-1 Supplement": (i) => i >= 128 && i <= 255, "Hangul Jamo": (i) => i >= 4352 && i <= 4607, Khmer: (i) => i >= 6016 && i <= 6143, "General Punctuation": (i) => i >= 8192 && i <= 8303, "Letterlike Symbols": (i) => i >= 8448 && i <= 8527, "Number Forms": (i) => i >= 8528 && i <= 8591, "Miscellaneous Technical": (i) => i >= 8960 && i <= 9215, "Control Pictures": (i) => i >= 9216 && i <= 9279, "Optical Character Recognition": (i) => i >= 9280 && i <= 9311, "Enclosed Alphanumerics": (i) => i >= 9312 && i <= 9471, "Geometric Shapes": (i) => i >= 9632 && i <= 9727, "Miscellaneous Symbols": (i) => i >= 9728 && i <= 9983, "Miscellaneous Symbols and Arrows": (i) => i >= 11008 && i <= 11263, "Ideographic Description Characters": (i) => i >= 12272 && i <= 12287, "CJK Symbols and Punctuation": (i) => i >= 12288 && i <= 12351, Katakana: (i) => i >= 12448 && i <= 12543, Kanbun: (i) => i >= 12688 && i <= 12703, "CJK Strokes": (i) => i >= 12736 && i <= 12783, "Enclosed CJK Letters and Months": (i) => i >= 12800 && i <= 13055, "CJK Compatibility": (i) => i >= 13056 && i <= 13311, "Yijing Hexagram Symbols": (i) => i >= 19904 && i <= 19967, "Private Use Area": (i) => i >= 57344 && i <= 63743, "Vertical Forms": (i) => i >= 65040 && i <= 65055, "CJK Compatibility Forms": (i) => i >= 65072 && i <= 65103, "Small Form Variants": (i) => i >= 65104 && i <= 65135, "Halfwidth and Fullwidth Forms": (i) => i >= 65280 && i <= 65519 };
      function hu(i) {
        for (const t of i) if (pu(t.charCodeAt(0))) return !0;
        return !1;
      }
      function Ec(i) {
        for (const t of i) if (!$s(t.charCodeAt(0))) return !1;
        return !0;
      }
      function Ll(i) {
        const t = i.map((n) => {
          try {
            return new RegExp(`\\p{sc=${n}}`, "u").source;
          } catch {
            return null;
          }
        }).filter((n) => n);
        return new RegExp(t.join("|"), "u");
      }
      const Bu = Ll(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function $s(i) {
        return !Bu.test(String.fromCodePoint(i));
      }
      const du = Ll(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
      function pu(i) {
        return !(i !== 746 && i !== 747 && (i < 4352 || !(vi["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || vi["CJK Compatibility"](i) || vi["CJK Strokes"](i) || !(!vi["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || vi["Enclosed CJK Letters and Months"](i) || vi["Ideographic Description Characters"](i) || vi.Kanbun(i) || vi.Katakana(i) && i !== 12540 || !(!vi["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!vi["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || vi["Vertical Forms"](i) || vi["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(i)) || du.test(String.fromCodePoint(i)))));
      }
      function ol(i) {
        return !(pu(i) || function(t) {
          return !!(vi["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || vi["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || vi["Letterlike Symbols"](t) || vi["Number Forms"](t) || vi["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || vi["Control Pictures"](t) && t !== 9251 || vi["Optical Character Recognition"](t) || vi["Enclosed Alphanumerics"](t) || vi["Geometric Shapes"](t) || vi["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || vi["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || vi["CJK Symbols and Punctuation"](t) || vi.Katakana(t) || vi["Private Use Area"](t) || vi["CJK Compatibility Forms"](t) || vi["Small Form Variants"](t) || vi["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
        }(i));
      }
      const Ml = Ll(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
      function Zs(i) {
        return Ml.test(String.fromCodePoint(i));
      }
      function fu(i, t) {
        return !(!t && Zs(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || vi.Khmer(i));
      }
      function Ru(i) {
        for (const t of i) if (Zs(t.charCodeAt(0))) return !0;
        return !1;
      }
      const Pn = new class {
        constructor() {
          this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
        }
        setState(i) {
          this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(i) {
          this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText;
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getPluginURL() {
          return this.pluginURL;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
      }();
      class Ji {
        constructor(t, n) {
          this.zoom = t, n ? (this.now = n.now, this.fadeDuration = n.fadeDuration, this.zoomHistory = n.zoomHistory, this.transition = n.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new La(), this.transition = {});
        }
        isSupportedScript(t) {
          return function(n, u) {
            for (const f of n) if (!fu(f.charCodeAt(0), u)) return !1;
            return !0;
          }(t, Pn.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const t = this.zoom, n = t - Math.floor(t), u = this.crossFadingFactor();
          return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * u } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - u) * n };
        }
      }
      class Eo {
        constructor(t, n) {
          this.property = t, this.value = n, this.expression = function(u, f) {
            if (un(u)) return new Vn(u, f);
            if (da(u)) {
              const _ = _s(u, f);
              if (_.result === "error") throw new Error(_.value.map((b) => `${b.key}: ${b.message}`).join(", "));
              return _.value;
            }
            {
              let _ = u;
              return f.type === "color" && typeof u == "string" ? _ = ji.parse(u) : f.type !== "padding" || typeof u != "number" && !Array.isArray(u) ? f.type === "variableAnchorOffsetCollection" && Array.isArray(u) && (_ = mn.parse(u)) : _ = sn.parse(u), { kind: "constant", evaluate: () => _ };
            }
          }(n === void 0 ? t.specification.default : n, t.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(t, n, u) {
          return this.property.possiblyEvaluate(this, t, n, u);
        }
      }
      class Nl {
        constructor(t) {
          this.property = t, this.value = new Eo(t, void 0);
        }
        transitioned(t, n) {
          return new Ou(this.property, this.value, n, Ie({}, t.transition, this.transition), t.now);
        }
        untransitioned() {
          return new Ou(this.property, this.value, null, {}, 0);
        }
      }
      class zl {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
        }
        getValue(t) {
          return X(this._values[t].value.value);
        }
        setValue(t, n) {
          Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Nl(this._values[t].property)), this._values[t].value = new Eo(this._values[t].property, n === null ? void 0 : X(n));
        }
        getTransition(t) {
          return X(this._values[t].transition);
        }
        setTransition(t, n) {
          Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new Nl(this._values[t].property)), this._values[t].transition = X(n) || void 0;
        }
        serialize() {
          const t = {};
          for (const n of Object.keys(this._values)) {
            const u = this.getValue(n);
            u !== void 0 && (t[n] = u);
            const f = this.getTransition(n);
            f !== void 0 && (t[`${n}-transition`] = f);
          }
          return t;
        }
        transitioned(t, n) {
          const u = new ll(this._properties);
          for (const f of Object.keys(this._values)) u._values[f] = this._values[f].transitioned(t, n._values[f]);
          return u;
        }
        untransitioned() {
          const t = new ll(this._properties);
          for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned();
          return t;
        }
      }
      class Ou {
        constructor(t, n, u, f, _) {
          this.property = t, this.value = n, this.begin = _ + f.delay || 0, this.end = this.begin + f.duration || 0, t.specification.transition && (f.delay || f.duration) && (this.prior = u);
        }
        possiblyEvaluate(t, n, u) {
          const f = t.now || 0, _ = this.value.possiblyEvaluate(t, n, u), b = this.prior;
          if (b) {
            if (f > this.end) return this.prior = null, _;
            if (this.value.isDataDriven()) return this.prior = null, _;
            if (f < this.begin) return b.possiblyEvaluate(t, n, u);
            {
              const E = (f - this.begin) / (this.end - this.begin);
              return this.property.interpolate(b.possiblyEvaluate(t, n, u), _, function(C) {
                if (C <= 0) return 0;
                if (C >= 1) return 1;
                const L = C * C, R = L * C;
                return 4 * (C < 0.5 ? R : 3 * (C - L) + R - 0.75);
              }(E));
            }
          }
          return _;
        }
      }
      class ll {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t, n, u) {
          const f = new bs(this._properties);
          for (const _ of Object.keys(this._values)) f._values[_] = this._values[_].possiblyEvaluate(t, n, u);
          return f;
        }
        hasTransition() {
          for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;
          return !1;
        }
      }
      class ul {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultPropertyValues);
        }
        hasValue(t) {
          return this._values[t].value !== void 0;
        }
        getValue(t) {
          return X(this._values[t].value);
        }
        setValue(t, n) {
          this._values[t] = new Eo(this._values[t].property, n === null ? void 0 : X(n));
        }
        serialize() {
          const t = {};
          for (const n of Object.keys(this._values)) {
            const u = this.getValue(n);
            u !== void 0 && (t[n] = u);
          }
          return t;
        }
        possiblyEvaluate(t, n, u) {
          const f = new bs(this._properties);
          for (const _ of Object.keys(this._values)) f._values[_] = this._values[_].possiblyEvaluate(t, n, u);
          return f;
        }
      }
      class ma {
        constructor(t, n, u) {
          this.property = t, this.value = n, this.parameters = u;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(t) {
          return this.value.kind === "constant" ? this.value.value : t;
        }
        evaluate(t, n, u, f) {
          return this.property.evaluate(this.value, this.parameters, t, n, u, f);
        }
      }
      class bs {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
        }
        get(t) {
          return this._values[t];
        }
      }
      class Gt {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, n) {
          if (t.isDataDriven()) throw new Error("Value should not be data driven");
          return t.expression.evaluate(n);
        }
        interpolate(t, n, u) {
          const f = jr[this.specification.type];
          return f ? f(t, n, u) : t;
        }
      }
      class li {
        constructor(t, n) {
          this.specification = t, this.overrides = n;
        }
        possiblyEvaluate(t, n, u, f) {
          return new ma(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(n, null, {}, u, f) } : t.expression, n);
        }
        interpolate(t, n, u) {
          if (t.value.kind !== "constant" || n.value.kind !== "constant") return t;
          if (t.value.value === void 0 || n.value.value === void 0) return new ma(this, { kind: "constant", value: void 0 }, t.parameters);
          const f = jr[this.specification.type];
          if (f) {
            const _ = f(t.value.value, n.value.value, u);
            return new ma(this, { kind: "constant", value: _ }, t.parameters);
          }
          return t;
        }
        evaluate(t, n, u, f, _, b) {
          return t.kind === "constant" ? t.value : t.evaluate(n, u, f, _, b);
        }
      }
      class cl extends li {
        possiblyEvaluate(t, n, u, f) {
          if (t.value === void 0) return new ma(this, { kind: "constant", value: void 0 }, n);
          if (t.expression.kind === "constant") {
            const _ = t.expression.evaluate(n, null, {}, u, f), b = t.property.specification.type === "resolvedImage" && typeof _ != "string" ? _.name : _, E = this._calculate(b, b, b, n);
            return new ma(this, { kind: "constant", value: E }, n);
          }
          if (t.expression.kind === "camera") {
            const _ = this._calculate(t.expression.evaluate({ zoom: n.zoom - 1 }), t.expression.evaluate({ zoom: n.zoom }), t.expression.evaluate({ zoom: n.zoom + 1 }), n);
            return new ma(this, { kind: "constant", value: _ }, n);
          }
          return new ma(this, t.expression, n);
        }
        evaluate(t, n, u, f, _, b) {
          if (t.kind === "source") {
            const E = t.evaluate(n, u, f, _, b);
            return this._calculate(E, E, E, n);
          }
          return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(n.zoom) - 1 }, u, f), t.evaluate({ zoom: Math.floor(n.zoom) }, u, f), t.evaluate({ zoom: Math.floor(n.zoom) + 1 }, u, f), n) : t.value;
        }
        _calculate(t, n, u, f) {
          return f.zoom > f.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: u, to: n };
        }
        interpolate(t) {
          return t;
        }
      }
      class y {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, n, u, f) {
          if (t.value !== void 0) {
            if (t.expression.kind === "constant") {
              const _ = t.expression.evaluate(n, null, {}, u, f);
              return this._calculate(_, _, _, n);
            }
            return this._calculate(t.expression.evaluate(new Ji(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new Ji(Math.floor(n.zoom), n)), t.expression.evaluate(new Ji(Math.floor(n.zoom + 1), n)), n);
          }
        }
        _calculate(t, n, u, f) {
          return f.zoom > f.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: u, to: n };
        }
        interpolate(t) {
          return t;
        }
      }
      class S {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, n, u, f) {
          return !!t.expression.evaluate(n, null, {}, u, f);
        }
        interpolate() {
          return !1;
        }
      }
      class c {
        constructor(t) {
          this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const n in t) {
            const u = t[n];
            u.specification.overridable && this.overridableProperties.push(n);
            const f = this.defaultPropertyValues[n] = new Eo(u, void 0), _ = this.defaultTransitionablePropertyValues[n] = new Nl(u);
            this.defaultTransitioningPropertyValues[n] = _.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = f.possiblyEvaluate({});
          }
        }
      }
      Ot("DataDrivenProperty", li), Ot("DataConstantProperty", Gt), Ot("CrossFadedDataDrivenProperty", cl), Ot("CrossFadedProperty", y), Ot("ColorRampProperty", S);
      const e = "-transition";
      class r extends it {
        constructor(t, n) {
          if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), n.layout && (this._unevaluatedLayout = new ul(n.layout)), n.paint)) {
            this._transitionablePaint = new zl(n.paint);
            for (const u in t.paint) this.setPaintProperty(u, t.paint[u], { validate: !1 });
            for (const u in t.layout) this.setLayoutProperty(u, t.layout[u], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new bs(n.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(t) {
          return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
        }
        setLayoutProperty(t, n, u = {}) {
          n != null && this._validate(uu, `layers.${this.id}.layout.${t}`, t, n, u) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n);
        }
        getPaintProperty(t) {
          return t.endsWith(e) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
        }
        setPaintProperty(t, n, u = {}) {
          if (n != null && this._validate(Fu, `layers.${this.id}.paint.${t}`, t, n, u)) return !1;
          if (t.endsWith(e)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), !1;
          {
            const f = this._transitionablePaint._values[t], _ = f.property.specification["property-type"] === "cross-faded-data-driven", b = f.value.isDataDriven(), E = f.value;
            this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t);
            const C = this._transitionablePaint._values[t].value;
            return C.isDataDriven() || b || _ || this._handleOverridablePaintPropertyUpdate(t, E, C);
          }
        }
        _handleSpecialPaintPropertyUpdate(t) {
        }
        _handleOverridablePaintPropertyUpdate(t, n, u) {
          return !1;
        }
        isHidden(t) {
          return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(t) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t, n) {
          t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n);
        }
        serialize() {
          const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), ve(t, (n, u) => !(n === void 0 || u === "layout" && !Object.keys(n).length || u === "paint" && !Object.keys(n).length));
        }
        _validate(t, n, u, f, _ = {}) {
          return (!_ || _.validate !== !1) && cu(this, t.call(Xa, { key: n, layerType: this.type, objectKey: u, value: f, styleSpec: Y, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const t in this.paint._values) {
            const n = this.paint.get(t);
            if (n instanceof ma && Ca(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return !0;
          }
          return !1;
        }
      }
      const o = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class h {
        constructor(t, n) {
          this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class p {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(t, n) {
          return t._trim(), n && (t.isTransferred = !0, n.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
        }
        static deserialize(t) {
          const n = Object.create(this.prototype);
          return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t) {
          this.reserve(t), this.length = t;
        }
        reserve(t) {
          if (t > this.capacity) {
            this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const n = this.uint8;
            this._refreshViews(), n && this.uint8.set(n);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function x(i, t = 1) {
        let n = 0, u = 0;
        return { members: i.map((f) => {
          const _ = o[f.type].BYTES_PER_ELEMENT, b = n = A(n, Math.max(t, _)), E = f.components || 1;
          return u = Math.max(u, _), n += _ * E, { name: f.name, type: f.type, components: E, offset: b };
        }), size: A(n, Math.max(u, t)), alignment: t };
      }
      function A(i, t) {
        return Math.ceil(i / t) * t;
      }
      class T extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, t, n);
        }
        emplace(t, n, u) {
          const f = 2 * t;
          return this.int16[f + 0] = n, this.int16[f + 1] = u, t;
        }
      }
      T.prototype.bytesPerElement = 4, Ot("StructArrayLayout2i4", T);
      class P extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, u);
        }
        emplace(t, n, u, f) {
          const _ = 3 * t;
          return this.int16[_ + 0] = n, this.int16[_ + 1] = u, this.int16[_ + 2] = f, t;
        }
      }
      P.prototype.bytesPerElement = 6, Ot("StructArrayLayout3i6", P);
      class F extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f) {
          const _ = this.length;
          return this.resize(_ + 1), this.emplace(_, t, n, u, f);
        }
        emplace(t, n, u, f, _) {
          const b = 4 * t;
          return this.int16[b + 0] = n, this.int16[b + 1] = u, this.int16[b + 2] = f, this.int16[b + 3] = _, t;
        }
      }
      F.prototype.bytesPerElement = 8, Ot("StructArrayLayout4i8", F);
      class N extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f, _, b) {
          const E = this.length;
          return this.resize(E + 1), this.emplace(E, t, n, u, f, _, b);
        }
        emplace(t, n, u, f, _, b, E) {
          const C = 6 * t;
          return this.int16[C + 0] = n, this.int16[C + 1] = u, this.int16[C + 2] = f, this.int16[C + 3] = _, this.int16[C + 4] = b, this.int16[C + 5] = E, t;
        }
      }
      N.prototype.bytesPerElement = 12, Ot("StructArrayLayout2i4i12", N);
      class Z extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f, _, b) {
          const E = this.length;
          return this.resize(E + 1), this.emplace(E, t, n, u, f, _, b);
        }
        emplace(t, n, u, f, _, b, E) {
          const C = 4 * t, L = 8 * t;
          return this.int16[C + 0] = n, this.int16[C + 1] = u, this.uint8[L + 4] = f, this.uint8[L + 5] = _, this.uint8[L + 6] = b, this.uint8[L + 7] = E, t;
        }
      }
      Z.prototype.bytesPerElement = 8, Ot("StructArrayLayout2i4ub8", Z);
      class G extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, t, n);
        }
        emplace(t, n, u) {
          const f = 2 * t;
          return this.float32[f + 0] = n, this.float32[f + 1] = u, t;
        }
      }
      G.prototype.bytesPerElement = 8, Ot("StructArrayLayout2f8", G);
      class V extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f, _, b, E, C, L, R) {
          const U = this.length;
          return this.resize(U + 1), this.emplace(U, t, n, u, f, _, b, E, C, L, R);
        }
        emplace(t, n, u, f, _, b, E, C, L, R, U) {
          const H = 10 * t;
          return this.uint16[H + 0] = n, this.uint16[H + 1] = u, this.uint16[H + 2] = f, this.uint16[H + 3] = _, this.uint16[H + 4] = b, this.uint16[H + 5] = E, this.uint16[H + 6] = C, this.uint16[H + 7] = L, this.uint16[H + 8] = R, this.uint16[H + 9] = U, t;
        }
      }
      V.prototype.bytesPerElement = 20, Ot("StructArrayLayout10ui20", V);
      class W extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f, _, b, E, C, L, R, U, H) {
          const J = this.length;
          return this.resize(J + 1), this.emplace(J, t, n, u, f, _, b, E, C, L, R, U, H);
        }
        emplace(t, n, u, f, _, b, E, C, L, R, U, H, J) {
          const ne = 12 * t;
          return this.int16[ne + 0] = n, this.int16[ne + 1] = u, this.int16[ne + 2] = f, this.int16[ne + 3] = _, this.uint16[ne + 4] = b, this.uint16[ne + 5] = E, this.uint16[ne + 6] = C, this.uint16[ne + 7] = L, this.int16[ne + 8] = R, this.int16[ne + 9] = U, this.int16[ne + 10] = H, this.int16[ne + 11] = J, t;
        }
      }
      W.prototype.bytesPerElement = 24, Ot("StructArrayLayout4i4ui4i24", W);
      class ae extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, u);
        }
        emplace(t, n, u, f) {
          const _ = 3 * t;
          return this.float32[_ + 0] = n, this.float32[_ + 1] = u, this.float32[_ + 2] = f, t;
        }
      }
      ae.prototype.bytesPerElement = 12, Ot("StructArrayLayout3f12", ae);
      class oe extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t);
        }
        emplace(t, n) {
          return this.uint32[1 * t + 0] = n, t;
        }
      }
      oe.prototype.bytesPerElement = 4, Ot("StructArrayLayout1ul4", oe);
      class de extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f, _, b, E, C, L) {
          const R = this.length;
          return this.resize(R + 1), this.emplace(R, t, n, u, f, _, b, E, C, L);
        }
        emplace(t, n, u, f, _, b, E, C, L, R) {
          const U = 10 * t, H = 5 * t;
          return this.int16[U + 0] = n, this.int16[U + 1] = u, this.int16[U + 2] = f, this.int16[U + 3] = _, this.int16[U + 4] = b, this.int16[U + 5] = E, this.uint32[H + 3] = C, this.uint16[U + 8] = L, this.uint16[U + 9] = R, t;
        }
      }
      de.prototype.bytesPerElement = 20, Ot("StructArrayLayout6i1ul2ui20", de);
      class ce extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f, _, b) {
          const E = this.length;
          return this.resize(E + 1), this.emplace(E, t, n, u, f, _, b);
        }
        emplace(t, n, u, f, _, b, E) {
          const C = 6 * t;
          return this.int16[C + 0] = n, this.int16[C + 1] = u, this.int16[C + 2] = f, this.int16[C + 3] = _, this.int16[C + 4] = b, this.int16[C + 5] = E, t;
        }
      }
      ce.prototype.bytesPerElement = 12, Ot("StructArrayLayout2i2i2i12", ce);
      class we extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f, _) {
          const b = this.length;
          return this.resize(b + 1), this.emplace(b, t, n, u, f, _);
        }
        emplace(t, n, u, f, _, b) {
          const E = 4 * t, C = 8 * t;
          return this.float32[E + 0] = n, this.float32[E + 1] = u, this.float32[E + 2] = f, this.int16[C + 6] = _, this.int16[C + 7] = b, t;
        }
      }
      we.prototype.bytesPerElement = 16, Ot("StructArrayLayout2f1f2i16", we);
      class Le extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f, _, b) {
          const E = this.length;
          return this.resize(E + 1), this.emplace(E, t, n, u, f, _, b);
        }
        emplace(t, n, u, f, _, b, E) {
          const C = 16 * t, L = 4 * t, R = 8 * t;
          return this.uint8[C + 0] = n, this.uint8[C + 1] = u, this.float32[L + 1] = f, this.float32[L + 2] = _, this.int16[R + 6] = b, this.int16[R + 7] = E, t;
        }
      }
      Le.prototype.bytesPerElement = 16, Ot("StructArrayLayout2ub2f2i16", Le);
      class ke extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, u);
        }
        emplace(t, n, u, f) {
          const _ = 3 * t;
          return this.uint16[_ + 0] = n, this.uint16[_ + 1] = u, this.uint16[_ + 2] = f, t;
        }
      }
      ke.prototype.bytesPerElement = 6, Ot("StructArrayLayout3ui6", ke);
      class tt extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f, _, b, E, C, L, R, U, H, J, ne, he, Se, Pe) {
          const Xe = this.length;
          return this.resize(Xe + 1), this.emplace(Xe, t, n, u, f, _, b, E, C, L, R, U, H, J, ne, he, Se, Pe);
        }
        emplace(t, n, u, f, _, b, E, C, L, R, U, H, J, ne, he, Se, Pe, Xe) {
          const Be = 24 * t, Ge = 12 * t, st = 48 * t;
          return this.int16[Be + 0] = n, this.int16[Be + 1] = u, this.uint16[Be + 2] = f, this.uint16[Be + 3] = _, this.uint32[Ge + 2] = b, this.uint32[Ge + 3] = E, this.uint32[Ge + 4] = C, this.uint16[Be + 10] = L, this.uint16[Be + 11] = R, this.uint16[Be + 12] = U, this.float32[Ge + 7] = H, this.float32[Ge + 8] = J, this.uint8[st + 36] = ne, this.uint8[st + 37] = he, this.uint8[st + 38] = Se, this.uint32[Ge + 10] = Pe, this.int16[Be + 22] = Xe, t;
        }
      }
      tt.prototype.bytesPerElement = 48, Ot("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", tt);
      class ht extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f, _, b, E, C, L, R, U, H, J, ne, he, Se, Pe, Xe, Be, Ge, st, Tt, Bt, hi, Ft, Nt, Xt, Vt) {
          const qt = this.length;
          return this.resize(qt + 1), this.emplace(qt, t, n, u, f, _, b, E, C, L, R, U, H, J, ne, he, Se, Pe, Xe, Be, Ge, st, Tt, Bt, hi, Ft, Nt, Xt, Vt);
        }
        emplace(t, n, u, f, _, b, E, C, L, R, U, H, J, ne, he, Se, Pe, Xe, Be, Ge, st, Tt, Bt, hi, Ft, Nt, Xt, Vt, qt) {
          const dt = 32 * t, Yt = 16 * t;
          return this.int16[dt + 0] = n, this.int16[dt + 1] = u, this.int16[dt + 2] = f, this.int16[dt + 3] = _, this.int16[dt + 4] = b, this.int16[dt + 5] = E, this.int16[dt + 6] = C, this.int16[dt + 7] = L, this.uint16[dt + 8] = R, this.uint16[dt + 9] = U, this.uint16[dt + 10] = H, this.uint16[dt + 11] = J, this.uint16[dt + 12] = ne, this.uint16[dt + 13] = he, this.uint16[dt + 14] = Se, this.uint16[dt + 15] = Pe, this.uint16[dt + 16] = Xe, this.uint16[dt + 17] = Be, this.uint16[dt + 18] = Ge, this.uint16[dt + 19] = st, this.uint16[dt + 20] = Tt, this.uint16[dt + 21] = Bt, this.uint16[dt + 22] = hi, this.uint32[Yt + 12] = Ft, this.float32[Yt + 13] = Nt, this.float32[Yt + 14] = Xt, this.uint16[dt + 30] = Vt, this.uint16[dt + 31] = qt, t;
        }
      }
      ht.prototype.bytesPerElement = 64, Ot("StructArrayLayout8i15ui1ul2f2ui64", ht);
      class _t extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t);
        }
        emplace(t, n) {
          return this.float32[1 * t + 0] = n, t;
        }
      }
      _t.prototype.bytesPerElement = 4, Ot("StructArrayLayout1f4", _t);
      class wt extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, u);
        }
        emplace(t, n, u, f) {
          const _ = 3 * t;
          return this.uint16[6 * t + 0] = n, this.float32[_ + 1] = u, this.float32[_ + 2] = f, t;
        }
      }
      wt.prototype.bytesPerElement = 12, Ot("StructArrayLayout1ui2f12", wt);
      class bt extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, u);
        }
        emplace(t, n, u, f) {
          const _ = 4 * t;
          return this.uint32[2 * t + 0] = n, this.uint16[_ + 2] = u, this.uint16[_ + 3] = f, t;
        }
      }
      bt.prototype.bytesPerElement = 8, Ot("StructArrayLayout1ul2ui8", bt);
      class yt extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, t, n);
        }
        emplace(t, n, u) {
          const f = 2 * t;
          return this.uint16[f + 0] = n, this.uint16[f + 1] = u, t;
        }
      }
      yt.prototype.bytesPerElement = 4, Ot("StructArrayLayout2ui4", yt);
      class St extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t);
        }
        emplace(t, n) {
          return this.uint16[1 * t + 0] = n, t;
        }
      }
      St.prototype.bytesPerElement = 2, Ot("StructArrayLayout1ui2", St);
      class Zt extends p {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, u, f) {
          const _ = this.length;
          return this.resize(_ + 1), this.emplace(_, t, n, u, f);
        }
        emplace(t, n, u, f, _) {
          const b = 4 * t;
          return this.float32[b + 0] = n, this.float32[b + 1] = u, this.float32[b + 2] = f, this.float32[b + 3] = _, t;
        }
      }
      Zt.prototype.bytesPerElement = 16, Ot("StructArrayLayout4f16", Zt);
      class Ct extends h {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new q(this.anchorPointX, this.anchorPointY);
        }
      }
      Ct.prototype.size = 20;
      class Dt extends de {
        get(t) {
          return new Ct(this, t);
        }
      }
      Ot("CollisionBoxArray", Dt);
      class Wt extends h {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(t) {
          this._structArray.uint8[this._pos1 + 37] = t;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(t) {
          this._structArray.uint8[this._pos1 + 38] = t;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 10] = t;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      Wt.prototype.size = 48;
      class di extends tt {
        get(t) {
          return new Wt(this, t);
        }
      }
      Ot("PlacedSymbolArray", di);
      class ci extends h {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 12] = t;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      ci.prototype.size = 64;
      class gi extends ht {
        get(t) {
          return new ci(this, t);
        }
      }
      Ot("SymbolInstanceArray", gi);
      class Ei extends _t {
        getoffsetX(t) {
          return this.float32[1 * t + 0];
        }
      }
      Ot("GlyphOffsetArray", Ei);
      class qi extends P {
        getx(t) {
          return this.int16[3 * t + 0];
        }
        gety(t) {
          return this.int16[3 * t + 1];
        }
        gettileUnitDistanceFromAnchor(t) {
          return this.int16[3 * t + 2];
        }
      }
      Ot("SymbolLineVertexArray", qi);
      class ar extends h {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      ar.prototype.size = 12;
      class Fi extends wt {
        get(t) {
          return new ar(this, t);
        }
      }
      Ot("TextAnchorOffsetArray", Fi);
      class _r extends h {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      _r.prototype.size = 8;
      class Ui extends bt {
        get(t) {
          return new _r(this, t);
        }
      }
      Ot("FeatureIndexArray", Ui);
      class pr extends T {
      }
      class Cr extends T {
      }
      class dn extends T {
      }
      class Ln extends N {
      }
      class sr extends Z {
      }
      class xs extends G {
      }
      class Mn extends V {
      }
      class hl extends W {
      }
      class To extends ae {
      }
      class Qr extends oe {
      }
      class pn extends ce {
      }
      class Br extends Le {
      }
      class en extends ke {
      }
      class wr extends yt {
      }
      const Ur = x([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: tn } = Ur;
      class Li {
        constructor(t = []) {
          this.segments = t;
        }
        prepareSegment(t, n, u, f) {
          let _ = this.segments[this.segments.length - 1];
          return t > Li.MAX_VERTEX_ARRAY_LENGTH && xe(`Max vertices per segment is ${Li.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!_ || _.vertexLength + t > Li.MAX_VERTEX_ARRAY_LENGTH || _.sortKey !== f) && (_ = { vertexOffset: n.length, primitiveOffset: u.length, vertexLength: 0, primitiveLength: 0 }, f !== void 0 && (_.sortKey = f), this.segments.push(_)), _;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t of this.segments) for (const n in t.vaos) t.vaos[n].destroy();
        }
        static simpleSegment(t, n, u, f) {
          return new Li([{ vertexOffset: t, primitiveOffset: n, vertexLength: u, primitiveLength: f, vaos: {}, sortKey: 0 }]);
        }
      }
      function Ma(i, t) {
        return 256 * (i = qe(Math.floor(i), 0, 255)) + qe(Math.floor(t), 0, 255);
      }
      Li.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ot("SegmentVector", Li);
      const ws = x([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var Ya = { exports: {} }, Co = { exports: {} };
      Co.exports = function(i, t) {
        var n, u, f, _, b, E, C, L;
        for (u = i.length - (n = 3 & i.length), f = t, b = 3432918353, E = 461845907, L = 0; L < u; ) C = 255 & i.charCodeAt(L) | (255 & i.charCodeAt(++L)) << 8 | (255 & i.charCodeAt(++L)) << 16 | (255 & i.charCodeAt(++L)) << 24, ++L, f = 27492 + (65535 & (_ = 5 * (65535 & (f = (f ^= C = (65535 & (C = (C = (65535 & C) * b + (((C >>> 16) * b & 65535) << 16) & 4294967295) << 15 | C >>> 17)) * E + (((C >>> 16) * E & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (_ >>> 16) & 65535) << 16);
        switch (C = 0, n) {
          case 3:
            C ^= (255 & i.charCodeAt(L + 2)) << 16;
          case 2:
            C ^= (255 & i.charCodeAt(L + 1)) << 8;
          case 1:
            f ^= C = (65535 & (C = (C = (65535 & (C ^= 255 & i.charCodeAt(L))) * b + (((C >>> 16) * b & 65535) << 16) & 4294967295) << 15 | C >>> 17)) * E + (((C >>> 16) * E & 65535) << 16) & 4294967295;
        }
        return f ^= i.length, f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295, f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295, (f ^= f >>> 16) >>> 0;
      };
      var Tc = Co.exports, ju = { exports: {} };
      ju.exports = function(i, t) {
        for (var n, u = i.length, f = t ^ u, _ = 0; u >= 4; ) n = 1540483477 * (65535 & (n = 255 & i.charCodeAt(_) | (255 & i.charCodeAt(++_)) << 8 | (255 & i.charCodeAt(++_)) << 16 | (255 & i.charCodeAt(++_)) << 24)) + ((1540483477 * (n >>> 16) & 65535) << 16), f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (n = 1540483477 * (65535 & (n ^= n >>> 24)) + ((1540483477 * (n >>> 16) & 65535) << 16)), u -= 4, ++_;
        switch (u) {
          case 3:
            f ^= (255 & i.charCodeAt(_ + 2)) << 16;
          case 2:
            f ^= (255 & i.charCodeAt(_ + 1)) << 8;
          case 1:
            f = 1540483477 * (65535 & (f ^= 255 & i.charCodeAt(_))) + ((1540483477 * (f >>> 16) & 65535) << 16);
        }
        return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16), (f ^= f >>> 15) >>> 0;
      };
      var Na = Tc, Ja = ju.exports;
      Ya.exports = Na, Ya.exports.murmur3 = Na, Ya.exports.murmur2 = Ja;
      var Fl = D(Ya.exports);
      class dl {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(t, n, u, f) {
          this.ids.push(Bl(t)), this.positions.push(n, u, f);
        }
        getPositions(t) {
          if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
          const n = Bl(t);
          let u = 0, f = this.ids.length - 1;
          for (; u < f; ) {
            const b = u + f >> 1;
            this.ids[b] >= n ? f = b : u = b + 1;
          }
          const _ = [];
          for (; this.ids[u] === n; ) _.push({ index: this.positions[3 * u], start: this.positions[3 * u + 1], end: this.positions[3 * u + 2] }), u++;
          return _;
        }
        static serialize(t, n) {
          const u = new Float64Array(t.ids), f = new Uint32Array(t.positions);
          return pl(u, f, 0, u.length - 1), n && n.push(u.buffer, f.buffer), { ids: u, positions: f };
        }
        static deserialize(t) {
          const n = new dl();
          return n.ids = t.ids, n.positions = t.positions, n.indexed = !0, n;
        }
      }
      function Bl(i) {
        const t = +i;
        return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Fl(String(i));
      }
      function pl(i, t, n, u) {
        for (; n < u; ) {
          const f = i[n + u >> 1];
          let _ = n - 1, b = u + 1;
          for (; ; ) {
            do
              _++;
            while (i[_] < f);
            do
              b--;
            while (i[b] > f);
            if (_ >= b) break;
            Ka(i, _, b), Ka(t, 3 * _, 3 * b), Ka(t, 3 * _ + 1, 3 * b + 1), Ka(t, 3 * _ + 2, 3 * b + 2);
          }
          b - n < u - b ? (pl(i, t, n, b), n = b + 1) : (pl(i, t, b + 1, u), u = b);
        }
      }
      function Ka(i, t, n) {
        const u = i[t];
        i[t] = i[n], i[n] = u;
      }
      Ot("FeaturePositionMap", dl);
      class Do {
        constructor(t, n) {
          this.gl = t.gl, this.location = n;
        }
      }
      class mu extends Do {
        constructor(t, n) {
          super(t, n), this.current = 0;
        }
        set(t) {
          this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
        }
      }
      class gu extends Do {
        constructor(t, n) {
          super(t, n), this.current = [0, 0, 0, 0];
        }
        set(t) {
          t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
        }
      }
      class qu extends Do {
        constructor(t, n) {
          super(t, n), this.current = ji.transparent;
        }
        set(t) {
          t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
        }
      }
      const _u = new Float32Array(16);
      function Uu(i) {
        return [Ma(255 * i.r, 255 * i.g), Ma(255 * i.b, 255 * i.a)];
      }
      class yu {
        constructor(t, n, u) {
          this.value = t, this.uniformNames = n.map((f) => `u_${f}`), this.type = u;
        }
        setUniform(t, n, u) {
          t.set(u.constantOr(this.value));
        }
        getBinding(t, n, u) {
          return this.type === "color" ? new qu(t, n) : new mu(t, n);
        }
      }
      class Gs {
        constructor(t, n) {
          this.uniformNames = n.map((u) => `u_${u}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(t, n) {
          this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr;
        }
        setUniform(t, n, u, f) {
          const _ = f === "u_pattern_to" ? this.patternTo : f === "u_pattern_from" ? this.patternFrom : f === "u_pixel_ratio_to" ? this.pixelRatioTo : f === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          _ && t.set(_);
        }
        getBinding(t, n, u) {
          return u.substr(0, 9) === "u_pattern" ? new gu(t, n) : new mu(t, n);
        }
      }
      class As {
        constructor(t, n, u, f) {
          this.expression = t, this.type = u, this.maxValue = 0, this.paintVertexAttributes = n.map((_) => ({ name: `a_${_}`, type: "Float32", components: u === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new f();
        }
        populatePaintArray(t, n, u, f, _) {
          const b = this.paintVertexArray.length, E = this.expression.evaluate(new Ji(0), n, {}, f, [], _);
          this.paintVertexArray.resize(t), this._setPaintValue(b, t, E);
        }
        updatePaintArray(t, n, u, f) {
          const _ = this.expression.evaluate({ zoom: 0 }, u, f);
          this._setPaintValue(t, n, _);
        }
        _setPaintValue(t, n, u) {
          if (this.type === "color") {
            const f = Uu(u);
            for (let _ = t; _ < n; _++) this.paintVertexArray.emplace(_, f[0], f[1]);
          } else {
            for (let f = t; f < n; f++) this.paintVertexArray.emplace(f, u);
            this.maxValue = Math.max(this.maxValue, Math.abs(u));
          }
        }
        upload(t) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class ga {
        constructor(t, n, u, f, _, b) {
          this.expression = t, this.uniformNames = n.map((E) => `u_${E}_t`), this.type = u, this.useIntegerZoom = f, this.zoom = _, this.maxValue = 0, this.paintVertexAttributes = n.map((E) => ({ name: `a_${E}`, type: "Float32", components: u === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new b();
        }
        populatePaintArray(t, n, u, f, _) {
          const b = this.expression.evaluate(new Ji(this.zoom), n, {}, f, [], _), E = this.expression.evaluate(new Ji(this.zoom + 1), n, {}, f, [], _), C = this.paintVertexArray.length;
          this.paintVertexArray.resize(t), this._setPaintValue(C, t, b, E);
        }
        updatePaintArray(t, n, u, f) {
          const _ = this.expression.evaluate({ zoom: this.zoom }, u, f), b = this.expression.evaluate({ zoom: this.zoom + 1 }, u, f);
          this._setPaintValue(t, n, _, b);
        }
        _setPaintValue(t, n, u, f) {
          if (this.type === "color") {
            const _ = Uu(u), b = Uu(f);
            for (let E = t; E < n; E++) this.paintVertexArray.emplace(E, _[0], _[1], b[0], b[1]);
          } else {
            for (let _ = t; _ < n; _++) this.paintVertexArray.emplace(_, u, f);
            this.maxValue = Math.max(this.maxValue, Math.abs(u), Math.abs(f));
          }
        }
        upload(t) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t, n) {
          const u = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, f = qe(this.expression.interpolationFactor(u, this.zoom, this.zoom + 1), 0, 1);
          t.set(f);
        }
        getBinding(t, n, u) {
          return new mu(t, n);
        }
      }
      class Nn {
        constructor(t, n, u, f, _, b) {
          this.expression = t, this.type = n, this.useIntegerZoom = u, this.zoom = f, this.layerId = b, this.zoomInPaintVertexArray = new _(), this.zoomOutPaintVertexArray = new _();
        }
        populatePaintArray(t, n, u) {
          const f = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(f, t, n.patterns && n.patterns[this.layerId], u);
        }
        updatePaintArray(t, n, u, f, _) {
          this._setPaintValues(t, n, u.patterns && u.patterns[this.layerId], _);
        }
        _setPaintValues(t, n, u, f) {
          if (!f || !u) return;
          const { min: _, mid: b, max: E } = u, C = f[_], L = f[b], R = f[E];
          if (C && L && R) for (let U = t; U < n; U++) this.zoomInPaintVertexArray.emplace(U, L.tl[0], L.tl[1], L.br[0], L.br[1], C.tl[0], C.tl[1], C.br[0], C.br[1], L.pixelRatio, C.pixelRatio), this.zoomOutPaintVertexArray.emplace(U, L.tl[0], L.tl[1], L.br[0], L.br[1], R.tl[0], R.tl[1], R.br[0], R.br[1], L.pixelRatio, R.pixelRatio);
        }
        upload(t) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, ws.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, ws.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class Cc {
        constructor(t, n, u) {
          this.binders = {}, this._buffers = [];
          const f = [];
          for (const _ in t.paint._values) {
            if (!u(_)) continue;
            const b = t.paint.get(_);
            if (!(b instanceof ma && Ca(b.property.specification))) continue;
            const E = _d(_, t.type), C = b.value, L = b.property.specification.type, R = b.property.useIntegerZoom, U = b.property.specification["property-type"], H = U === "cross-faded" || U === "cross-faded-data-driven";
            if (C.kind === "constant") this.binders[_] = H ? new Gs(C.value, E) : new yu(C.value, E, L), f.push(`/u_${_}`);
            else if (C.kind === "source" || H) {
              const J = Dc(_, L, "source");
              this.binders[_] = H ? new Nn(C, L, R, n, J, t.id) : new As(C, E, L, J), f.push(`/a_${_}`);
            } else {
              const J = Dc(_, L, "composite");
              this.binders[_] = new ga(C, E, L, R, n, J), f.push(`/z_${_}`);
            }
          }
          this.cacheKey = f.sort().join("");
        }
        getMaxValue(t) {
          const n = this.binders[t];
          return n instanceof As || n instanceof ga ? n.maxValue : 0;
        }
        populatePaintArrays(t, n, u, f, _) {
          for (const b in this.binders) {
            const E = this.binders[b];
            (E instanceof As || E instanceof ga || E instanceof Nn) && E.populatePaintArray(t, n, u, f, _);
          }
        }
        setConstantPatternPositions(t, n) {
          for (const u in this.binders) {
            const f = this.binders[u];
            f instanceof Gs && f.setConstantPatternPositions(t, n);
          }
        }
        updatePaintArrays(t, n, u, f, _) {
          let b = !1;
          for (const E in t) {
            const C = n.getPositions(E);
            for (const L of C) {
              const R = u.feature(L.index);
              for (const U in this.binders) {
                const H = this.binders[U];
                if ((H instanceof As || H instanceof ga || H instanceof Nn) && H.expression.isStateDependent === !0) {
                  const J = f.paint.get(U);
                  H.expression = J.value, H.updatePaintArray(L.start, L.end, R, t[E], _), b = !0;
                }
              }
            }
          }
          return b;
        }
        defines() {
          const t = [];
          for (const n in this.binders) {
            const u = this.binders[n];
            (u instanceof yu || u instanceof Gs) && t.push(...u.uniformNames.map((f) => `#define HAS_UNIFORM_${f}`));
          }
          return t;
        }
        getBinderAttributes() {
          const t = [];
          for (const n in this.binders) {
            const u = this.binders[n];
            if (u instanceof As || u instanceof ga) for (let f = 0; f < u.paintVertexAttributes.length; f++) t.push(u.paintVertexAttributes[f].name);
            else if (u instanceof Nn) for (let f = 0; f < ws.members.length; f++) t.push(ws.members[f].name);
          }
          return t;
        }
        getBinderUniforms() {
          const t = [];
          for (const n in this.binders) {
            const u = this.binders[n];
            if (u instanceof yu || u instanceof Gs || u instanceof ga) for (const f of u.uniformNames) t.push(f);
          }
          return t;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t, n) {
          const u = [];
          for (const f in this.binders) {
            const _ = this.binders[f];
            if (_ instanceof yu || _ instanceof Gs || _ instanceof ga) {
              for (const b of _.uniformNames) if (n[b]) {
                const E = _.getBinding(t, n[b], b);
                u.push({ name: b, property: f, binding: E });
              }
            }
          }
          return u;
        }
        setUniforms(t, n, u, f) {
          for (const { name: _, property: b, binding: E } of n) this.binders[b].setUniform(E, f, u.get(b), _);
        }
        updatePaintBuffers(t) {
          this._buffers = [];
          for (const n in this.binders) {
            const u = this.binders[n];
            if (t && u instanceof Nn) {
              const f = t.fromScale === 2 ? u.zoomInPaintVertexBuffer : u.zoomOutPaintVertexBuffer;
              f && this._buffers.push(f);
            } else (u instanceof As || u instanceof ga) && u.paintVertexBuffer && this._buffers.push(u.paintVertexBuffer);
          }
        }
        upload(t) {
          for (const n in this.binders) {
            const u = this.binders[n];
            (u instanceof As || u instanceof ga || u instanceof Nn) && u.upload(t);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t in this.binders) {
            const n = this.binders[t];
            (n instanceof As || n instanceof ga || n instanceof Nn) && n.destroy();
          }
        }
      }
      class Io {
        constructor(t, n, u = () => !0) {
          this.programConfigurations = {};
          for (const f of t) this.programConfigurations[f.id] = new Cc(f, n, u);
          this.needsUpload = !1, this._featureMap = new dl(), this._bufferOffset = 0;
        }
        populatePaintArrays(t, n, u, f, _, b) {
          for (const E in this.programConfigurations) this.programConfigurations[E].populatePaintArrays(t, n, f, _, b);
          n.id !== void 0 && this._featureMap.add(n.id, u, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
        }
        updatePaintArrays(t, n, u, f) {
          for (const _ of u) this.needsUpload = this.programConfigurations[_.id].updatePaintArrays(t, this._featureMap, n, _, f) || this.needsUpload;
        }
        get(t) {
          return this.programConfigurations[t];
        }
        upload(t) {
          if (this.needsUpload) {
            for (const n in this.programConfigurations) this.programConfigurations[n].upload(t);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
        }
      }
      function _d(i, t) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[i] || [i.replace(`${t}-`, "").replace(/-/g, "_")];
      }
      function Dc(i, t, n) {
        const u = { color: { source: G, composite: Zt }, number: { source: _t, composite: G } }, f = function(_) {
          return { "line-pattern": { source: Mn, composite: Mn }, "fill-pattern": { source: Mn, composite: Mn }, "fill-extrusion-pattern": { source: Mn, composite: Mn } }[_];
        }(i);
        return f && f[n] || u[t][n];
      }
      Ot("ConstantBinder", yu), Ot("CrossFadedConstantBinder", Gs), Ot("SourceExpressionBinder", As), Ot("CrossFadedCompositeBinder", Nn), Ot("CompositeExpressionBinder", ga), Ot("ProgramConfiguration", Cc, { omit: ["_buffers"] }), Ot("ProgramConfigurationSet", Io);
      const or = 8192, Ic = Math.pow(2, 14) - 1, kc = -Ic - 1;
      function fl(i) {
        const t = or / i.extent, n = i.loadGeometry();
        for (let u = 0; u < n.length; u++) {
          const f = n[u];
          for (let _ = 0; _ < f.length; _++) {
            const b = f[_], E = Math.round(b.x * t), C = Math.round(b.y * t);
            b.x = qe(E, kc, Ic), b.y = qe(C, kc, Ic), (E < b.x || E > b.x + 1 || C < b.y || C > b.y + 1) && xe("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return n;
      }
      function ko(i, t) {
        return { type: i.type, id: i.id, properties: i.properties, geometry: t ? fl(i) : [] };
      }
      function Vu(i, t, n, u, f) {
        i.emplaceBack(2 * t + (u + 1) / 2, 2 * n + (f + 1) / 2);
      }
      class ml {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Cr(), this.indexArray = new en(), this.segments = new Li(), this.programConfigurations = new Io(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, u) {
          const f = this.layers[0], _ = [];
          let b = null, E = !1;
          f.type === "circle" && (b = f.layout.get("circle-sort-key"), E = !b.isConstant());
          for (const { feature: C, id: L, index: R, sourceLayerIndex: U } of t) {
            const H = this.layers[0]._featureFilter.needGeometry, J = ko(C, H);
            if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), J, u)) continue;
            const ne = E ? b.evaluate(J, {}, u) : void 0, he = { id: L, properties: C.properties, type: C.type, sourceLayerIndex: U, index: R, geometry: H ? J.geometry : fl(C), patterns: {}, sortKey: ne };
            _.push(he);
          }
          E && _.sort((C, L) => C.sortKey - L.sortKey);
          for (const C of _) {
            const { geometry: L, index: R, sourceLayerIndex: U } = C, H = t[R].feature;
            this.addFeature(C, L, R, u), n.featureIndex.insert(H, L, R, U, this.index);
          }
        }
        update(t, n, u) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, u);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, tn), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t, n, u, f) {
          for (const _ of n) for (const b of _) {
            const E = b.x, C = b.y;
            if (E < 0 || E >= or || C < 0 || C >= or) continue;
            const L = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey), R = L.vertexLength;
            Vu(this.layoutVertexArray, E, C, -1, -1), Vu(this.layoutVertexArray, E, C, 1, -1), Vu(this.layoutVertexArray, E, C, 1, 1), Vu(this.layoutVertexArray, E, C, -1, 1), this.indexArray.emplaceBack(R, R + 1, R + 2), this.indexArray.emplaceBack(R, R + 3, R + 2), L.vertexLength += 4, L.primitiveLength += 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, {}, f);
        }
      }
      function $u(i, t) {
        for (let n = 0; n < i.length; n++) if (Lo(t, i[n])) return !0;
        for (let n = 0; n < t.length; n++) if (Lo(i, t[n])) return !0;
        return !!Es(i, t);
      }
      function Zu(i, t, n) {
        return !!Lo(i, t) || !!vu(t, i, n);
      }
      function Ss(i, t) {
        if (i.length === 1) return wh(t, i[0]);
        for (let n = 0; n < t.length; n++) {
          const u = t[n];
          for (let f = 0; f < u.length; f++) if (Lo(i, u[f])) return !0;
        }
        for (let n = 0; n < i.length; n++) if (wh(t, i[n])) return !0;
        for (let n = 0; n < t.length; n++) if (Es(i, t[n])) return !0;
        return !1;
      }
      function Po(i, t, n) {
        if (i.length > 1) {
          if (Es(i, t)) return !0;
          for (let u = 0; u < t.length; u++) if (vu(t[u], i, n)) return !0;
        }
        for (let u = 0; u < i.length; u++) if (vu(i[u], t, n)) return !0;
        return !1;
      }
      function Es(i, t) {
        if (i.length === 0 || t.length === 0) return !1;
        for (let n = 0; n < i.length - 1; n++) {
          const u = i[n], f = i[n + 1];
          for (let _ = 0; _ < t.length - 1; _++) if (Gu(u, f, t[_], t[_ + 1])) return !0;
        }
        return !1;
      }
      function Gu(i, t, n, u) {
        return ye(i, n, u) !== ye(t, n, u) && ye(i, t, n) !== ye(i, t, u);
      }
      function vu(i, t, n) {
        const u = n * n;
        if (t.length === 1) return i.distSqr(t[0]) < u;
        for (let f = 1; f < t.length; f++) if (Pc(i, t[f - 1], t[f]) < u) return !0;
        return !1;
      }
      function Pc(i, t, n) {
        const u = t.distSqr(n);
        if (u === 0) return i.distSqr(t);
        const f = ((i.x - t.x) * (n.x - t.x) + (i.y - t.y) * (n.y - t.y)) / u;
        return i.distSqr(f < 0 ? t : f > 1 ? n : n.sub(t)._mult(f)._add(t));
      }
      function wh(i, t) {
        let n, u, f, _ = !1;
        for (let b = 0; b < i.length; b++) {
          n = i[b];
          for (let E = 0, C = n.length - 1; E < n.length; C = E++) u = n[E], f = n[C], u.y > t.y != f.y > t.y && t.x < (f.x - u.x) * (t.y - u.y) / (f.y - u.y) + u.x && (_ = !_);
        }
        return _;
      }
      function Lo(i, t) {
        let n = !1;
        for (let u = 0, f = i.length - 1; u < i.length; f = u++) {
          const _ = i[u], b = i[f];
          _.y > t.y != b.y > t.y && t.x < (b.x - _.x) * (t.y - _.y) / (b.y - _.y) + _.x && (n = !n);
        }
        return n;
      }
      function Lc(i, t, n) {
        const u = n[0], f = n[2];
        if (i.x < u.x && t.x < u.x || i.x > f.x && t.x > f.x || i.y < u.y && t.y < u.y || i.y > f.y && t.y > f.y) return !1;
        const _ = ye(i, t, n[0]);
        return _ !== ye(i, t, n[1]) || _ !== ye(i, t, n[2]) || _ !== ye(i, t, n[3]);
      }
      function Mc(i, t, n) {
        const u = t.paint.get(i).value;
        return u.kind === "constant" ? u.value : n.programConfigurations.get(t.id).getMaxValue(i);
      }
      function Ah(i) {
        return Math.sqrt(i[0] * i[0] + i[1] * i[1]);
      }
      function Sh(i, t, n, u, f) {
        if (!t[0] && !t[1]) return i;
        const _ = q.convert(t)._mult(f);
        n === "viewport" && _._rotate(-u);
        const b = [];
        for (let E = 0; E < i.length; E++) b.push(i[E].sub(_));
        return b;
      }
      let of, lf;
      Ot("CircleBucket", ml, { omit: ["layers"] });
      var i1 = { get paint() {
        return lf = lf || new c({ "circle-radius": new li(Y.paint_circle["circle-radius"]), "circle-color": new li(Y.paint_circle["circle-color"]), "circle-blur": new li(Y.paint_circle["circle-blur"]), "circle-opacity": new li(Y.paint_circle["circle-opacity"]), "circle-translate": new Gt(Y.paint_circle["circle-translate"]), "circle-translate-anchor": new Gt(Y.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Gt(Y.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Gt(Y.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new li(Y.paint_circle["circle-stroke-width"]), "circle-stroke-color": new li(Y.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new li(Y.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return of = of || new c({ "circle-sort-key": new li(Y.layout_circle["circle-sort-key"]) });
      } }, Xn = 1e-6, Hu = typeof Float32Array < "u" ? Float32Array : Array;
      function yd(i) {
        return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }
      function uf(i, t, n) {
        var u = t[0], f = t[1], _ = t[2], b = t[3], E = t[4], C = t[5], L = t[6], R = t[7], U = t[8], H = t[9], J = t[10], ne = t[11], he = t[12], Se = t[13], Pe = t[14], Xe = t[15], Be = n[0], Ge = n[1], st = n[2], Tt = n[3];
        return i[0] = Be * u + Ge * E + st * U + Tt * he, i[1] = Be * f + Ge * C + st * H + Tt * Se, i[2] = Be * _ + Ge * L + st * J + Tt * Pe, i[3] = Be * b + Ge * R + st * ne + Tt * Xe, i[4] = (Be = n[4]) * u + (Ge = n[5]) * E + (st = n[6]) * U + (Tt = n[7]) * he, i[5] = Be * f + Ge * C + st * H + Tt * Se, i[6] = Be * _ + Ge * L + st * J + Tt * Pe, i[7] = Be * b + Ge * R + st * ne + Tt * Xe, i[8] = (Be = n[8]) * u + (Ge = n[9]) * E + (st = n[10]) * U + (Tt = n[11]) * he, i[9] = Be * f + Ge * C + st * H + Tt * Se, i[10] = Be * _ + Ge * L + st * J + Tt * Pe, i[11] = Be * b + Ge * R + st * ne + Tt * Xe, i[12] = (Be = n[12]) * u + (Ge = n[13]) * E + (st = n[14]) * U + (Tt = n[15]) * he, i[13] = Be * f + Ge * C + st * H + Tt * Se, i[14] = Be * _ + Ge * L + st * J + Tt * Pe, i[15] = Be * b + Ge * R + st * ne + Tt * Xe, i;
      }
      Math.hypot || (Math.hypot = function() {
        for (var i = 0, t = arguments.length; t--; ) i += arguments[t] * arguments[t];
        return Math.sqrt(i);
      });
      var Nc, r1 = uf;
      function Eh(i, t, n) {
        var u = t[0], f = t[1], _ = t[2], b = t[3];
        return i[0] = n[0] * u + n[4] * f + n[8] * _ + n[12] * b, i[1] = n[1] * u + n[5] * f + n[9] * _ + n[13] * b, i[2] = n[2] * u + n[6] * f + n[10] * _ + n[14] * b, i[3] = n[3] * u + n[7] * f + n[11] * _ + n[15] * b, i;
      }
      Nc = new Hu(4), Hu != Float32Array && (Nc[0] = 0, Nc[1] = 0, Nc[2] = 0, Nc[3] = 0);
      class n1 extends r {
        constructor(t) {
          super(t, i1);
        }
        createBucket(t) {
          return new ml(t);
        }
        queryRadius(t) {
          const n = t;
          return Mc("circle-radius", this, n) + Mc("circle-stroke-width", this, n) + Ah(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t, n, u, f, _, b, E, C) {
          const L = Sh(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), b.angle, E), R = this.paint.get("circle-radius").evaluate(n, u) + this.paint.get("circle-stroke-width").evaluate(n, u), U = this.paint.get("circle-pitch-alignment") === "map", H = U ? L : function(ne, he) {
            return ne.map((Se) => cf(Se, he));
          }(L, C), J = U ? R * E : R;
          for (const ne of f) for (const he of ne) {
            const Se = U ? he : cf(he, C);
            let Pe = J;
            const Xe = Eh([], [he.x, he.y, 0, 1], C);
            if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Pe *= Xe[3] / b.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Pe *= b.cameraToCenterDistance / Xe[3]), Zu(H, Se, Pe)) return !0;
          }
          return !1;
        }
      }
      function cf(i, t) {
        const n = Eh([], [i.x, i.y, 0, 1], t);
        return new q(n[0] / n[3], n[1] / n[3]);
      }
      class hf extends ml {
      }
      let df;
      Ot("HeatmapBucket", hf, { omit: ["layers"] });
      var a1 = { get paint() {
        return df = df || new c({ "heatmap-radius": new li(Y.paint_heatmap["heatmap-radius"]), "heatmap-weight": new li(Y.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Gt(Y.paint_heatmap["heatmap-intensity"]), "heatmap-color": new S(Y.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Gt(Y.paint_heatmap["heatmap-opacity"]) });
      } };
      function vd(i, { width: t, height: n }, u, f) {
        if (f) {
          if (f instanceof Uint8ClampedArray) f = new Uint8Array(f.buffer);
          else if (f.length !== t * n * u) throw new RangeError(`mismatched image size. expected: ${f.length} but got: ${t * n * u}`);
        } else f = new Uint8Array(t * n * u);
        return i.width = t, i.height = n, i.data = f, i;
      }
      function pf(i, { width: t, height: n }, u) {
        if (t === i.width && n === i.height) return;
        const f = vd({}, { width: t, height: n }, u);
        bd(i, f, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(i.width, t), height: Math.min(i.height, n) }, u), i.width = t, i.height = n, i.data = f.data;
      }
      function bd(i, t, n, u, f, _) {
        if (f.width === 0 || f.height === 0) return t;
        if (f.width > i.width || f.height > i.height || n.x > i.width - f.width || n.y > i.height - f.height) throw new RangeError("out of range source coordinates for image copy");
        if (f.width > t.width || f.height > t.height || u.x > t.width - f.width || u.y > t.height - f.height) throw new RangeError("out of range destination coordinates for image copy");
        const b = i.data, E = t.data;
        if (b === E) throw new Error("srcData equals dstData, so image is already copied");
        for (let C = 0; C < f.height; C++) {
          const L = ((n.y + C) * i.width + n.x) * _, R = ((u.y + C) * t.width + u.x) * _;
          for (let U = 0; U < f.width * _; U++) E[R + U] = b[L + U];
        }
        return t;
      }
      class zc {
        constructor(t, n) {
          vd(this, t, 1, n);
        }
        resize(t) {
          pf(this, t, 1);
        }
        clone() {
          return new zc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t, n, u, f, _) {
          bd(t, n, u, f, _, 1);
        }
      }
      class Qa {
        constructor(t, n) {
          vd(this, t, 4, n);
        }
        resize(t) {
          pf(this, t, 4);
        }
        replace(t, n) {
          n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
        }
        clone() {
          return new Qa({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t, n, u, f, _) {
          bd(t, n, u, f, _, 4);
        }
      }
      function ff(i) {
        const t = {}, n = i.resolution || 256, u = i.clips ? i.clips.length : 1, f = i.image || new Qa({ width: n, height: u });
        if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
        const _ = (b, E, C) => {
          t[i.evaluationKey] = C;
          const L = i.expression.evaluate(t);
          f.data[b + E + 0] = Math.floor(255 * L.r / L.a), f.data[b + E + 1] = Math.floor(255 * L.g / L.a), f.data[b + E + 2] = Math.floor(255 * L.b / L.a), f.data[b + E + 3] = Math.floor(255 * L.a);
        };
        if (i.clips) for (let b = 0, E = 0; b < u; ++b, E += 4 * n) for (let C = 0, L = 0; C < n; C++, L += 4) {
          const R = C / (n - 1), { start: U, end: H } = i.clips[b];
          _(E, L, U * (1 - R) + H * R);
        }
        else for (let b = 0, E = 0; b < n; b++, E += 4) _(0, E, b / (n - 1));
        return f;
      }
      Ot("AlphaImage", zc), Ot("RGBAImage", Qa);
      const xd = "big-fb";
      class s1 extends r {
        createBucket(t) {
          return new hf(t);
        }
        constructor(t) {
          super(t, a1), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t) {
          t === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = ff({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbos.has(xd) && this.heatmapFbos.delete(xd);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let mf;
      var o1 = { get paint() {
        return mf = mf || new c({ "hillshade-illumination-direction": new Gt(Y.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Gt(Y.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Gt(Y.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Gt(Y.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Gt(Y.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Gt(Y.paint_hillshade["hillshade-accent-color"]) });
      } };
      class l1 extends r {
        constructor(t) {
          super(t, o1);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const u1 = x([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: c1 } = u1;
      function gf(i, t, n = 2) {
        const u = t && t.length, f = u ? t[0] * n : i.length;
        let _ = _f(i, 0, f, n, !0);
        const b = [];
        if (!_ || _.next === _.prev) return b;
        let E, C, L;
        if (u && (_ = function(R, U, H, J) {
          const ne = [];
          for (let he = 0, Se = U.length; he < Se; he++) {
            const Pe = _f(R, U[he] * J, he < Se - 1 ? U[he + 1] * J : R.length, J, !1);
            Pe === Pe.next && (Pe.steiner = !0), ne.push(y1(Pe));
          }
          ne.sort(m1);
          for (let he = 0; he < ne.length; he++) H = g1(ne[he], H);
          return H;
        }(i, t, _, n)), i.length > 80 * n) {
          E = 1 / 0, C = 1 / 0;
          let R = -1 / 0, U = -1 / 0;
          for (let H = n; H < f; H += n) {
            const J = i[H], ne = i[H + 1];
            J < E && (E = J), ne < C && (C = ne), J > R && (R = J), ne > U && (U = ne);
          }
          L = Math.max(R - E, U - C), L = L !== 0 ? 32767 / L : 0;
        }
        return Fc(_, b, n, E, C, L, 0), b;
      }
      function _f(i, t, n, u, f) {
        let _;
        if (f === function(b, E, C, L) {
          let R = 0;
          for (let U = E, H = C - L; U < C; U += L) R += (b[H] - b[U]) * (b[U + 1] + b[H + 1]), H = U;
          return R;
        }(i, t, n, u) > 0) for (let b = t; b < n; b += u) _ = bf(b / u | 0, i[b], i[b + 1], _);
        else for (let b = n - u; b >= t; b -= u) _ = bf(b / u | 0, i[b], i[b + 1], _);
        return _ && Th(_, _.next) && (Rc(_), _ = _.next), _;
      }
      function bu(i, t) {
        if (!i) return i;
        t || (t = i);
        let n, u = i;
        do
          if (n = !1, u.steiner || !Th(u, u.next) && Nr(u.prev, u, u.next) !== 0) u = u.next;
          else {
            if (Rc(u), u = t = u.prev, u === u.next) break;
            n = !0;
          }
        while (n || u !== t);
        return t;
      }
      function Fc(i, t, n, u, f, _, b) {
        if (!i) return;
        !b && _ && function(C, L, R, U) {
          let H = C;
          do
            H.z === 0 && (H.z = wd(H.x, H.y, L, R, U)), H.prevZ = H.prev, H.nextZ = H.next, H = H.next;
          while (H !== C);
          H.prevZ.nextZ = null, H.prevZ = null, function(J) {
            let ne, he = 1;
            do {
              let Se, Pe = J;
              J = null;
              let Xe = null;
              for (ne = 0; Pe; ) {
                ne++;
                let Be = Pe, Ge = 0;
                for (let Tt = 0; Tt < he && (Ge++, Be = Be.nextZ, Be); Tt++) ;
                let st = he;
                for (; Ge > 0 || st > 0 && Be; ) Ge !== 0 && (st === 0 || !Be || Pe.z <= Be.z) ? (Se = Pe, Pe = Pe.nextZ, Ge--) : (Se = Be, Be = Be.nextZ, st--), Xe ? Xe.nextZ = Se : J = Se, Se.prevZ = Xe, Xe = Se;
                Pe = Be;
              }
              Xe.nextZ = null, he *= 2;
            } while (ne > 1);
          }(H);
        }(i, u, f, _);
        let E = i;
        for (; i.prev !== i.next; ) {
          const C = i.prev, L = i.next;
          if (_ ? d1(i, u, f, _) : h1(i)) t.push(C.i, i.i, L.i), Rc(i), i = L.next, E = L.next;
          else if ((i = L) === E) {
            b ? b === 1 ? Fc(i = p1(bu(i), t), t, n, u, f, _, 2) : b === 2 && f1(i, t, n, u, f, _) : Fc(bu(i), t, n, u, f, _, 1);
            break;
          }
        }
      }
      function h1(i) {
        const t = i.prev, n = i, u = i.next;
        if (Nr(t, n, u) >= 0) return !1;
        const f = t.x, _ = n.x, b = u.x, E = t.y, C = n.y, L = u.y, R = f < _ ? f < b ? f : b : _ < b ? _ : b, U = E < C ? E < L ? E : L : C < L ? C : L, H = f > _ ? f > b ? f : b : _ > b ? _ : b, J = E > C ? E > L ? E : L : C > L ? C : L;
        let ne = u.next;
        for (; ne !== t; ) {
          if (ne.x >= R && ne.x <= H && ne.y >= U && ne.y <= J && Wu(f, E, _, C, b, L, ne.x, ne.y) && Nr(ne.prev, ne, ne.next) >= 0) return !1;
          ne = ne.next;
        }
        return !0;
      }
      function d1(i, t, n, u) {
        const f = i.prev, _ = i, b = i.next;
        if (Nr(f, _, b) >= 0) return !1;
        const E = f.x, C = _.x, L = b.x, R = f.y, U = _.y, H = b.y, J = E < C ? E < L ? E : L : C < L ? C : L, ne = R < U ? R < H ? R : H : U < H ? U : H, he = E > C ? E > L ? E : L : C > L ? C : L, Se = R > U ? R > H ? R : H : U > H ? U : H, Pe = wd(J, ne, t, n, u), Xe = wd(he, Se, t, n, u);
        let Be = i.prevZ, Ge = i.nextZ;
        for (; Be && Be.z >= Pe && Ge && Ge.z <= Xe; ) {
          if (Be.x >= J && Be.x <= he && Be.y >= ne && Be.y <= Se && Be !== f && Be !== b && Wu(E, R, C, U, L, H, Be.x, Be.y) && Nr(Be.prev, Be, Be.next) >= 0 || (Be = Be.prevZ, Ge.x >= J && Ge.x <= he && Ge.y >= ne && Ge.y <= Se && Ge !== f && Ge !== b && Wu(E, R, C, U, L, H, Ge.x, Ge.y) && Nr(Ge.prev, Ge, Ge.next) >= 0)) return !1;
          Ge = Ge.nextZ;
        }
        for (; Be && Be.z >= Pe; ) {
          if (Be.x >= J && Be.x <= he && Be.y >= ne && Be.y <= Se && Be !== f && Be !== b && Wu(E, R, C, U, L, H, Be.x, Be.y) && Nr(Be.prev, Be, Be.next) >= 0) return !1;
          Be = Be.prevZ;
        }
        for (; Ge && Ge.z <= Xe; ) {
          if (Ge.x >= J && Ge.x <= he && Ge.y >= ne && Ge.y <= Se && Ge !== f && Ge !== b && Wu(E, R, C, U, L, H, Ge.x, Ge.y) && Nr(Ge.prev, Ge, Ge.next) >= 0) return !1;
          Ge = Ge.nextZ;
        }
        return !0;
      }
      function p1(i, t) {
        let n = i;
        do {
          const u = n.prev, f = n.next.next;
          !Th(u, f) && yf(u, n, n.next, f) && Bc(u, f) && Bc(f, u) && (t.push(u.i, n.i, f.i), Rc(n), Rc(n.next), n = i = f), n = n.next;
        } while (n !== i);
        return bu(n);
      }
      function f1(i, t, n, u, f, _) {
        let b = i;
        do {
          let E = b.next.next;
          for (; E !== b.prev; ) {
            if (b.i !== E.i && v1(b, E)) {
              let C = vf(b, E);
              return b = bu(b, b.next), C = bu(C, C.next), Fc(b, t, n, u, f, _, 0), void Fc(C, t, n, u, f, _, 0);
            }
            E = E.next;
          }
          b = b.next;
        } while (b !== i);
      }
      function m1(i, t) {
        return i.x - t.x;
      }
      function g1(i, t) {
        const n = function(f, _) {
          let b = _;
          const E = f.x, C = f.y;
          let L, R = -1 / 0;
          do {
            if (C <= b.y && C >= b.next.y && b.next.y !== b.y) {
              const he = b.x + (C - b.y) * (b.next.x - b.x) / (b.next.y - b.y);
              if (he <= E && he > R && (R = he, L = b.x < b.next.x ? b : b.next, he === E)) return L;
            }
            b = b.next;
          } while (b !== _);
          if (!L) return null;
          const U = L, H = L.x, J = L.y;
          let ne = 1 / 0;
          b = L;
          do {
            if (E >= b.x && b.x >= H && E !== b.x && Wu(C < J ? E : R, C, H, J, C < J ? R : E, C, b.x, b.y)) {
              const he = Math.abs(C - b.y) / (E - b.x);
              Bc(b, f) && (he < ne || he === ne && (b.x > L.x || b.x === L.x && _1(L, b))) && (L = b, ne = he);
            }
            b = b.next;
          } while (b !== U);
          return L;
        }(i, t);
        if (!n) return t;
        const u = vf(n, i);
        return bu(u, u.next), bu(n, n.next);
      }
      function _1(i, t) {
        return Nr(i.prev, i, t.prev) < 0 && Nr(t.next, i, i.next) < 0;
      }
      function wd(i, t, n, u, f) {
        return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - n) * f | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - u) * f | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
      }
      function y1(i) {
        let t = i, n = i;
        do
          (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
        while (t !== i);
        return n;
      }
      function Wu(i, t, n, u, f, _, b, E) {
        return (f - b) * (t - E) >= (i - b) * (_ - E) && (i - b) * (u - E) >= (n - b) * (t - E) && (n - b) * (_ - E) >= (f - b) * (u - E);
      }
      function v1(i, t) {
        return i.next.i !== t.i && i.prev.i !== t.i && !function(n, u) {
          let f = n;
          do {
            if (f.i !== n.i && f.next.i !== n.i && f.i !== u.i && f.next.i !== u.i && yf(f, f.next, n, u)) return !0;
            f = f.next;
          } while (f !== n);
          return !1;
        }(i, t) && (Bc(i, t) && Bc(t, i) && function(n, u) {
          let f = n, _ = !1;
          const b = (n.x + u.x) / 2, E = (n.y + u.y) / 2;
          do
            f.y > E != f.next.y > E && f.next.y !== f.y && b < (f.next.x - f.x) * (E - f.y) / (f.next.y - f.y) + f.x && (_ = !_), f = f.next;
          while (f !== n);
          return _;
        }(i, t) && (Nr(i.prev, i, t.prev) || Nr(i, t.prev, t)) || Th(i, t) && Nr(i.prev, i, i.next) > 0 && Nr(t.prev, t, t.next) > 0);
      }
      function Nr(i, t, n) {
        return (t.y - i.y) * (n.x - t.x) - (t.x - i.x) * (n.y - t.y);
      }
      function Th(i, t) {
        return i.x === t.x && i.y === t.y;
      }
      function yf(i, t, n, u) {
        const f = Dh(Nr(i, t, n)), _ = Dh(Nr(i, t, u)), b = Dh(Nr(n, u, i)), E = Dh(Nr(n, u, t));
        return f !== _ && b !== E || !(f !== 0 || !Ch(i, n, t)) || !(_ !== 0 || !Ch(i, u, t)) || !(b !== 0 || !Ch(n, i, u)) || !(E !== 0 || !Ch(n, t, u));
      }
      function Ch(i, t, n) {
        return t.x <= Math.max(i.x, n.x) && t.x >= Math.min(i.x, n.x) && t.y <= Math.max(i.y, n.y) && t.y >= Math.min(i.y, n.y);
      }
      function Dh(i) {
        return i > 0 ? 1 : i < 0 ? -1 : 0;
      }
      function Bc(i, t) {
        return Nr(i.prev, i, i.next) < 0 ? Nr(i, t, i.next) >= 0 && Nr(i, i.prev, t) >= 0 : Nr(i, t, i.prev) < 0 || Nr(i, i.next, t) < 0;
      }
      function vf(i, t) {
        const n = Ad(i.i, i.x, i.y), u = Ad(t.i, t.x, t.y), f = i.next, _ = t.prev;
        return i.next = t, t.prev = i, n.next = f, f.prev = n, u.next = n, n.prev = u, _.next = u, u.prev = _, u;
      }
      function bf(i, t, n, u) {
        const f = Ad(i, t, n);
        return u ? (f.next = u.next, f.prev = u, u.next.prev = f, u.next = f) : (f.prev = f, f.next = f), f;
      }
      function Rc(i) {
        i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
      }
      function Ad(i, t, n) {
        return { i, x: t, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
      }
      function Sd(i, t, n) {
        const u = n.patternDependencies;
        let f = !1;
        for (const _ of t) {
          const b = _.paint.get(`${i}-pattern`);
          b.isConstant() || (f = !0);
          const E = b.constantOr(null);
          E && (f = !0, u[E.to] = !0, u[E.from] = !0);
        }
        return f;
      }
      function Ed(i, t, n, u, f) {
        const _ = f.patternDependencies;
        for (const b of t) {
          const E = b.paint.get(`${i}-pattern`).value;
          if (E.kind !== "constant") {
            let C = E.evaluate({ zoom: u - 1 }, n, {}, f.availableImages), L = E.evaluate({ zoom: u }, n, {}, f.availableImages), R = E.evaluate({ zoom: u + 1 }, n, {}, f.availableImages);
            C = C && C.name ? C.name : C, L = L && L.name ? L.name : L, R = R && R.name ? R.name : R, _[C] = !0, _[L] = !0, _[R] = !0, n.patterns[b.id] = { min: C, mid: L, max: R };
          }
        }
        return n;
      }
      class Td {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new dn(), this.indexArray = new en(), this.indexArray2 = new wr(), this.programConfigurations = new Io(t.layers, t.zoom), this.segments = new Li(), this.segments2 = new Li(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, u) {
          this.hasPattern = Sd("fill", this.layers, n);
          const f = this.layers[0].layout.get("fill-sort-key"), _ = !f.isConstant(), b = [];
          for (const { feature: E, id: C, index: L, sourceLayerIndex: R } of t) {
            const U = this.layers[0]._featureFilter.needGeometry, H = ko(E, U);
            if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), H, u)) continue;
            const J = _ ? f.evaluate(H, {}, u, n.availableImages) : void 0, ne = { id: C, properties: E.properties, type: E.type, sourceLayerIndex: R, index: L, geometry: U ? H.geometry : fl(E), patterns: {}, sortKey: J };
            b.push(ne);
          }
          _ && b.sort((E, C) => E.sortKey - C.sortKey);
          for (const E of b) {
            const { geometry: C, index: L, sourceLayerIndex: R } = E;
            if (this.hasPattern) {
              const U = Ed("fill", this.layers, E, this.zoom, n);
              this.patternFeatures.push(U);
            } else this.addFeature(E, C, L, u, {});
            n.featureIndex.insert(t[L].feature, C, L, R, this.index);
          }
        }
        update(t, n, u) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, u);
        }
        addFeatures(t, n, u) {
          for (const f of this.patternFeatures) this.addFeature(f, f.geometry, f.index, n, u);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, c1), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t, n, u, f, _) {
          for (const b of Sa(n, 500)) {
            let E = 0;
            for (const J of b) E += J.length;
            const C = this.segments.prepareSegment(E, this.layoutVertexArray, this.indexArray), L = C.vertexLength, R = [], U = [];
            for (const J of b) {
              if (J.length === 0) continue;
              J !== b[0] && U.push(R.length / 2);
              const ne = this.segments2.prepareSegment(J.length, this.layoutVertexArray, this.indexArray2), he = ne.vertexLength;
              this.layoutVertexArray.emplaceBack(J[0].x, J[0].y), this.indexArray2.emplaceBack(he + J.length - 1, he), R.push(J[0].x), R.push(J[0].y);
              for (let Se = 1; Se < J.length; Se++) this.layoutVertexArray.emplaceBack(J[Se].x, J[Se].y), this.indexArray2.emplaceBack(he + Se - 1, he + Se), R.push(J[Se].x), R.push(J[Se].y);
              ne.vertexLength += J.length, ne.primitiveLength += J.length;
            }
            const H = gf(R, U);
            for (let J = 0; J < H.length; J += 3) this.indexArray.emplaceBack(L + H[J], L + H[J + 1], L + H[J + 2]);
            C.vertexLength += E, C.primitiveLength += H.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, _, f);
        }
      }
      let xf, wf;
      Ot("FillBucket", Td, { omit: ["layers", "patternFeatures"] });
      var b1 = { get paint() {
        return wf = wf || new c({ "fill-antialias": new Gt(Y.paint_fill["fill-antialias"]), "fill-opacity": new li(Y.paint_fill["fill-opacity"]), "fill-color": new li(Y.paint_fill["fill-color"]), "fill-outline-color": new li(Y.paint_fill["fill-outline-color"]), "fill-translate": new Gt(Y.paint_fill["fill-translate"]), "fill-translate-anchor": new Gt(Y.paint_fill["fill-translate-anchor"]), "fill-pattern": new cl(Y.paint_fill["fill-pattern"]) });
      }, get layout() {
        return xf = xf || new c({ "fill-sort-key": new li(Y.layout_fill["fill-sort-key"]) });
      } };
      class x1 extends r {
        constructor(t) {
          super(t, b1);
        }
        recalculate(t, n) {
          super.recalculate(t, n);
          const u = this.paint._values["fill-outline-color"];
          u.value.kind === "constant" && u.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t) {
          return new Td(t);
        }
        queryRadius() {
          return Ah(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t, n, u, f, _, b, E) {
          return Ss(Sh(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), b.angle, E), f);
        }
        isTileClipped() {
          return !0;
        }
      }
      const w1 = x([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), A1 = x([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: S1 } = w1;
      var Rl = {}, E1 = k, Af = Xu;
      function Xu(i, t, n, u, f) {
        this.properties = {}, this.extent = n, this.type = 0, this._pbf = i, this._geometry = -1, this._keys = u, this._values = f, i.readFields(T1, this, t);
      }
      function T1(i, t, n) {
        i == 1 ? t.id = n.readVarint() : i == 2 ? function(u, f) {
          for (var _ = u.readVarint() + u.pos; u.pos < _; ) {
            var b = f._keys[u.readVarint()], E = f._values[u.readVarint()];
            f.properties[b] = E;
          }
        }(n, t) : i == 3 ? t.type = n.readVarint() : i == 4 && (t._geometry = n.pos);
      }
      function C1(i) {
        for (var t, n, u = 0, f = 0, _ = i.length, b = _ - 1; f < _; b = f++) u += ((n = i[b]).x - (t = i[f]).x) * (t.y + n.y);
        return u;
      }
      Xu.types = ["Unknown", "Point", "LineString", "Polygon"], Xu.prototype.loadGeometry = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var t, n = i.readVarint() + i.pos, u = 1, f = 0, _ = 0, b = 0, E = []; i.pos < n; ) {
          if (f <= 0) {
            var C = i.readVarint();
            u = 7 & C, f = C >> 3;
          }
          if (f--, u === 1 || u === 2) _ += i.readSVarint(), b += i.readSVarint(), u === 1 && (t && E.push(t), t = []), t.push(new E1(_, b));
          else {
            if (u !== 7) throw new Error("unknown command " + u);
            t && t.push(t[0].clone());
          }
        }
        return t && E.push(t), E;
      }, Xu.prototype.bbox = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var t = i.readVarint() + i.pos, n = 1, u = 0, f = 0, _ = 0, b = 1 / 0, E = -1 / 0, C = 1 / 0, L = -1 / 0; i.pos < t; ) {
          if (u <= 0) {
            var R = i.readVarint();
            n = 7 & R, u = R >> 3;
          }
          if (u--, n === 1 || n === 2) (f += i.readSVarint()) < b && (b = f), f > E && (E = f), (_ += i.readSVarint()) < C && (C = _), _ > L && (L = _);
          else if (n !== 7) throw new Error("unknown command " + n);
        }
        return [b, C, E, L];
      }, Xu.prototype.toGeoJSON = function(i, t, n) {
        var u, f, _ = this.extent * Math.pow(2, n), b = this.extent * i, E = this.extent * t, C = this.loadGeometry(), L = Xu.types[this.type];
        function R(J) {
          for (var ne = 0; ne < J.length; ne++) {
            var he = J[ne];
            J[ne] = [360 * (he.x + b) / _ - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (he.y + E) / _) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var U = [];
            for (u = 0; u < C.length; u++) U[u] = C[u][0];
            R(C = U);
            break;
          case 2:
            for (u = 0; u < C.length; u++) R(C[u]);
            break;
          case 3:
            for (C = function(J) {
              var ne = J.length;
              if (ne <= 1) return [J];
              for (var he, Se, Pe = [], Xe = 0; Xe < ne; Xe++) {
                var Be = C1(J[Xe]);
                Be !== 0 && (Se === void 0 && (Se = Be < 0), Se === Be < 0 ? (he && Pe.push(he), he = [J[Xe]]) : he.push(J[Xe]));
              }
              return he && Pe.push(he), Pe;
            }(C), u = 0; u < C.length; u++) for (f = 0; f < C[u].length; f++) R(C[u][f]);
        }
        C.length === 1 ? C = C[0] : L = "Multi" + L;
        var H = { type: "Feature", geometry: { type: L, coordinates: C }, properties: this.properties };
        return "id" in this && (H.id = this.id), H;
      };
      var D1 = Af, Sf = Ef;
      function Ef(i, t) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = i, this._keys = [], this._values = [], this._features = [], i.readFields(I1, this, t), this.length = this._features.length;
      }
      function I1(i, t, n) {
        i === 15 ? t.version = n.readVarint() : i === 1 ? t.name = n.readString() : i === 5 ? t.extent = n.readVarint() : i === 2 ? t._features.push(n.pos) : i === 3 ? t._keys.push(n.readString()) : i === 4 && t._values.push(function(u) {
          for (var f = null, _ = u.readVarint() + u.pos; u.pos < _; ) {
            var b = u.readVarint() >> 3;
            f = b === 1 ? u.readString() : b === 2 ? u.readFloat() : b === 3 ? u.readDouble() : b === 4 ? u.readVarint64() : b === 5 ? u.readVarint() : b === 6 ? u.readSVarint() : b === 7 ? u.readBoolean() : null;
          }
          return f;
        }(n));
      }
      Ef.prototype.feature = function(i) {
        if (i < 0 || i >= this._features.length) throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[i];
        var t = this._pbf.readVarint() + this._pbf.pos;
        return new D1(this._pbf, t, this.extent, this._keys, this._values);
      };
      var k1 = Sf;
      function P1(i, t, n) {
        if (i === 3) {
          var u = new k1(n, n.readVarint() + n.pos);
          u.length && (t[u.name] = u);
        }
      }
      Rl.VectorTile = function(i, t) {
        this.layers = i.readFields(P1, {}, t);
      }, Rl.VectorTileFeature = Af, Rl.VectorTileLayer = Sf;
      const L1 = Rl.VectorTileFeature.types, Cd = Math.pow(2, 13);
      function Oc(i, t, n, u, f, _, b, E) {
        i.emplaceBack(t, n, 2 * Math.floor(u * Cd) + b, f * Cd * 2, _ * Cd * 2, Math.round(E));
      }
      class Dd {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Ln(), this.centroidVertexArray = new pr(), this.indexArray = new en(), this.programConfigurations = new Io(t.layers, t.zoom), this.segments = new Li(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, u) {
          this.features = [], this.hasPattern = Sd("fill-extrusion", this.layers, n);
          for (const { feature: f, id: _, index: b, sourceLayerIndex: E } of t) {
            const C = this.layers[0]._featureFilter.needGeometry, L = ko(f, C);
            if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), L, u)) continue;
            const R = { id: _, sourceLayerIndex: E, index: b, geometry: C ? L.geometry : fl(f), properties: f.properties, type: f.type, patterns: {} };
            this.hasPattern ? this.features.push(Ed("fill-extrusion", this.layers, R, this.zoom, n)) : this.addFeature(R, R.geometry, b, u, {}), n.featureIndex.insert(f, R.geometry, b, E, this.index, !0);
          }
        }
        addFeatures(t, n, u) {
          for (const f of this.features) {
            const { geometry: _ } = f;
            this.addFeature(f, _, f.index, n, u);
          }
        }
        update(t, n, u) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, u);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, S1), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, A1.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(t, n, u, f, _) {
          for (const b of Sa(n, 500)) {
            const E = { x: 0, y: 0, vertexCount: 0 };
            let C = 0;
            for (const ne of b) C += ne.length;
            let L = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const ne of b) {
              if (ne.length === 0 || N1(ne)) continue;
              let he = 0;
              for (let Se = 0; Se < ne.length; Se++) {
                const Pe = ne[Se];
                if (Se >= 1) {
                  const Xe = ne[Se - 1];
                  if (!M1(Pe, Xe)) {
                    L.vertexLength + 4 > Li.MAX_VERTEX_ARRAY_LENGTH && (L = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const Be = Pe.sub(Xe)._perp()._unit(), Ge = Xe.dist(Pe);
                    he + Ge > 32768 && (he = 0), Oc(this.layoutVertexArray, Pe.x, Pe.y, Be.x, Be.y, 0, 0, he), Oc(this.layoutVertexArray, Pe.x, Pe.y, Be.x, Be.y, 0, 1, he), E.x += 2 * Pe.x, E.y += 2 * Pe.y, E.vertexCount += 2, he += Ge, Oc(this.layoutVertexArray, Xe.x, Xe.y, Be.x, Be.y, 0, 0, he), Oc(this.layoutVertexArray, Xe.x, Xe.y, Be.x, Be.y, 0, 1, he), E.x += 2 * Xe.x, E.y += 2 * Xe.y, E.vertexCount += 2;
                    const st = L.vertexLength;
                    this.indexArray.emplaceBack(st, st + 2, st + 1), this.indexArray.emplaceBack(st + 1, st + 2, st + 3), L.vertexLength += 4, L.primitiveLength += 2;
                  }
                }
              }
            }
            if (L.vertexLength + C > Li.MAX_VERTEX_ARRAY_LENGTH && (L = this.segments.prepareSegment(C, this.layoutVertexArray, this.indexArray)), L1[t.type] !== "Polygon") continue;
            const R = [], U = [], H = L.vertexLength;
            for (const ne of b) if (ne.length !== 0) {
              ne !== b[0] && U.push(R.length / 2);
              for (let he = 0; he < ne.length; he++) {
                const Se = ne[he];
                Oc(this.layoutVertexArray, Se.x, Se.y, 0, 0, 1, 1, 0), E.x += Se.x, E.y += Se.y, E.vertexCount += 1, R.push(Se.x), R.push(Se.y);
              }
            }
            const J = gf(R, U);
            for (let ne = 0; ne < J.length; ne += 3) this.indexArray.emplaceBack(H + J[ne], H + J[ne + 2], H + J[ne + 1]);
            L.primitiveLength += J.length / 3, L.vertexLength += C;
            for (let ne = 0; ne < E.vertexCount; ne++) {
              const he = Math.floor(E.x / E.vertexCount), Se = Math.floor(E.y / E.vertexCount);
              this.centroidVertexArray.emplaceBack(he, Se);
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, _, f);
        }
      }
      function M1(i, t) {
        return i.x === t.x && (i.x < 0 || i.x > or) || i.y === t.y && (i.y < 0 || i.y > or);
      }
      function N1(i) {
        return i.every((t) => t.x < 0) || i.every((t) => t.x > or) || i.every((t) => t.y < 0) || i.every((t) => t.y > or);
      }
      let Tf;
      Ot("FillExtrusionBucket", Dd, { omit: ["layers", "features"] });
      var z1 = { get paint() {
        return Tf = Tf || new c({ "fill-extrusion-opacity": new Gt(Y["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new li(Y["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Gt(Y["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Gt(Y["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new cl(Y["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new li(Y["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new li(Y["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Gt(Y["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };
      class F1 extends r {
        constructor(t) {
          super(t, z1);
        }
        createBucket(t) {
          return new Dd(t);
        }
        queryRadius() {
          return Ah(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature(t, n, u, f, _, b, E, C) {
          const L = Sh(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), b.angle, E), R = this.paint.get("fill-extrusion-height").evaluate(n, u), U = this.paint.get("fill-extrusion-base").evaluate(n, u), H = function(ne, he, Se, Pe) {
            const Xe = [];
            for (const Be of ne) {
              const Ge = [Be.x, Be.y, 0, 1];
              Eh(Ge, Ge, he), Xe.push(new q(Ge[0] / Ge[3], Ge[1] / Ge[3]));
            }
            return Xe;
          }(L, C), J = function(ne, he, Se, Pe) {
            const Xe = [], Be = [], Ge = Pe[8] * he, st = Pe[9] * he, Tt = Pe[10] * he, Bt = Pe[11] * he, hi = Pe[8] * Se, Ft = Pe[9] * Se, Nt = Pe[10] * Se, Xt = Pe[11] * Se;
            for (const Vt of ne) {
              const qt = [], dt = [];
              for (const Yt of Vt) {
                const Ht = Yt.x, _i = Yt.y, ir = Pe[0] * Ht + Pe[4] * _i + Pe[12], Qi = Pe[1] * Ht + Pe[5] * _i + Pe[13], rn = Pe[2] * Ht + Pe[6] * _i + Pe[14], Ts = Pe[3] * Ht + Pe[7] * _i + Pe[15], xn = rn + Tt, nn = Ts + Bt, Yn = ir + hi, Jn = Qi + Ft, Kn = rn + Nt, Lr = Ts + Xt, an = new q((ir + Ge) / nn, (Qi + st) / nn);
                an.z = xn / nn, qt.push(an);
                const zn = new q(Yn / Lr, Jn / Lr);
                zn.z = Kn / Lr, dt.push(zn);
              }
              Xe.push(qt), Be.push(dt);
            }
            return [Xe, Be];
          }(f, U, R, C);
          return function(ne, he, Se) {
            let Pe = 1 / 0;
            Ss(Se, he) && (Pe = Cf(Se, he[0]));
            for (let Xe = 0; Xe < he.length; Xe++) {
              const Be = he[Xe], Ge = ne[Xe];
              for (let st = 0; st < Be.length - 1; st++) {
                const Tt = Be[st], Bt = [Tt, Be[st + 1], Ge[st + 1], Ge[st], Tt];
                $u(Se, Bt) && (Pe = Math.min(Pe, Cf(Se, Bt)));
              }
            }
            return Pe !== 1 / 0 && Pe;
          }(J[0], J[1], H);
        }
      }
      function jc(i, t) {
        return i.x * t.x + i.y * t.y;
      }
      function Cf(i, t) {
        if (i.length === 1) {
          let n = 0;
          const u = t[n++];
          let f;
          for (; !f || u.equals(f); ) if (f = t[n++], !f) return 1 / 0;
          for (; n < t.length; n++) {
            const _ = t[n], b = i[0], E = f.sub(u), C = _.sub(u), L = b.sub(u), R = jc(E, E), U = jc(E, C), H = jc(C, C), J = jc(L, E), ne = jc(L, C), he = R * H - U * U, Se = (H * J - U * ne) / he, Pe = (R * ne - U * J) / he, Xe = u.z * (1 - Se - Pe) + f.z * Se + _.z * Pe;
            if (isFinite(Xe)) return Xe;
          }
          return 1 / 0;
        }
        {
          let n = 1 / 0;
          for (const u of t) n = Math.min(n, u.z);
          return n;
        }
      }
      const B1 = x([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: R1 } = B1, O1 = x([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: j1 } = O1, q1 = Rl.VectorTileFeature.types, U1 = Math.cos(Math.PI / 180 * 37.5), Df = Math.pow(2, 14) / 0.5;
      class Id {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((n) => {
            this.gradients[n.id] = {};
          }), this.layoutVertexArray = new sr(), this.layoutVertexArray2 = new xs(), this.indexArray = new en(), this.programConfigurations = new Io(t.layers, t.zoom), this.segments = new Li(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, u) {
          this.hasPattern = Sd("line", this.layers, n);
          const f = this.layers[0].layout.get("line-sort-key"), _ = !f.isConstant(), b = [];
          for (const { feature: E, id: C, index: L, sourceLayerIndex: R } of t) {
            const U = this.layers[0]._featureFilter.needGeometry, H = ko(E, U);
            if (!this.layers[0]._featureFilter.filter(new Ji(this.zoom), H, u)) continue;
            const J = _ ? f.evaluate(H, {}, u) : void 0, ne = { id: C, properties: E.properties, type: E.type, sourceLayerIndex: R, index: L, geometry: U ? H.geometry : fl(E), patterns: {}, sortKey: J };
            b.push(ne);
          }
          _ && b.sort((E, C) => E.sortKey - C.sortKey);
          for (const E of b) {
            const { geometry: C, index: L, sourceLayerIndex: R } = E;
            if (this.hasPattern) {
              const U = Ed("line", this.layers, E, this.zoom, n);
              this.patternFeatures.push(U);
            } else this.addFeature(E, C, L, u, {});
            n.featureIndex.insert(t[L].feature, C, L, R, this.index);
          }
        }
        update(t, n, u) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, u);
        }
        addFeatures(t, n, u) {
          for (const f of this.patternFeatures) this.addFeature(f, f.geometry, f.index, n, u);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, j1)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, R1), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t) {
          if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
        }
        addFeature(t, n, u, f, _) {
          const b = this.layers[0].layout, E = b.get("line-join").evaluate(t, {}), C = b.get("line-cap"), L = b.get("line-miter-limit"), R = b.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t);
          for (const U of n) this.addLine(U, t, E, C, L, R);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, _, f);
        }
        addLine(t, n, u, f, _, b) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let Pe = 0; Pe < t.length - 1; Pe++) this.totalDistance += t[Pe].dist(t[Pe + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const E = q1[n.type] === "Polygon";
          let C = t.length;
          for (; C >= 2 && t[C - 1].equals(t[C - 2]); ) C--;
          let L = 0;
          for (; L < C - 1 && t[L].equals(t[L + 1]); ) L++;
          if (C < (E ? 3 : 2)) return;
          u === "bevel" && (_ = 1.05);
          const R = this.overscaling <= 16 ? 15 * or / (512 * this.overscaling) : 0, U = this.segments.prepareSegment(10 * C, this.layoutVertexArray, this.indexArray);
          let H, J, ne, he, Se;
          this.e1 = this.e2 = -1, E && (H = t[C - 2], Se = t[L].sub(H)._unit()._perp());
          for (let Pe = L; Pe < C; Pe++) {
            if (ne = Pe === C - 1 ? E ? t[L + 1] : void 0 : t[Pe + 1], ne && t[Pe].equals(ne)) continue;
            Se && (he = Se), H && (J = H), H = t[Pe], Se = ne ? ne.sub(H)._unit()._perp() : he, he = he || Se;
            let Xe = he.add(Se);
            Xe.x === 0 && Xe.y === 0 || Xe._unit();
            const Be = he.x * Se.x + he.y * Se.y, Ge = Xe.x * Se.x + Xe.y * Se.y, st = Ge !== 0 ? 1 / Ge : 1 / 0, Tt = 2 * Math.sqrt(2 - 2 * Ge), Bt = Ge < U1 && J && ne, hi = he.x * Se.y - he.y * Se.x > 0;
            if (Bt && Pe > L) {
              const Xt = H.dist(J);
              if (Xt > 2 * R) {
                const Vt = H.sub(H.sub(J)._mult(R / Xt)._round());
                this.updateDistance(J, Vt), this.addCurrentVertex(Vt, he, 0, 0, U), J = Vt;
              }
            }
            const Ft = J && ne;
            let Nt = Ft ? u : E ? "butt" : f;
            if (Ft && Nt === "round" && (st < b ? Nt = "miter" : st <= 2 && (Nt = "fakeround")), Nt === "miter" && st > _ && (Nt = "bevel"), Nt === "bevel" && (st > 2 && (Nt = "flipbevel"), st < _ && (Nt = "miter")), J && this.updateDistance(J, H), Nt === "miter") Xe._mult(st), this.addCurrentVertex(H, Xe, 0, 0, U);
            else if (Nt === "flipbevel") {
              if (st > 100) Xe = Se.mult(-1);
              else {
                const Xt = st * he.add(Se).mag() / he.sub(Se).mag();
                Xe._perp()._mult(Xt * (hi ? -1 : 1));
              }
              this.addCurrentVertex(H, Xe, 0, 0, U), this.addCurrentVertex(H, Xe.mult(-1), 0, 0, U);
            } else if (Nt === "bevel" || Nt === "fakeround") {
              const Xt = -Math.sqrt(st * st - 1), Vt = hi ? Xt : 0, qt = hi ? 0 : Xt;
              if (J && this.addCurrentVertex(H, he, Vt, qt, U), Nt === "fakeround") {
                const dt = Math.round(180 * Tt / Math.PI / 20);
                for (let Yt = 1; Yt < dt; Yt++) {
                  let Ht = Yt / dt;
                  if (Ht !== 0.5) {
                    const ir = Ht - 0.5;
                    Ht += Ht * ir * (Ht - 1) * ((1.0904 + Be * (Be * (3.55645 - 1.43519 * Be) - 3.2452)) * ir * ir + (0.848013 + Be * (0.215638 * Be - 1.06021)));
                  }
                  const _i = Se.sub(he)._mult(Ht)._add(he)._unit()._mult(hi ? -1 : 1);
                  this.addHalfVertex(H, _i.x, _i.y, !1, hi, 0, U);
                }
              }
              ne && this.addCurrentVertex(H, Se, -Vt, -qt, U);
            } else if (Nt === "butt") this.addCurrentVertex(H, Xe, 0, 0, U);
            else if (Nt === "square") {
              const Xt = J ? 1 : -1;
              this.addCurrentVertex(H, Xe, Xt, Xt, U);
            } else Nt === "round" && (J && (this.addCurrentVertex(H, he, 0, 0, U), this.addCurrentVertex(H, he, 1, 1, U, !0)), ne && (this.addCurrentVertex(H, Se, -1, -1, U, !0), this.addCurrentVertex(H, Se, 0, 0, U)));
            if (Bt && Pe < C - 1) {
              const Xt = H.dist(ne);
              if (Xt > 2 * R) {
                const Vt = H.add(ne.sub(H)._mult(R / Xt)._round());
                this.updateDistance(H, Vt), this.addCurrentVertex(Vt, Se, 0, 0, U), H = Vt;
              }
            }
          }
        }
        addCurrentVertex(t, n, u, f, _, b = !1) {
          const E = n.y * f - n.x, C = -n.y - n.x * f;
          this.addHalfVertex(t, n.x + n.y * u, n.y - n.x * u, b, !1, u, _), this.addHalfVertex(t, E, C, b, !0, -f, _), this.distance > Df / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, u, f, _, b));
        }
        addHalfVertex({ x: t, y: n }, u, f, _, b, E, C) {
          const L = 0.5 * (this.lineClips ? this.scaledDistance * (Df - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((t << 1) + (_ ? 1 : 0), (n << 1) + (b ? 1 : 0), Math.round(63 * u) + 128, Math.round(63 * f) + 128, 1 + (E === 0 ? 0 : E < 0 ? -1 : 1) | (63 & L) << 2, L >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const R = C.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, R), C.primitiveLength++), b ? this.e2 = R : this.e1 = R;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(t, n) {
          this.distance += t.dist(n), this.updateScaledDistance();
        }
      }
      let If, kf;
      Ot("LineBucket", Id, { omit: ["layers", "patternFeatures"] });
      var Pf = { get paint() {
        return kf = kf || new c({ "line-opacity": new li(Y.paint_line["line-opacity"]), "line-color": new li(Y.paint_line["line-color"]), "line-translate": new Gt(Y.paint_line["line-translate"]), "line-translate-anchor": new Gt(Y.paint_line["line-translate-anchor"]), "line-width": new li(Y.paint_line["line-width"]), "line-gap-width": new li(Y.paint_line["line-gap-width"]), "line-offset": new li(Y.paint_line["line-offset"]), "line-blur": new li(Y.paint_line["line-blur"]), "line-dasharray": new y(Y.paint_line["line-dasharray"]), "line-pattern": new cl(Y.paint_line["line-pattern"]), "line-gradient": new S(Y.paint_line["line-gradient"]) });
      }, get layout() {
        return If = If || new c({ "line-cap": new Gt(Y.layout_line["line-cap"]), "line-join": new li(Y.layout_line["line-join"]), "line-miter-limit": new Gt(Y.layout_line["line-miter-limit"]), "line-round-limit": new Gt(Y.layout_line["line-round-limit"]), "line-sort-key": new li(Y.layout_line["line-sort-key"]) });
      } };
      class V1 extends li {
        possiblyEvaluate(t, n) {
          return n = new Ji(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(t, n);
        }
        evaluate(t, n, u, f) {
          return n = Ie({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(t, n, u, f);
        }
      }
      let Ih;
      class $1 extends r {
        constructor(t) {
          super(t, Pf), this.gradientVersion = 0, Ih || (Ih = new V1(Pf.paint.properties["line-width"].specification), Ih.useIntegerZoom = !0);
        }
        _handleSpecialPaintPropertyUpdate(t) {
          if (t === "line-gradient") {
            const n = this.gradientExpression();
            this.stepInterpolant = !!function(u) {
              return u._styleExpression !== void 0;
            }(n) && n._styleExpression.expression instanceof us, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(t, n) {
          super.recalculate(t, n), this.paint._values["line-floorwidth"] = Ih.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
        }
        createBucket(t) {
          return new Id(t);
        }
        queryRadius(t) {
          const n = t, u = Lf(Mc("line-width", this, n), Mc("line-gap-width", this, n)), f = Mc("line-offset", this, n);
          return u / 2 + Math.abs(f) + Ah(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t, n, u, f, _, b, E) {
          const C = Sh(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), b.angle, E), L = E / 2 * Lf(this.paint.get("line-width").evaluate(n, u), this.paint.get("line-gap-width").evaluate(n, u)), R = this.paint.get("line-offset").evaluate(n, u);
          return R && (f = function(U, H) {
            const J = [];
            for (let ne = 0; ne < U.length; ne++) {
              const he = U[ne], Se = [];
              for (let Pe = 0; Pe < he.length; Pe++) {
                const Xe = he[Pe - 1], Be = he[Pe], Ge = he[Pe + 1], st = Pe === 0 ? new q(0, 0) : Be.sub(Xe)._unit()._perp(), Tt = Pe === he.length - 1 ? new q(0, 0) : Ge.sub(Be)._unit()._perp(), Bt = st._add(Tt)._unit(), hi = Bt.x * Tt.x + Bt.y * Tt.y;
                hi !== 0 && Bt._mult(1 / hi), Se.push(Bt._mult(H)._add(Be));
              }
              J.push(Se);
            }
            return J;
          }(f, R * E)), function(U, H, J) {
            for (let ne = 0; ne < H.length; ne++) {
              const he = H[ne];
              if (U.length >= 3) {
                for (let Se = 0; Se < he.length; Se++) if (Lo(U, he[Se])) return !0;
              }
              if (Po(U, he, J)) return !0;
            }
            return !1;
          }(C, f, L);
        }
        isTileClipped() {
          return !0;
        }
      }
      function Lf(i, t) {
        return t > 0 ? t + 2 * i : i;
      }
      const Z1 = x([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), G1 = x([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      x([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const H1 = x([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      x([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const Mf = x([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), W1 = x([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function X1(i, t, n) {
        return i.sections.forEach((u) => {
          u.text = function(f, _, b) {
            const E = _.layout.get("text-transform").evaluate(b, {});
            return E === "uppercase" ? f = f.toLocaleUpperCase() : E === "lowercase" && (f = f.toLocaleLowerCase()), Pn.applyArabicShaping && (f = Pn.applyArabicShaping(f)), f;
          }(u.text, t, n);
        }), i;
      }
      x([{ name: "triangle", components: 3, type: "Uint16" }]), x([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), x([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), x([{ type: "Float32", name: "offsetX" }]), x([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), x([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const qc = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
      var Vr = 24, Nf = Ki, zf = function(i, t, n, u, f) {
        var _, b, E = 8 * f - u - 1, C = (1 << E) - 1, L = C >> 1, R = -7, U = f - 1, H = -1, J = i[t + U];
        for (U += H, _ = J & (1 << -R) - 1, J >>= -R, R += E; R > 0; _ = 256 * _ + i[t + U], U += H, R -= 8) ;
        for (b = _ & (1 << -R) - 1, _ >>= -R, R += u; R > 0; b = 256 * b + i[t + U], U += H, R -= 8) ;
        if (_ === 0) _ = 1 - L;
        else {
          if (_ === C) return b ? NaN : 1 / 0 * (J ? -1 : 1);
          b += Math.pow(2, u), _ -= L;
        }
        return (J ? -1 : 1) * b * Math.pow(2, _ - u);
      }, Ff = function(i, t, n, u, f, _) {
        var b, E, C, L = 8 * _ - f - 1, R = (1 << L) - 1, U = R >> 1, H = f === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, J = 0, ne = 1, he = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
        for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (E = isNaN(t) ? 1 : 0, b = R) : (b = Math.floor(Math.log(t) / Math.LN2), t * (C = Math.pow(2, -b)) < 1 && (b--, C *= 2), (t += b + U >= 1 ? H / C : H * Math.pow(2, 1 - U)) * C >= 2 && (b++, C /= 2), b + U >= R ? (E = 0, b = R) : b + U >= 1 ? (E = (t * C - 1) * Math.pow(2, f), b += U) : (E = t * Math.pow(2, U - 1) * Math.pow(2, f), b = 0)); f >= 8; i[n + J] = 255 & E, J += ne, E /= 256, f -= 8) ;
        for (b = b << f | E, L += f; L > 0; i[n + J] = 255 & b, J += ne, b /= 256, L -= 8) ;
        i[n + J - ne] |= 128 * he;
      };
      function Ki(i) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(i) ? i : new Uint8Array(i || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      Ki.Varint = 0, Ki.Fixed64 = 1, Ki.Bytes = 2, Ki.Fixed32 = 5;
      var kd = 4294967296, Bf = 1 / kd, Rf = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
      function gl(i) {
        return i.type === Ki.Bytes ? i.readVarint() + i.pos : i.pos + 1;
      }
      function Yu(i, t, n) {
        return n ? 4294967296 * t + (i >>> 0) : 4294967296 * (t >>> 0) + (i >>> 0);
      }
      function Of(i, t, n) {
        var u = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
        n.realloc(u);
        for (var f = n.pos - 1; f >= i; f--) n.buf[f + u] = n.buf[f];
      }
      function Y1(i, t) {
        for (var n = 0; n < i.length; n++) t.writeVarint(i[n]);
      }
      function J1(i, t) {
        for (var n = 0; n < i.length; n++) t.writeSVarint(i[n]);
      }
      function K1(i, t) {
        for (var n = 0; n < i.length; n++) t.writeFloat(i[n]);
      }
      function Q1(i, t) {
        for (var n = 0; n < i.length; n++) t.writeDouble(i[n]);
      }
      function e2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeBoolean(i[n]);
      }
      function t2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeFixed32(i[n]);
      }
      function i2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeSFixed32(i[n]);
      }
      function r2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeFixed64(i[n]);
      }
      function n2(i, t) {
        for (var n = 0; n < i.length; n++) t.writeSFixed64(i[n]);
      }
      function kh(i, t) {
        return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) + 16777216 * i[t + 3];
      }
      function Ju(i, t, n) {
        i[n] = t, i[n + 1] = t >>> 8, i[n + 2] = t >>> 16, i[n + 3] = t >>> 24;
      }
      function jf(i, t) {
        return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) + (i[t + 3] << 24);
      }
      Ki.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(i, t, n) {
        for (n = n || this.length; this.pos < n; ) {
          var u = this.readVarint(), f = u >> 3, _ = this.pos;
          this.type = 7 & u, i(f, t, this), this.pos === _ && this.skip(u);
        }
        return t;
      }, readMessage: function(i, t) {
        return this.readFields(i, t, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var i = kh(this.buf, this.pos);
        return this.pos += 4, i;
      }, readSFixed32: function() {
        var i = jf(this.buf, this.pos);
        return this.pos += 4, i;
      }, readFixed64: function() {
        var i = kh(this.buf, this.pos) + kh(this.buf, this.pos + 4) * kd;
        return this.pos += 8, i;
      }, readSFixed64: function() {
        var i = kh(this.buf, this.pos) + jf(this.buf, this.pos + 4) * kd;
        return this.pos += 8, i;
      }, readFloat: function() {
        var i = zf(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, i;
      }, readDouble: function() {
        var i = zf(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, i;
      }, readVarint: function(i) {
        var t, n, u = this.buf;
        return t = 127 & (n = u[this.pos++]), n < 128 ? t : (t |= (127 & (n = u[this.pos++])) << 7, n < 128 ? t : (t |= (127 & (n = u[this.pos++])) << 14, n < 128 ? t : (t |= (127 & (n = u[this.pos++])) << 21, n < 128 ? t : function(f, _, b) {
          var E, C, L = b.buf;
          if (E = (112 & (C = L[b.pos++])) >> 4, C < 128 || (E |= (127 & (C = L[b.pos++])) << 3, C < 128) || (E |= (127 & (C = L[b.pos++])) << 10, C < 128) || (E |= (127 & (C = L[b.pos++])) << 17, C < 128) || (E |= (127 & (C = L[b.pos++])) << 24, C < 128) || (E |= (1 & (C = L[b.pos++])) << 31, C < 128)) return Yu(f, E, _);
          throw new Error("Expected varint not more than 10 bytes");
        }(t |= (15 & (n = u[this.pos])) << 28, i, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var i = this.readVarint();
        return i % 2 == 1 ? (i + 1) / -2 : i / 2;
      }, readBoolean: function() {
        return !!this.readVarint();
      }, readString: function() {
        var i = this.readVarint() + this.pos, t = this.pos;
        return this.pos = i, i - t >= 12 && Rf ? function(n, u, f) {
          return Rf.decode(n.subarray(u, f));
        }(this.buf, t, i) : function(n, u, f) {
          for (var _ = "", b = u; b < f; ) {
            var E, C, L, R = n[b], U = null, H = R > 239 ? 4 : R > 223 ? 3 : R > 191 ? 2 : 1;
            if (b + H > f) break;
            H === 1 ? R < 128 && (U = R) : H === 2 ? (192 & (E = n[b + 1])) == 128 && (U = (31 & R) << 6 | 63 & E) <= 127 && (U = null) : H === 3 ? (C = n[b + 2], (192 & (E = n[b + 1])) == 128 && (192 & C) == 128 && ((U = (15 & R) << 12 | (63 & E) << 6 | 63 & C) <= 2047 || U >= 55296 && U <= 57343) && (U = null)) : H === 4 && (C = n[b + 2], L = n[b + 3], (192 & (E = n[b + 1])) == 128 && (192 & C) == 128 && (192 & L) == 128 && ((U = (15 & R) << 18 | (63 & E) << 12 | (63 & C) << 6 | 63 & L) <= 65535 || U >= 1114112) && (U = null)), U === null ? (U = 65533, H = 1) : U > 65535 && (U -= 65536, _ += String.fromCharCode(U >>> 10 & 1023 | 55296), U = 56320 | 1023 & U), _ += String.fromCharCode(U), b += H;
          }
          return _;
        }(this.buf, t, i);
      }, readBytes: function() {
        var i = this.readVarint() + this.pos, t = this.buf.subarray(this.pos, i);
        return this.pos = i, t;
      }, readPackedVarint: function(i, t) {
        if (this.type !== Ki.Bytes) return i.push(this.readVarint(t));
        var n = gl(this);
        for (i = i || []; this.pos < n; ) i.push(this.readVarint(t));
        return i;
      }, readPackedSVarint: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readSVarint());
        var t = gl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readSVarint());
        return i;
      }, readPackedBoolean: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readBoolean());
        var t = gl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readBoolean());
        return i;
      }, readPackedFloat: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readFloat());
        var t = gl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readFloat());
        return i;
      }, readPackedDouble: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readDouble());
        var t = gl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readDouble());
        return i;
      }, readPackedFixed32: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readFixed32());
        var t = gl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readFixed32());
        return i;
      }, readPackedSFixed32: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readSFixed32());
        var t = gl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readSFixed32());
        return i;
      }, readPackedFixed64: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readFixed64());
        var t = gl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readFixed64());
        return i;
      }, readPackedSFixed64: function(i) {
        if (this.type !== Ki.Bytes) return i.push(this.readSFixed64());
        var t = gl(this);
        for (i = i || []; this.pos < t; ) i.push(this.readSFixed64());
        return i;
      }, skip: function(i) {
        var t = 7 & i;
        if (t === Ki.Varint) for (; this.buf[this.pos++] > 127; ) ;
        else if (t === Ki.Bytes) this.pos = this.readVarint() + this.pos;
        else if (t === Ki.Fixed32) this.pos += 4;
        else {
          if (t !== Ki.Fixed64) throw new Error("Unimplemented type: " + t);
          this.pos += 8;
        }
      }, writeTag: function(i, t) {
        this.writeVarint(i << 3 | t);
      }, realloc: function(i) {
        for (var t = this.length || 16; t < this.pos + i; ) t *= 2;
        if (t !== this.length) {
          var n = new Uint8Array(t);
          n.set(this.buf), this.buf = n, this.length = t;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(i) {
        this.realloc(4), Ju(this.buf, i, this.pos), this.pos += 4;
      }, writeSFixed32: function(i) {
        this.realloc(4), Ju(this.buf, i, this.pos), this.pos += 4;
      }, writeFixed64: function(i) {
        this.realloc(8), Ju(this.buf, -1 & i, this.pos), Ju(this.buf, Math.floor(i * Bf), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(i) {
        this.realloc(8), Ju(this.buf, -1 & i, this.pos), Ju(this.buf, Math.floor(i * Bf), this.pos + 4), this.pos += 8;
      }, writeVarint: function(i) {
        (i = +i || 0) > 268435455 || i < 0 ? function(t, n) {
          var u, f;
          if (t >= 0 ? (u = t % 4294967296 | 0, f = t / 4294967296 | 0) : (f = ~(-t / 4294967296), 4294967295 ^ (u = ~(-t % 4294967296)) ? u = u + 1 | 0 : (u = 0, f = f + 1 | 0)), t >= 18446744073709552e3 || t < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
          n.realloc(10), function(_, b, E) {
            E.buf[E.pos++] = 127 & _ | 128, _ >>>= 7, E.buf[E.pos++] = 127 & _ | 128, _ >>>= 7, E.buf[E.pos++] = 127 & _ | 128, _ >>>= 7, E.buf[E.pos++] = 127 & _ | 128, E.buf[E.pos] = 127 & (_ >>>= 7);
          }(u, 0, n), function(_, b) {
            var E = (7 & _) << 4;
            b.buf[b.pos++] |= E | ((_ >>>= 3) ? 128 : 0), _ && (b.buf[b.pos++] = 127 & _ | ((_ >>>= 7) ? 128 : 0), _ && (b.buf[b.pos++] = 127 & _ | ((_ >>>= 7) ? 128 : 0), _ && (b.buf[b.pos++] = 127 & _ | ((_ >>>= 7) ? 128 : 0), _ && (b.buf[b.pos++] = 127 & _ | ((_ >>>= 7) ? 128 : 0), _ && (b.buf[b.pos++] = 127 & _)))));
          }(f, n);
        }(i, this) : (this.realloc(4), this.buf[this.pos++] = 127 & i | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = i >>> 7 & 127))));
      }, writeSVarint: function(i) {
        this.writeVarint(i < 0 ? 2 * -i - 1 : 2 * i);
      }, writeBoolean: function(i) {
        this.writeVarint(!!i);
      }, writeString: function(i) {
        i = String(i), this.realloc(4 * i.length), this.pos++;
        var t = this.pos;
        this.pos = function(u, f, _) {
          for (var b, E, C = 0; C < f.length; C++) {
            if ((b = f.charCodeAt(C)) > 55295 && b < 57344) {
              if (!E) {
                b > 56319 || C + 1 === f.length ? (u[_++] = 239, u[_++] = 191, u[_++] = 189) : E = b;
                continue;
              }
              if (b < 56320) {
                u[_++] = 239, u[_++] = 191, u[_++] = 189, E = b;
                continue;
              }
              b = E - 55296 << 10 | b - 56320 | 65536, E = null;
            } else E && (u[_++] = 239, u[_++] = 191, u[_++] = 189, E = null);
            b < 128 ? u[_++] = b : (b < 2048 ? u[_++] = b >> 6 | 192 : (b < 65536 ? u[_++] = b >> 12 | 224 : (u[_++] = b >> 18 | 240, u[_++] = b >> 12 & 63 | 128), u[_++] = b >> 6 & 63 | 128), u[_++] = 63 & b | 128);
          }
          return _;
        }(this.buf, i, this.pos);
        var n = this.pos - t;
        n >= 128 && Of(t, n, this), this.pos = t - 1, this.writeVarint(n), this.pos += n;
      }, writeFloat: function(i) {
        this.realloc(4), Ff(this.buf, i, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(i) {
        this.realloc(8), Ff(this.buf, i, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(i) {
        var t = i.length;
        this.writeVarint(t), this.realloc(t);
        for (var n = 0; n < t; n++) this.buf[this.pos++] = i[n];
      }, writeRawMessage: function(i, t) {
        this.pos++;
        var n = this.pos;
        i(t, this);
        var u = this.pos - n;
        u >= 128 && Of(n, u, this), this.pos = n - 1, this.writeVarint(u), this.pos += u;
      }, writeMessage: function(i, t, n) {
        this.writeTag(i, Ki.Bytes), this.writeRawMessage(t, n);
      }, writePackedVarint: function(i, t) {
        t.length && this.writeMessage(i, Y1, t);
      }, writePackedSVarint: function(i, t) {
        t.length && this.writeMessage(i, J1, t);
      }, writePackedBoolean: function(i, t) {
        t.length && this.writeMessage(i, e2, t);
      }, writePackedFloat: function(i, t) {
        t.length && this.writeMessage(i, K1, t);
      }, writePackedDouble: function(i, t) {
        t.length && this.writeMessage(i, Q1, t);
      }, writePackedFixed32: function(i, t) {
        t.length && this.writeMessage(i, t2, t);
      }, writePackedSFixed32: function(i, t) {
        t.length && this.writeMessage(i, i2, t);
      }, writePackedFixed64: function(i, t) {
        t.length && this.writeMessage(i, r2, t);
      }, writePackedSFixed64: function(i, t) {
        t.length && this.writeMessage(i, n2, t);
      }, writeBytesField: function(i, t) {
        this.writeTag(i, Ki.Bytes), this.writeBytes(t);
      }, writeFixed32Field: function(i, t) {
        this.writeTag(i, Ki.Fixed32), this.writeFixed32(t);
      }, writeSFixed32Field: function(i, t) {
        this.writeTag(i, Ki.Fixed32), this.writeSFixed32(t);
      }, writeFixed64Field: function(i, t) {
        this.writeTag(i, Ki.Fixed64), this.writeFixed64(t);
      }, writeSFixed64Field: function(i, t) {
        this.writeTag(i, Ki.Fixed64), this.writeSFixed64(t);
      }, writeVarintField: function(i, t) {
        this.writeTag(i, Ki.Varint), this.writeVarint(t);
      }, writeSVarintField: function(i, t) {
        this.writeTag(i, Ki.Varint), this.writeSVarint(t);
      }, writeStringField: function(i, t) {
        this.writeTag(i, Ki.Bytes), this.writeString(t);
      }, writeFloatField: function(i, t) {
        this.writeTag(i, Ki.Fixed32), this.writeFloat(t);
      }, writeDoubleField: function(i, t) {
        this.writeTag(i, Ki.Fixed64), this.writeDouble(t);
      }, writeBooleanField: function(i, t) {
        this.writeVarintField(i, !!t);
      } };
      var Pd = D(Nf);
      const Ld = 3;
      function a2(i, t, n) {
        i === 1 && n.readMessage(s2, t);
      }
      function s2(i, t, n) {
        if (i === 3) {
          const { id: u, bitmap: f, width: _, height: b, left: E, top: C, advance: L } = n.readMessage(o2, {});
          t.push({ id: u, bitmap: new zc({ width: _ + 2 * Ld, height: b + 2 * Ld }, f), metrics: { width: _, height: b, left: E, top: C, advance: L } });
        }
      }
      function o2(i, t, n) {
        i === 1 ? t.id = n.readVarint() : i === 2 ? t.bitmap = n.readBytes() : i === 3 ? t.width = n.readVarint() : i === 4 ? t.height = n.readVarint() : i === 5 ? t.left = n.readSVarint() : i === 6 ? t.top = n.readSVarint() : i === 7 && (t.advance = n.readVarint());
      }
      const qf = Ld;
      function Uf(i) {
        let t = 0, n = 0;
        for (const b of i) t += b.w * b.h, n = Math.max(n, b.w);
        i.sort((b, E) => E.h - b.h);
        const u = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), n), h: 1 / 0 }];
        let f = 0, _ = 0;
        for (const b of i) for (let E = u.length - 1; E >= 0; E--) {
          const C = u[E];
          if (!(b.w > C.w || b.h > C.h)) {
            if (b.x = C.x, b.y = C.y, _ = Math.max(_, b.y + b.h), f = Math.max(f, b.x + b.w), b.w === C.w && b.h === C.h) {
              const L = u.pop();
              E < u.length && (u[E] = L);
            } else b.h === C.h ? (C.x += b.w, C.w -= b.w) : b.w === C.w ? (C.y += b.h, C.h -= b.h) : (u.push({ x: C.x + b.w, y: C.y, w: C.w - b.w, h: b.h }), C.y += b.h, C.h -= b.h);
            break;
          }
        }
        return { w: f, h: _, fill: t / (f * _) || 0 };
      }
      const _a = 1;
      class Md {
        constructor(t, { pixelRatio: n, version: u, stretchX: f, stretchY: _, content: b, textFitWidth: E, textFitHeight: C }) {
          this.paddedRect = t, this.pixelRatio = n, this.stretchX = f, this.stretchY = _, this.content = b, this.version = u, this.textFitWidth = E, this.textFitHeight = C;
        }
        get tl() {
          return [this.paddedRect.x + _a, this.paddedRect.y + _a];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - _a, this.paddedRect.y + this.paddedRect.h - _a];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * _a) / this.pixelRatio, (this.paddedRect.h - 2 * _a) / this.pixelRatio];
        }
      }
      class Vf {
        constructor(t, n) {
          const u = {}, f = {};
          this.haveRenderCallbacks = [];
          const _ = [];
          this.addImages(t, u, _), this.addImages(n, f, _);
          const { w: b, h: E } = Uf(_), C = new Qa({ width: b || 1, height: E || 1 });
          for (const L in t) {
            const R = t[L], U = u[L].paddedRect;
            Qa.copy(R.data, C, { x: 0, y: 0 }, { x: U.x + _a, y: U.y + _a }, R.data);
          }
          for (const L in n) {
            const R = n[L], U = f[L].paddedRect, H = U.x + _a, J = U.y + _a, ne = R.data.width, he = R.data.height;
            Qa.copy(R.data, C, { x: 0, y: 0 }, { x: H, y: J }, R.data), Qa.copy(R.data, C, { x: 0, y: he - 1 }, { x: H, y: J - 1 }, { width: ne, height: 1 }), Qa.copy(R.data, C, { x: 0, y: 0 }, { x: H, y: J + he }, { width: ne, height: 1 }), Qa.copy(R.data, C, { x: ne - 1, y: 0 }, { x: H - 1, y: J }, { width: 1, height: he }), Qa.copy(R.data, C, { x: 0, y: 0 }, { x: H + ne, y: J }, { width: 1, height: he });
          }
          this.image = C, this.iconPositions = u, this.patternPositions = f;
        }
        addImages(t, n, u) {
          for (const f in t) {
            const _ = t[f], b = { x: 0, y: 0, w: _.data.width + 2 * _a, h: _.data.height + 2 * _a };
            u.push(b), n[f] = new Md(b, _), _.hasRenderCallback && this.haveRenderCallbacks.push(f);
          }
        }
        patchUpdatedImages(t, n) {
          t.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const u in t.updatedImages) this.patchUpdatedImage(this.iconPositions[u], t.getImage(u), n), this.patchUpdatedImage(this.patternPositions[u], t.getImage(u), n);
        }
        patchUpdatedImage(t, n, u) {
          if (!t || !n || t.version === n.version) return;
          t.version = n.version;
          const [f, _] = t.tl;
          u.update(n.data, void 0, { x: f, y: _ });
        }
      }
      var Ol;
      Ot("ImagePosition", Md), Ot("ImageAtlas", Vf), g.ah = void 0, (Ol = g.ah || (g.ah = {}))[Ol.none = 0] = "none", Ol[Ol.horizontal = 1] = "horizontal", Ol[Ol.vertical = 2] = "vertical", Ol[Ol.horizontalOnly = 3] = "horizontalOnly";
      const Uc = -17;
      class Vc {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(t, n) {
          const u = new Vc();
          return u.scale = t || 1, u.fontStack = n, u;
        }
        static forImage(t) {
          const n = new Vc();
          return n.imageName = t, n;
        }
      }
      class Ku {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t, n) {
          const u = new Ku();
          for (let f = 0; f < t.sections.length; f++) {
            const _ = t.sections[f];
            _.image ? u.addImageSection(_) : u.addTextSection(_, n);
          }
          return u;
        }
        length() {
          return this.text.length;
        }
        getSection(t) {
          return this.sections[this.sectionIndex[t]];
        }
        getSectionIndex(t) {
          return this.sectionIndex[t];
        }
        getCharCode(t) {
          return this.text.charCodeAt(t);
        }
        verticalizePunctuation() {
          this.text = function(t) {
            let n = "";
            for (let u = 0; u < t.length; u++) {
              const f = t.charCodeAt(u + 1) || null, _ = t.charCodeAt(u - 1) || null;
              n += f && ol(f) && !qc[t[u + 1]] || _ && ol(_) && !qc[t[u - 1]] || !qc[t[u]] ? t[u] : qc[t[u]];
            }
            return n;
          }(this.text);
        }
        trim() {
          let t = 0;
          for (let u = 0; u < this.text.length && Lh[this.text.charCodeAt(u)]; u++) t++;
          let n = this.text.length;
          for (let u = this.text.length - 1; u >= 0 && u >= t && Lh[this.text.charCodeAt(u)]; u--) n--;
          this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n);
        }
        substring(t, n) {
          const u = new Ku();
          return u.text = this.text.substring(t, n), u.sectionIndex = this.sectionIndex.slice(t, n), u.sections = this.sections, u;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t, n) => Math.max(t, this.sections[n].scale), 0);
        }
        addTextSection(t, n) {
          this.text += t.text, this.sections.push(Vc.forText(t.scale, t.fontStack || n));
          const u = this.sections.length - 1;
          for (let f = 0; f < t.text.length; ++f) this.sectionIndex.push(u);
        }
        addImageSection(t) {
          const n = t.image ? t.image.name : "";
          if (n.length === 0) return void xe("Can't add FormattedSection with an empty image.");
          const u = this.getNextImageSectionCharCode();
          u ? (this.text += String.fromCharCode(u), this.sections.push(Vc.forImage(n)), this.sectionIndex.push(this.sections.length - 1)) : xe("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Ph(i, t, n, u, f, _, b, E, C, L, R, U, H, J, ne) {
        const he = Ku.fromFeature(i, f);
        let Se;
        U === g.ah.vertical && he.verticalizePunctuation();
        const { processBidirectionalText: Pe, processStyledBidirectionalText: Xe } = Pn;
        if (Pe && he.sections.length === 1) {
          Se = [];
          const st = Pe(he.toString(), Nd(he, L, _, t, u, J));
          for (const Tt of st) {
            const Bt = new Ku();
            Bt.text = Tt, Bt.sections = he.sections;
            for (let hi = 0; hi < Tt.length; hi++) Bt.sectionIndex.push(0);
            Se.push(Bt);
          }
        } else if (Xe) {
          Se = [];
          const st = Xe(he.text, he.sectionIndex, Nd(he, L, _, t, u, J));
          for (const Tt of st) {
            const Bt = new Ku();
            Bt.text = Tt[0], Bt.sectionIndex = Tt[1], Bt.sections = he.sections, Se.push(Bt);
          }
        } else Se = function(st, Tt) {
          const Bt = [], hi = st.text;
          let Ft = 0;
          for (const Nt of Tt) Bt.push(st.substring(Ft, Nt)), Ft = Nt;
          return Ft < hi.length && Bt.push(st.substring(Ft, hi.length)), Bt;
        }(he, Nd(he, L, _, t, u, J));
        const Be = [], Ge = { positionedLines: Be, text: he.toString(), top: R[1], bottom: R[1], left: R[0], right: R[0], writingMode: U, iconsInText: !1, verticalizable: !1 };
        return function(st, Tt, Bt, hi, Ft, Nt, Xt, Vt, qt, dt, Yt, Ht) {
          let _i = 0, ir = Uc, Qi = 0, rn = 0;
          const Ts = Vt === "right" ? 1 : Vt === "left" ? 0 : 0.5;
          let xn = 0;
          for (const Lr of Ft) {
            Lr.trim();
            const an = Lr.getMaxScale(), zn = (an - 1) * Vr, wn = { positionedGlyphs: [], lineOffset: 0 };
            st.positionedLines[xn] = wn;
            const Qn = wn.positionedGlyphs;
            let An = 0;
            if (!Lr.length()) {
              ir += Nt, ++xn;
              continue;
            }
            for (let ya = 0; ya < Lr.length(); ya++) {
              const Vi = Lr.getSection(ya), lr = Lr.getSectionIndex(ya), fr = Lr.getCharCode(ya);
              let za = 0, Dr = null, ic = null, No = null, zo = Vr;
              const Cs = !(qt === g.ah.horizontal || !Yt && !pu(fr) || Yt && (Lh[fr] || (nn = fr, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(nn)))));
              if (Vi.imageName) {
                const is = hi[Vi.imageName];
                if (!is) continue;
                No = Vi.imageName, st.iconsInText = st.iconsInText || !0, ic = is.paddedRect;
                const fn = is.displaySize;
                Vi.scale = Vi.scale * Vr / Ht, Dr = { width: fn[0], height: fn[1], left: _a, top: -qf, advance: Cs ? fn[1] : fn[0] }, za = zn + (Vr - fn[1] * Vi.scale), zo = Dr.advance;
                const _l = Cs ? fn[0] * Vi.scale - Vr * an : fn[1] * Vi.scale - Vr * an;
                _l > 0 && _l > An && (An = _l);
              } else {
                const is = Bt[Vi.fontStack], fn = is && is[fr];
                if (fn && fn.rect) ic = fn.rect, Dr = fn.metrics;
                else {
                  const _l = Tt[Vi.fontStack], Xc = _l && _l[fr];
                  if (!Xc) continue;
                  Dr = Xc.metrics;
                }
                za = (an - Vi.scale) * Vr;
              }
              Cs ? (st.verticalizable = !0, Qn.push({ glyph: fr, imageName: No, x: _i, y: ir + za, vertical: Cs, scale: Vi.scale, fontStack: Vi.fontStack, sectionIndex: lr, metrics: Dr, rect: ic }), _i += zo * Vi.scale + dt) : (Qn.push({ glyph: fr, imageName: No, x: _i, y: ir + za, vertical: Cs, scale: Vi.scale, fontStack: Vi.fontStack, sectionIndex: lr, metrics: Dr, rect: ic }), _i += Dr.advance * Vi.scale + dt);
            }
            Qn.length !== 0 && (Qi = Math.max(_i - dt, Qi), h2(Qn, 0, Qn.length - 1, Ts, An)), _i = 0;
            const ts = Nt * an + An;
            wn.lineOffset = Math.max(An, zn), ir += ts, rn = Math.max(ts, rn), ++xn;
          }
          var nn;
          const Yn = ir - Uc, { horizontalAlign: Jn, verticalAlign: Kn } = zd(Xt);
          (function(Lr, an, zn, wn, Qn, An, ts, ya, Vi) {
            const lr = (an - zn) * Qn;
            let fr = 0;
            fr = An !== ts ? -ya * wn - Uc : (-wn * Vi + 0.5) * ts;
            for (const za of Lr) for (const Dr of za.positionedGlyphs) Dr.x += lr, Dr.y += fr;
          })(st.positionedLines, Ts, Jn, Kn, Qi, rn, Nt, Yn, Ft.length), st.top += -Kn * Yn, st.bottom = st.top + Yn, st.left += -Jn * Qi, st.right = st.left + Qi;
        }(Ge, t, n, u, Se, b, E, C, U, L, H, ne), !function(st) {
          for (const Tt of st) if (Tt.positionedGlyphs.length !== 0) return !1;
          return !0;
        }(Be) && Ge;
      }
      const Lh = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, l2 = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, u2 = { 40: !0 };
      function $f(i, t, n, u, f, _) {
        if (t.imageName) {
          const b = u[t.imageName];
          return b ? b.displaySize[0] * t.scale * Vr / _ + f : 0;
        }
        {
          const b = n[t.fontStack], E = b && b[i];
          return E ? E.metrics.advance * t.scale + f : 0;
        }
      }
      function Zf(i, t, n, u) {
        const f = Math.pow(i - t, 2);
        return u ? i < t ? f / 2 : 2 * f : f + Math.abs(n) * n;
      }
      function c2(i, t, n) {
        let u = 0;
        return i === 10 && (u -= 1e4), n && (u += 150), i !== 40 && i !== 65288 || (u += 50), t !== 41 && t !== 65289 || (u += 50), u;
      }
      function Gf(i, t, n, u, f, _) {
        let b = null, E = Zf(t, n, f, _);
        for (const C of u) {
          const L = Zf(t - C.x, n, f, _) + C.badness;
          L <= E && (b = C, E = L);
        }
        return { index: i, x: t, priorBreak: b, badness: E };
      }
      function Hf(i) {
        return i ? Hf(i.priorBreak).concat(i.index) : [];
      }
      function Nd(i, t, n, u, f, _) {
        if (!i) return [];
        const b = [], E = function(U, H, J, ne, he, Se) {
          let Pe = 0;
          for (let Xe = 0; Xe < U.length(); Xe++) {
            const Be = U.getSection(Xe);
            Pe += $f(U.getCharCode(Xe), Be, ne, he, H, Se);
          }
          return Pe / Math.max(1, Math.ceil(Pe / J));
        }(i, t, n, u, f, _), C = i.text.indexOf("") >= 0;
        let L = 0;
        for (let U = 0; U < i.length(); U++) {
          const H = i.getSection(U), J = i.getCharCode(U);
          if (Lh[J] || (L += $f(J, H, u, f, t, _)), U < i.length() - 1) {
            const ne = !((R = J) < 11904) && (!!vi["CJK Compatibility Forms"](R) || !!vi["CJK Compatibility"](R) || !!vi["CJK Strokes"](R) || !!vi["CJK Symbols and Punctuation"](R) || !!vi["Enclosed CJK Letters and Months"](R) || !!vi["Halfwidth and Fullwidth Forms"](R) || !!vi["Ideographic Description Characters"](R) || !!vi["Vertical Forms"](R) || du.test(String.fromCodePoint(R)));
            (l2[J] || ne || H.imageName || U !== i.length() - 2 && u2[i.getCharCode(U + 1)]) && b.push(Gf(U + 1, L, E, b, c2(J, i.getCharCode(U + 1), ne && C), !1));
          }
        }
        var R;
        return Hf(Gf(i.length(), L, E, b, 0, !0));
      }
      function zd(i) {
        let t = 0.5, n = 0.5;
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            t = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            t = 0;
        }
        switch (i) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            n = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            n = 0;
        }
        return { horizontalAlign: t, verticalAlign: n };
      }
      function h2(i, t, n, u, f) {
        if (!u && !f) return;
        const _ = i[n], b = (i[n].x + _.metrics.advance * _.scale) * u;
        for (let E = t; E <= n; E++) i[E].x -= b, i[E].y += f;
      }
      function d2(i, t, n) {
        const { horizontalAlign: u, verticalAlign: f } = zd(n), _ = t[0] - i.displaySize[0] * u, b = t[1] - i.displaySize[1] * f;
        return { image: i, top: b, bottom: b + i.displaySize[1], left: _, right: _ + i.displaySize[0] };
      }
      function Wf(i) {
        var t, n;
        let u = i.left, f = i.top, _ = i.right - u, b = i.bottom - f;
        const E = (t = i.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", C = (n = i.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", L = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
        if (C === "proportional") {
          if (E === "stretchOnly" && _ / b < L || E === "proportional") {
            const R = Math.ceil(b * L);
            u *= R / _, _ = R;
          }
        } else if (E === "proportional" && C === "stretchOnly" && L !== 0 && _ / b > L) {
          const R = Math.ceil(_ / L);
          f *= R / b, b = R;
        }
        return { x1: u, y1: f, x2: u + _, y2: f + b };
      }
      function Xf(i, t, n, u, f, _) {
        const b = i.image;
        let E;
        if (b.content) {
          const Se = b.content, Pe = b.pixelRatio || 1;
          E = [Se[0] / Pe, Se[1] / Pe, b.displaySize[0] - Se[2] / Pe, b.displaySize[1] - Se[3] / Pe];
        }
        const C = t.left * _, L = t.right * _;
        let R, U, H, J;
        n === "width" || n === "both" ? (J = f[0] + C - u[3], U = f[0] + L + u[1]) : (J = f[0] + (C + L - b.displaySize[0]) / 2, U = J + b.displaySize[0]);
        const ne = t.top * _, he = t.bottom * _;
        return n === "height" || n === "both" ? (R = f[1] + ne - u[0], H = f[1] + he + u[2]) : (R = f[1] + (ne + he - b.displaySize[1]) / 2, H = R + b.displaySize[1]), { image: b, top: R, right: U, bottom: H, left: J, collisionPadding: E };
      }
      const $c = 255, Mo = 128, jl = $c * Mo;
      function Yf(i, t) {
        const { expression: n } = t;
        if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new Ji(i + 1)) };
        if (n.kind === "source") return { kind: "source" };
        {
          const { zoomStops: u, interpolationType: f } = n;
          let _ = 0;
          for (; _ < u.length && u[_] <= i; ) _++;
          _ = Math.max(0, _ - 1);
          let b = _;
          for (; b < u.length && u[b] < i + 1; ) b++;
          b = Math.min(u.length - 1, b);
          const E = u[_], C = u[b];
          return n.kind === "composite" ? { kind: "composite", minZoom: E, maxZoom: C, interpolationType: f } : { kind: "camera", minZoom: E, maxZoom: C, minSize: n.evaluate(new Ji(E)), maxSize: n.evaluate(new Ji(C)), interpolationType: f };
        }
      }
      function Fd(i, t, n) {
        let u = "never";
        const f = i.get(t);
        return f ? u = f : i.get(n) && (u = "always"), u;
      }
      const p2 = Rl.VectorTileFeature.types, f2 = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Mh(i, t, n, u, f, _, b, E, C, L, R, U, H) {
        const J = E ? Math.min(jl, Math.round(E[0])) : 0, ne = E ? Math.min(jl, Math.round(E[1])) : 0;
        i.emplaceBack(t, n, Math.round(32 * u), Math.round(32 * f), _, b, (J << 1) + (C ? 1 : 0), ne, 16 * L, 16 * R, 256 * U, 256 * H);
      }
      function Bd(i, t, n) {
        i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n);
      }
      function m2(i) {
        for (const t of i.sections) if (Ru(t.text)) return !0;
        return !1;
      }
      class Rd {
        constructor(t) {
          this.layoutVertexArray = new hl(), this.indexArray = new en(), this.programConfigurations = t, this.segments = new Li(), this.dynamicLayoutVertexArray = new To(), this.opacityVertexArray = new Qr(), this.hasVisibleVertices = !1, this.placedSymbolArray = new di();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(t, n, u, f) {
          this.isEmpty() || (u && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Z1.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, G1.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, f2, !0), this.opacityVertexBuffer.itemSize = 1), (u || f) && this.programConfigurations.upload(t));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      Ot("SymbolBuffers", Rd);
      class Od {
        constructor(t, n, u) {
          this.layoutVertexArray = new t(), this.layoutAttributes = n, this.indexArray = new u(), this.segments = new Li(), this.collisionVertexArray = new Br();
        }
        upload(t) {
          this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, H1.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      Ot("CollisionBuffers", Od);
      class Qu {
        constructor(t) {
          this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((b) => b.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = yd([]), this.placementViewportMatrix = yd([]);
          const n = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = Yf(this.zoom, n["text-size"]), this.iconSizeData = Yf(this.zoom, n["icon-size"]);
          const u = this.layers[0].layout, f = u.get("symbol-sort-key"), _ = u.get("symbol-z-order");
          this.canOverlap = Fd(u, "text-overlap", "text-allow-overlap") !== "never" || Fd(u, "icon-overlap", "icon-allow-overlap") !== "never" || u.get("text-ignore-placement") || u.get("icon-ignore-placement"), this.sortFeaturesByKey = _ !== "viewport-y" && !f.isConstant(), this.sortFeaturesByY = (_ === "viewport-y" || _ === "auto" && !this.sortFeaturesByKey) && this.canOverlap, u.get("symbol-placement") === "point" && (this.writingModes = u.get("text-writing-mode").map((b) => g.ah[b])), this.stateDependentLayerIds = this.layers.filter((b) => b.isStateDependent()).map((b) => b.id), this.sourceID = t.sourceID;
        }
        createArrays() {
          this.text = new Rd(new Io(this.layers, this.zoom, (t) => /^text/.test(t))), this.icon = new Rd(new Io(this.layers, this.zoom, (t) => /^icon/.test(t))), this.glyphOffsetArray = new Ei(), this.lineVertexArray = new qi(), this.symbolInstances = new gi(), this.textAnchorOffsets = new Fi();
        }
        calculateGlyphDependencies(t, n, u, f, _) {
          for (let b = 0; b < t.length; b++) if (n[t.charCodeAt(b)] = !0, (u || f) && _) {
            const E = qc[t.charAt(b)];
            E && (n[E.charCodeAt(0)] = !0);
          }
        }
        populate(t, n, u) {
          const f = this.layers[0], _ = f.layout, b = _.get("text-font"), E = _.get("text-field"), C = _.get("icon-image"), L = (E.value.kind !== "constant" || E.value.value instanceof Hr && !E.value.value.isEmpty() || E.value.value.toString().length > 0) && (b.value.kind !== "constant" || b.value.value.length > 0), R = C.value.kind !== "constant" || !!C.value.value || Object.keys(C.parameters).length > 0, U = _.get("symbol-sort-key");
          if (this.features = [], !L && !R) return;
          const H = n.iconDependencies, J = n.glyphDependencies, ne = n.availableImages, he = new Ji(this.zoom);
          for (const { feature: Se, id: Pe, index: Xe, sourceLayerIndex: Be } of t) {
            const Ge = f._featureFilter.needGeometry, st = ko(Se, Ge);
            if (!f._featureFilter.filter(he, st, u)) continue;
            let Tt, Bt;
            if (Ge || (st.geometry = fl(Se)), L) {
              const Ft = f.getValueAndResolveTokens("text-field", st, u, ne), Nt = Hr.factory(Ft), Xt = this.hasRTLText = this.hasRTLText || m2(Nt);
              (!Xt || Pn.getRTLTextPluginStatus() === "unavailable" || Xt && Pn.isParsed()) && (Tt = X1(Nt, f, st));
            }
            if (R) {
              const Ft = f.getValueAndResolveTokens("icon-image", st, u, ne);
              Bt = Ft instanceof Wr ? Ft : Wr.fromString(Ft);
            }
            if (!Tt && !Bt) continue;
            const hi = this.sortFeaturesByKey ? U.evaluate(st, {}, u) : void 0;
            if (this.features.push({ id: Pe, text: Tt, icon: Bt, index: Xe, sourceLayerIndex: Be, geometry: st.geometry, properties: Se.properties, type: p2[Se.type], sortKey: hi }), Bt && (H[Bt.name] = !0), Tt) {
              const Ft = b.evaluate(st, {}, u).join(","), Nt = _.get("text-rotation-alignment") !== "viewport" && _.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(g.ah.vertical) >= 0;
              for (const Xt of Tt.sections) if (Xt.image) H[Xt.image.name] = !0;
              else {
                const Vt = hu(Tt.toString()), qt = Xt.fontStack || Ft, dt = J[qt] = J[qt] || {};
                this.calculateGlyphDependencies(Xt.text, dt, Nt, this.allowVerticalPlacement, Vt);
              }
            }
          }
          _.get("symbol-placement") === "line" && (this.features = function(Se) {
            const Pe = {}, Xe = {}, Be = [];
            let Ge = 0;
            function st(Ft) {
              Be.push(Se[Ft]), Ge++;
            }
            function Tt(Ft, Nt, Xt) {
              const Vt = Xe[Ft];
              return delete Xe[Ft], Xe[Nt] = Vt, Be[Vt].geometry[0].pop(), Be[Vt].geometry[0] = Be[Vt].geometry[0].concat(Xt[0]), Vt;
            }
            function Bt(Ft, Nt, Xt) {
              const Vt = Pe[Nt];
              return delete Pe[Nt], Pe[Ft] = Vt, Be[Vt].geometry[0].shift(), Be[Vt].geometry[0] = Xt[0].concat(Be[Vt].geometry[0]), Vt;
            }
            function hi(Ft, Nt, Xt) {
              const Vt = Xt ? Nt[0][Nt[0].length - 1] : Nt[0][0];
              return `${Ft}:${Vt.x}:${Vt.y}`;
            }
            for (let Ft = 0; Ft < Se.length; Ft++) {
              const Nt = Se[Ft], Xt = Nt.geometry, Vt = Nt.text ? Nt.text.toString() : null;
              if (!Vt) {
                st(Ft);
                continue;
              }
              const qt = hi(Vt, Xt), dt = hi(Vt, Xt, !0);
              if (qt in Xe && dt in Pe && Xe[qt] !== Pe[dt]) {
                const Yt = Bt(qt, dt, Xt), Ht = Tt(qt, dt, Be[Yt].geometry);
                delete Pe[qt], delete Xe[dt], Xe[hi(Vt, Be[Ht].geometry, !0)] = Ht, Be[Yt].geometry = null;
              } else qt in Xe ? Tt(qt, dt, Xt) : dt in Pe ? Bt(qt, dt, Xt) : (st(Ft), Pe[qt] = Ge - 1, Xe[dt] = Ge - 1);
            }
            return Be.filter((Ft) => Ft.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((Se, Pe) => Se.sortKey - Pe.sortKey);
        }
        update(t, n, u) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, u), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, u));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t, n) {
          const u = this.lineVertexArray.length;
          if (t.segment !== void 0) {
            let f = t.dist(n[t.segment + 1]), _ = t.dist(n[t.segment]);
            const b = {};
            for (let E = t.segment + 1; E < n.length; E++) b[E] = { x: n[E].x, y: n[E].y, tileUnitDistanceFromAnchor: f }, E < n.length - 1 && (f += n[E + 1].dist(n[E]));
            for (let E = t.segment || 0; E >= 0; E--) b[E] = { x: n[E].x, y: n[E].y, tileUnitDistanceFromAnchor: _ }, E > 0 && (_ += n[E - 1].dist(n[E]));
            for (let E = 0; E < n.length; E++) {
              const C = b[E];
              this.lineVertexArray.emplaceBack(C.x, C.y, C.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: u, lineLength: this.lineVertexArray.length - u };
        }
        addSymbols(t, n, u, f, _, b, E, C, L, R, U, H) {
          const J = t.indexArray, ne = t.layoutVertexArray, he = t.segments.prepareSegment(4 * n.length, ne, J, this.canOverlap ? b.sortKey : void 0), Se = this.glyphOffsetArray.length, Pe = he.vertexLength, Xe = this.allowVerticalPlacement && E === g.ah.vertical ? Math.PI / 2 : 0, Be = b.text && b.text.sections;
          for (let Ge = 0; Ge < n.length; Ge++) {
            const { tl: st, tr: Tt, bl: Bt, br: hi, tex: Ft, pixelOffsetTL: Nt, pixelOffsetBR: Xt, minFontScaleX: Vt, minFontScaleY: qt, glyphOffset: dt, isSDF: Yt, sectionIndex: Ht } = n[Ge], _i = he.vertexLength, ir = dt[1];
            Mh(ne, C.x, C.y, st.x, ir + st.y, Ft.x, Ft.y, u, Yt, Nt.x, Nt.y, Vt, qt), Mh(ne, C.x, C.y, Tt.x, ir + Tt.y, Ft.x + Ft.w, Ft.y, u, Yt, Xt.x, Nt.y, Vt, qt), Mh(ne, C.x, C.y, Bt.x, ir + Bt.y, Ft.x, Ft.y + Ft.h, u, Yt, Nt.x, Xt.y, Vt, qt), Mh(ne, C.x, C.y, hi.x, ir + hi.y, Ft.x + Ft.w, Ft.y + Ft.h, u, Yt, Xt.x, Xt.y, Vt, qt), Bd(t.dynamicLayoutVertexArray, C, Xe), J.emplaceBack(_i, _i + 1, _i + 2), J.emplaceBack(_i + 1, _i + 2, _i + 3), he.vertexLength += 4, he.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(dt[0]), Ge !== n.length - 1 && Ht === n[Ge + 1].sectionIndex || t.programConfigurations.populatePaintArrays(ne.length, b, b.index, {}, H, Be && Be[Ht]);
          }
          t.placedSymbolArray.emplaceBack(C.x, C.y, Se, this.glyphOffsetArray.length - Se, Pe, L, R, C.segment, u ? u[0] : 0, u ? u[1] : 0, f[0], f[1], E, 0, !1, 0, U);
        }
        _addCollisionDebugVertex(t, n, u, f, _, b) {
          return n.emplaceBack(0, 0), t.emplaceBack(u.x, u.y, f, _, Math.round(b.x), Math.round(b.y));
        }
        addCollisionDebugVertices(t, n, u, f, _, b, E) {
          const C = _.segments.prepareSegment(4, _.layoutVertexArray, _.indexArray), L = C.vertexLength, R = _.layoutVertexArray, U = _.collisionVertexArray, H = E.anchorX, J = E.anchorY;
          this._addCollisionDebugVertex(R, U, b, H, J, new q(t, n)), this._addCollisionDebugVertex(R, U, b, H, J, new q(u, n)), this._addCollisionDebugVertex(R, U, b, H, J, new q(u, f)), this._addCollisionDebugVertex(R, U, b, H, J, new q(t, f)), C.vertexLength += 4;
          const ne = _.indexArray;
          ne.emplaceBack(L, L + 1), ne.emplaceBack(L + 1, L + 2), ne.emplaceBack(L + 2, L + 3), ne.emplaceBack(L + 3, L), C.primitiveLength += 4;
        }
        addDebugCollisionBoxes(t, n, u, f) {
          for (let _ = t; _ < n; _++) {
            const b = this.collisionBoxArray.get(_);
            this.addCollisionDebugVertices(b.x1, b.y1, b.x2, b.y2, f ? this.textCollisionBox : this.iconCollisionBox, b.anchorPoint, u);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Od(pn, Mf.members, wr), this.iconCollisionBox = new Od(pn, Mf.members, wr);
          for (let t = 0; t < this.symbolInstances.length; t++) {
            const n = this.symbolInstances.get(t);
            this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1);
          }
        }
        _deserializeCollisionBoxesForSymbol(t, n, u, f, _, b, E, C, L) {
          const R = {};
          for (let U = n; U < u; U++) {
            const H = t.get(U);
            R.textBox = { x1: H.x1, y1: H.y1, x2: H.x2, y2: H.y2, anchorPointX: H.anchorPointX, anchorPointY: H.anchorPointY }, R.textFeatureIndex = H.featureIndex;
            break;
          }
          for (let U = f; U < _; U++) {
            const H = t.get(U);
            R.verticalTextBox = { x1: H.x1, y1: H.y1, x2: H.x2, y2: H.y2, anchorPointX: H.anchorPointX, anchorPointY: H.anchorPointY }, R.verticalTextFeatureIndex = H.featureIndex;
            break;
          }
          for (let U = b; U < E; U++) {
            const H = t.get(U);
            R.iconBox = { x1: H.x1, y1: H.y1, x2: H.x2, y2: H.y2, anchorPointX: H.anchorPointX, anchorPointY: H.anchorPointY }, R.iconFeatureIndex = H.featureIndex;
            break;
          }
          for (let U = C; U < L; U++) {
            const H = t.get(U);
            R.verticalIconBox = { x1: H.x1, y1: H.y1, x2: H.x2, y2: H.y2, anchorPointX: H.anchorPointX, anchorPointY: H.anchorPointY }, R.verticalIconFeatureIndex = H.featureIndex;
            break;
          }
          return R;
        }
        deserializeCollisionBoxes(t) {
          this.collisionArrays = [];
          for (let n = 0; n < this.symbolInstances.length; n++) {
            const u = this.symbolInstances.get(n);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, u.textBoxStartIndex, u.textBoxEndIndex, u.verticalTextBoxStartIndex, u.verticalTextBoxEndIndex, u.iconBoxStartIndex, u.iconBoxEndIndex, u.verticalIconBoxStartIndex, u.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(t, n) {
          const u = t.placedSymbolArray.get(n), f = u.vertexStartIndex + 4 * u.numGlyphs;
          for (let _ = u.vertexStartIndex; _ < f; _ += 4) t.indexArray.emplaceBack(_, _ + 1, _ + 2), t.indexArray.emplaceBack(_ + 1, _ + 2, _ + 3);
        }
        getSortedSymbolIndexes(t) {
          if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          const n = Math.sin(t), u = Math.cos(t), f = [], _ = [], b = [];
          for (let E = 0; E < this.symbolInstances.length; ++E) {
            b.push(E);
            const C = this.symbolInstances.get(E);
            f.push(0 | Math.round(n * C.anchorX + u * C.anchorY)), _.push(C.featureIndex);
          }
          return b.sort((E, C) => f[E] - f[C] || _[C] - _[E]), b;
        }
        addToSortKeyRanges(t, n) {
          const u = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          u && u.sortKey === n ? u.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
        }
        sortFeatures(t) {
          if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const n of this.symbolInstanceIndexes) {
              const u = this.symbolInstances.get(n);
              this.featureSortOrder.push(u.featureIndex), [u.rightJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.leftJustifiedTextSymbolIndex].forEach((f, _, b) => {
                f >= 0 && b.indexOf(f) === _ && this.addIndicesForPlacedSymbol(this.text, f);
              }), u.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, u.verticalPlacedTextSymbolIndex), u.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.placedIconSymbolIndex), u.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let Jf, Kf;
      Ot("SymbolBucket", Qu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Qu.MAX_GLYPHS = 65535, Qu.addDynamicAttributes = Bd;
      var jd = { get paint() {
        return Kf = Kf || new c({ "icon-opacity": new li(Y.paint_symbol["icon-opacity"]), "icon-color": new li(Y.paint_symbol["icon-color"]), "icon-halo-color": new li(Y.paint_symbol["icon-halo-color"]), "icon-halo-width": new li(Y.paint_symbol["icon-halo-width"]), "icon-halo-blur": new li(Y.paint_symbol["icon-halo-blur"]), "icon-translate": new Gt(Y.paint_symbol["icon-translate"]), "icon-translate-anchor": new Gt(Y.paint_symbol["icon-translate-anchor"]), "text-opacity": new li(Y.paint_symbol["text-opacity"]), "text-color": new li(Y.paint_symbol["text-color"], { runtimeType: Si, getOverride: (i) => i.textColor, hasOverride: (i) => !!i.textColor }), "text-halo-color": new li(Y.paint_symbol["text-halo-color"]), "text-halo-width": new li(Y.paint_symbol["text-halo-width"]), "text-halo-blur": new li(Y.paint_symbol["text-halo-blur"]), "text-translate": new Gt(Y.paint_symbol["text-translate"]), "text-translate-anchor": new Gt(Y.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return Jf = Jf || new c({ "symbol-placement": new Gt(Y.layout_symbol["symbol-placement"]), "symbol-spacing": new Gt(Y.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Gt(Y.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new li(Y.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Gt(Y.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Gt(Y.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Gt(Y.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Gt(Y.layout_symbol["icon-ignore-placement"]), "icon-optional": new Gt(Y.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Gt(Y.layout_symbol["icon-rotation-alignment"]), "icon-size": new li(Y.layout_symbol["icon-size"]), "icon-text-fit": new Gt(Y.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Gt(Y.layout_symbol["icon-text-fit-padding"]), "icon-image": new li(Y.layout_symbol["icon-image"]), "icon-rotate": new li(Y.layout_symbol["icon-rotate"]), "icon-padding": new li(Y.layout_symbol["icon-padding"]), "icon-keep-upright": new Gt(Y.layout_symbol["icon-keep-upright"]), "icon-offset": new li(Y.layout_symbol["icon-offset"]), "icon-anchor": new li(Y.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Gt(Y.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Gt(Y.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Gt(Y.layout_symbol["text-rotation-alignment"]), "text-field": new li(Y.layout_symbol["text-field"]), "text-font": new li(Y.layout_symbol["text-font"]), "text-size": new li(Y.layout_symbol["text-size"]), "text-max-width": new li(Y.layout_symbol["text-max-width"]), "text-line-height": new Gt(Y.layout_symbol["text-line-height"]), "text-letter-spacing": new li(Y.layout_symbol["text-letter-spacing"]), "text-justify": new li(Y.layout_symbol["text-justify"]), "text-radial-offset": new li(Y.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Gt(Y.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new li(Y.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new li(Y.layout_symbol["text-anchor"]), "text-max-angle": new Gt(Y.layout_symbol["text-max-angle"]), "text-writing-mode": new Gt(Y.layout_symbol["text-writing-mode"]), "text-rotate": new li(Y.layout_symbol["text-rotate"]), "text-padding": new Gt(Y.layout_symbol["text-padding"]), "text-keep-upright": new Gt(Y.layout_symbol["text-keep-upright"]), "text-transform": new li(Y.layout_symbol["text-transform"]), "text-offset": new li(Y.layout_symbol["text-offset"]), "text-allow-overlap": new Gt(Y.layout_symbol["text-allow-overlap"]), "text-overlap": new Gt(Y.layout_symbol["text-overlap"]), "text-ignore-placement": new Gt(Y.layout_symbol["text-ignore-placement"]), "text-optional": new Gt(Y.layout_symbol["text-optional"]) });
      } };
      class Qf {
        constructor(t) {
          if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = t.property.overrides ? t.property.overrides.runtimeType : Zi, this.defaultValue = t;
        }
        evaluate(t) {
          if (t.formattedSection) {
            const n = this.defaultValue.property.overrides;
            if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection);
          }
          return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t) {
          this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      Ot("FormatSectionOverride", Qf, { omit: ["defaultValue"] });
      class Nh extends r {
        constructor(t) {
          super(t, jd);
        }
        recalculate(t, n) {
          if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const u = this.layout.get("text-writing-mode");
            if (u) {
              const f = [];
              for (const _ of u) f.indexOf(_) < 0 && f.push(_);
              this.layout._values["text-writing-mode"] = f;
            } else this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t, n, u, f) {
          const _ = this.layout.get(t).evaluate(n, {}, u, f), b = this._unevaluatedLayout._values[t];
          return b.isDataDriven() || da(b.value) || !_ ? _ : function(E, C) {
            return C.replace(/{([^{}]+)}/g, (L, R) => E && R in E ? String(E[R]) : "");
          }(n.properties, _);
        }
        createBucket(t) {
          return new Qu(t);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const t of jd.paint.overridableProperties) {
            if (!Nh.hasPaintOverride(this.layout, t)) continue;
            const n = this.paint.get(t), u = new Qf(n), f = new gs(u, n.property.specification);
            let _ = null;
            _ = n.value.kind === "constant" || n.value.kind === "source" ? new yn("source", f) : new Un("composite", f, n.value.zoomStops), this.paint._values[t] = new ma(n.property, _, n.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t, n, u) {
          return !(!this.layout || n.isDataDriven() || u.isDataDriven()) && Nh.hasPaintOverride(this.layout, t);
        }
        static hasPaintOverride(t, n) {
          const u = t.get("text-field"), f = jd.paint.properties[n];
          let _ = !1;
          const b = (E) => {
            for (const C of E) if (f.overrides && f.overrides.hasOverride(C)) return void (_ = !0);
          };
          if (u.value.kind === "constant" && u.value.value instanceof Hr) b(u.value.value.sections);
          else if (u.value.kind === "source") {
            const E = (L) => {
              _ || (L instanceof gn && br(L.value) === Ni ? b(L.value.sections) : L instanceof lo ? b(L.sections) : L.eachChild(E));
            }, C = u.value;
            C._styleExpression && E(C._styleExpression.expression);
          }
          return _;
        }
      }
      let em;
      var g2 = { get paint() {
        return em = em || new c({ "background-color": new Gt(Y.paint_background["background-color"]), "background-pattern": new y(Y.paint_background["background-pattern"]), "background-opacity": new Gt(Y.paint_background["background-opacity"]) });
      } };
      class _2 extends r {
        constructor(t) {
          super(t, g2);
        }
      }
      let tm;
      var y2 = { get paint() {
        return tm = tm || new c({ "raster-opacity": new Gt(Y.paint_raster["raster-opacity"]), "raster-hue-rotate": new Gt(Y.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Gt(Y.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Gt(Y.paint_raster["raster-brightness-max"]), "raster-saturation": new Gt(Y.paint_raster["raster-saturation"]), "raster-contrast": new Gt(Y.paint_raster["raster-contrast"]), "raster-resampling": new Gt(Y.paint_raster["raster-resampling"]), "raster-fade-duration": new Gt(Y.paint_raster["raster-fade-duration"]) });
      } };
      class v2 extends r {
        constructor(t) {
          super(t, y2);
        }
      }
      class b2 extends r {
        constructor(t) {
          super(t, {}), this.onAdd = (n) => {
            this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl);
          }, this.onRemove = (n) => {
            this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl);
          }, this.implementation = t;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class x2 {
        constructor(t) {
          this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const qd = 63710088e-1;
      class ql {
        constructor(t, n) {
          if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`);
          if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new ql(at(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t) {
          const n = Math.PI / 180, u = this.lat * n, f = t.lat * n, _ = Math.sin(u) * Math.sin(f) + Math.cos(u) * Math.cos(f) * Math.cos((t.lng - this.lng) * n);
          return qd * Math.acos(Math.min(_, 1));
        }
        static convert(t) {
          if (t instanceof ql) return t;
          if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new ql(Number(t[0]), Number(t[1]));
          if (!Array.isArray(t) && typeof t == "object" && t !== null) return new ql(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const im = 2 * Math.PI * qd;
      function rm(i) {
        return im * Math.cos(i * Math.PI / 180);
      }
      function nm(i) {
        return (180 + i) / 360;
      }
      function am(i) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360;
      }
      function sm(i, t) {
        return i / rm(t);
      }
      function Ud(i) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90;
      }
      class Zc {
        constructor(t, n, u = 0) {
          this.x = +t, this.y = +n, this.z = +u;
        }
        static fromLngLat(t, n = 0) {
          const u = ql.convert(t);
          return new Zc(nm(u.lng), am(u.lat), sm(n, u.lat));
        }
        toLngLat() {
          return new ql(360 * this.x - 180, Ud(this.y));
        }
        toAltitude() {
          return this.z * rm(Ud(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / im * (t = Ud(this.y), 1 / Math.cos(t * Math.PI / 180));
          var t;
        }
      }
      function om(i, t, n) {
        var u = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
        return [i * u - 2 * Math.PI * 6378137 / 2, t * u - 2 * Math.PI * 6378137 / 2];
      }
      class Vd {
        constructor(t, n, u) {
          if (!function(f, _, b) {
            return !(f < 0 || f > 25 || b < 0 || b >= Math.pow(2, f) || _ < 0 || _ >= Math.pow(2, f));
          }(t, n, u)) throw new Error(`x=${n}, y=${u}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
          this.z = t, this.x = n, this.y = u, this.key = Gc(0, t, t, n, u);
        }
        equals(t) {
          return this.z === t.z && this.x === t.x && this.y === t.y;
        }
        url(t, n, u) {
          const f = (b = this.y, E = this.z, C = om(256 * (_ = this.x), 256 * (b = Math.pow(2, E) - b - 1), E), L = om(256 * (_ + 1), 256 * (b + 1), E), C[0] + "," + C[1] + "," + L[0] + "," + L[1]);
          var _, b, E, C, L;
          const R = function(U, H, J) {
            let ne, he = "";
            for (let Se = U; Se > 0; Se--) ne = 1 << Se - 1, he += (H & ne ? 1 : 0) + (J & ne ? 2 : 0);
            return he;
          }(this.z, this.x, this.y);
          return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(u === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, R).replace(/{bbox-epsg-3857}/g, f);
        }
        isChildOf(t) {
          const n = this.z - t.z;
          return n > 0 && t.x === this.x >> n && t.y === this.y >> n;
        }
        getTilePoint(t) {
          const n = Math.pow(2, this.z);
          return new q((t.x * n - this.x) * or, (t.y * n - this.y) * or);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class lm {
        constructor(t, n) {
          this.wrap = t, this.canonical = n, this.key = Gc(t, n.z, n.z, n.x, n.y);
        }
      }
      class es {
        constructor(t, n, u, f, _) {
          if (t < u) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${u}`);
          this.overscaledZ = t, this.wrap = n, this.canonical = new Vd(u, +f, +_), this.key = Gc(n, t, u, f, _);
        }
        clone() {
          return new es(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(t) {
          return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
        }
        scaledTo(t) {
          if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
          const n = this.canonical.z - t;
          return t > this.canonical.z ? new es(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new es(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n);
        }
        calculateScaledKey(t, n) {
          if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
          const u = this.canonical.z - t;
          return t > this.canonical.z ? Gc(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : Gc(this.wrap * +n, t, t, this.canonical.x >> u, this.canonical.y >> u);
        }
        isChildOf(t) {
          if (t.wrap !== this.wrap) return !1;
          const n = this.canonical.z - t.canonical.z;
          return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n;
        }
        children(t) {
          if (this.overscaledZ >= t) return [new es(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const n = this.canonical.z + 1, u = 2 * this.canonical.x, f = 2 * this.canonical.y;
          return [new es(n, this.wrap, n, u, f), new es(n, this.wrap, n, u + 1, f), new es(n, this.wrap, n, u, f + 1), new es(n, this.wrap, n, u + 1, f + 1)];
        }
        isLessThan(t) {
          return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
        }
        wrapped() {
          return new es(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t) {
          return new es(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new lm(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(t) {
          return this.canonical.getTilePoint(new Zc(t.x - this.wrap, t.y));
        }
      }
      function Gc(i, t, n, u, f) {
        (i *= 2) < 0 && (i = -1 * i - 1);
        const _ = 1 << n;
        return (_ * _ * i + _ * f + u).toString(36) + n.toString(36) + t.toString(36);
      }
      Ot("CanonicalTileID", Vd), Ot("OverscaledTileID", es, { omit: ["posMatrix"] });
      class um {
        constructor(t, n, u, f = 1, _ = 1, b = 1, E = 0) {
          if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square");
          if (u && !["mapbox", "terrarium", "custom"].includes(u)) return void xe(`"${u}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = n.height;
          const C = this.dim = n.height - 2;
          switch (this.data = new Uint32Array(n.data.buffer), u) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = f, this.greenFactor = _, this.blueFactor = b, this.baseShift = E;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let L = 0; L < C; L++) this.data[this._idx(-1, L)] = this.data[this._idx(0, L)], this.data[this._idx(C, L)] = this.data[this._idx(C - 1, L)], this.data[this._idx(L, -1)] = this.data[this._idx(L, 0)], this.data[this._idx(L, C)] = this.data[this._idx(L, C - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(C, -1)] = this.data[this._idx(C - 1, 0)], this.data[this._idx(-1, C)] = this.data[this._idx(0, C - 1)], this.data[this._idx(C, C)] = this.data[this._idx(C - 1, C - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let L = 0; L < C; L++) for (let R = 0; R < C; R++) {
            const U = this.get(L, R);
            U > this.max && (this.max = U), U < this.min && (this.min = U);
          }
        }
        get(t, n) {
          const u = new Uint8Array(this.data.buffer), f = 4 * this._idx(t, n);
          return this.unpack(u[f], u[f + 1], u[f + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(t, n) {
          if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (n + 1) * this.stride + (t + 1);
        }
        unpack(t, n, u) {
          return t * this.redFactor + n * this.greenFactor + u * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new Qa({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(t, n, u) {
          if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
          let f = n * this.dim, _ = n * this.dim + this.dim, b = u * this.dim, E = u * this.dim + this.dim;
          switch (n) {
            case -1:
              f = _ - 1;
              break;
            case 1:
              _ = f + 1;
          }
          switch (u) {
            case -1:
              b = E - 1;
              break;
            case 1:
              E = b + 1;
          }
          const C = -n * this.dim, L = -u * this.dim;
          for (let R = b; R < E; R++) for (let U = f; U < _; U++) this.data[this._idx(U, R)] = t.data[this._idx(U + C, R + L)];
        }
      }
      Ot("DEMData", um);
      class cm {
        constructor(t) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let n = 0; n < t.length; n++) {
            const u = t[n];
            this._stringToNumber[u] = n, this._numberToString[n] = u;
          }
        }
        encode(t) {
          return this._stringToNumber[t];
        }
        decode(t) {
          if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[t];
        }
      }
      class hm {
        constructor(t, n, u, f, _) {
          this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = u, t._y = f, this.properties = t.properties, this.id = _;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(t) {
          this._geometry = t;
        }
        toJSON() {
          const t = { geometry: this.geometry };
          for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
          return t;
        }
      }
      class dm {
        constructor(t, n) {
          this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Ao(or, 16, 0), this.grid3D = new Ao(or, 16, 0), this.featureIndexArray = new Ui(), this.promoteId = n;
        }
        insert(t, n, u, f, _, b) {
          const E = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(u, f, _);
          const C = b ? this.grid3D : this.grid;
          for (let L = 0; L < n.length; L++) {
            const R = n[L], U = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let H = 0; H < R.length; H++) {
              const J = R[H];
              U[0] = Math.min(U[0], J.x), U[1] = Math.min(U[1], J.y), U[2] = Math.max(U[2], J.x), U[3] = Math.max(U[3], J.y);
            }
            U[0] < or && U[1] < or && U[2] >= 0 && U[3] >= 0 && C.insert(E, U[0], U[1], U[2], U[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new Rl.VectorTile(new Pd(this.rawTileData)).layers, this.sourceLayerCoder = new cm(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(t, n, u, f) {
          this.loadVTLayers();
          const _ = t.params || {}, b = or / t.tileSize / t.scale, E = pa(_.filter), C = t.queryGeometry, L = t.queryPadding * b, R = fm(C), U = this.grid.query(R.minX - L, R.minY - L, R.maxX + L, R.maxY + L), H = fm(t.cameraQueryGeometry), J = this.grid3D.query(H.minX - L, H.minY - L, H.maxX + L, H.maxY + L, (Se, Pe, Xe, Be) => function(Ge, st, Tt, Bt, hi) {
            for (const Nt of Ge) if (st <= Nt.x && Tt <= Nt.y && Bt >= Nt.x && hi >= Nt.y) return !0;
            const Ft = [new q(st, Tt), new q(st, hi), new q(Bt, hi), new q(Bt, Tt)];
            if (Ge.length > 2) {
              for (const Nt of Ft) if (Lo(Ge, Nt)) return !0;
            }
            for (let Nt = 0; Nt < Ge.length - 1; Nt++) if (Lc(Ge[Nt], Ge[Nt + 1], Ft)) return !0;
            return !1;
          }(t.cameraQueryGeometry, Se - L, Pe - L, Xe + L, Be + L));
          for (const Se of J) U.push(Se);
          U.sort(w2);
          const ne = {};
          let he;
          for (let Se = 0; Se < U.length; Se++) {
            const Pe = U[Se];
            if (Pe === he) continue;
            he = Pe;
            const Xe = this.featureIndexArray.get(Pe);
            let Be = null;
            this.loadMatchingFeature(ne, Xe.bucketIndex, Xe.sourceLayerIndex, Xe.featureIndex, E, _.layers, _.availableImages, n, u, f, (Ge, st, Tt) => (Be || (Be = fl(Ge)), st.queryIntersectsFeature(C, Ge, Tt, Be, this.z, t.transform, b, t.pixelPosMatrix)));
          }
          return ne;
        }
        loadMatchingFeature(t, n, u, f, _, b, E, C, L, R, U) {
          const H = this.bucketLayerIDs[n];
          if (b && !function(Se, Pe) {
            for (let Xe = 0; Xe < Se.length; Xe++) if (Pe.indexOf(Se[Xe]) >= 0) return !0;
            return !1;
          }(b, H)) return;
          const J = this.sourceLayerCoder.decode(u), ne = this.vtLayers[J].feature(f);
          if (_.needGeometry) {
            const Se = ko(ne, !0);
            if (!_.filter(new Ji(this.tileID.overscaledZ), Se, this.tileID.canonical)) return;
          } else if (!_.filter(new Ji(this.tileID.overscaledZ), ne)) return;
          const he = this.getId(ne, J);
          for (let Se = 0; Se < H.length; Se++) {
            const Pe = H[Se];
            if (b && b.indexOf(Pe) < 0) continue;
            const Xe = C[Pe];
            if (!Xe) continue;
            let Be = {};
            he && R && (Be = R.getState(Xe.sourceLayer || "_geojsonTileLayer", he));
            const Ge = Ie({}, L[Pe]);
            Ge.paint = pm(Ge.paint, Xe.paint, ne, Be, E), Ge.layout = pm(Ge.layout, Xe.layout, ne, Be, E);
            const st = !U || U(ne, Xe, Be);
            if (!st) continue;
            const Tt = new hm(ne, this.z, this.x, this.y, he);
            Tt.layer = Ge;
            let Bt = t[Pe];
            Bt === void 0 && (Bt = t[Pe] = []), Bt.push({ featureIndex: f, feature: Tt, intersectionZ: st });
          }
        }
        lookupSymbolFeatures(t, n, u, f, _, b, E, C) {
          const L = {};
          this.loadVTLayers();
          const R = pa(_);
          for (const U of t) this.loadMatchingFeature(L, u, f, U, R, b, E, C, n);
          return L;
        }
        hasLayer(t) {
          for (const n of this.bucketLayerIDs) for (const u of n) if (t === u) return !0;
          return !1;
        }
        getId(t, n) {
          let u = t.id;
          return this.promoteId && (u = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof u == "boolean" && (u = Number(u))), u;
        }
      }
      function pm(i, t, n, u, f) {
        return me(i, (_, b) => {
          const E = t instanceof bs ? t.get(b) : null;
          return E && E.evaluate ? E.evaluate(n, u, f) : E;
        });
      }
      function fm(i) {
        let t = 1 / 0, n = 1 / 0, u = -1 / 0, f = -1 / 0;
        for (const _ of i) t = Math.min(t, _.x), n = Math.min(n, _.y), u = Math.max(u, _.x), f = Math.max(f, _.y);
        return { minX: t, minY: n, maxX: u, maxY: f };
      }
      function w2(i, t) {
        return t - i;
      }
      function mm(i, t, n, u, f) {
        const _ = [];
        for (let b = 0; b < i.length; b++) {
          const E = i[b];
          let C;
          for (let L = 0; L < E.length - 1; L++) {
            let R = E[L], U = E[L + 1];
            R.x < t && U.x < t || (R.x < t ? R = new q(t, R.y + (t - R.x) / (U.x - R.x) * (U.y - R.y))._round() : U.x < t && (U = new q(t, R.y + (t - R.x) / (U.x - R.x) * (U.y - R.y))._round()), R.y < n && U.y < n || (R.y < n ? R = new q(R.x + (n - R.y) / (U.y - R.y) * (U.x - R.x), n)._round() : U.y < n && (U = new q(R.x + (n - R.y) / (U.y - R.y) * (U.x - R.x), n)._round()), R.x >= u && U.x >= u || (R.x >= u ? R = new q(u, R.y + (u - R.x) / (U.x - R.x) * (U.y - R.y))._round() : U.x >= u && (U = new q(u, R.y + (u - R.x) / (U.x - R.x) * (U.y - R.y))._round()), R.y >= f && U.y >= f || (R.y >= f ? R = new q(R.x + (f - R.y) / (U.y - R.y) * (U.x - R.x), f)._round() : U.y >= f && (U = new q(R.x + (f - R.y) / (U.y - R.y) * (U.x - R.x), f)._round()), C && R.equals(C[C.length - 1]) || (C = [R], _.push(C)), C.push(U)))));
          }
        }
        return _;
      }
      Ot("FeatureIndex", dm, { omit: ["rawTileData", "sourceLayerCoder"] });
      class Ul extends q {
        constructor(t, n, u, f) {
          super(t, n), this.angle = u, f !== void 0 && (this.segment = f);
        }
        clone() {
          return new Ul(this.x, this.y, this.angle, this.segment);
        }
      }
      function gm(i, t, n, u, f) {
        if (t.segment === void 0 || n === 0) return !0;
        let _ = t, b = t.segment + 1, E = 0;
        for (; E > -n / 2; ) {
          if (b--, b < 0) return !1;
          E -= i[b].dist(_), _ = i[b];
        }
        E += i[b].dist(i[b + 1]), b++;
        const C = [];
        let L = 0;
        for (; E < n / 2; ) {
          const R = i[b], U = i[b + 1];
          if (!U) return !1;
          let H = i[b - 1].angleTo(R) - R.angleTo(U);
          for (H = Math.abs((H + 3 * Math.PI) % (2 * Math.PI) - Math.PI), C.push({ distance: E, angleDelta: H }), L += H; E - C[0].distance > u; ) L -= C.shift().angleDelta;
          if (L > f) return !1;
          b++, E += R.dist(U);
        }
        return !0;
      }
      function _m(i) {
        let t = 0;
        for (let n = 0; n < i.length - 1; n++) t += i[n].dist(i[n + 1]);
        return t;
      }
      function ym(i, t, n) {
        return i ? 0.6 * t * n : 0;
      }
      function vm(i, t) {
        return Math.max(i ? i.right - i.left : 0, t ? t.right - t.left : 0);
      }
      function A2(i, t, n, u, f, _) {
        const b = ym(n, f, _), E = vm(n, u) * _;
        let C = 0;
        const L = _m(i) / 2;
        for (let R = 0; R < i.length - 1; R++) {
          const U = i[R], H = i[R + 1], J = U.dist(H);
          if (C + J > L) {
            const ne = (L - C) / J, he = jr.number(U.x, H.x, ne), Se = jr.number(U.y, H.y, ne), Pe = new Ul(he, Se, H.angleTo(U), R);
            return Pe._round(), !b || gm(i, Pe, E, b, t) ? Pe : void 0;
          }
          C += J;
        }
      }
      function S2(i, t, n, u, f, _, b, E, C) {
        const L = ym(u, _, b), R = vm(u, f), U = R * b, H = i[0].x === 0 || i[0].x === C || i[0].y === 0 || i[0].y === C;
        return t - U < t / 4 && (t = U + t / 4), bm(i, H ? t / 2 * E % t : (R / 2 + 2 * _) * b * E % t, t, L, n, U, H, !1, C);
      }
      function bm(i, t, n, u, f, _, b, E, C) {
        const L = _ / 2, R = _m(i);
        let U = 0, H = t - n, J = [];
        for (let ne = 0; ne < i.length - 1; ne++) {
          const he = i[ne], Se = i[ne + 1], Pe = he.dist(Se), Xe = Se.angleTo(he);
          for (; H + n < U + Pe; ) {
            H += n;
            const Be = (H - U) / Pe, Ge = jr.number(he.x, Se.x, Be), st = jr.number(he.y, Se.y, Be);
            if (Ge >= 0 && Ge < C && st >= 0 && st < C && H - L >= 0 && H + L <= R) {
              const Tt = new Ul(Ge, st, Xe, ne);
              Tt._round(), u && !gm(i, Tt, _, u, f) || J.push(Tt);
            }
          }
          U += Pe;
        }
        return E || J.length || b || (J = bm(i, U / 2, n, u, f, _, b, !0, C)), J;
      }
      Ot("Anchor", Ul);
      const ec = _a;
      function xm(i, t, n, u) {
        const f = [], _ = i.image, b = _.pixelRatio, E = _.paddedRect.w - 2 * ec, C = _.paddedRect.h - 2 * ec;
        let L = { x1: i.left, y1: i.top, x2: i.right, y2: i.bottom };
        const R = _.stretchX || [[0, E]], U = _.stretchY || [[0, C]], H = (dt, Yt) => dt + Yt[1] - Yt[0], J = R.reduce(H, 0), ne = U.reduce(H, 0), he = E - J, Se = C - ne;
        let Pe = 0, Xe = J, Be = 0, Ge = ne, st = 0, Tt = he, Bt = 0, hi = Se;
        if (_.content && u) {
          const dt = _.content, Yt = dt[2] - dt[0], Ht = dt[3] - dt[1];
          (_.textFitWidth || _.textFitHeight) && (L = Wf(i)), Pe = zh(R, 0, dt[0]), Be = zh(U, 0, dt[1]), Xe = zh(R, dt[0], dt[2]), Ge = zh(U, dt[1], dt[3]), st = dt[0] - Pe, Bt = dt[1] - Be, Tt = Yt - Xe, hi = Ht - Ge;
        }
        const Ft = L.x1, Nt = L.y1, Xt = L.x2 - Ft, Vt = L.y2 - Nt, qt = (dt, Yt, Ht, _i) => {
          const ir = Fh(dt.stretch - Pe, Xe, Xt, Ft), Qi = Bh(dt.fixed - st, Tt, dt.stretch, J), rn = Fh(Yt.stretch - Be, Ge, Vt, Nt), Ts = Bh(Yt.fixed - Bt, hi, Yt.stretch, ne), xn = Fh(Ht.stretch - Pe, Xe, Xt, Ft), nn = Bh(Ht.fixed - st, Tt, Ht.stretch, J), Yn = Fh(_i.stretch - Be, Ge, Vt, Nt), Jn = Bh(_i.fixed - Bt, hi, _i.stretch, ne), Kn = new q(ir, rn), Lr = new q(xn, rn), an = new q(xn, Yn), zn = new q(ir, Yn), wn = new q(Qi / b, Ts / b), Qn = new q(nn / b, Jn / b), An = t * Math.PI / 180;
          if (An) {
            const Vi = Math.sin(An), lr = Math.cos(An), fr = [lr, -Vi, Vi, lr];
            Kn._matMult(fr), Lr._matMult(fr), zn._matMult(fr), an._matMult(fr);
          }
          const ts = dt.stretch + dt.fixed, ya = Yt.stretch + Yt.fixed;
          return { tl: Kn, tr: Lr, bl: zn, br: an, tex: { x: _.paddedRect.x + ec + ts, y: _.paddedRect.y + ec + ya, w: Ht.stretch + Ht.fixed - ts, h: _i.stretch + _i.fixed - ya }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: wn, pixelOffsetBR: Qn, minFontScaleX: Tt / b / Xt, minFontScaleY: hi / b / Vt, isSDF: n };
        };
        if (u && (_.stretchX || _.stretchY)) {
          const dt = wm(R, he, J), Yt = wm(U, Se, ne);
          for (let Ht = 0; Ht < dt.length - 1; Ht++) {
            const _i = dt[Ht], ir = dt[Ht + 1];
            for (let Qi = 0; Qi < Yt.length - 1; Qi++) f.push(qt(_i, Yt[Qi], ir, Yt[Qi + 1]));
          }
        } else f.push(qt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: E + 1 }, { fixed: 0, stretch: C + 1 }));
        return f;
      }
      function zh(i, t, n) {
        let u = 0;
        for (const f of i) u += Math.max(t, Math.min(n, f[1])) - Math.max(t, Math.min(n, f[0]));
        return u;
      }
      function wm(i, t, n) {
        const u = [{ fixed: -ec, stretch: 0 }];
        for (const [f, _] of i) {
          const b = u[u.length - 1];
          u.push({ fixed: f - b.stretch, stretch: b.stretch }), u.push({ fixed: f - b.stretch, stretch: b.stretch + (_ - f) });
        }
        return u.push({ fixed: t + ec, stretch: n }), u;
      }
      function Fh(i, t, n, u) {
        return i / t * n + u;
      }
      function Bh(i, t, n, u) {
        return i - t * n / u;
      }
      class Rh {
        constructor(t, n, u, f, _, b, E, C, L, R) {
          var U;
          if (this.boxStartIndex = t.length, L) {
            let H = b.top, J = b.bottom;
            const ne = b.collisionPadding;
            ne && (H -= ne[1], J += ne[3]);
            let he = J - H;
            he > 0 && (he = Math.max(10, he), this.circleDiameter = he);
          } else {
            const H = !((U = b.image) === null || U === void 0) && U.content && (b.image.textFitWidth || b.image.textFitHeight) ? Wf(b) : { x1: b.left, y1: b.top, x2: b.right, y2: b.bottom };
            H.y1 = H.y1 * E - C[0], H.y2 = H.y2 * E + C[2], H.x1 = H.x1 * E - C[3], H.x2 = H.x2 * E + C[1];
            const J = b.collisionPadding;
            if (J && (H.x1 -= J[0] * E, H.y1 -= J[1] * E, H.x2 += J[2] * E, H.y2 += J[3] * E), R) {
              const ne = new q(H.x1, H.y1), he = new q(H.x2, H.y1), Se = new q(H.x1, H.y2), Pe = new q(H.x2, H.y2), Xe = R * Math.PI / 180;
              ne._rotate(Xe), he._rotate(Xe), Se._rotate(Xe), Pe._rotate(Xe), H.x1 = Math.min(ne.x, he.x, Se.x, Pe.x), H.x2 = Math.max(ne.x, he.x, Se.x, Pe.x), H.y1 = Math.min(ne.y, he.y, Se.y, Pe.y), H.y2 = Math.max(ne.y, he.y, Se.y, Pe.y);
            }
            t.emplaceBack(n.x, n.y, H.x1, H.y1, H.x2, H.y2, u, f, _);
          }
          this.boxEndIndex = t.length;
        }
      }
      class E2 {
        constructor(t = [], n = (u, f) => u < f ? -1 : u > f ? 1 : 0) {
          if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0) for (let u = (this.length >> 1) - 1; u >= 0; u--) this._down(u);
        }
        push(t) {
          this.data.push(t), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const t = this.data[0], n = this.data.pop();
          return --this.length > 0 && (this.data[0] = n, this._down(0)), t;
        }
        peek() {
          return this.data[0];
        }
        _up(t) {
          const { data: n, compare: u } = this, f = n[t];
          for (; t > 0; ) {
            const _ = t - 1 >> 1, b = n[_];
            if (u(f, b) >= 0) break;
            n[t] = b, t = _;
          }
          n[t] = f;
        }
        _down(t) {
          const { data: n, compare: u } = this, f = this.length >> 1, _ = n[t];
          for (; t < f; ) {
            let b = 1 + (t << 1);
            const E = b + 1;
            if (E < this.length && u(n[E], n[b]) < 0 && (b = E), u(n[b], _) >= 0) break;
            n[t] = n[b], t = b;
          }
          n[t] = _;
        }
      }
      function T2(i, t = 1, n = !1) {
        let u = 1 / 0, f = 1 / 0, _ = -1 / 0, b = -1 / 0;
        const E = i[0];
        for (let J = 0; J < E.length; J++) {
          const ne = E[J];
          (!J || ne.x < u) && (u = ne.x), (!J || ne.y < f) && (f = ne.y), (!J || ne.x > _) && (_ = ne.x), (!J || ne.y > b) && (b = ne.y);
        }
        const C = Math.min(_ - u, b - f);
        let L = C / 2;
        const R = new E2([], C2);
        if (C === 0) return new q(u, f);
        for (let J = u; J < _; J += C) for (let ne = f; ne < b; ne += C) R.push(new tc(J + L, ne + L, L, i));
        let U = function(J) {
          let ne = 0, he = 0, Se = 0;
          const Pe = J[0];
          for (let Xe = 0, Be = Pe.length, Ge = Be - 1; Xe < Be; Ge = Xe++) {
            const st = Pe[Xe], Tt = Pe[Ge], Bt = st.x * Tt.y - Tt.x * st.y;
            he += (st.x + Tt.x) * Bt, Se += (st.y + Tt.y) * Bt, ne += 3 * Bt;
          }
          return new tc(he / ne, Se / ne, 0, J);
        }(i), H = R.length;
        for (; R.length; ) {
          const J = R.pop();
          (J.d > U.d || !U.d) && (U = J, n && console.log("found best %d after %d probes", Math.round(1e4 * J.d) / 1e4, H)), J.max - U.d <= t || (L = J.h / 2, R.push(new tc(J.p.x - L, J.p.y - L, L, i)), R.push(new tc(J.p.x + L, J.p.y - L, L, i)), R.push(new tc(J.p.x - L, J.p.y + L, L, i)), R.push(new tc(J.p.x + L, J.p.y + L, L, i)), H += 4);
        }
        return n && (console.log(`num probes: ${H}`), console.log(`best distance: ${U.d}`)), U.p;
      }
      function C2(i, t) {
        return t.max - i.max;
      }
      function tc(i, t, n, u) {
        this.p = new q(i, t), this.h = n, this.d = function(f, _) {
          let b = !1, E = 1 / 0;
          for (let C = 0; C < _.length; C++) {
            const L = _[C];
            for (let R = 0, U = L.length, H = U - 1; R < U; H = R++) {
              const J = L[R], ne = L[H];
              J.y > f.y != ne.y > f.y && f.x < (ne.x - J.x) * (f.y - J.y) / (ne.y - J.y) + J.x && (b = !b), E = Math.min(E, Pc(f, J, ne));
            }
          }
          return (b ? 1 : -1) * Math.sqrt(E);
        }(this.p, u), this.max = this.d + this.h * Math.SQRT2;
      }
      var bn;
      g.aq = void 0, (bn = g.aq || (g.aq = {}))[bn.center = 1] = "center", bn[bn.left = 2] = "left", bn[bn.right = 3] = "right", bn[bn.top = 4] = "top", bn[bn.bottom = 5] = "bottom", bn[bn["top-left"] = 6] = "top-left", bn[bn["top-right"] = 7] = "top-right", bn[bn["bottom-left"] = 8] = "bottom-left", bn[bn["bottom-right"] = 9] = "bottom-right";
      const Vl = 7, $d = Number.POSITIVE_INFINITY;
      function Am(i, t) {
        return t[1] !== $d ? function(n, u, f) {
          let _ = 0, b = 0;
          switch (u = Math.abs(u), f = Math.abs(f), n) {
            case "top-right":
            case "top-left":
            case "top":
              b = f - Vl;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              b = -f + Vl;
          }
          switch (n) {
            case "top-right":
            case "bottom-right":
            case "right":
              _ = -u;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              _ = u;
          }
          return [_, b];
        }(i, t[0], t[1]) : function(n, u) {
          let f = 0, _ = 0;
          u < 0 && (u = 0);
          const b = u / Math.SQRT2;
          switch (n) {
            case "top-right":
            case "top-left":
              _ = b - Vl;
              break;
            case "bottom-right":
            case "bottom-left":
              _ = -b + Vl;
              break;
            case "bottom":
              _ = -u + Vl;
              break;
            case "top":
              _ = u - Vl;
          }
          switch (n) {
            case "top-right":
            case "bottom-right":
              f = -b;
              break;
            case "top-left":
            case "bottom-left":
              f = b;
              break;
            case "left":
              f = u;
              break;
            case "right":
              f = -u;
          }
          return [f, _];
        }(i, t[0]);
      }
      function Sm(i, t, n) {
        var u;
        const f = i.layout, _ = (u = f.get("text-variable-anchor-offset")) === null || u === void 0 ? void 0 : u.evaluate(t, {}, n);
        if (_) {
          const E = _.values, C = [];
          for (let L = 0; L < E.length; L += 2) {
            const R = C[L] = E[L], U = E[L + 1].map((H) => H * Vr);
            R.startsWith("top") ? U[1] -= Vl : R.startsWith("bottom") && (U[1] += Vl), C[L + 1] = U;
          }
          return new mn(C);
        }
        const b = f.get("text-variable-anchor");
        if (b) {
          let E;
          E = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [f.get("text-radial-offset").evaluate(t, {}, n) * Vr, $d] : f.get("text-offset").evaluate(t, {}, n).map((L) => L * Vr);
          const C = [];
          for (const L of b) C.push(L, Am(L, E));
          return new mn(C);
        }
        return null;
      }
      function Zd(i) {
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function D2(i, t, n, u, f, _, b, E, C, L, R) {
        let U = _.textMaxSize.evaluate(t, {});
        U === void 0 && (U = b);
        const H = i.layers[0].layout, J = H.get("icon-offset").evaluate(t, {}, R), ne = Tm(n.horizontal), he = b / 24, Se = i.tilePixelRatio * he, Pe = i.tilePixelRatio * U / 24, Xe = i.tilePixelRatio * E, Be = i.tilePixelRatio * H.get("symbol-spacing"), Ge = H.get("text-padding") * i.tilePixelRatio, st = function(dt, Yt, Ht, _i = 1) {
          const ir = dt.get("icon-padding").evaluate(Yt, {}, Ht), Qi = ir && ir.values;
          return [Qi[0] * _i, Qi[1] * _i, Qi[2] * _i, Qi[3] * _i];
        }(H, t, R, i.tilePixelRatio), Tt = H.get("text-max-angle") / 180 * Math.PI, Bt = H.get("text-rotation-alignment") !== "viewport" && H.get("symbol-placement") !== "point", hi = H.get("icon-rotation-alignment") === "map" && H.get("symbol-placement") !== "point", Ft = H.get("symbol-placement"), Nt = Be / 2, Xt = H.get("icon-text-fit");
        let Vt;
        u && Xt !== "none" && (i.allowVerticalPlacement && n.vertical && (Vt = Xf(u, n.vertical, Xt, H.get("icon-text-fit-padding"), J, he)), ne && (u = Xf(u, ne, Xt, H.get("icon-text-fit-padding"), J, he)));
        const qt = (dt, Yt) => {
          Yt.x < 0 || Yt.x >= or || Yt.y < 0 || Yt.y >= or || function(Ht, _i, ir, Qi, rn, Ts, xn, nn, Yn, Jn, Kn, Lr, an, zn, wn, Qn, An, ts, ya, Vi, lr, fr, za, Dr, ic) {
            const No = Ht.addToLineVertexArray(_i, ir);
            let zo, Cs, is, fn, _l = 0, Xc = 0, km = 0, Pm = 0, Qd = -1, ep = -1;
            const yl = {};
            let Lm = Fl("");
            if (Ht.allowVerticalPlacement && Qi.vertical) {
              const Fn = nn.layout.get("text-rotate").evaluate(lr, {}, Dr) + 90;
              is = new Rh(Yn, _i, Jn, Kn, Lr, Qi.vertical, an, zn, wn, Fn), xn && (fn = new Rh(Yn, _i, Jn, Kn, Lr, xn, An, ts, wn, Fn));
            }
            if (rn) {
              const Fn = nn.layout.get("icon-rotate").evaluate(lr, {}), rs = nn.layout.get("icon-text-fit") !== "none", xu = xm(rn, Fn, za, rs), Ws = xn ? xm(xn, Fn, za, rs) : void 0;
              Cs = new Rh(Yn, _i, Jn, Kn, Lr, rn, An, ts, !1, Fn), _l = 4 * xu.length;
              const wu = Ht.iconSizeData;
              let Fo = null;
              wu.kind === "source" ? (Fo = [Mo * nn.layout.get("icon-size").evaluate(lr, {})], Fo[0] > jl && xe(`${Ht.layerIds[0]}: Value for "icon-size" is >= ${$c}. Reduce your "icon-size".`)) : wu.kind === "composite" && (Fo = [Mo * fr.compositeIconSizes[0].evaluate(lr, {}, Dr), Mo * fr.compositeIconSizes[1].evaluate(lr, {}, Dr)], (Fo[0] > jl || Fo[1] > jl) && xe(`${Ht.layerIds[0]}: Value for "icon-size" is >= ${$c}. Reduce your "icon-size".`)), Ht.addSymbols(Ht.icon, xu, Fo, Vi, ya, lr, g.ah.none, _i, No.lineStartIndex, No.lineLength, -1, Dr), Qd = Ht.icon.placedSymbolArray.length - 1, Ws && (Xc = 4 * Ws.length, Ht.addSymbols(Ht.icon, Ws, Fo, Vi, ya, lr, g.ah.vertical, _i, No.lineStartIndex, No.lineLength, -1, Dr), ep = Ht.icon.placedSymbolArray.length - 1);
            }
            const Mm = Object.keys(Qi.horizontal);
            for (const Fn of Mm) {
              const rs = Qi.horizontal[Fn];
              if (!zo) {
                Lm = Fl(rs.text);
                const Ws = nn.layout.get("text-rotate").evaluate(lr, {}, Dr);
                zo = new Rh(Yn, _i, Jn, Kn, Lr, rs, an, zn, wn, Ws);
              }
              const xu = rs.positionedLines.length === 1;
              if (km += Em(Ht, _i, rs, Ts, nn, wn, lr, Qn, No, Qi.vertical ? g.ah.horizontal : g.ah.horizontalOnly, xu ? Mm : [Fn], yl, Qd, fr, Dr), xu) break;
            }
            Qi.vertical && (Pm += Em(Ht, _i, Qi.vertical, Ts, nn, wn, lr, Qn, No, g.ah.vertical, ["vertical"], yl, ep, fr, Dr));
            const P2 = zo ? zo.boxStartIndex : Ht.collisionBoxArray.length, L2 = zo ? zo.boxEndIndex : Ht.collisionBoxArray.length, M2 = is ? is.boxStartIndex : Ht.collisionBoxArray.length, N2 = is ? is.boxEndIndex : Ht.collisionBoxArray.length, z2 = Cs ? Cs.boxStartIndex : Ht.collisionBoxArray.length, F2 = Cs ? Cs.boxEndIndex : Ht.collisionBoxArray.length, B2 = fn ? fn.boxStartIndex : Ht.collisionBoxArray.length, R2 = fn ? fn.boxEndIndex : Ht.collisionBoxArray.length;
            let Hs = -1;
            const jh = (Fn, rs) => Fn && Fn.circleDiameter ? Math.max(Fn.circleDiameter, rs) : rs;
            Hs = jh(zo, Hs), Hs = jh(is, Hs), Hs = jh(Cs, Hs), Hs = jh(fn, Hs);
            const Nm = Hs > -1 ? 1 : 0;
            Nm && (Hs *= ic / Vr), Ht.glyphOffsetArray.length >= Qu.MAX_GLYPHS && xe("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), lr.sortKey !== void 0 && Ht.addToSortKeyRanges(Ht.symbolInstances.length, lr.sortKey);
            const O2 = Sm(nn, lr, Dr), [j2, q2] = function(Fn, rs) {
              const xu = Fn.length, Ws = rs == null ? void 0 : rs.values;
              if ((Ws == null ? void 0 : Ws.length) > 0) for (let wu = 0; wu < Ws.length; wu += 2) {
                const Fo = Ws[wu + 1];
                Fn.emplaceBack(g.aq[Ws[wu]], Fo[0], Fo[1]);
              }
              return [xu, Fn.length];
            }(Ht.textAnchorOffsets, O2);
            Ht.symbolInstances.emplaceBack(_i.x, _i.y, yl.right >= 0 ? yl.right : -1, yl.center >= 0 ? yl.center : -1, yl.left >= 0 ? yl.left : -1, yl.vertical || -1, Qd, ep, Lm, P2, L2, M2, N2, z2, F2, B2, R2, Jn, km, Pm, _l, Xc, Nm, 0, an, Hs, j2, q2);
          }(i, Yt, dt, n, u, f, Vt, i.layers[0], i.collisionBoxArray, t.index, t.sourceLayerIndex, i.index, Se, [Ge, Ge, Ge, Ge], Bt, C, Xe, st, hi, J, t, _, L, R, b);
        };
        if (Ft === "line") for (const dt of mm(t.geometry, 0, 0, or, or)) {
          const Yt = S2(dt, Be, Tt, n.vertical || ne, u, 24, Pe, i.overscaling, or);
          for (const Ht of Yt) ne && I2(i, ne.text, Nt, Ht) || qt(dt, Ht);
        }
        else if (Ft === "line-center") {
          for (const dt of t.geometry) if (dt.length > 1) {
            const Yt = A2(dt, Tt, n.vertical || ne, u, 24, Pe);
            Yt && qt(dt, Yt);
          }
        } else if (t.type === "Polygon") for (const dt of Sa(t.geometry, 0)) {
          const Yt = T2(dt, 16);
          qt(dt[0], new Ul(Yt.x, Yt.y, 0));
        }
        else if (t.type === "LineString") for (const dt of t.geometry) qt(dt, new Ul(dt[0].x, dt[0].y, 0));
        else if (t.type === "Point") for (const dt of t.geometry) for (const Yt of dt) qt([Yt], new Ul(Yt.x, Yt.y, 0));
      }
      function Em(i, t, n, u, f, _, b, E, C, L, R, U, H, J, ne) {
        const he = function(Xe, Be, Ge, st, Tt, Bt, hi, Ft) {
          const Nt = st.layout.get("text-rotate").evaluate(Bt, {}) * Math.PI / 180, Xt = [];
          for (const Vt of Be.positionedLines) for (const qt of Vt.positionedGlyphs) {
            if (!qt.rect) continue;
            const dt = qt.rect || {};
            let Yt = qf + 1, Ht = !0, _i = 1, ir = 0;
            const Qi = (Tt || Ft) && qt.vertical, rn = qt.metrics.advance * qt.scale / 2;
            if (Ft && Be.verticalizable && (ir = Vt.lineOffset / 2 - (qt.imageName ? -(Vr - qt.metrics.width * qt.scale) / 2 : (qt.scale - 1) * Vr)), qt.imageName) {
              const Vi = hi[qt.imageName];
              Ht = Vi.sdf, _i = Vi.pixelRatio, Yt = _a / _i;
            }
            const Ts = Tt ? [qt.x + rn, qt.y] : [0, 0];
            let xn = Tt ? [0, 0] : [qt.x + rn + Ge[0], qt.y + Ge[1] - ir], nn = [0, 0];
            Qi && (nn = xn, xn = [0, 0]);
            const Yn = qt.metrics.isDoubleResolution ? 2 : 1, Jn = (qt.metrics.left - Yt) * qt.scale - rn + xn[0], Kn = (-qt.metrics.top - Yt) * qt.scale + xn[1], Lr = Jn + dt.w / Yn * qt.scale / _i, an = Kn + dt.h / Yn * qt.scale / _i, zn = new q(Jn, Kn), wn = new q(Lr, Kn), Qn = new q(Jn, an), An = new q(Lr, an);
            if (Qi) {
              const Vi = new q(-rn, rn - Uc), lr = -Math.PI / 2, fr = Vr / 2 - rn, za = new q(5 - Uc - fr, -(qt.imageName ? fr : 0)), Dr = new q(...nn);
              zn._rotateAround(lr, Vi)._add(za)._add(Dr), wn._rotateAround(lr, Vi)._add(za)._add(Dr), Qn._rotateAround(lr, Vi)._add(za)._add(Dr), An._rotateAround(lr, Vi)._add(za)._add(Dr);
            }
            if (Nt) {
              const Vi = Math.sin(Nt), lr = Math.cos(Nt), fr = [lr, -Vi, Vi, lr];
              zn._matMult(fr), wn._matMult(fr), Qn._matMult(fr), An._matMult(fr);
            }
            const ts = new q(0, 0), ya = new q(0, 0);
            Xt.push({ tl: zn, tr: wn, bl: Qn, br: An, tex: dt, writingMode: Be.writingMode, glyphOffset: Ts, sectionIndex: qt.sectionIndex, isSDF: Ht, pixelOffsetTL: ts, pixelOffsetBR: ya, minFontScaleX: 0, minFontScaleY: 0 });
          }
          return Xt;
        }(0, n, E, f, _, b, u, i.allowVerticalPlacement), Se = i.textSizeData;
        let Pe = null;
        Se.kind === "source" ? (Pe = [Mo * f.layout.get("text-size").evaluate(b, {})], Pe[0] > jl && xe(`${i.layerIds[0]}: Value for "text-size" is >= ${$c}. Reduce your "text-size".`)) : Se.kind === "composite" && (Pe = [Mo * J.compositeTextSizes[0].evaluate(b, {}, ne), Mo * J.compositeTextSizes[1].evaluate(b, {}, ne)], (Pe[0] > jl || Pe[1] > jl) && xe(`${i.layerIds[0]}: Value for "text-size" is >= ${$c}. Reduce your "text-size".`)), i.addSymbols(i.text, he, Pe, E, _, b, L, t, C.lineStartIndex, C.lineLength, H, ne);
        for (const Xe of R) U[Xe] = i.text.placedSymbolArray.length - 1;
        return 4 * he.length;
      }
      function Tm(i) {
        for (const t in i) return i[t];
        return null;
      }
      function I2(i, t, n, u) {
        const f = i.compareText;
        if (t in f) {
          const _ = f[t];
          for (let b = _.length - 1; b >= 0; b--) if (u.dist(_[b]) < n) return !0;
        } else f[t] = [];
        return f[t].push(u), !1;
      }
      const Cm = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class Gd {
        static from(t) {
          if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [n, u] = new Uint8Array(t, 0, 2);
          if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const f = u >> 4;
          if (f !== 1) throw new Error(`Got v${f} data when expected v1.`);
          const _ = Cm[15 & u];
          if (!_) throw new Error("Unrecognized array type.");
          const [b] = new Uint16Array(t, 2, 1), [E] = new Uint32Array(t, 4, 1);
          return new Gd(E, b, _, t);
        }
        constructor(t, n = 64, u = Float64Array, f) {
          if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
          this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = u, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
          const _ = Cm.indexOf(this.ArrayType), b = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, E = t * this.IndexArrayType.BYTES_PER_ELEMENT, C = (8 - E % 8) % 8;
          if (_ < 0) throw new Error(`Unexpected typed array class: ${u}.`);
          f && f instanceof ArrayBuffer ? (this.data = f, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + E + C, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + b + E + C), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + E + C, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + _]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
        }
        add(t, n) {
          const u = this._pos >> 1;
          return this.ids[u] = u, this.coords[this._pos++] = t, this.coords[this._pos++] = n, u;
        }
        finish() {
          const t = this._pos >> 1;
          if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
          return Hd(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(t, n, u, f) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: _, coords: b, nodeSize: E } = this, C = [0, _.length - 1, 0], L = [];
          for (; C.length; ) {
            const R = C.pop() || 0, U = C.pop() || 0, H = C.pop() || 0;
            if (U - H <= E) {
              for (let Se = H; Se <= U; Se++) {
                const Pe = b[2 * Se], Xe = b[2 * Se + 1];
                Pe >= t && Pe <= u && Xe >= n && Xe <= f && L.push(_[Se]);
              }
              continue;
            }
            const J = H + U >> 1, ne = b[2 * J], he = b[2 * J + 1];
            ne >= t && ne <= u && he >= n && he <= f && L.push(_[J]), (R === 0 ? t <= ne : n <= he) && (C.push(H), C.push(J - 1), C.push(1 - R)), (R === 0 ? u >= ne : f >= he) && (C.push(J + 1), C.push(U), C.push(1 - R));
          }
          return L;
        }
        within(t, n, u) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: f, coords: _, nodeSize: b } = this, E = [0, f.length - 1, 0], C = [], L = u * u;
          for (; E.length; ) {
            const R = E.pop() || 0, U = E.pop() || 0, H = E.pop() || 0;
            if (U - H <= b) {
              for (let Se = H; Se <= U; Se++) Im(_[2 * Se], _[2 * Se + 1], t, n) <= L && C.push(f[Se]);
              continue;
            }
            const J = H + U >> 1, ne = _[2 * J], he = _[2 * J + 1];
            Im(ne, he, t, n) <= L && C.push(f[J]), (R === 0 ? t - u <= ne : n - u <= he) && (E.push(H), E.push(J - 1), E.push(1 - R)), (R === 0 ? t + u >= ne : n + u >= he) && (E.push(J + 1), E.push(U), E.push(1 - R));
          }
          return C;
        }
      }
      function Hd(i, t, n, u, f, _) {
        if (f - u <= n) return;
        const b = u + f >> 1;
        Dm(i, t, b, u, f, _), Hd(i, t, n, u, b - 1, 1 - _), Hd(i, t, n, b + 1, f, 1 - _);
      }
      function Dm(i, t, n, u, f, _) {
        for (; f > u; ) {
          if (f - u > 600) {
            const L = f - u + 1, R = n - u + 1, U = Math.log(L), H = 0.5 * Math.exp(2 * U / 3), J = 0.5 * Math.sqrt(U * H * (L - H) / L) * (R - L / 2 < 0 ? -1 : 1);
            Dm(i, t, n, Math.max(u, Math.floor(n - R * H / L + J)), Math.min(f, Math.floor(n + (L - R) * H / L + J)), _);
          }
          const b = t[2 * n + _];
          let E = u, C = f;
          for (Hc(i, t, u, n), t[2 * f + _] > b && Hc(i, t, u, f); E < C; ) {
            for (Hc(i, t, E, C), E++, C--; t[2 * E + _] < b; ) E++;
            for (; t[2 * C + _] > b; ) C--;
          }
          t[2 * u + _] === b ? Hc(i, t, u, C) : (C++, Hc(i, t, C, f)), C <= n && (u = C + 1), n <= C && (f = C - 1);
        }
      }
      function Hc(i, t, n, u) {
        Wd(i, n, u), Wd(t, 2 * n, 2 * u), Wd(t, 2 * n + 1, 2 * u + 1);
      }
      function Wd(i, t, n) {
        const u = i[t];
        i[t] = i[n], i[n] = u;
      }
      function Im(i, t, n, u) {
        const f = i - n, _ = t - u;
        return f * f + _ * _;
      }
      var Xd;
      g.bg = void 0, (Xd = g.bg || (g.bg = {})).create = "create", Xd.load = "load", Xd.fullLoad = "fullLoad";
      let Oh = null, Wc = [];
      const Yd = 1e3 / 60, Jd = "loadTime", Kd = "fullLoadTime", k2 = { mark(i) {
        performance.mark(i);
      }, frame(i) {
        const t = i;
        Oh != null && Wc.push(t - Oh), Oh = t;
      }, clearMetrics() {
        Oh = null, Wc = [], performance.clearMeasures(Jd), performance.clearMeasures(Kd);
        for (const i in g.bg) performance.clearMarks(g.bg[i]);
      }, getPerformanceMetrics() {
        performance.measure(Jd, g.bg.create, g.bg.load), performance.measure(Kd, g.bg.create, g.bg.fullLoad);
        const i = performance.getEntriesByName(Jd)[0].duration, t = performance.getEntriesByName(Kd)[0].duration, n = Wc.length, u = 1 / (Wc.reduce((_, b) => _ + b, 0) / n / 1e3), f = Wc.filter((_) => _ > Yd).reduce((_, b) => _ + (b - Yd) / Yd, 0);
        return { loadTime: i, fullLoadTime: t, fps: u, percentDroppedFrames: f / (n + f) * 100, totalFrames: n };
      } };
      g.$ = class extends F {
      }, g.A = Hu, g.B = Sc, g.C = function(i) {
        if (He == null) {
          const t = i.navigator ? i.navigator.userAgent : null;
          He = !!i.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
        }
        return He;
      }, g.D = Gt, g.E = it, g.F = class {
        constructor(i, t) {
          this.target = i, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new x2(() => this.process()), this.subscription = function(n, u, f, _) {
            return n.addEventListener(u, f, !1), { unsubscribe: () => {
              n.removeEventListener(u, f, !1);
            } };
          }(this.target, "message", (n) => this.receive(n)), this.globalScope = Ve(self) ? i : window;
        }
        registerMessageHandler(i, t) {
          this.messageHandlers[i] = t;
        }
        sendAsync(i, t) {
          return new Promise((n, u) => {
            const f = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[f] = { resolve: n, reject: u }, t && t.signal.addEventListener("abort", () => {
              delete this.resolveRejects[f];
              const E = { id: f, type: "<cancel>", origin: location.origin, targetMapId: i.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(E);
            }, { once: !0 });
            const _ = [], b = Object.assign(Object.assign({}, i), { id: f, sourceMapId: this.mapId, origin: location.origin, data: So(i.data, _) });
            this.target.postMessage(b, { transfer: _ });
          });
        }
        receive(i) {
          const t = i.data, n = t.id;
          if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
            if (t.type === "<cancel>") {
              delete this.tasks[n];
              const u = this.abortControllers[n];
              return delete this.abortControllers[n], void (u && u.abort());
            }
            if (Ve(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
            this.processTask(n, t);
          }
        }
        process() {
          if (this.taskQueue.length === 0) return;
          const i = this.taskQueue.shift(), t = this.tasks[i];
          delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(i, t);
        }
        processTask(i, t) {
          return s(this, void 0, void 0, function* () {
            if (t.type === "<response>") {
              const f = this.resolveRejects[i];
              return delete this.resolveRejects[i], f ? void (t.error ? f.reject(Vs(t.error)) : f.resolve(Vs(t.data))) : void 0;
            }
            if (!this.messageHandlers[t.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const n = Vs(t.data), u = new AbortController();
            this.abortControllers[i] = u;
            try {
              const f = yield this.messageHandlers[t.type](t.sourceMapId, n, u);
              this.completeTask(i, null, f);
            } catch (f) {
              this.completeTask(i, f);
            }
          });
        }
        completeTask(i, t, n) {
          const u = [];
          delete this.abortControllers[i];
          const f = { id: i, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? So(t) : null, data: So(n, u) };
          this.target.postMessage(f, { transfer: u });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, g.G = Oe, g.H = function() {
        var i = new Hu(16);
        return Hu != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i;
      }, g.I = Md, g.J = function(i, t, n) {
        var u, f, _, b, E, C, L, R, U, H, J, ne, he = n[0], Se = n[1], Pe = n[2];
        return t === i ? (i[12] = t[0] * he + t[4] * Se + t[8] * Pe + t[12], i[13] = t[1] * he + t[5] * Se + t[9] * Pe + t[13], i[14] = t[2] * he + t[6] * Se + t[10] * Pe + t[14], i[15] = t[3] * he + t[7] * Se + t[11] * Pe + t[15]) : (f = t[1], _ = t[2], b = t[3], E = t[4], C = t[5], L = t[6], R = t[7], U = t[8], H = t[9], J = t[10], ne = t[11], i[0] = u = t[0], i[1] = f, i[2] = _, i[3] = b, i[4] = E, i[5] = C, i[6] = L, i[7] = R, i[8] = U, i[9] = H, i[10] = J, i[11] = ne, i[12] = u * he + E * Se + U * Pe + t[12], i[13] = f * he + C * Se + H * Pe + t[13], i[14] = _ * he + L * Se + J * Pe + t[14], i[15] = b * he + R * Se + ne * Pe + t[15]), i;
      }, g.K = function(i, t, n) {
        var u = n[0], f = n[1], _ = n[2];
        return i[0] = t[0] * u, i[1] = t[1] * u, i[2] = t[2] * u, i[3] = t[3] * u, i[4] = t[4] * f, i[5] = t[5] * f, i[6] = t[6] * f, i[7] = t[7] * f, i[8] = t[8] * _, i[9] = t[9] * _, i[10] = t[10] * _, i[11] = t[11] * _, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
      }, g.L = uf, g.M = function(i, t) {
        const n = {};
        for (let u = 0; u < t.length; u++) {
          const f = t[u];
          f in i && (n[f] = i[f]);
        }
        return n;
      }, g.N = ql, g.O = nm, g.P = q, g.Q = am, g.R = Qa, g.S = es, g.T = zl, g.U = ee, g.V = fe, g.W = Je, g.X = or, g.Y = x, g.Z = Zc, g._ = s, g.a = be, g.a$ = function(i, t) {
        var n = i[0], u = i[1], f = i[2], _ = i[3], b = i[4], E = i[5], C = i[6], L = i[7], R = i[8], U = i[9], H = i[10], J = i[11], ne = i[12], he = i[13], Se = i[14], Pe = i[15], Xe = t[0], Be = t[1], Ge = t[2], st = t[3], Tt = t[4], Bt = t[5], hi = t[6], Ft = t[7], Nt = t[8], Xt = t[9], Vt = t[10], qt = t[11], dt = t[12], Yt = t[13], Ht = t[14], _i = t[15];
        return Math.abs(n - Xe) <= Xn * Math.max(1, Math.abs(n), Math.abs(Xe)) && Math.abs(u - Be) <= Xn * Math.max(1, Math.abs(u), Math.abs(Be)) && Math.abs(f - Ge) <= Xn * Math.max(1, Math.abs(f), Math.abs(Ge)) && Math.abs(_ - st) <= Xn * Math.max(1, Math.abs(_), Math.abs(st)) && Math.abs(b - Tt) <= Xn * Math.max(1, Math.abs(b), Math.abs(Tt)) && Math.abs(E - Bt) <= Xn * Math.max(1, Math.abs(E), Math.abs(Bt)) && Math.abs(C - hi) <= Xn * Math.max(1, Math.abs(C), Math.abs(hi)) && Math.abs(L - Ft) <= Xn * Math.max(1, Math.abs(L), Math.abs(Ft)) && Math.abs(R - Nt) <= Xn * Math.max(1, Math.abs(R), Math.abs(Nt)) && Math.abs(U - Xt) <= Xn * Math.max(1, Math.abs(U), Math.abs(Xt)) && Math.abs(H - Vt) <= Xn * Math.max(1, Math.abs(H), Math.abs(Vt)) && Math.abs(J - qt) <= Xn * Math.max(1, Math.abs(J), Math.abs(qt)) && Math.abs(ne - dt) <= Xn * Math.max(1, Math.abs(ne), Math.abs(dt)) && Math.abs(he - Yt) <= Xn * Math.max(1, Math.abs(he), Math.abs(Yt)) && Math.abs(Se - Ht) <= Xn * Math.max(1, Math.abs(Se), Math.abs(Ht)) && Math.abs(Pe - _i) <= Xn * Math.max(1, Math.abs(Pe), Math.abs(_i));
      }, g.a0 = Li, g.a1 = Vd, g.a2 = pt, g.a3 = (i) => {
        const t = window.document.createElement("video");
        return t.muted = !0, new Promise((n) => {
          t.onloadstart = () => {
            n(t);
          };
          for (const u of i) {
            const f = window.document.createElement("source");
            rt(u) || (t.crossOrigin = "Anonymous"), f.src = u, t.appendChild(f);
          }
        });
      }, g.a4 = function() {
        return Ae++;
      }, g.a5 = Dt, g.a6 = Qu, g.a7 = pa, g.a8 = ko, g.a9 = hm, g.aA = function(i) {
        if (i.type === "custom") return new b2(i);
        switch (i.type) {
          case "background":
            return new _2(i);
          case "circle":
            return new n1(i);
          case "fill":
            return new x1(i);
          case "fill-extrusion":
            return new F1(i);
          case "heatmap":
            return new s1(i);
          case "hillshade":
            return new l1(i);
          case "line":
            return new $1(i);
          case "raster":
            return new v2(i);
          case "symbol":
            return new Nh(i);
        }
      }, g.aB = X, g.aC = function(i, t) {
        if (!i) return [{ command: "setStyle", args: [t] }];
        let n = [];
        try {
          if (!lt(i.version, t.version)) return [{ command: "setStyle", args: [t] }];
          lt(i.center, t.center) || n.push({ command: "setCenter", args: [t.center] }), lt(i.zoom, t.zoom) || n.push({ command: "setZoom", args: [t.zoom] }), lt(i.bearing, t.bearing) || n.push({ command: "setBearing", args: [t.bearing] }), lt(i.pitch, t.pitch) || n.push({ command: "setPitch", args: [t.pitch] }), lt(i.sprite, t.sprite) || n.push({ command: "setSprite", args: [t.sprite] }), lt(i.glyphs, t.glyphs) || n.push({ command: "setGlyphs", args: [t.glyphs] }), lt(i.transition, t.transition) || n.push({ command: "setTransition", args: [t.transition] }), lt(i.light, t.light) || n.push({ command: "setLight", args: [t.light] }), lt(i.terrain, t.terrain) || n.push({ command: "setTerrain", args: [t.terrain] }), lt(i.sky, t.sky) || n.push({ command: "setSky", args: [t.sky] }), lt(i.projection, t.projection) || n.push({ command: "setProjection", args: [t.projection] });
          const u = {}, f = [];
          (function(b, E, C, L) {
            let R;
            for (R in E = E || {}, b = b || {}) Object.prototype.hasOwnProperty.call(b, R) && (Object.prototype.hasOwnProperty.call(E, R) || Et(R, C, L));
            for (R in E) Object.prototype.hasOwnProperty.call(E, R) && (Object.prototype.hasOwnProperty.call(b, R) ? lt(b[R], E[R]) || (b[R].type === "geojson" && E[R].type === "geojson" && ni(b, E, R) ? xt(C, { command: "setGeoJSONSourceData", args: [R, E[R].data] }) : jt(R, E, C, L)) : At(R, E, C));
          })(i.sources, t.sources, f, u);
          const _ = [];
          i.layers && i.layers.forEach((b) => {
            "source" in b && u[b.source] ? n.push({ command: "removeLayer", args: [b.id] }) : _.push(b);
          }), n = n.concat(f), function(b, E, C) {
            E = E || [];
            const L = (b = b || []).map(yi), R = E.map(yi), U = b.reduce(xi, {}), H = E.reduce(xi, {}), J = L.slice(), ne = /* @__PURE__ */ Object.create(null);
            let he, Se, Pe, Xe, Be;
            for (let Ge = 0, st = 0; Ge < L.length; Ge++) he = L[Ge], Object.prototype.hasOwnProperty.call(H, he) ? st++ : (xt(C, { command: "removeLayer", args: [he] }), J.splice(J.indexOf(he, st), 1));
            for (let Ge = 0, st = 0; Ge < R.length; Ge++) he = R[R.length - 1 - Ge], J[J.length - 1 - Ge] !== he && (Object.prototype.hasOwnProperty.call(U, he) ? (xt(C, { command: "removeLayer", args: [he] }), J.splice(J.lastIndexOf(he, J.length - st), 1)) : st++, Xe = J[J.length - Ge], xt(C, { command: "addLayer", args: [H[he], Xe] }), J.splice(J.length - Ge, 0, he), ne[he] = !0);
            for (let Ge = 0; Ge < R.length; Ge++) if (he = R[Ge], Se = U[he], Pe = H[he], !ne[he] && !lt(Se, Pe)) if (lt(Se.source, Pe.source) && lt(Se["source-layer"], Pe["source-layer"]) && lt(Se.type, Pe.type)) {
              for (Be in ii(Se.layout, Pe.layout, C, he, null, "setLayoutProperty"), ii(Se.paint, Pe.paint, C, he, null, "setPaintProperty"), lt(Se.filter, Pe.filter) || xt(C, { command: "setFilter", args: [he, Pe.filter] }), lt(Se.minzoom, Pe.minzoom) && lt(Se.maxzoom, Pe.maxzoom) || xt(C, { command: "setLayerZoomRange", args: [he, Pe.minzoom, Pe.maxzoom] }), Se) Object.prototype.hasOwnProperty.call(Se, Be) && Be !== "layout" && Be !== "paint" && Be !== "filter" && Be !== "metadata" && Be !== "minzoom" && Be !== "maxzoom" && (Be.indexOf("paint.") === 0 ? ii(Se[Be], Pe[Be], C, he, Be.slice(6), "setPaintProperty") : lt(Se[Be], Pe[Be]) || xt(C, { command: "setLayerProperty", args: [he, Be, Pe[Be]] }));
              for (Be in Pe) Object.prototype.hasOwnProperty.call(Pe, Be) && !Object.prototype.hasOwnProperty.call(Se, Be) && Be !== "layout" && Be !== "paint" && Be !== "filter" && Be !== "metadata" && Be !== "minzoom" && Be !== "maxzoom" && (Be.indexOf("paint.") === 0 ? ii(Se[Be], Pe[Be], C, he, Be.slice(6), "setPaintProperty") : lt(Se[Be], Pe[Be]) || xt(C, { command: "setLayerProperty", args: [he, Be, Pe[Be]] }));
            } else xt(C, { command: "removeLayer", args: [he] }), Xe = J[J.lastIndexOf(he) + 1], xt(C, { command: "addLayer", args: [Pe, Xe] });
          }(_, t.layers, n);
        } catch (u) {
          console.warn("Unable to compute style diff:", u), n = [{ command: "setStyle", args: [t] }];
        }
        return n;
      }, g.aD = function(i) {
        const t = [], n = i.id;
        return n === void 0 && t.push({ message: `layers.${n}: missing required property "id"` }), i.render === void 0 && t.push({ message: `layers.${n}: missing required method "render"` }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && t.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), t;
      }, g.aE = function i(t, n) {
        if (Array.isArray(t)) {
          if (!Array.isArray(n) || t.length !== n.length) return !1;
          for (let u = 0; u < t.length; u++) if (!i(t[u], n[u])) return !1;
          return !0;
        }
        if (typeof t == "object" && t !== null && n !== null) {
          if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return !1;
          for (const u in t) if (!i(t[u], n[u])) return !1;
          return !0;
        }
        return t === n;
      }, g.aF = me, g.aG = ve, g.aH = class extends Do {
        constructor(i, t) {
          super(i, t), this.current = 0;
        }
        set(i) {
          this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i));
        }
      }, g.aI = mu, g.aJ = class extends Do {
        constructor(i, t) {
          super(i, t), this.current = _u;
        }
        set(i) {
          if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
          for (let t = 1; t < 16; t++) if (i[t] !== this.current[t]) {
            this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
            break;
          }
        }
      }, g.aK = gu, g.aL = qu, g.aM = ji, g.aN = class extends Do {
        constructor(i, t) {
          super(i, t), this.current = [0, 0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]));
        }
      }, g.aO = class extends Do {
        constructor(i, t) {
          super(i, t), this.current = [0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]));
        }
      }, g.aP = function(i, t, n, u, f, _, b) {
        var E = 1 / (t - n), C = 1 / (u - f), L = 1 / (_ - b);
        return i[0] = -2 * E, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * C, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * L, i[11] = 0, i[12] = (t + n) * E, i[13] = (f + u) * C, i[14] = (b + _) * L, i[15] = 1, i;
      }, g.aQ = r1, g.aR = class extends we {
      }, g.aS = W1, g.aT = class extends ke {
      }, g.aU = xd, g.aV = function(i) {
        return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
      }, g.aW = ff, g.aX = pr, g.aY = en, g.aZ = class extends St {
      }, g.a_ = function(i, t) {
        return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15];
      }, g.aa = function(i) {
        const t = {};
        if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (n, u, f, _) => {
          const b = f || _;
          return t[u] = !b || b.toLowerCase(), "";
        }), t["max-age"]) {
          const n = parseInt(t["max-age"], 10);
          isNaN(n) ? delete t["max-age"] : t["max-age"] = n;
        }
        return t;
      }, g.ab = function(i, t) {
        const n = [];
        for (const u in i) u in t || n.push(u);
        return n;
      }, g.ac = qe, g.ad = function(i, t, n) {
        var u = Math.sin(n), f = Math.cos(n), _ = t[0], b = t[1], E = t[2], C = t[3], L = t[4], R = t[5], U = t[6], H = t[7];
        return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = _ * f + L * u, i[1] = b * f + R * u, i[2] = E * f + U * u, i[3] = C * f + H * u, i[4] = L * f - _ * u, i[5] = R * f - b * u, i[6] = U * f - E * u, i[7] = H * f - C * u, i;
      }, g.ae = function(i) {
        var t = new Hu(16);
        return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], t;
      }, g.af = Eh, g.ag = function(i, t) {
        let n = 0, u = 0;
        if (i.kind === "constant") u = i.layoutSize;
        else if (i.kind !== "source") {
          const { interpolationType: f, minZoom: _, maxZoom: b } = i, E = f ? qe(si.interpolationFactor(f, t, _, b), 0, 1) : 0;
          i.kind === "camera" ? u = jr.number(i.minSize, i.maxSize, E) : n = E;
        }
        return { uSizeT: n, uSize: u };
      }, g.ai = function(i, { uSize: t, uSizeT: n }, { lowerSize: u, upperSize: f }) {
        return i.kind === "source" ? u / Mo : i.kind === "composite" ? jr.number(u / Mo, f / Mo, n) : t;
      }, g.aj = Bd, g.ak = function(i, t, n, u) {
        const f = t.y - i.y, _ = t.x - i.x, b = u.y - n.y, E = u.x - n.x, C = b * _ - E * f;
        if (C === 0) return null;
        const L = (E * (i.y - n.y) - b * (i.x - n.x)) / C;
        return new q(i.x + L * _, i.y + L * f);
      }, g.al = mm, g.am = $u, g.an = yd, g.ao = function(i) {
        let t = 1 / 0, n = 1 / 0, u = -1 / 0, f = -1 / 0;
        for (const _ of i) t = Math.min(t, _.x), n = Math.min(n, _.y), u = Math.max(u, _.x), f = Math.max(f, _.y);
        return [t, n, u, f];
      }, g.ap = Vr, g.ar = Fd, g.as = function(i, t) {
        var n = t[0], u = t[1], f = t[2], _ = t[3], b = t[4], E = t[5], C = t[6], L = t[7], R = t[8], U = t[9], H = t[10], J = t[11], ne = t[12], he = t[13], Se = t[14], Pe = t[15], Xe = n * E - u * b, Be = n * C - f * b, Ge = n * L - _ * b, st = u * C - f * E, Tt = u * L - _ * E, Bt = f * L - _ * C, hi = R * he - U * ne, Ft = R * Se - H * ne, Nt = R * Pe - J * ne, Xt = U * Se - H * he, Vt = U * Pe - J * he, qt = H * Pe - J * Se, dt = Xe * qt - Be * Vt + Ge * Xt + st * Nt - Tt * Ft + Bt * hi;
        return dt ? (i[0] = (E * qt - C * Vt + L * Xt) * (dt = 1 / dt), i[1] = (f * Vt - u * qt - _ * Xt) * dt, i[2] = (he * Bt - Se * Tt + Pe * st) * dt, i[3] = (H * Tt - U * Bt - J * st) * dt, i[4] = (C * Nt - b * qt - L * Ft) * dt, i[5] = (n * qt - f * Nt + _ * Ft) * dt, i[6] = (Se * Ge - ne * Bt - Pe * Be) * dt, i[7] = (R * Bt - H * Ge + J * Be) * dt, i[8] = (b * Vt - E * Nt + L * hi) * dt, i[9] = (u * Nt - n * Vt - _ * hi) * dt, i[10] = (ne * Tt - he * Ge + Pe * Xe) * dt, i[11] = (U * Ge - R * Tt - J * Xe) * dt, i[12] = (E * Ft - b * Xt - C * hi) * dt, i[13] = (n * Xt - u * Ft + f * hi) * dt, i[14] = (he * Be - ne * st - Se * Xe) * dt, i[15] = (R * st - U * Be + H * Xe) * dt, i) : null;
      }, g.at = Zd, g.au = zd, g.av = Gd, g.aw = function() {
        const i = {}, t = Y.$version;
        for (const n in Y.$root) {
          const u = Y.$root[n];
          if (u.required) {
            let f = null;
            f = n === "version" ? t : u.type === "array" ? [] : {}, f != null && (i[n] = f);
          }
        }
        return i;
      }, g.ax = La, g.ay = Ue, g.az = function(i) {
        i = i.slice();
        const t = /* @__PURE__ */ Object.create(null);
        for (let n = 0; n < i.length; n++) t[i[n].id] = i[n];
        for (let n = 0; n < i.length; n++) "ref" in i[n] && (i[n] = Rt(i[n], t[i[n].ref]));
        return i;
      }, g.b = Ze, g.b0 = function(i, t) {
        return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
      }, g.b1 = function(i, t, n) {
        return i[0] = t[0] * n[0], i[1] = t[1] * n[1], i[2] = t[2] * n[2], i[3] = t[3] * n[3], i;
      }, g.b2 = function(i, t) {
        return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3] * t[3];
      }, g.b3 = at, g.b4 = lm, g.b5 = sm, g.b6 = function(i, t, n, u, f) {
        var _, b = 1 / Math.tan(t / 2);
        return i[0] = b / n, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = b, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, f != null && f !== 1 / 0 ? (i[10] = (f + u) * (_ = 1 / (u - f)), i[14] = 2 * f * u * _) : (i[10] = -1, i[14] = -2 * u), i;
      }, g.b7 = function(i, t, n) {
        var u = Math.sin(n), f = Math.cos(n), _ = t[4], b = t[5], E = t[6], C = t[7], L = t[8], R = t[9], U = t[10], H = t[11];
        return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = _ * f + L * u, i[5] = b * f + R * u, i[6] = E * f + U * u, i[7] = C * f + H * u, i[8] = L * f - _ * u, i[9] = R * f - b * u, i[10] = U * f - E * u, i[11] = H * f - C * u, i;
      }, g.b8 = Te, g.b9 = ze, g.bA = Nf, g.bB = function(i) {
        return i.message === Q;
      }, g.bC = Kr, g.bD = Pn, g.ba = function(i) {
        return i * Math.PI / 180;
      }, g.bb = function(i, t) {
        const { x: n, y: u } = Zc.fromLngLat(t);
        return !(i < 0 || i > 25 || u < 0 || u >= 1 || n < 0 || n >= 1);
      }, g.bc = function(i, t) {
        return i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }, g.bd = class extends P {
      }, g.be = qd, g.bf = k2, g.bh = $e, g.bi = function(i, t) {
        be.REGISTERED_PROTOCOLS[i] = t;
      }, g.bj = function(i) {
        delete be.REGISTERED_PROTOCOLS[i];
      }, g.bk = function(i, t) {
        const n = {};
        for (let f = 0; f < i.length; f++) {
          const _ = t && t[i[f].id] || nu(i[f]);
          t && (t[i[f].id] = _);
          let b = n[_];
          b || (b = n[_] = []), b.push(i[f]);
        }
        const u = [];
        for (const f in n) u.push(n[f]);
        return u;
      }, g.bl = Ot, g.bm = cm, g.bn = dm, g.bo = Vf, g.bp = function(i) {
        i.bucket.createArrays(), i.bucket.tilePixelRatio = or / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
        const t = i.bucket.layers[0], n = t.layout, u = t._unevaluatedLayout._values, f = { layoutIconSize: u["icon-size"].possiblyEvaluate(new Ji(i.bucket.zoom + 1), i.canonical), layoutTextSize: u["text-size"].possiblyEvaluate(new Ji(i.bucket.zoom + 1), i.canonical), textMaxSize: u["text-size"].possiblyEvaluate(new Ji(18)) };
        if (i.bucket.textSizeData.kind === "composite") {
          const { minZoom: L, maxZoom: R } = i.bucket.textSizeData;
          f.compositeTextSizes = [u["text-size"].possiblyEvaluate(new Ji(L), i.canonical), u["text-size"].possiblyEvaluate(new Ji(R), i.canonical)];
        }
        if (i.bucket.iconSizeData.kind === "composite") {
          const { minZoom: L, maxZoom: R } = i.bucket.iconSizeData;
          f.compositeIconSizes = [u["icon-size"].possiblyEvaluate(new Ji(L), i.canonical), u["icon-size"].possiblyEvaluate(new Ji(R), i.canonical)];
        }
        const _ = n.get("text-line-height") * Vr, b = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", E = n.get("text-keep-upright"), C = n.get("text-size");
        for (const L of i.bucket.features) {
          const R = n.get("text-font").evaluate(L, {}, i.canonical).join(","), U = C.evaluate(L, {}, i.canonical), H = f.layoutTextSize.evaluate(L, {}, i.canonical), J = f.layoutIconSize.evaluate(L, {}, i.canonical), ne = { horizontal: {}, vertical: void 0 }, he = L.text;
          let Se, Pe = [0, 0];
          if (he) {
            const Ge = he.toString(), st = n.get("text-letter-spacing").evaluate(L, {}, i.canonical) * Vr, Tt = Ec(Ge) ? st : 0, Bt = n.get("text-anchor").evaluate(L, {}, i.canonical), hi = Sm(t, L, i.canonical);
            if (!hi) {
              const Vt = n.get("text-radial-offset").evaluate(L, {}, i.canonical);
              Pe = Vt ? Am(Bt, [Vt * Vr, $d]) : n.get("text-offset").evaluate(L, {}, i.canonical).map((qt) => qt * Vr);
            }
            let Ft = b ? "center" : n.get("text-justify").evaluate(L, {}, i.canonical);
            const Nt = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(L, {}, i.canonical) * Vr : 1 / 0, Xt = () => {
              i.bucket.allowVerticalPlacement && hu(Ge) && (ne.vertical = Ph(he, i.glyphMap, i.glyphPositions, i.imagePositions, R, Nt, _, Bt, "left", Tt, Pe, g.ah.vertical, !0, H, U));
            };
            if (!b && hi) {
              const Vt = /* @__PURE__ */ new Set();
              if (Ft === "auto") for (let dt = 0; dt < hi.values.length; dt += 2) Vt.add(Zd(hi.values[dt]));
              else Vt.add(Ft);
              let qt = !1;
              for (const dt of Vt) if (!ne.horizontal[dt]) if (qt) ne.horizontal[dt] = ne.horizontal[0];
              else {
                const Yt = Ph(he, i.glyphMap, i.glyphPositions, i.imagePositions, R, Nt, _, "center", dt, Tt, Pe, g.ah.horizontal, !1, H, U);
                Yt && (ne.horizontal[dt] = Yt, qt = Yt.positionedLines.length === 1);
              }
              Xt();
            } else {
              Ft === "auto" && (Ft = Zd(Bt));
              const Vt = Ph(he, i.glyphMap, i.glyphPositions, i.imagePositions, R, Nt, _, Bt, Ft, Tt, Pe, g.ah.horizontal, !1, H, U);
              Vt && (ne.horizontal[Ft] = Vt), Xt(), hu(Ge) && b && E && (ne.vertical = Ph(he, i.glyphMap, i.glyphPositions, i.imagePositions, R, Nt, _, Bt, Ft, Tt, Pe, g.ah.vertical, !1, H, U));
            }
          }
          let Xe = !1;
          if (L.icon && L.icon.name) {
            const Ge = i.imageMap[L.icon.name];
            Ge && (Se = d2(i.imagePositions[L.icon.name], n.get("icon-offset").evaluate(L, {}, i.canonical), n.get("icon-anchor").evaluate(L, {}, i.canonical)), Xe = !!Ge.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = Xe : i.bucket.sdfIcons !== Xe && xe("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ge.pixelRatio !== i.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0));
          }
          const Be = Tm(ne.horizontal) || ne.vertical;
          i.bucket.iconsInText = !!Be && Be.iconsInText, (Be || Se) && D2(i.bucket, L, ne, Se, i.imageMap, f, H, J, Pe, Xe, i.canonical);
        }
        i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers();
      }, g.bq = Id, g.br = Td, g.bs = Dd, g.bt = Rl, g.bu = Pd, g.bv = class {
        constructor(i) {
          this._marks = { start: [i.url, "start"].join("#"), end: [i.url, "end"].join("#"), measure: i.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let i = performance.getEntriesByName(this._marks.measure);
          return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i;
        }
      }, g.bw = function(i, t, n, u, f) {
        return s(this, void 0, void 0, function* () {
          if (fe()) try {
            return yield Je(i, t, n, u, f);
          } catch {
          }
          return function(_, b, E, C, L) {
            const R = _.width, U = _.height;
            Qe && nt || (Qe = new OffscreenCanvas(R, U), nt = Qe.getContext("2d", { willReadFrequently: !0 })), Qe.width = R, Qe.height = U, nt.drawImage(_, 0, 0, R, U);
            const H = nt.getImageData(b, E, C, L);
            return nt.clearRect(0, 0, R, U), H.data;
          }(i, t, n, u, f);
        });
      }, g.bx = um, g.by = D, g.bz = k, g.c = _e, g.d = (i) => s(void 0, void 0, void 0, function* () {
        if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
        const t = new Blob([new Uint8Array(i)], { type: "image/png" });
        try {
          return createImageBitmap(t);
        } catch (n) {
          throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), g.e = Ie, g.f = (i) => new Promise((t, n) => {
        const u = new Image();
        u.onload = () => {
          t(u), URL.revokeObjectURL(u.src), u.onload = null, window.requestAnimationFrame(() => {
            u.src = je;
          });
        }, u.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const f = new Blob([new Uint8Array(i)], { type: "image/png" });
        u.src = i.byteLength ? URL.createObjectURL(f) : je;
      }), g.g = Ce, g.h = (i, t) => Ke(Ie(i, { type: "json" }), t), g.i = Ve, g.j = Pt, g.k = mt, g.l = (i, t) => Ke(Ie(i, { type: "arrayBuffer" }), t), g.m = Ke, g.n = function(i) {
        return new Pd(i).readFields(a2, []);
      }, g.o = zc, g.p = Uf, g.q = c, g.r = sl, g.s = rt, g.t = cu, g.u = Xa, g.v = Y, g.w = xe, g.x = function([i, t, n]) {
        return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, { x: i * Math.cos(t) * Math.sin(n), y: i * Math.sin(t) * Math.sin(n), z: i * Math.cos(n) };
      }, g.y = jr, g.z = Ji;
    }), w("worker", ["./shared"], function(g) {
      class s {
        constructor(B) {
          this.keyCache = {}, B && this.replace(B);
        }
        replace(B) {
          this._layerConfigs = {}, this._layers = {}, this.update(B, []);
        }
        update(B, j) {
          for (const ge of B) {
            this._layerConfigs[ge.id] = ge;
            const Me = this._layers[ge.id] = g.aA(ge);
            Me._featureFilter = g.a7(Me.filter), this.keyCache[ge.id] && delete this.keyCache[ge.id];
          }
          for (const ge of j) delete this.keyCache[ge], delete this._layerConfigs[ge], delete this._layers[ge];
          this.familiesBySource = {};
          const te = g.bk(Object.values(this._layerConfigs), this.keyCache);
          for (const ge of te) {
            const Me = ge.map((We) => this._layers[We.id]), Fe = Me[0];
            if (Fe.visibility === "none") continue;
            const Ne = Fe.source || "";
            let De = this.familiesBySource[Ne];
            De || (De = this.familiesBySource[Ne] = {});
            const et = Fe.sourceLayer || "_geojsonTileLayer";
            let ut = De[et];
            ut || (ut = De[et] = []), ut.push(Me);
          }
        }
      }
      class D {
        constructor(B) {
          const j = {}, te = [];
          for (const Ne in B) {
            const De = B[Ne], et = j[Ne] = {};
            for (const ut in De) {
              const We = De[+ut];
              if (!We || We.bitmap.width === 0 || We.bitmap.height === 0) continue;
              const gt = { x: 0, y: 0, w: We.bitmap.width + 2, h: We.bitmap.height + 2 };
              te.push(gt), et[ut] = { rect: gt, metrics: We.metrics };
            }
          }
          const { w: ge, h: Me } = g.p(te), Fe = new g.o({ width: ge || 1, height: Me || 1 });
          for (const Ne in B) {
            const De = B[Ne];
            for (const et in De) {
              const ut = De[+et];
              if (!ut || ut.bitmap.width === 0 || ut.bitmap.height === 0) continue;
              const We = j[Ne][et].rect;
              g.o.copy(ut.bitmap, Fe, { x: 0, y: 0 }, { x: We.x + 1, y: We.y + 1 }, ut.bitmap);
            }
          }
          this.image = Fe, this.positions = j;
        }
      }
      g.bl("GlyphAtlas", D);
      class k {
        constructor(B) {
          this.tileID = new g.S(B.tileID.overscaledZ, B.tileID.wrap, B.tileID.canonical.z, B.tileID.canonical.x, B.tileID.canonical.y), this.uid = B.uid, this.zoom = B.zoom, this.pixelRatio = B.pixelRatio, this.tileSize = B.tileSize, this.source = B.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = B.showCollisionBoxes, this.collectResourceTiming = !!B.collectResourceTiming, this.returnDependencies = !!B.returnDependencies, this.promoteId = B.promoteId, this.inFlightDependencies = [];
        }
        parse(B, j, te, ge) {
          return g._(this, void 0, void 0, function* () {
            this.status = "parsing", this.data = B, this.collisionBoxArray = new g.a5();
            const Me = new g.bm(Object.keys(B.layers).sort()), Fe = new g.bn(this.tileID, this.promoteId);
            Fe.bucketLayerIDs = [];
            const Ne = {}, De = { featureIndex: Fe, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: te }, et = j.familiesBySource[this.source];
            for (const mi in et) {
              const Bi = B.layers[mi];
              if (!Bi) continue;
              Bi.version === 1 && g.w(`Vector tile source "${this.source}" layer "${mi}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const Hi = Me.encode(mi), mr = [];
              for (let vr = 0; vr < Bi.length; vr++) {
                const kr = Bi.feature(vr), Oa = Fe.getId(kr, mi);
                mr.push({ feature: kr, id: Oa, index: vr, sourceLayerIndex: Hi });
              }
              for (const vr of et[mi]) {
                const kr = vr[0];
                kr.source !== this.source && g.w(`layer.source = ${kr.source} does not equal this.source = ${this.source}`), kr.minzoom && this.zoom < Math.floor(kr.minzoom) || kr.maxzoom && this.zoom >= kr.maxzoom || kr.visibility !== "none" && (M(vr, this.zoom, te), (Ne[kr.id] = kr.createBucket({ index: Fe.bucketLayerIDs.length, layers: vr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Hi, sourceID: this.source })).populate(mr, De, this.tileID.canonical), Fe.bucketLayerIDs.push(vr.map((Oa) => Oa.id)));
              }
            }
            const ut = g.aF(De.glyphDependencies, (mi) => Object.keys(mi).map(Number));
            this.inFlightDependencies.forEach((mi) => mi == null ? void 0 : mi.abort()), this.inFlightDependencies = [];
            let We = Promise.resolve({});
            if (Object.keys(ut).length) {
              const mi = new AbortController();
              this.inFlightDependencies.push(mi), We = ge.sendAsync({ type: "GG", data: { stacks: ut, source: this.source, tileID: this.tileID, type: "glyphs" } }, mi);
            }
            const gt = Object.keys(De.iconDependencies);
            let Mt = Promise.resolve({});
            if (gt.length) {
              const mi = new AbortController();
              this.inFlightDependencies.push(mi), Mt = ge.sendAsync({ type: "GI", data: { icons: gt, source: this.source, tileID: this.tileID, type: "icons" } }, mi);
            }
            const $t = Object.keys(De.patternDependencies);
            let Qt = Promise.resolve({});
            if ($t.length) {
              const mi = new AbortController();
              this.inFlightDependencies.push(mi), Qt = ge.sendAsync({ type: "GI", data: { icons: $t, source: this.source, tileID: this.tileID, type: "patterns" } }, mi);
            }
            const [ei, pi, fi] = yield Promise.all([We, Mt, Qt]), Wi = new D(ei), Oi = new g.bo(pi, fi);
            for (const mi in Ne) {
              const Bi = Ne[mi];
              Bi instanceof g.a6 ? (M(Bi.layers, this.zoom, te), g.bp({ bucket: Bi, glyphMap: ei, glyphPositions: Wi.positions, imageMap: pi, imagePositions: Oi.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : Bi.hasPattern && (Bi instanceof g.bq || Bi instanceof g.br || Bi instanceof g.bs) && (M(Bi.layers, this.zoom, te), Bi.addFeatures(De, this.tileID.canonical, Oi.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(Ne).filter((mi) => !mi.isEmpty()), featureIndex: Fe, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Wi.image, imageAtlas: Oi, glyphMap: this.returnDependencies ? ei : null, iconMap: this.returnDependencies ? pi : null, glyphPositions: this.returnDependencies ? Wi.positions : null };
          });
        }
      }
      function M($, B, j) {
        const te = new g.z(B);
        for (const ge of $) ge.recalculate(te, j);
      }
      class q {
        constructor(B, j, te) {
          this.actor = B, this.layerIndex = j, this.availableImages = te, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(B, j) {
          return g._(this, void 0, void 0, function* () {
            const te = yield g.l(B.request, j);
            try {
              return { vectorTile: new g.bt.VectorTile(new g.bu(te.data)), rawData: te.data, cacheControl: te.cacheControl, expires: te.expires };
            } catch (ge) {
              const Me = new Uint8Array(te.data);
              let Fe = `Unable to parse the tile at ${B.request.url}, `;
              throw Fe += Me[0] === 31 && Me[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ge.message}`, new Error(Fe);
            }
          });
        }
        loadTile(B) {
          return g._(this, void 0, void 0, function* () {
            const j = B.uid, te = !!(B && B.request && B.request.collectResourceTiming) && new g.bv(B.request), ge = new k(B);
            this.loading[j] = ge;
            const Me = new AbortController();
            ge.abort = Me;
            try {
              const Fe = yield this.loadVectorTile(B, Me);
              if (delete this.loading[j], !Fe) return null;
              const Ne = Fe.rawData, De = {};
              Fe.expires && (De.expires = Fe.expires), Fe.cacheControl && (De.cacheControl = Fe.cacheControl);
              const et = {};
              if (te) {
                const We = te.finish();
                We && (et.resourceTiming = JSON.parse(JSON.stringify(We)));
              }
              ge.vectorTile = Fe.vectorTile;
              const ut = ge.parse(Fe.vectorTile, this.layerIndex, this.availableImages, this.actor);
              this.loaded[j] = ge, this.fetching[j] = { rawTileData: Ne, cacheControl: De, resourceTiming: et };
              try {
                const We = yield ut;
                return g.e({ rawTileData: Ne.slice(0) }, We, De, et);
              } finally {
                delete this.fetching[j];
              }
            } catch (Fe) {
              throw delete this.loading[j], ge.status = "done", this.loaded[j] = ge, Fe;
            }
          });
        }
        reloadTile(B) {
          return g._(this, void 0, void 0, function* () {
            const j = B.uid;
            if (!this.loaded || !this.loaded[j]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const te = this.loaded[j];
            if (te.showCollisionBoxes = B.showCollisionBoxes, te.status === "parsing") {
              const ge = yield te.parse(te.vectorTile, this.layerIndex, this.availableImages, this.actor);
              let Me;
              if (this.fetching[j]) {
                const { rawTileData: Fe, cacheControl: Ne, resourceTiming: De } = this.fetching[j];
                delete this.fetching[j], Me = g.e({ rawTileData: Fe.slice(0) }, ge, Ne, De);
              } else Me = ge;
              return Me;
            }
            if (te.status === "done" && te.vectorTile) return te.parse(te.vectorTile, this.layerIndex, this.availableImages, this.actor);
          });
        }
        abortTile(B) {
          return g._(this, void 0, void 0, function* () {
            const j = this.loading, te = B.uid;
            j && j[te] && j[te].abort && (j[te].abort.abort(), delete j[te]);
          });
        }
        removeTile(B) {
          return g._(this, void 0, void 0, function* () {
            this.loaded && this.loaded[B.uid] && delete this.loaded[B.uid];
          });
        }
      }
      class O {
        constructor() {
          this.loaded = {};
        }
        loadTile(B) {
          return g._(this, void 0, void 0, function* () {
            const { uid: j, encoding: te, rawImageData: ge, redFactor: Me, greenFactor: Fe, blueFactor: Ne, baseShift: De } = B, et = ge.width + 2, ut = ge.height + 2, We = g.b(ge) ? new g.R({ width: et, height: ut }, yield g.bw(ge, -1, -1, et, ut)) : ge, gt = new g.bx(j, We, te, Me, Fe, Ne, De);
            return this.loaded = this.loaded || {}, this.loaded[j] = gt, gt;
          });
        }
        removeTile(B) {
          const j = this.loaded, te = B.uid;
          j && j[te] && delete j[te];
        }
      }
      function z($, B) {
        if ($.length !== 0) {
          pe($[0], B);
          for (var j = 1; j < $.length; j++) pe($[j], !B);
        }
      }
      function pe($, B) {
        for (var j = 0, te = 0, ge = 0, Me = $.length, Fe = Me - 1; ge < Me; Fe = ge++) {
          var Ne = ($[ge][0] - $[Fe][0]) * ($[Fe][1] + $[ge][1]), De = j + Ne;
          te += Math.abs(j) >= Math.abs(Ne) ? j - De + Ne : Ne - De + j, j = De;
        }
        j + te >= 0 != !!B && $.reverse();
      }
      var le = g.by(function $(B, j) {
        var te, ge = B && B.type;
        if (ge === "FeatureCollection") for (te = 0; te < B.features.length; te++) $(B.features[te], j);
        else if (ge === "GeometryCollection") for (te = 0; te < B.geometries.length; te++) $(B.geometries[te], j);
        else if (ge === "Feature") $(B.geometry, j);
        else if (ge === "Polygon") z(B.coordinates, j);
        else if (ge === "MultiPolygon") for (te = 0; te < B.coordinates.length; te++) z(B.coordinates[te], j);
        return B;
      });
      const se = g.bt.VectorTileFeature.prototype.toGeoJSON;
      var ee = { exports: {} }, fe = g.bz, Te = g.bt.VectorTileFeature, ze = qe;
      function qe($, B) {
        this.options = B || {}, this.features = $, this.length = $.length;
      }
      function at($, B) {
        this.id = typeof $.id == "number" ? $.id : void 0, this.type = $.type, this.rawGeometry = $.type === 1 ? [$.geometry] : $.geometry, this.properties = $.tags, this.extent = B || 4096;
      }
      qe.prototype.feature = function($) {
        return new at(this.features[$], this.options.extent);
      }, at.prototype.loadGeometry = function() {
        var $ = this.rawGeometry;
        this.geometry = [];
        for (var B = 0; B < $.length; B++) {
          for (var j = $[B], te = [], ge = 0; ge < j.length; ge++) te.push(new fe(j[ge][0], j[ge][1]));
          this.geometry.push(te);
        }
        return this.geometry;
      }, at.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var $ = this.geometry, B = 1 / 0, j = -1 / 0, te = 1 / 0, ge = -1 / 0, Me = 0; Me < $.length; Me++) for (var Fe = $[Me], Ne = 0; Ne < Fe.length; Ne++) {
          var De = Fe[Ne];
          B = Math.min(B, De.x), j = Math.max(j, De.x), te = Math.min(te, De.y), ge = Math.max(ge, De.y);
        }
        return [B, te, j, ge];
      }, at.prototype.toGeoJSON = Te.prototype.toGeoJSON;
      var Ie = g.bA, Ae = ze;
      function me($) {
        var B = new Ie();
        return function(j, te) {
          for (var ge in j.layers) te.writeMessage(3, ve, j.layers[ge]);
        }($, B), B.finish();
      }
      function ve($, B) {
        var j;
        B.writeVarintField(15, $.version || 1), B.writeStringField(1, $.name || ""), B.writeVarintField(5, $.extent || 4096);
        var te = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (j = 0; j < $.length; j++) te.feature = $.feature(j), B.writeMessage(2, X, te);
        var ge = te.keys;
        for (j = 0; j < ge.length; j++) B.writeStringField(3, ge[j]);
        var Me = te.values;
        for (j = 0; j < Me.length; j++) B.writeMessage(4, He, Me[j]);
      }
      function X($, B) {
        var j = $.feature;
        j.id !== void 0 && B.writeVarintField(1, j.id), B.writeMessage(2, re, $), B.writeVarintField(3, j.type), B.writeMessage(4, Ve, j);
      }
      function re($, B) {
        var j = $.feature, te = $.keys, ge = $.values, Me = $.keycache, Fe = $.valuecache;
        for (var Ne in j.properties) {
          var De = j.properties[Ne], et = Me[Ne];
          if (De !== null) {
            et === void 0 && (te.push(Ne), Me[Ne] = et = te.length - 1), B.writeVarint(et);
            var ut = typeof De;
            ut !== "string" && ut !== "boolean" && ut !== "number" && (De = JSON.stringify(De));
            var We = ut + ":" + De, gt = Fe[We];
            gt === void 0 && (ge.push(De), Fe[We] = gt = ge.length - 1), B.writeVarint(gt);
          }
        }
      }
      function xe($, B) {
        return (B << 3) + (7 & $);
      }
      function ye($) {
        return $ << 1 ^ $ >> 31;
      }
      function Ve($, B) {
        for (var j = $.loadGeometry(), te = $.type, ge = 0, Me = 0, Fe = j.length, Ne = 0; Ne < Fe; Ne++) {
          var De = j[Ne], et = 1;
          te === 1 && (et = De.length), B.writeVarint(xe(1, et));
          for (var ut = te === 3 ? De.length - 1 : De.length, We = 0; We < ut; We++) {
            We === 1 && te !== 1 && B.writeVarint(xe(2, ut - 1));
            var gt = De[We].x - ge, Mt = De[We].y - Me;
            B.writeVarint(ye(gt)), B.writeVarint(ye(Mt)), ge += gt, Me += Mt;
          }
          te === 3 && B.writeVarint(xe(7, 1));
        }
      }
      function He($, B) {
        var j = typeof $;
        j === "string" ? B.writeStringField(1, $) : j === "boolean" ? B.writeBooleanField(7, $) : j === "number" && ($ % 1 != 0 ? B.writeDoubleField(3, $) : $ < 0 ? B.writeSVarintField(6, $) : B.writeVarintField(5, $));
      }
      ee.exports = me, ee.exports.fromVectorTileJs = me, ee.exports.fromGeojsonVt = function($, B) {
        B = B || {};
        var j = {};
        for (var te in $) j[te] = new Ae($[te].features, B), j[te].name = te, j[te].version = B.version, j[te].extent = B.extent;
        return me({ layers: j });
      }, ee.exports.GeoJSONWrapper = Ae;
      var Ze = g.by(ee.exports);
      const je = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: ($) => $ }, Je = Math.fround || (Qe = new Float32Array(1), ($) => (Qe[0] = +$, Qe[0]));
      var Qe;
      const nt = 3, Q = 5, _e = 6;
      class be {
        constructor(B) {
          this.options = Object.assign(Object.create(je), B), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(B) {
          const { log: j, minZoom: te, maxZoom: ge } = this.options;
          j && console.time("total time");
          const Me = `prepare ${B.length} points`;
          j && console.time(Me), this.points = B;
          const Fe = [];
          for (let De = 0; De < B.length; De++) {
            const et = B[De];
            if (!et.geometry) continue;
            const [ut, We] = et.geometry.coordinates, gt = Je($e(ut)), Mt = Je(Ue(We));
            Fe.push(gt, Mt, 1 / 0, De, -1, 1), this.options.reduce && Fe.push(0);
          }
          let Ne = this.trees[ge + 1] = this._createTree(Fe);
          j && console.timeEnd(Me);
          for (let De = ge; De >= te; De--) {
            const et = +Date.now();
            Ne = this.trees[De] = this._createTree(this._cluster(Ne, De)), j && console.log("z%d: %d clusters in %dms", De, Ne.numItems, +Date.now() - et);
          }
          return j && console.timeEnd("total time"), this;
        }
        getClusters(B, j) {
          let te = ((B[0] + 180) % 360 + 360) % 360 - 180;
          const ge = Math.max(-90, Math.min(90, B[1]));
          let Me = B[2] === 180 ? 180 : ((B[2] + 180) % 360 + 360) % 360 - 180;
          const Fe = Math.max(-90, Math.min(90, B[3]));
          if (B[2] - B[0] >= 360) te = -180, Me = 180;
          else if (te > Me) {
            const We = this.getClusters([te, ge, 180, Fe], j), gt = this.getClusters([-180, ge, Me, Fe], j);
            return We.concat(gt);
          }
          const Ne = this.trees[this._limitZoom(j)], De = Ne.range($e(te), Ue(Fe), $e(Me), Ue(ge)), et = Ne.data, ut = [];
          for (const We of De) {
            const gt = this.stride * We;
            ut.push(et[gt + Q] > 1 ? Ce(et, gt, this.clusterProps) : this.points[et[gt + nt]]);
          }
          return ut;
        }
        getChildren(B) {
          const j = this._getOriginId(B), te = this._getOriginZoom(B), ge = "No cluster with the specified id.", Me = this.trees[te];
          if (!Me) throw new Error(ge);
          const Fe = Me.data;
          if (j * this.stride >= Fe.length) throw new Error(ge);
          const Ne = this.options.radius / (this.options.extent * Math.pow(2, te - 1)), De = Me.within(Fe[j * this.stride], Fe[j * this.stride + 1], Ne), et = [];
          for (const ut of De) {
            const We = ut * this.stride;
            Fe[We + 4] === B && et.push(Fe[We + Q] > 1 ? Ce(Fe, We, this.clusterProps) : this.points[Fe[We + nt]]);
          }
          if (et.length === 0) throw new Error(ge);
          return et;
        }
        getLeaves(B, j, te) {
          const ge = [];
          return this._appendLeaves(ge, B, j = j || 10, te = te || 0, 0), ge;
        }
        getTile(B, j, te) {
          const ge = this.trees[this._limitZoom(B)], Me = Math.pow(2, B), { extent: Fe, radius: Ne } = this.options, De = Ne / Fe, et = (te - De) / Me, ut = (te + 1 + De) / Me, We = { features: [] };
          return this._addTileFeatures(ge.range((j - De) / Me, et, (j + 1 + De) / Me, ut), ge.data, j, te, Me, We), j === 0 && this._addTileFeatures(ge.range(1 - De / Me, et, 1, ut), ge.data, Me, te, Me, We), j === Me - 1 && this._addTileFeatures(ge.range(0, et, De / Me, ut), ge.data, -1, te, Me, We), We.features.length ? We : null;
        }
        getClusterExpansionZoom(B) {
          let j = this._getOriginZoom(B) - 1;
          for (; j <= this.options.maxZoom; ) {
            const te = this.getChildren(B);
            if (j++, te.length !== 1) break;
            B = te[0].properties.cluster_id;
          }
          return j;
        }
        _appendLeaves(B, j, te, ge, Me) {
          const Fe = this.getChildren(j);
          for (const Ne of Fe) {
            const De = Ne.properties;
            if (De && De.cluster ? Me + De.point_count <= ge ? Me += De.point_count : Me = this._appendLeaves(B, De.cluster_id, te, ge, Me) : Me < ge ? Me++ : B.push(Ne), B.length === te) break;
          }
          return Me;
        }
        _createTree(B) {
          const j = new g.av(B.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let te = 0; te < B.length; te += this.stride) j.add(B[te], B[te + 1]);
          return j.finish(), j.data = B, j;
        }
        _addTileFeatures(B, j, te, ge, Me, Fe) {
          for (const Ne of B) {
            const De = Ne * this.stride, et = j[De + Q] > 1;
            let ut, We, gt;
            if (et) ut = Oe(j, De, this.clusterProps), We = j[De], gt = j[De + 1];
            else {
              const Qt = this.points[j[De + nt]];
              ut = Qt.properties;
              const [ei, pi] = Qt.geometry.coordinates;
              We = $e(ei), gt = Ue(pi);
            }
            const Mt = { type: 1, geometry: [[Math.round(this.options.extent * (We * Me - te)), Math.round(this.options.extent * (gt * Me - ge))]], tags: ut };
            let $t;
            $t = et || this.options.generateId ? j[De + nt] : this.points[j[De + nt]].id, $t !== void 0 && (Mt.id = $t), Fe.features.push(Mt);
          }
        }
        _limitZoom(B) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+B), this.options.maxZoom + 1));
        }
        _cluster(B, j) {
          const { radius: te, extent: ge, reduce: Me, minPoints: Fe } = this.options, Ne = te / (ge * Math.pow(2, j)), De = B.data, et = [], ut = this.stride;
          for (let We = 0; We < De.length; We += ut) {
            if (De[We + 2] <= j) continue;
            De[We + 2] = j;
            const gt = De[We], Mt = De[We + 1], $t = B.within(De[We], De[We + 1], Ne), Qt = De[We + Q];
            let ei = Qt;
            for (const pi of $t) {
              const fi = pi * ut;
              De[fi + 2] > j && (ei += De[fi + Q]);
            }
            if (ei > Qt && ei >= Fe) {
              let pi, fi = gt * Qt, Wi = Mt * Qt, Oi = -1;
              const mi = ((We / ut | 0) << 5) + (j + 1) + this.points.length;
              for (const Bi of $t) {
                const Hi = Bi * ut;
                if (De[Hi + 2] <= j) continue;
                De[Hi + 2] = j;
                const mr = De[Hi + Q];
                fi += De[Hi] * mr, Wi += De[Hi + 1] * mr, De[Hi + 4] = mi, Me && (pi || (pi = this._map(De, We, !0), Oi = this.clusterProps.length, this.clusterProps.push(pi)), Me(pi, this._map(De, Hi)));
              }
              De[We + 4] = mi, et.push(fi / ei, Wi / ei, 1 / 0, mi, -1, ei), Me && et.push(Oi);
            } else {
              for (let pi = 0; pi < ut; pi++) et.push(De[We + pi]);
              if (ei > 1) for (const pi of $t) {
                const fi = pi * ut;
                if (!(De[fi + 2] <= j)) {
                  De[fi + 2] = j;
                  for (let Wi = 0; Wi < ut; Wi++) et.push(De[fi + Wi]);
                }
              }
            }
          }
          return et;
        }
        _getOriginId(B) {
          return B - this.points.length >> 5;
        }
        _getOriginZoom(B) {
          return (B - this.points.length) % 32;
        }
        _map(B, j, te) {
          if (B[j + Q] > 1) {
            const Fe = this.clusterProps[B[j + _e]];
            return te ? Object.assign({}, Fe) : Fe;
          }
          const ge = this.points[B[j + nt]].properties, Me = this.options.map(ge);
          return te && Me === ge ? Object.assign({}, Me) : Me;
        }
      }
      function Ce($, B, j) {
        return { type: "Feature", id: $[B + nt], properties: Oe($, B, j), geometry: { type: "Point", coordinates: [(te = $[B], 360 * (te - 0.5)), Ke($[B + 1])] } };
        var te;
      }
      function Oe($, B, j) {
        const te = $[B + Q], ge = te >= 1e4 ? `${Math.round(te / 1e3)}k` : te >= 1e3 ? Math.round(te / 100) / 10 + "k" : te, Me = $[B + _e], Fe = Me === -1 ? {} : Object.assign({}, j[Me]);
        return Object.assign(Fe, { cluster: !0, cluster_id: $[B + nt], point_count: te, point_count_abbreviated: ge });
      }
      function $e($) {
        return $ / 360 + 0.5;
      }
      function Ue($) {
        const B = Math.sin($ * Math.PI / 180), j = 0.5 - 0.25 * Math.log((1 + B) / (1 - B)) / Math.PI;
        return j < 0 ? 0 : j > 1 ? 1 : j;
      }
      function Ke($) {
        const B = (180 - 360 * $) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(B)) / Math.PI - 90;
      }
      function rt($, B, j, te) {
        let ge = te;
        const Me = B + (j - B >> 1);
        let Fe, Ne = j - B;
        const De = $[B], et = $[B + 1], ut = $[j], We = $[j + 1];
        for (let gt = B + 3; gt < j; gt += 3) {
          const Mt = ot($[gt], $[gt + 1], De, et, ut, We);
          if (Mt > ge) Fe = gt, ge = Mt;
          else if (Mt === ge) {
            const $t = Math.abs(gt - Me);
            $t < Ne && (Fe = gt, Ne = $t);
          }
        }
        ge > te && (Fe - B > 3 && rt($, B, Fe, te), $[Fe + 2] = ge, j - Fe > 3 && rt($, Fe, j, te));
      }
      function ot($, B, j, te, ge, Me) {
        let Fe = ge - j, Ne = Me - te;
        if (Fe !== 0 || Ne !== 0) {
          const De = (($ - j) * Fe + (B - te) * Ne) / (Fe * Fe + Ne * Ne);
          De > 1 ? (j = ge, te = Me) : De > 0 && (j += Fe * De, te += Ne * De);
        }
        return Fe = $ - j, Ne = B - te, Fe * Fe + Ne * Ne;
      }
      function vt($, B, j, te) {
        const ge = { id: $ ?? null, type: B, geometry: j, tags: te, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (B === "Point" || B === "MultiPoint" || B === "LineString") mt(ge, j);
        else if (B === "Polygon") mt(ge, j[0]);
        else if (B === "MultiLineString") for (const Me of j) mt(ge, Me);
        else if (B === "MultiPolygon") for (const Me of j) mt(ge, Me[0]);
        return ge;
      }
      function mt($, B) {
        for (let j = 0; j < B.length; j += 3) $.minX = Math.min($.minX, B[j]), $.minY = Math.min($.minY, B[j + 1]), $.maxX = Math.max($.maxX, B[j]), $.maxY = Math.max($.maxY, B[j + 1]);
      }
      function Pt($, B, j, te) {
        if (!B.geometry) return;
        const ge = B.geometry.coordinates;
        if (ge && ge.length === 0) return;
        const Me = B.geometry.type, Fe = Math.pow(j.tolerance / ((1 << j.maxZoom) * j.extent), 2);
        let Ne = [], De = B.id;
        if (j.promoteId ? De = B.properties[j.promoteId] : j.generateId && (De = te || 0), Me === "Point") it(ge, Ne);
        else if (Me === "MultiPoint") for (const et of ge) it(et, Ne);
        else if (Me === "LineString") Y(ge, Ne, Fe, !1);
        else if (Me === "MultiLineString") {
          if (j.lineMetrics) {
            for (const et of ge) Ne = [], Y(et, Ne, Fe, !1), $.push(vt(De, "LineString", Ne, B.properties));
            return;
          }
          Kt(ge, Ne, Fe, !1);
        } else if (Me === "Polygon") Kt(ge, Ne, Fe, !0);
        else {
          if (Me !== "MultiPolygon") {
            if (Me === "GeometryCollection") {
              for (const et of B.geometry.geometries) Pt($, { id: De, geometry: et, properties: B.properties }, j, te);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const et of ge) {
            const ut = [];
            Kt(et, ut, Fe, !0), Ne.push(ut);
          }
        }
        $.push(vt(De, Me, Ne, B.properties));
      }
      function it($, B) {
        B.push(Rt($[0]), lt($[1]), 0);
      }
      function Y($, B, j, te) {
        let ge, Me, Fe = 0;
        for (let De = 0; De < $.length; De++) {
          const et = Rt($[De][0]), ut = lt($[De][1]);
          B.push(et, ut, 0), De > 0 && (Fe += te ? (ge * ut - et * Me) / 2 : Math.sqrt(Math.pow(et - ge, 2) + Math.pow(ut - Me, 2))), ge = et, Me = ut;
        }
        const Ne = B.length - 3;
        B[2] = 1, rt(B, 0, Ne, j), B[Ne + 2] = 1, B.size = Math.abs(Fe), B.start = 0, B.end = B.size;
      }
      function Kt($, B, j, te) {
        for (let ge = 0; ge < $.length; ge++) {
          const Me = [];
          Y($[ge], Me, j, te), B.push(Me);
        }
      }
      function Rt($) {
        return $ / 360 + 0.5;
      }
      function lt($) {
        const B = Math.sin($ * Math.PI / 180), j = 0.5 - 0.25 * Math.log((1 + B) / (1 - B)) / Math.PI;
        return j < 0 ? 0 : j > 1 ? 1 : j;
      }
      function xt($, B, j, te, ge, Me, Fe, Ne) {
        if (te /= B, Me >= (j /= B) && Fe < te) return $;
        if (Fe < j || Me >= te) return null;
        const De = [];
        for (const et of $) {
          const ut = et.geometry;
          let We = et.type;
          const gt = ge === 0 ? et.minX : et.minY, Mt = ge === 0 ? et.maxX : et.maxY;
          if (gt >= j && Mt < te) {
            De.push(et);
            continue;
          }
          if (Mt < j || gt >= te) continue;
          let $t = [];
          if (We === "Point" || We === "MultiPoint") At(ut, $t, j, te, ge);
          else if (We === "LineString") Et(ut, $t, j, te, ge, !1, Ne.lineMetrics);
          else if (We === "MultiLineString") ni(ut, $t, j, te, ge, !1);
          else if (We === "Polygon") ni(ut, $t, j, te, ge, !0);
          else if (We === "MultiPolygon") for (const Qt of ut) {
            const ei = [];
            ni(Qt, ei, j, te, ge, !0), ei.length && $t.push(ei);
          }
          if ($t.length) {
            if (Ne.lineMetrics && We === "LineString") {
              for (const Qt of $t) De.push(vt(et.id, We, Qt, et.tags));
              continue;
            }
            We !== "LineString" && We !== "MultiLineString" || ($t.length === 1 ? (We = "LineString", $t = $t[0]) : We = "MultiLineString"), We !== "Point" && We !== "MultiPoint" || (We = $t.length === 3 ? "Point" : "MultiPoint"), De.push(vt(et.id, We, $t, et.tags));
          }
        }
        return De.length ? De : null;
      }
      function At($, B, j, te, ge) {
        for (let Me = 0; Me < $.length; Me += 3) {
          const Fe = $[Me + ge];
          Fe >= j && Fe <= te && ii(B, $[Me], $[Me + 1], $[Me + 2]);
        }
      }
      function Et($, B, j, te, ge, Me, Fe) {
        let Ne = jt($);
        const De = ge === 0 ? yi : xi;
        let et, ut, We = $.start;
        for (let ei = 0; ei < $.length - 3; ei += 3) {
          const pi = $[ei], fi = $[ei + 1], Wi = $[ei + 2], Oi = $[ei + 3], mi = $[ei + 4], Bi = ge === 0 ? pi : fi, Hi = ge === 0 ? Oi : mi;
          let mr = !1;
          Fe && (et = Math.sqrt(Math.pow(pi - Oi, 2) + Math.pow(fi - mi, 2))), Bi < j ? Hi > j && (ut = De(Ne, pi, fi, Oi, mi, j), Fe && (Ne.start = We + et * ut)) : Bi > te ? Hi < te && (ut = De(Ne, pi, fi, Oi, mi, te), Fe && (Ne.start = We + et * ut)) : ii(Ne, pi, fi, Wi), Hi < j && Bi >= j && (ut = De(Ne, pi, fi, Oi, mi, j), mr = !0), Hi > te && Bi <= te && (ut = De(Ne, pi, fi, Oi, mi, te), mr = !0), !Me && mr && (Fe && (Ne.end = We + et * ut), B.push(Ne), Ne = jt($)), Fe && (We += et);
        }
        let gt = $.length - 3;
        const Mt = $[gt], $t = $[gt + 1], Qt = ge === 0 ? Mt : $t;
        Qt >= j && Qt <= te && ii(Ne, Mt, $t, $[gt + 2]), gt = Ne.length - 3, Me && gt >= 3 && (Ne[gt] !== Ne[0] || Ne[gt + 1] !== Ne[1]) && ii(Ne, Ne[0], Ne[1], Ne[2]), Ne.length && B.push(Ne);
      }
      function jt($) {
        const B = [];
        return B.size = $.size, B.start = $.start, B.end = $.end, B;
      }
      function ni($, B, j, te, ge, Me) {
        for (const Fe of $) Et(Fe, B, j, te, ge, Me, !1);
      }
      function ii($, B, j, te) {
        $.push(B, j, te);
      }
      function yi($, B, j, te, ge, Me) {
        const Fe = (Me - B) / (te - B);
        return ii($, Me, j + (ge - j) * Fe, 1), Fe;
      }
      function xi($, B, j, te, ge, Me) {
        const Fe = (Me - j) / (ge - j);
        return ii($, B + (te - B) * Fe, Me, 1), Fe;
      }
      function pt($, B) {
        const j = [];
        for (let te = 0; te < $.length; te++) {
          const ge = $[te], Me = ge.type;
          let Fe;
          if (Me === "Point" || Me === "MultiPoint" || Me === "LineString") Fe = Jt(ge.geometry, B);
          else if (Me === "MultiLineString" || Me === "Polygon") {
            Fe = [];
            for (const Ne of ge.geometry) Fe.push(Jt(Ne, B));
          } else if (Me === "MultiPolygon") {
            Fe = [];
            for (const Ne of ge.geometry) {
              const De = [];
              for (const et of Ne) De.push(Jt(et, B));
              Fe.push(De);
            }
          }
          j.push(vt(ge.id, Me, Fe, ge.tags));
        }
        return j;
      }
      function Jt($, B) {
        const j = [];
        j.size = $.size, $.start !== void 0 && (j.start = $.start, j.end = $.end);
        for (let te = 0; te < $.length; te += 3) j.push($[te] + B, $[te + 1], $[te + 2]);
        return j;
      }
      function ai($, B) {
        if ($.transformed) return $;
        const j = 1 << $.z, te = $.x, ge = $.y;
        for (const Me of $.features) {
          const Fe = Me.geometry, Ne = Me.type;
          if (Me.geometry = [], Ne === 1) for (let De = 0; De < Fe.length; De += 2) Me.geometry.push(kt(Fe[De], Fe[De + 1], B, j, te, ge));
          else for (let De = 0; De < Fe.length; De++) {
            const et = [];
            for (let ut = 0; ut < Fe[De].length; ut += 2) et.push(kt(Fe[De][ut], Fe[De][ut + 1], B, j, te, ge));
            Me.geometry.push(et);
          }
        }
        return $.transformed = !0, $;
      }
      function kt($, B, j, te, ge, Me) {
        return [Math.round(j * ($ * te - ge)), Math.round(j * (B * te - Me))];
      }
      function Zi($, B, j, te, ge) {
        const Me = B === ge.maxZoom ? 0 : ge.tolerance / ((1 << B) * ge.extent), Fe = { features: [], numPoints: 0, numSimplified: 0, numFeatures: $.length, source: null, x: j, y: te, z: B, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const Ne of $) ft(Fe, Ne, Me, ge);
        return Fe;
      }
      function ft($, B, j, te) {
        const ge = B.geometry, Me = B.type, Fe = [];
        if ($.minX = Math.min($.minX, B.minX), $.minY = Math.min($.minY, B.minY), $.maxX = Math.max($.maxX, B.maxX), $.maxY = Math.max($.maxY, B.maxY), Me === "Point" || Me === "MultiPoint") for (let Ne = 0; Ne < ge.length; Ne += 3) Fe.push(ge[Ne], ge[Ne + 1]), $.numPoints++, $.numSimplified++;
        else if (Me === "LineString") ri(Fe, ge, $, j, !1, !1);
        else if (Me === "MultiLineString" || Me === "Polygon") for (let Ne = 0; Ne < ge.length; Ne++) ri(Fe, ge[Ne], $, j, Me === "Polygon", Ne === 0);
        else if (Me === "MultiPolygon") for (let Ne = 0; Ne < ge.length; Ne++) {
          const De = ge[Ne];
          for (let et = 0; et < De.length; et++) ri(Fe, De[et], $, j, !0, et === 0);
        }
        if (Fe.length) {
          let Ne = B.tags || null;
          if (Me === "LineString" && te.lineMetrics) {
            Ne = {};
            for (const et in B.tags) Ne[et] = B.tags[et];
            Ne.mapbox_clip_start = ge.start / ge.size, Ne.mapbox_clip_end = ge.end / ge.size;
          }
          const De = { geometry: Fe, type: Me === "Polygon" || Me === "MultiPolygon" ? 3 : Me === "LineString" || Me === "MultiLineString" ? 2 : 1, tags: Ne };
          B.id !== null && (De.id = B.id), $.features.push(De);
        }
      }
      function ri($, B, j, te, ge, Me) {
        const Fe = te * te;
        if (te > 0 && B.size < (ge ? Fe : te)) return void (j.numPoints += B.length / 3);
        const Ne = [];
        for (let De = 0; De < B.length; De += 3) (te === 0 || B[De + 2] > Fe) && (j.numSimplified++, Ne.push(B[De], B[De + 1])), j.numPoints++;
        ge && function(De, et) {
          let ut = 0;
          for (let We = 0, gt = De.length, Mt = gt - 2; We < gt; Mt = We, We += 2) ut += (De[We] - De[Mt]) * (De[We + 1] + De[Mt + 1]);
          if (ut > 0 === et) for (let We = 0, gt = De.length; We < gt / 2; We += 2) {
            const Mt = De[We], $t = De[We + 1];
            De[We] = De[gt - 2 - We], De[We + 1] = De[gt - 1 - We], De[gt - 2 - We] = Mt, De[gt - 1 - We] = $t;
          }
        }(Ne, Me), $.push(Ne);
      }
      const Lt = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
      class Si {
        constructor(B, j) {
          const te = (j = this.options = function(Me, Fe) {
            for (const Ne in Fe) Me[Ne] = Fe[Ne];
            return Me;
          }(Object.create(Lt), j)).debug;
          if (te && console.time("preprocess data"), j.maxZoom < 0 || j.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (j.promoteId && j.generateId) throw new Error("promoteId and generateId cannot be used together.");
          let ge = function(Me, Fe) {
            const Ne = [];
            if (Me.type === "FeatureCollection") for (let De = 0; De < Me.features.length; De++) Pt(Ne, Me.features[De], Fe, De);
            else Pt(Ne, Me.type === "Feature" ? Me : { geometry: Me }, Fe);
            return Ne;
          }(B, j);
          this.tiles = {}, this.tileCoords = [], te && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", j.indexMaxZoom, j.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ge = function(Me, Fe) {
            const Ne = Fe.buffer / Fe.extent;
            let De = Me;
            const et = xt(Me, 1, -1 - Ne, Ne, 0, -1, 2, Fe), ut = xt(Me, 1, 1 - Ne, 2 + Ne, 0, -1, 2, Fe);
            return (et || ut) && (De = xt(Me, 1, -Ne, 1 + Ne, 0, -1, 2, Fe) || [], et && (De = pt(et, 1).concat(De)), ut && (De = De.concat(pt(ut, -1)))), De;
          }(ge, j), ge.length && this.splitTile(ge, 0, 0, 0), te && (ge.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(B, j, te, ge, Me, Fe, Ne) {
          const De = [B, j, te, ge], et = this.options, ut = et.debug;
          for (; De.length; ) {
            ge = De.pop(), te = De.pop(), j = De.pop(), B = De.pop();
            const We = 1 << j, gt = Gi(j, te, ge);
            let Mt = this.tiles[gt];
            if (!Mt && (ut > 1 && console.time("creation"), Mt = this.tiles[gt] = Zi(B, j, te, ge, et), this.tileCoords.push({ z: j, x: te, y: ge }), ut)) {
              ut > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", j, te, ge, Mt.numFeatures, Mt.numPoints, Mt.numSimplified), console.timeEnd("creation"));
              const mr = `z${j}`;
              this.stats[mr] = (this.stats[mr] || 0) + 1, this.total++;
            }
            if (Mt.source = B, Me == null) {
              if (j === et.indexMaxZoom || Mt.numPoints <= et.indexMaxPoints) continue;
            } else {
              if (j === et.maxZoom || j === Me) continue;
              if (Me != null) {
                const mr = Me - j;
                if (te !== Fe >> mr || ge !== Ne >> mr) continue;
              }
            }
            if (Mt.source = null, B.length === 0) continue;
            ut > 1 && console.time("clipping");
            const $t = 0.5 * et.buffer / et.extent, Qt = 0.5 - $t, ei = 0.5 + $t, pi = 1 + $t;
            let fi = null, Wi = null, Oi = null, mi = null, Bi = xt(B, We, te - $t, te + ei, 0, Mt.minX, Mt.maxX, et), Hi = xt(B, We, te + Qt, te + pi, 0, Mt.minX, Mt.maxX, et);
            B = null, Bi && (fi = xt(Bi, We, ge - $t, ge + ei, 1, Mt.minY, Mt.maxY, et), Wi = xt(Bi, We, ge + Qt, ge + pi, 1, Mt.minY, Mt.maxY, et), Bi = null), Hi && (Oi = xt(Hi, We, ge - $t, ge + ei, 1, Mt.minY, Mt.maxY, et), mi = xt(Hi, We, ge + Qt, ge + pi, 1, Mt.minY, Mt.maxY, et), Hi = null), ut > 1 && console.timeEnd("clipping"), De.push(fi || [], j + 1, 2 * te, 2 * ge), De.push(Wi || [], j + 1, 2 * te, 2 * ge + 1), De.push(Oi || [], j + 1, 2 * te + 1, 2 * ge), De.push(mi || [], j + 1, 2 * te + 1, 2 * ge + 1);
          }
        }
        getTile(B, j, te) {
          B = +B, j = +j, te = +te;
          const ge = this.options, { extent: Me, debug: Fe } = ge;
          if (B < 0 || B > 24) return null;
          const Ne = 1 << B, De = Gi(B, j = j + Ne & Ne - 1, te);
          if (this.tiles[De]) return ai(this.tiles[De], Me);
          Fe > 1 && console.log("drilling down to z%d-%d-%d", B, j, te);
          let et, ut = B, We = j, gt = te;
          for (; !et && ut > 0; ) ut--, We >>= 1, gt >>= 1, et = this.tiles[Gi(ut, We, gt)];
          return et && et.source ? (Fe > 1 && (console.log("found parent tile z%d-%d-%d", ut, We, gt), console.time("drilling down")), this.splitTile(et.source, ut, We, gt, B, j, te), Fe > 1 && console.timeEnd("drilling down"), this.tiles[De] ? ai(this.tiles[De], Me) : null) : null;
        }
      }
      function Gi($, B, j) {
        return 32 * ((1 << $) * j + B) + $;
      }
      function zt($, B) {
        return B ? $.properties[B] : $.id;
      }
      function cr($, B) {
        if ($ == null) return !0;
        if ($.type === "Feature") return zt($, B) != null;
        if ($.type === "FeatureCollection") {
          const j = /* @__PURE__ */ new Set();
          for (const te of $.features) {
            const ge = zt(te, B);
            if (ge == null || j.has(ge)) return !1;
            j.add(ge);
          }
          return !0;
        }
        return !1;
      }
      function Ni($, B) {
        const j = /* @__PURE__ */ new Map();
        if ($ != null) if ($.type === "Feature") j.set(zt($, B), $);
        else for (const te of $.features) j.set(zt(te, B), te);
        return j;
      }
      class ie extends q {
        constructor() {
          super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
        }
        loadVectorTile(B, j) {
          return g._(this, void 0, void 0, function* () {
            const te = B.tileID.canonical;
            if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
            const ge = this._geoJSONIndex.getTile(te.z, te.x, te.y);
            if (!ge) return null;
            const Me = new class {
              constructor(Ne) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = g.X, this.length = Ne.length, this._features = Ne;
              }
              feature(Ne) {
                return new class {
                  constructor(De) {
                    this._feature = De, this.extent = g.X, this.type = De.type, this.properties = De.tags, "id" in De && !isNaN(De.id) && (this.id = parseInt(De.id, 10));
                  }
                  loadGeometry() {
                    if (this._feature.type === 1) {
                      const De = [];
                      for (const et of this._feature.geometry) De.push([new g.P(et[0], et[1])]);
                      return De;
                    }
                    {
                      const De = [];
                      for (const et of this._feature.geometry) {
                        const ut = [];
                        for (const We of et) ut.push(new g.P(We[0], We[1]));
                        De.push(ut);
                      }
                      return De;
                    }
                  }
                  toGeoJSON(De, et, ut) {
                    return se.call(this, De, et, ut);
                  }
                }(this._features[Ne]);
              }
            }(ge.features);
            let Fe = Ze(Me);
            return Fe.byteOffset === 0 && Fe.byteLength === Fe.buffer.byteLength || (Fe = new Uint8Array(Fe)), { vectorTile: Me, rawData: Fe.buffer };
          });
        }
        loadData(B) {
          return g._(this, void 0, void 0, function* () {
            var j;
            (j = this._pendingRequest) === null || j === void 0 || j.abort();
            const te = !!(B && B.request && B.request.collectResourceTiming) && new g.bv(B.request);
            this._pendingRequest = new AbortController();
            try {
              this._pendingData = this.loadAndProcessGeoJSON(B, this._pendingRequest), this._geoJSONIndex = B.cluster ? new be(function({ superclusterOptions: Fe, clusterProperties: Ne }) {
                if (!Ne || !Fe) return Fe;
                const De = {}, et = {}, ut = { accumulated: null, zoom: 0 }, We = { properties: null }, gt = Object.keys(Ne);
                for (const Mt of gt) {
                  const [$t, Qt] = Ne[Mt], ei = g.bC(Qt), pi = g.bC(typeof $t == "string" ? [$t, ["accumulated"], ["get", Mt]] : $t);
                  De[Mt] = ei.value, et[Mt] = pi.value;
                }
                return Fe.map = (Mt) => {
                  We.properties = Mt;
                  const $t = {};
                  for (const Qt of gt) $t[Qt] = De[Qt].evaluate(ut, We);
                  return $t;
                }, Fe.reduce = (Mt, $t) => {
                  We.properties = $t;
                  for (const Qt of gt) ut.accumulated = Mt[Qt], Mt[Qt] = et[Qt].evaluate(ut, We);
                }, Fe;
              }(B)).load((yield this._pendingData).features) : (ge = yield this._pendingData, new Si(ge, B.geojsonVtOptions)), this.loaded = {};
              const Me = {};
              if (te) {
                const Fe = te.finish();
                Fe && (Me.resourceTiming = {}, Me.resourceTiming[B.source] = JSON.parse(JSON.stringify(Fe)));
              }
              return Me;
            } catch (Me) {
              if (delete this._pendingRequest, g.bB(Me)) return { abandoned: !0 };
              throw Me;
            }
            var ge;
          });
        }
        getData() {
          return g._(this, void 0, void 0, function* () {
            return this._pendingData;
          });
        }
        reloadTile(B) {
          const j = this.loaded;
          return j && j[B.uid] ? super.reloadTile(B) : this.loadTile(B);
        }
        loadAndProcessGeoJSON(B, j) {
          return g._(this, void 0, void 0, function* () {
            let te = yield this.loadGeoJSON(B, j);
            if (delete this._pendingRequest, typeof te != "object") throw new Error(`Input data given to '${B.source}' is not a valid GeoJSON object.`);
            if (le(te, !0), B.filter) {
              const ge = g.bC(B.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
              if (ge.result === "error") throw new Error(ge.value.map((Fe) => `${Fe.key}: ${Fe.message}`).join(", "));
              te = { type: "FeatureCollection", features: te.features.filter((Fe) => ge.value.evaluate({ zoom: 0 }, Fe)) };
            }
            return te;
          });
        }
        loadGeoJSON(B, j) {
          return g._(this, void 0, void 0, function* () {
            const { promoteId: te } = B;
            if (B.request) {
              const ge = yield g.h(B.request, j);
              return this._dataUpdateable = cr(ge.data, te) ? Ni(ge.data, te) : void 0, ge.data;
            }
            if (typeof B.data == "string") try {
              const ge = JSON.parse(B.data);
              return this._dataUpdateable = cr(ge, te) ? Ni(ge, te) : void 0, ge;
            } catch {
              throw new Error(`Input data given to '${B.source}' is not a valid GeoJSON object.`);
            }
            if (!B.dataDiff) throw new Error(`Input data given to '${B.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${B.source}`);
            return function(ge, Me, Fe) {
              var Ne, De, et, ut;
              if (Me.removeAll && ge.clear(), Me.remove) for (const We of Me.remove) ge.delete(We);
              if (Me.add) for (const We of Me.add) {
                const gt = zt(We, Fe);
                gt != null && ge.set(gt, We);
              }
              if (Me.update) for (const We of Me.update) {
                let gt = ge.get(We.id);
                if (gt == null) continue;
                const Mt = !We.removeAllProperties && (((Ne = We.removeProperties) === null || Ne === void 0 ? void 0 : Ne.length) > 0 || ((De = We.addOrUpdateProperties) === null || De === void 0 ? void 0 : De.length) > 0);
                if ((We.newGeometry || We.removeAllProperties || Mt) && (gt = Object.assign({}, gt), ge.set(We.id, gt), Mt && (gt.properties = Object.assign({}, gt.properties))), We.newGeometry && (gt.geometry = We.newGeometry), We.removeAllProperties) gt.properties = {};
                else if (((et = We.removeProperties) === null || et === void 0 ? void 0 : et.length) > 0) for (const $t of We.removeProperties) Object.prototype.hasOwnProperty.call(gt.properties, $t) && delete gt.properties[$t];
                if (((ut = We.addOrUpdateProperties) === null || ut === void 0 ? void 0 : ut.length) > 0) for (const { key: $t, value: Qt } of We.addOrUpdateProperties) gt.properties[$t] = Qt;
              }
            }(this._dataUpdateable, B.dataDiff, te), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource(B) {
          return g._(this, void 0, void 0, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(B) {
          return this._geoJSONIndex.getClusterExpansionZoom(B.clusterId);
        }
        getClusterChildren(B) {
          return this._geoJSONIndex.getChildren(B.clusterId);
        }
        getClusterLeaves(B) {
          return this._geoJSONIndex.getLeaves(B.clusterId, B.limit, B.offset);
        }
      }
      class ue {
        constructor(B) {
          this.self = B, this.actor = new g.F(B), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (j, te) => {
            if (this.externalWorkerSourceTypes[j]) throw new Error(`Worker source with name "${j}" already registered.`);
            this.externalWorkerSourceTypes[j] = te;
          }, this.self.addProtocol = g.bi, this.self.removeProtocol = g.bj, this.self.registerRTLTextPlugin = (j) => {
            if (g.bD.isParsed()) throw new Error("RTL text plugin already registered.");
            g.bD.setMethods(j);
          }, this.actor.registerMessageHandler("LDT", (j, te) => this._getDEMWorkerSource(j, te.source).loadTile(te)), this.actor.registerMessageHandler("RDT", (j, te) => g._(this, void 0, void 0, function* () {
            this._getDEMWorkerSource(j, te.source).removeTile(te);
          })), this.actor.registerMessageHandler("GCEZ", (j, te) => g._(this, void 0, void 0, function* () {
            return this._getWorkerSource(j, te.type, te.source).getClusterExpansionZoom(te);
          })), this.actor.registerMessageHandler("GCC", (j, te) => g._(this, void 0, void 0, function* () {
            return this._getWorkerSource(j, te.type, te.source).getClusterChildren(te);
          })), this.actor.registerMessageHandler("GCL", (j, te) => g._(this, void 0, void 0, function* () {
            return this._getWorkerSource(j, te.type, te.source).getClusterLeaves(te);
          })), this.actor.registerMessageHandler("LD", (j, te) => this._getWorkerSource(j, te.type, te.source).loadData(te)), this.actor.registerMessageHandler("GD", (j, te) => this._getWorkerSource(j, te.type, te.source).getData()), this.actor.registerMessageHandler("LT", (j, te) => this._getWorkerSource(j, te.type, te.source).loadTile(te)), this.actor.registerMessageHandler("RT", (j, te) => this._getWorkerSource(j, te.type, te.source).reloadTile(te)), this.actor.registerMessageHandler("AT", (j, te) => this._getWorkerSource(j, te.type, te.source).abortTile(te)), this.actor.registerMessageHandler("RMT", (j, te) => this._getWorkerSource(j, te.type, te.source).removeTile(te)), this.actor.registerMessageHandler("RS", (j, te) => g._(this, void 0, void 0, function* () {
            if (!this.workerSources[j] || !this.workerSources[j][te.type] || !this.workerSources[j][te.type][te.source]) return;
            const ge = this.workerSources[j][te.type][te.source];
            delete this.workerSources[j][te.type][te.source], ge.removeSource !== void 0 && ge.removeSource(te);
          })), this.actor.registerMessageHandler("RM", (j) => g._(this, void 0, void 0, function* () {
            delete this.layerIndexes[j], delete this.availableImages[j], delete this.workerSources[j], delete this.demWorkerSources[j];
          })), this.actor.registerMessageHandler("SR", (j, te) => g._(this, void 0, void 0, function* () {
            this.referrer = te;
          })), this.actor.registerMessageHandler("SRPS", (j, te) => this._syncRTLPluginState(j, te)), this.actor.registerMessageHandler("IS", (j, te) => g._(this, void 0, void 0, function* () {
            this.self.importScripts(te);
          })), this.actor.registerMessageHandler("SI", (j, te) => this._setImages(j, te)), this.actor.registerMessageHandler("UL", (j, te) => g._(this, void 0, void 0, function* () {
            this._getLayerIndex(j).update(te.layers, te.removedIds);
          })), this.actor.registerMessageHandler("SL", (j, te) => g._(this, void 0, void 0, function* () {
            this._getLayerIndex(j).replace(te);
          }));
        }
        _setImages(B, j) {
          return g._(this, void 0, void 0, function* () {
            this.availableImages[B] = j;
            for (const te in this.workerSources[B]) {
              const ge = this.workerSources[B][te];
              for (const Me in ge) ge[Me].availableImages = j;
            }
          });
        }
        _syncRTLPluginState(B, j) {
          return g._(this, void 0, void 0, function* () {
            if (g.bD.isParsed()) return g.bD.getState();
            if (j.pluginStatus !== "loading") return g.bD.setState(j), j;
            const te = j.pluginURL;
            if (this.self.importScripts(te), g.bD.isParsed()) {
              const ge = { pluginStatus: "loaded", pluginURL: te };
              return g.bD.setState(ge), ge;
            }
            throw g.bD.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${te}`);
          });
        }
        _getAvailableImages(B) {
          let j = this.availableImages[B];
          return j || (j = []), j;
        }
        _getLayerIndex(B) {
          let j = this.layerIndexes[B];
          return j || (j = this.layerIndexes[B] = new s()), j;
        }
        _getWorkerSource(B, j, te) {
          if (this.workerSources[B] || (this.workerSources[B] = {}), this.workerSources[B][j] || (this.workerSources[B][j] = {}), !this.workerSources[B][j][te]) {
            const ge = { sendAsync: (Me, Fe) => (Me.targetMapId = B, this.actor.sendAsync(Me, Fe)) };
            switch (j) {
              case "vector":
                this.workerSources[B][j][te] = new q(ge, this._getLayerIndex(B), this._getAvailableImages(B));
                break;
              case "geojson":
                this.workerSources[B][j][te] = new ie(ge, this._getLayerIndex(B), this._getAvailableImages(B));
                break;
              default:
                this.workerSources[B][j][te] = new this.externalWorkerSourceTypes[j](ge, this._getLayerIndex(B), this._getAvailableImages(B));
            }
          }
          return this.workerSources[B][j][te];
        }
        _getDEMWorkerSource(B, j) {
          return this.demWorkerSources[B] || (this.demWorkerSources[B] = {}), this.demWorkerSources[B][j] || (this.demWorkerSources[B][j] = new O()), this.demWorkerSources[B][j];
        }
      }
      return g.i(self) && (self.worker = new ue(self)), ue;
    }), w("index", ["exports", "./shared"], function(g, s) {
      var D = "4.7.1";
      let k, M;
      const q = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (c) => new Promise((e, r) => {
        const o = requestAnimationFrame(e);
        c.signal.addEventListener("abort", () => {
          cancelAnimationFrame(o), r(s.c());
        });
      }), getImageData(c, e = 0) {
        return this.getImageCanvasContext(c).getImageData(-e, -e, c.width + 2 * e, c.height + 2 * e);
      }, getImageCanvasContext(c) {
        const e = window.document.createElement("canvas"), r = e.getContext("2d", { willReadFrequently: !0 });
        if (!r) throw new Error("failed to create canvas 2d context");
        return e.width = c.width, e.height = c.height, r.drawImage(c, 0, 0, c.width, c.height), r;
      }, resolveURL: (c) => (k || (k = document.createElement("a")), k.href = c, k.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (M == null && (M = matchMedia("(prefers-reduced-motion: reduce)")), M.matches);
      } };
      class O {
        static testProp(e) {
          if (!O.docStyle) return e[0];
          for (let r = 0; r < e.length; r++) if (e[r] in O.docStyle) return e[r];
          return e[0];
        }
        static create(e, r, o) {
          const h = window.document.createElement(e);
          return r !== void 0 && (h.className = r), o && o.appendChild(h), h;
        }
        static createNS(e, r) {
          return window.document.createElementNS(e, r);
        }
        static disableDrag() {
          O.docStyle && O.selectProp && (O.userSelect = O.docStyle[O.selectProp], O.docStyle[O.selectProp] = "none");
        }
        static enableDrag() {
          O.docStyle && O.selectProp && (O.docStyle[O.selectProp] = O.userSelect);
        }
        static setTransform(e, r) {
          e.style[O.transformProp] = r;
        }
        static addEventListener(e, r, o, h = {}) {
          e.addEventListener(r, o, "passive" in h ? h : h.capture);
        }
        static removeEventListener(e, r, o, h = {}) {
          e.removeEventListener(r, o, "passive" in h ? h : h.capture);
        }
        static suppressClickInternal(e) {
          e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", O.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener("click", O.suppressClickInternal, !0), window.setTimeout(() => {
            window.removeEventListener("click", O.suppressClickInternal, !0);
          }, 0);
        }
        static getScale(e) {
          const r = e.getBoundingClientRect();
          return { x: r.width / e.offsetWidth || 1, y: r.height / e.offsetHeight || 1, boundingClientRect: r };
        }
        static getPoint(e, r, o) {
          const h = r.boundingClientRect;
          return new s.P((o.clientX - h.left) / r.x - e.clientLeft, (o.clientY - h.top) / r.y - e.clientTop);
        }
        static mousePos(e, r) {
          const o = O.getScale(e);
          return O.getPoint(e, o, r);
        }
        static touchPos(e, r) {
          const o = [], h = O.getScale(e);
          for (let p = 0; p < r.length; p++) o.push(O.getPoint(e, h, r[p]));
          return o;
        }
        static mouseButton(e) {
          return e.button;
        }
        static remove(e) {
          e.parentNode && e.parentNode.removeChild(e);
        }
      }
      O.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, O.selectProp = O.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), O.transformProp = O.testProp(["transform", "WebkitTransform"]);
      const z = { supported: !1, testSupport: function(c) {
        !se && le && (ee ? fe(c) : pe = c);
      } };
      let pe, le, se = !1, ee = !1;
      function fe(c) {
        const e = c.createTexture();
        c.bindTexture(c.TEXTURE_2D, e);
        try {
          if (c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, le), c.isContextLost()) return;
          z.supported = !0;
        } catch {
        }
        c.deleteTexture(e), se = !0;
      }
      var Te;
      typeof document < "u" && (le = document.createElement("img"), le.onload = () => {
        pe && fe(pe), pe = null, ee = !0;
      }, le.onerror = () => {
        se = !0, pe = null;
      }, le.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(c) {
        let e, r, o, h;
        c.resetRequestQueue = () => {
          e = [], r = 0, o = 0, h = {};
        }, c.addThrottleControl = (T) => {
          const P = o++;
          return h[P] = T, P;
        }, c.removeThrottleControl = (T) => {
          delete h[T], x();
        }, c.getImage = (T, P, F = !0) => new Promise((N, Z) => {
          z.supported && (T.headers || (T.headers = {}), T.headers.accept = "image/webp,*/*"), s.e(T, { type: "image" }), e.push({ abortController: P, requestParameters: T, supportImageRefresh: F, state: "queued", onError: (G) => {
            Z(G);
          }, onSuccess: (G) => {
            N(G);
          } }), x();
        });
        const p = (T) => s._(this, void 0, void 0, function* () {
          T.state = "running";
          const { requestParameters: P, supportImageRefresh: F, onError: N, onSuccess: Z, abortController: G } = T, V = F === !1 && !s.i(self) && !s.g(P.url) && (!P.headers || Object.keys(P.headers).reduce((oe, de) => oe && de === "accept", !0));
          r++;
          const W = V ? A(P, G) : s.m(P, G);
          try {
            const oe = yield W;
            delete T.abortController, T.state = "completed", oe.data instanceof HTMLImageElement || s.b(oe.data) ? Z(oe) : oe.data && Z({ data: yield (ae = oe.data, typeof createImageBitmap == "function" ? s.d(ae) : s.f(ae)), cacheControl: oe.cacheControl, expires: oe.expires });
          } catch (oe) {
            delete T.abortController, N(oe);
          } finally {
            r--, x();
          }
          var ae;
        }), x = () => {
          const T = (() => {
            for (const P of Object.keys(h)) if (h[P]()) return !0;
            return !1;
          })() ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let P = r; P < T && e.length > 0; P++) {
            const F = e.shift();
            F.abortController.signal.aborted ? P-- : p(F);
          }
        }, A = (T, P) => new Promise((F, N) => {
          const Z = new Image(), G = T.url, V = T.credentials;
          V && V === "include" ? Z.crossOrigin = "use-credentials" : (V && V === "same-origin" || !s.s(G)) && (Z.crossOrigin = "anonymous"), P.signal.addEventListener("abort", () => {
            Z.src = "", N(s.c());
          }), Z.fetchPriority = "high", Z.onload = () => {
            Z.onerror = Z.onload = null, F({ data: Z });
          }, Z.onerror = () => {
            Z.onerror = Z.onload = null, P.signal.aborted || N(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, Z.src = G;
        });
      }(Te || (Te = {})), Te.resetRequestQueue();
      class ze {
        constructor(e) {
          this._transformRequestFn = e;
        }
        transformRequest(e, r) {
          return this._transformRequestFn && this._transformRequestFn(e, r) || { url: e };
        }
        setTransformRequest(e) {
          this._transformRequestFn = e;
        }
      }
      function qe(c) {
        var e = new s.A(3);
        return e[0] = c[0], e[1] = c[1], e[2] = c[2], e;
      }
      var at, Ie = function(c, e, r) {
        return c[0] = e[0] - r[0], c[1] = e[1] - r[1], c[2] = e[2] - r[2], c;
      };
      at = new s.A(3), s.A != Float32Array && (at[0] = 0, at[1] = 0, at[2] = 0);
      var Ae = function(c) {
        var e = c[0], r = c[1];
        return e * e + r * r;
      };
      function me(c) {
        const e = [];
        if (typeof c == "string") e.push({ id: "default", url: c });
        else if (c && c.length > 0) {
          const r = [];
          for (const { id: o, url: h } of c) {
            const p = `${o}${h}`;
            r.indexOf(p) === -1 && (r.push(p), e.push({ id: o, url: h }));
          }
        }
        return e;
      }
      function ve(c, e, r) {
        const o = c.split("?");
        return o[0] += `${e}${r}`, o.join("?");
      }
      (function() {
        var c = new s.A(2);
        s.A != Float32Array && (c[0] = 0, c[1] = 0);
      })();
      class X {
        constructor(e, r, o, h) {
          this.context = e, this.format = o, this.texture = e.gl.createTexture(), this.update(r, h);
        }
        update(e, r, o) {
          const { width: h, height: p } = e, x = !(this.size && this.size[0] === h && this.size[1] === p || o), { context: A } = this, { gl: T } = A;
          if (this.useMipmap = !!(r && r.useMipmap), T.bindTexture(T.TEXTURE_2D, this.texture), A.pixelStoreUnpackFlipY.set(!1), A.pixelStoreUnpack.set(1), A.pixelStoreUnpackPremultiplyAlpha.set(this.format === T.RGBA && (!r || r.premultiply !== !1)), x) this.size = [h, p], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || s.b(e) ? T.texImage2D(T.TEXTURE_2D, 0, this.format, this.format, T.UNSIGNED_BYTE, e) : T.texImage2D(T.TEXTURE_2D, 0, this.format, h, p, 0, this.format, T.UNSIGNED_BYTE, e.data);
          else {
            const { x: P, y: F } = o || { x: 0, y: 0 };
            e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || s.b(e) ? T.texSubImage2D(T.TEXTURE_2D, 0, P, F, T.RGBA, T.UNSIGNED_BYTE, e) : T.texSubImage2D(T.TEXTURE_2D, 0, P, F, h, p, T.RGBA, T.UNSIGNED_BYTE, e.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && T.generateMipmap(T.TEXTURE_2D);
        }
        bind(e, r, o) {
          const { context: h } = this, { gl: p } = h;
          p.bindTexture(p.TEXTURE_2D, this.texture), o !== p.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (o = p.LINEAR), e !== this.filter && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, e), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, o || e), this.filter = e), r !== this.wrap && (p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, r), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, r), this.wrap = r);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: e } = this.context;
          e.deleteTexture(this.texture), this.texture = null;
        }
      }
      function re(c) {
        const { userImage: e } = c;
        return !!(e && e.render && e.render()) && (c.data.replace(new Uint8Array(e.data.buffer)), !0);
      }
      class xe extends s.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new s.R({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(e) {
          if (this.loaded !== e && (this.loaded = e, e)) {
            for (const { ids: r, promiseResolve: o } of this.requestors) o(this._getImagesForIds(r));
            this.requestors = [];
          }
        }
        getImage(e) {
          const r = this.images[e];
          if (r && !r.data && r.spriteData) {
            const o = r.spriteData;
            r.data = new s.R({ width: o.width, height: o.height }, o.context.getImageData(o.x, o.y, o.width, o.height).data), r.spriteData = null;
          }
          return r;
        }
        addImage(e, r) {
          if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
          this._validate(e, r) && (this.images[e] = r);
        }
        _validate(e, r) {
          let o = !0;
          const h = r.data || r.spriteData;
          return this._validateStretch(r.stretchX, h && h.width) || (this.fire(new s.j(new Error(`Image "${e}" has invalid "stretchX" value`))), o = !1), this._validateStretch(r.stretchY, h && h.height) || (this.fire(new s.j(new Error(`Image "${e}" has invalid "stretchY" value`))), o = !1), this._validateContent(r.content, r) || (this.fire(new s.j(new Error(`Image "${e}" has invalid "content" value`))), o = !1), o;
        }
        _validateStretch(e, r) {
          if (!e) return !0;
          let o = 0;
          for (const h of e) {
            if (h[0] < o || h[1] < h[0] || r < h[1]) return !1;
            o = h[1];
          }
          return !0;
        }
        _validateContent(e, r) {
          if (!e) return !0;
          if (e.length !== 4) return !1;
          const o = r.spriteData, h = o && o.width || r.data.width, p = o && o.height || r.data.height;
          return !(e[0] < 0 || h < e[0] || e[1] < 0 || p < e[1] || e[2] < 0 || h < e[2] || e[3] < 0 || p < e[3] || e[2] < e[0] || e[3] < e[1]);
        }
        updateImage(e, r, o = !0) {
          const h = this.getImage(e);
          if (o && (h.data.width !== r.data.width || h.data.height !== r.data.height)) throw new Error(`size mismatch between old image (${h.data.width}x${h.data.height}) and new image (${r.data.width}x${r.data.height}).`);
          r.version = h.version + 1, this.images[e] = r, this.updatedImages[e] = !0;
        }
        removeImage(e) {
          const r = this.images[e];
          delete this.images[e], delete this.patterns[e], r.userImage && r.userImage.onRemove && r.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(e) {
          return new Promise((r, o) => {
            let h = !0;
            if (!this.isLoaded()) for (const p of e) this.images[p] || (h = !1);
            this.isLoaded() || h ? r(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: r });
          });
        }
        _getImagesForIds(e) {
          const r = {};
          for (const o of e) {
            let h = this.getImage(o);
            h || (this.fire(new s.k("styleimagemissing", { id: o })), h = this.getImage(o)), h ? r[o] = { data: h.data.clone(), pixelRatio: h.pixelRatio, sdf: h.sdf, version: h.version, stretchX: h.stretchX, stretchY: h.stretchY, content: h.content, textFitWidth: h.textFitWidth, textFitHeight: h.textFitHeight, hasRenderCallback: !!(h.userImage && h.userImage.render) } : s.w(`Image "${o}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return r;
        }
        getPixelSize() {
          const { width: e, height: r } = this.atlasImage;
          return { width: e, height: r };
        }
        getPattern(e) {
          const r = this.patterns[e], o = this.getImage(e);
          if (!o) return null;
          if (r && r.position.version === o.version) return r.position;
          if (r) r.position.version = o.version;
          else {
            const h = { w: o.data.width + 2, h: o.data.height + 2, x: 0, y: 0 }, p = new s.I(h, o);
            this.patterns[e] = { bin: h, position: p };
          }
          return this._updatePatternAtlas(), this.patterns[e].position;
        }
        bind(e) {
          const r = e.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new X(e, this.atlasImage, r.RGBA), this.atlasTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const e = [];
          for (const p in this.patterns) e.push(this.patterns[p].bin);
          const { w: r, h: o } = s.p(e), h = this.atlasImage;
          h.resize({ width: r || 1, height: o || 1 });
          for (const p in this.patterns) {
            const { bin: x } = this.patterns[p], A = x.x + 1, T = x.y + 1, P = this.getImage(p).data, F = P.width, N = P.height;
            s.R.copy(P, h, { x: 0, y: 0 }, { x: A, y: T }, { width: F, height: N }), s.R.copy(P, h, { x: 0, y: N - 1 }, { x: A, y: T - 1 }, { width: F, height: 1 }), s.R.copy(P, h, { x: 0, y: 0 }, { x: A, y: T + N }, { width: F, height: 1 }), s.R.copy(P, h, { x: F - 1, y: 0 }, { x: A - 1, y: T }, { width: 1, height: N }), s.R.copy(P, h, { x: 0, y: 0 }, { x: A + F, y: T }, { width: 1, height: N });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(e) {
          for (const r of e) {
            if (this.callbackDispatchedThisFrame[r]) continue;
            this.callbackDispatchedThisFrame[r] = !0;
            const o = this.getImage(r);
            o || s.w(`Image with ID: "${r}" was not found`), re(o) && this.updateImage(r, o);
          }
        }
      }
      const ye = 1e20;
      function Ve(c, e, r, o, h, p, x, A, T) {
        for (let P = e; P < e + o; P++) He(c, r * p + P, p, h, x, A, T);
        for (let P = r; P < r + h; P++) He(c, P * p + e, 1, o, x, A, T);
      }
      function He(c, e, r, o, h, p, x) {
        p[0] = 0, x[0] = -ye, x[1] = ye, h[0] = c[e];
        for (let A = 1, T = 0, P = 0; A < o; A++) {
          h[A] = c[e + A * r];
          const F = A * A;
          do {
            const N = p[T];
            P = (h[A] - h[N] + F - N * N) / (A - N) / 2;
          } while (P <= x[T] && --T > -1);
          T++, p[T] = A, x[T] = P, x[T + 1] = ye;
        }
        for (let A = 0, T = 0; A < o; A++) {
          for (; x[T + 1] < A; ) T++;
          const P = p[T], F = A - P;
          c[e + A * r] = h[P] + F * F;
        }
      }
      class Ze {
        constructor(e, r) {
          this.requestManager = e, this.localIdeographFontFamily = r, this.entries = {};
        }
        setURL(e) {
          this.url = e;
        }
        getGlyphs(e) {
          return s._(this, void 0, void 0, function* () {
            const r = [];
            for (const p in e) for (const x of e[p]) r.push(this._getAndCacheGlyphsPromise(p, x));
            const o = yield Promise.all(r), h = {};
            for (const { stack: p, id: x, glyph: A } of o) h[p] || (h[p] = {}), h[p][x] = A && { id: A.id, bitmap: A.bitmap.clone(), metrics: A.metrics };
            return h;
          });
        }
        _getAndCacheGlyphsPromise(e, r) {
          return s._(this, void 0, void 0, function* () {
            let o = this.entries[e];
            o || (o = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
            let h = o.glyphs[r];
            if (h !== void 0) return { stack: e, id: r, glyph: h };
            if (h = this._tinySDF(o, e, r), h) return o.glyphs[r] = h, { stack: e, id: r, glyph: h };
            const p = Math.floor(r / 256);
            if (256 * p > 65535) throw new Error("glyphs > 65535 not supported");
            if (o.ranges[p]) return { stack: e, id: r, glyph: h };
            if (!this.url) throw new Error("glyphsUrl is not set");
            if (!o.requests[p]) {
              const A = Ze.loadGlyphRange(e, p, this.url, this.requestManager);
              o.requests[p] = A;
            }
            const x = yield o.requests[p];
            for (const A in x) this._doesCharSupportLocalGlyph(+A) || (o.glyphs[+A] = x[+A]);
            return o.ranges[p] = !0, { stack: e, id: r, glyph: x[r] || null };
          });
        }
        _doesCharSupportLocalGlyph(e) {
          return !!this.localIdeographFontFamily && new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e));
        }
        _tinySDF(e, r, o) {
          const h = this.localIdeographFontFamily;
          if (!h || !this._doesCharSupportLocalGlyph(o)) return;
          let p = e.tinySDF;
          if (!p) {
            let A = "400";
            /bold/i.test(r) ? A = "900" : /medium/i.test(r) ? A = "500" : /light/i.test(r) && (A = "200"), p = e.tinySDF = new Ze.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: h, fontWeight: A });
          }
          const x = p.draw(String.fromCharCode(o));
          return { id: o, bitmap: new s.o({ width: x.width || 60, height: x.height || 60 }, x.data), metrics: { width: x.glyphWidth / 2 || 24, height: x.glyphHeight / 2 || 24, left: x.glyphLeft / 2 + 0.5 || 0, top: x.glyphTop / 2 - 27.5 || -8, advance: x.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
        }
      }
      Ze.loadGlyphRange = function(c, e, r, o) {
        return s._(this, void 0, void 0, function* () {
          const h = 256 * e, p = h + 255, x = o.transformRequest(r.replace("{fontstack}", c).replace("{range}", `${h}-${p}`), "Glyphs"), A = yield s.l(x, new AbortController());
          if (!A || !A.data) throw new Error(`Could not load glyph range. range: ${e}, ${h}-${p}`);
          const T = {};
          for (const P of s.n(A.data)) T[P.id] = P;
          return T;
        });
      }, Ze.TinySDF = class {
        constructor({ fontSize: c = 24, buffer: e = 3, radius: r = 8, cutoff: o = 0.25, fontFamily: h = "sans-serif", fontWeight: p = "normal", fontStyle: x = "normal" } = {}) {
          this.buffer = e, this.cutoff = o, this.radius = r;
          const A = this.size = c + 4 * e, T = this._createCanvas(A), P = this.ctx = T.getContext("2d", { willReadFrequently: !0 });
          P.font = `${x} ${p} ${c}px ${h}`, P.textBaseline = "alphabetic", P.textAlign = "left", P.fillStyle = "black", this.gridOuter = new Float64Array(A * A), this.gridInner = new Float64Array(A * A), this.f = new Float64Array(A), this.z = new Float64Array(A + 1), this.v = new Uint16Array(A);
        }
        _createCanvas(c) {
          const e = document.createElement("canvas");
          return e.width = e.height = c, e;
        }
        draw(c) {
          const { width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: o, actualBoundingBoxLeft: h, actualBoundingBoxRight: p } = this.ctx.measureText(c), x = Math.ceil(r), A = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(p - h))), T = Math.min(this.size - this.buffer, x + Math.ceil(o)), P = A + 2 * this.buffer, F = T + 2 * this.buffer, N = Math.max(P * F, 0), Z = new Uint8ClampedArray(N), G = { data: Z, width: P, height: F, glyphWidth: A, glyphHeight: T, glyphTop: x, glyphLeft: 0, glyphAdvance: e };
          if (A === 0 || T === 0) return G;
          const { ctx: V, buffer: W, gridInner: ae, gridOuter: oe } = this;
          V.clearRect(W, W, A, T), V.fillText(c, W, W + x);
          const de = V.getImageData(W, W, A, T);
          oe.fill(ye, 0, N), ae.fill(0, 0, N);
          for (let ce = 0; ce < T; ce++) for (let we = 0; we < A; we++) {
            const Le = de.data[4 * (ce * A + we) + 3] / 255;
            if (Le === 0) continue;
            const ke = (ce + W) * P + we + W;
            if (Le === 1) oe[ke] = 0, ae[ke] = ye;
            else {
              const tt = 0.5 - Le;
              oe[ke] = tt > 0 ? tt * tt : 0, ae[ke] = tt < 0 ? tt * tt : 0;
            }
          }
          Ve(oe, 0, 0, P, F, P, this.f, this.v, this.z), Ve(ae, W, W, A, T, P, this.f, this.v, this.z);
          for (let ce = 0; ce < N; ce++) {
            const we = Math.sqrt(oe[ce]) - Math.sqrt(ae[ce]);
            Z[ce] = Math.round(255 - 255 * (we / this.radius + this.cutoff));
          }
          return G;
        }
      };
      class je {
        constructor() {
          this.specification = s.v.light.position;
        }
        possiblyEvaluate(e, r) {
          return s.x(e.expression.evaluate(r));
        }
        interpolate(e, r, o) {
          return { x: s.y.number(e.x, r.x, o), y: s.y.number(e.y, r.y, o), z: s.y.number(e.z, r.z, o) };
        }
      }
      let Je;
      class Qe extends s.E {
        constructor(e) {
          super(), Je = Je || new s.q({ anchor: new s.D(s.v.light.anchor), position: new je(), color: new s.D(s.v.light.color), intensity: new s.D(s.v.light.intensity) }), this._transitionable = new s.T(Je), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(e, r = {}) {
          if (!this._validate(s.r, e, r)) for (const o in e) {
            const h = e[o];
            o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), h) : this._transitionable.setValue(o, h);
          }
        }
        updateTransitions(e) {
          this._transitioning = this._transitionable.transitioned(e, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e) {
          this.properties = this._transitioning.possiblyEvaluate(e);
        }
        _validate(e, r, o) {
          return (!o || o.validate !== !1) && s.t(this, e.call(s.u, { value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: s.v }));
        }
      }
      const nt = new s.q({ "sky-color": new s.D(s.v.sky["sky-color"]), "horizon-color": new s.D(s.v.sky["horizon-color"]), "fog-color": new s.D(s.v.sky["fog-color"]), "fog-ground-blend": new s.D(s.v.sky["fog-ground-blend"]), "horizon-fog-blend": new s.D(s.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new s.D(s.v.sky["sky-horizon-blend"]), "atmosphere-blend": new s.D(s.v.sky["atmosphere-blend"]) });
      class Q extends s.E {
        constructor(e) {
          super(), this._transitionable = new s.T(nt), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.z(0));
        }
        setSky(e, r = {}) {
          if (!this._validate(s.B, e, r)) {
            e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
            for (const o in e) {
              const h = e[o];
              o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), h) : this._transitionable.setValue(o, h);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(e) {
          this._transitioning = this._transitionable.transitioned(e, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e) {
          this.properties = this._transitioning.possiblyEvaluate(e);
        }
        _validate(e, r, o = {}) {
          return (o == null ? void 0 : o.validate) !== !1 && s.t(this, e.call(s.u, s.e({ value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: s.v })));
        }
        calculateFogBlendOpacity(e) {
          return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
        }
      }
      class _e {
        constructor(e, r) {
          this.width = e, this.height = r, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(e, r) {
          const o = e.join(",") + String(r);
          return this.dashEntry[o] || (this.dashEntry[o] = this.addDash(e, r)), this.dashEntry[o];
        }
        getDashRanges(e, r, o) {
          const h = [];
          let p = e.length % 2 == 1 ? -e[e.length - 1] * o : 0, x = e[0] * o, A = !0;
          h.push({ left: p, right: x, isDash: A, zeroLength: e[0] === 0 });
          let T = e[0];
          for (let P = 1; P < e.length; P++) {
            A = !A;
            const F = e[P];
            p = T * o, T += F, x = T * o, h.push({ left: p, right: x, isDash: A, zeroLength: F === 0 });
          }
          return h;
        }
        addRoundDash(e, r, o) {
          const h = r / 2;
          for (let p = -o; p <= o; p++) {
            const x = this.width * (this.nextRow + o + p);
            let A = 0, T = e[A];
            for (let P = 0; P < this.width; P++) {
              P / T.right > 1 && (T = e[++A]);
              const F = Math.abs(P - T.left), N = Math.abs(P - T.right), Z = Math.min(F, N);
              let G;
              const V = p / o * (h + 1);
              if (T.isDash) {
                const W = h - Math.abs(V);
                G = Math.sqrt(Z * Z + W * W);
              } else G = h - Math.sqrt(Z * Z + V * V);
              this.data[x + P] = Math.max(0, Math.min(255, G + 128));
            }
          }
        }
        addRegularDash(e) {
          for (let A = e.length - 1; A >= 0; --A) {
            const T = e[A], P = e[A + 1];
            T.zeroLength ? e.splice(A, 1) : P && P.isDash === T.isDash && (P.left = T.left, e.splice(A, 1));
          }
          const r = e[0], o = e[e.length - 1];
          r.isDash === o.isDash && (r.left = o.left - this.width, o.right = r.right + this.width);
          const h = this.width * this.nextRow;
          let p = 0, x = e[p];
          for (let A = 0; A < this.width; A++) {
            A / x.right > 1 && (x = e[++p]);
            const T = Math.abs(A - x.left), P = Math.abs(A - x.right), F = Math.min(T, P);
            this.data[h + A] = Math.max(0, Math.min(255, (x.isDash ? F : -F) + 128));
          }
        }
        addDash(e, r) {
          const o = r ? 7 : 0, h = 2 * o + 1;
          if (this.nextRow + h > this.height) return s.w("LineAtlas out of space"), null;
          let p = 0;
          for (let A = 0; A < e.length; A++) p += e[A];
          if (p !== 0) {
            const A = this.width / p, T = this.getDashRanges(e, this.width, A);
            r ? this.addRoundDash(T, A, o) : this.addRegularDash(T);
          }
          const x = { y: (this.nextRow + o + 0.5) / this.height, height: 2 * o / this.height, width: p };
          return this.nextRow += h, this.dirty = !0, x;
        }
        bind(e) {
          const r = e.gl;
          this.texture ? (r.bindTexture(r.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, this.width, this.height, r.ALPHA, r.UNSIGNED_BYTE, this.data))) : (this.texture = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this.texture), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texImage2D(r.TEXTURE_2D, 0, r.ALPHA, this.width, this.height, 0, r.ALPHA, r.UNSIGNED_BYTE, this.data));
        }
      }
      const be = "maplibre_preloaded_worker_pool";
      class Ce {
        constructor() {
          this.active = {};
        }
        acquire(e) {
          if (!this.workers) for (this.workers = []; this.workers.length < Ce.workerCount; ) this.workers.push(new Worker(s.a.WORKER_URL));
          return this.active[e] = !0, this.workers.slice();
        }
        release(e) {
          delete this.active[e], this.numActive() === 0 && (this.workers.forEach((r) => {
            r.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[be];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const Oe = Math.floor(q.hardwareConcurrency / 2);
      let $e, Ue;
      function Ke() {
        return $e || ($e = new Ce()), $e;
      }
      Ce.workerCount = s.C(globalThis) ? Math.max(Math.min(Oe, 3), 1) : 1;
      class rt {
        constructor(e, r) {
          this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = r;
          const o = this.workerPool.acquire(r);
          for (let h = 0; h < o.length; h++) {
            const p = new s.F(o[h], r);
            p.name = `Worker ${h}`, this.actors.push(p);
          }
          if (!this.actors.length) throw new Error("No actors found");
        }
        broadcast(e, r) {
          const o = [];
          for (const h of this.actors) o.push(h.sendAsync({ type: e, data: r }));
          return Promise.all(o);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(e = !0) {
          this.actors.forEach((r) => {
            r.remove();
          }), this.actors = [], e && this.workerPool.release(this.id);
        }
        registerMessageHandler(e, r) {
          for (const o of this.actors) o.registerMessageHandler(e, r);
        }
      }
      function ot() {
        return Ue || (Ue = new rt(Ke(), s.G), Ue.registerMessageHandler("GR", (c, e, r) => s.m(e, r))), Ue;
      }
      function vt(c, e) {
        const r = s.H();
        return s.J(r, r, [1, 1, 0]), s.K(r, r, [0.5 * c.width, 0.5 * c.height, 1]), s.L(r, r, c.calculatePosMatrix(e.toUnwrapped()));
      }
      function mt(c, e, r, o, h, p) {
        const x = function(N, Z, G) {
          if (N) for (const V of N) {
            const W = Z[V];
            if (W && W.source === G && W.type === "fill-extrusion") return !0;
          }
          else for (const V in Z) {
            const W = Z[V];
            if (W.source === G && W.type === "fill-extrusion") return !0;
          }
          return !1;
        }(h && h.layers, e, c.id), A = p.maxPitchScaleFactor(), T = c.tilesIn(o, A, x);
        T.sort(Pt);
        const P = [];
        for (const N of T) P.push({ wrappedTileID: N.tileID.wrapped().key, queryResults: N.tile.queryRenderedFeatures(e, r, c._state, N.queryGeometry, N.cameraQueryGeometry, N.scale, h, p, A, vt(c.transform, N.tileID)) });
        const F = function(N) {
          const Z = {}, G = {};
          for (const V of N) {
            const W = V.queryResults, ae = V.wrappedTileID, oe = G[ae] = G[ae] || {};
            for (const de in W) {
              const ce = W[de], we = oe[de] = oe[de] || {}, Le = Z[de] = Z[de] || [];
              for (const ke of ce) we[ke.featureIndex] || (we[ke.featureIndex] = !0, Le.push(ke));
            }
          }
          return Z;
        }(P);
        for (const N in F) F[N].forEach((Z) => {
          const G = Z.feature, V = c.getFeatureState(G.layer["source-layer"], G.id);
          G.source = G.layer.source, G.layer["source-layer"] && (G.sourceLayer = G.layer["source-layer"]), G.state = V;
        });
        return F;
      }
      function Pt(c, e) {
        const r = c.tileID, o = e.tileID;
        return r.overscaledZ - o.overscaledZ || r.canonical.y - o.canonical.y || r.wrap - o.wrap || r.canonical.x - o.canonical.x;
      }
      function it(c, e, r) {
        return s._(this, void 0, void 0, function* () {
          let o = c;
          if (c.url ? o = (yield s.h(e.transformRequest(c.url, "Source"), r)).data : yield q.frameAsync(r), !o) return null;
          const h = s.M(s.e(o, c), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in o && o.vector_layers && (h.vectorLayerIds = o.vector_layers.map((p) => p.id)), h;
        });
      }
      class Y {
        constructor(e, r) {
          e && (r ? this.setSouthWest(e).setNorthEast(r) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
        }
        setNorthEast(e) {
          return this._ne = e instanceof s.N ? new s.N(e.lng, e.lat) : s.N.convert(e), this;
        }
        setSouthWest(e) {
          return this._sw = e instanceof s.N ? new s.N(e.lng, e.lat) : s.N.convert(e), this;
        }
        extend(e) {
          const r = this._sw, o = this._ne;
          let h, p;
          if (e instanceof s.N) h = e, p = e;
          else {
            if (!(e instanceof Y)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(Y.convert(e)) : this.extend(s.N.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(s.N.convert(e)) : this;
            if (h = e._sw, p = e._ne, !h || !p) return this;
          }
          return r || o ? (r.lng = Math.min(h.lng, r.lng), r.lat = Math.min(h.lat, r.lat), o.lng = Math.max(p.lng, o.lng), o.lat = Math.max(p.lat, o.lat)) : (this._sw = new s.N(h.lng, h.lat), this._ne = new s.N(p.lng, p.lat)), this;
        }
        getCenter() {
          return new s.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new s.N(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new s.N(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(e) {
          const { lng: r, lat: o } = s.N.convert(e);
          let h = this._sw.lng <= r && r <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (h = this._sw.lng >= r && r >= this._ne.lng), this._sw.lat <= o && o <= this._ne.lat && h;
        }
        static convert(e) {
          return e instanceof Y ? e : e && new Y(e);
        }
        static fromLngLat(e, r = 0) {
          const o = 360 * r / 40075017, h = o / Math.cos(Math.PI / 180 * e.lat);
          return new Y(new s.N(e.lng - h, e.lat - o), new s.N(e.lng + h, e.lat + o));
        }
        adjustAntiMeridian() {
          const e = new s.N(this._sw.lng, this._sw.lat), r = new s.N(this._ne.lng, this._ne.lat);
          return new Y(e, e.lng > r.lng ? new s.N(r.lng + 360, r.lat) : r);
        }
      }
      class Kt {
        constructor(e, r, o) {
          this.bounds = Y.convert(this.validateBounds(e)), this.minzoom = r || 0, this.maxzoom = o || 24;
        }
        validateBounds(e) {
          return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
        }
        contains(e) {
          const r = Math.pow(2, e.z), o = Math.floor(s.O(this.bounds.getWest()) * r), h = Math.floor(s.Q(this.bounds.getNorth()) * r), p = Math.ceil(s.O(this.bounds.getEast()) * r), x = Math.ceil(s.Q(this.bounds.getSouth()) * r);
          return e.x >= o && e.x < p && e.y >= h && e.y < x;
        }
      }
      class Rt extends s.E {
        constructor(e, r, o, h) {
          if (super(), this.id = e, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, s.e(this, s.M(r, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.e({ type: "vector" }, r), this._collectResourceTiming = r.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(h);
        }
        load() {
          return s._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new s.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const e = yield it(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (s.e(this, e), e.bounds && (this.tileBounds = new Kt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new s.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (e) {
              this._tileJSONRequest = null, this.fire(new s.j(e));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e) {
          return !this.tileBounds || this.tileBounds.contains(e.canonical);
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        setSourceProperty(e) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
        }
        setTiles(e) {
          return this.setSourceProperty(() => {
            this._options.tiles = e;
          }), this;
        }
        setUrl(e) {
          return this.setSourceProperty(() => {
            this.url = e, this._options.url = e;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return s.e({}, this._options);
        }
        loadTile(e) {
          return s._(this, void 0, void 0, function* () {
            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), o = { request: this.map._requestManager.transformRequest(r, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            o.request.collectResourceTiming = this._collectResourceTiming;
            let h = "RT";
            if (e.actor && e.state !== "expired") {
              if (e.state === "loading") return new Promise((p, x) => {
                e.reloadPromise = { resolve: p, reject: x };
              });
            } else e.actor = this.dispatcher.getActor(), h = "LT";
            e.abortController = new AbortController();
            try {
              const p = yield e.actor.sendAsync({ type: h, data: o }, e.abortController);
              if (delete e.abortController, e.aborted) return;
              this._afterTileLoadWorkerResponse(e, p);
            } catch (p) {
              if (delete e.abortController, e.aborted) return;
              if (p && p.status !== 404) throw p;
              this._afterTileLoadWorkerResponse(e, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(e, r) {
          if (r && r.resourceTiming && (e.resourceTiming = r.resourceTiming), r && this.map._refreshExpiredTiles && e.setExpiryData(r), e.loadVectorData(r, this.map.painter), e.reloadPromise) {
            const o = e.reloadPromise;
            e.reloadPromise = null, this.loadTile(e).then(o.resolve).catch(o.reject);
          }
        }
        abortTile(e) {
          return s._(this, void 0, void 0, function* () {
            e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(e) {
          return s._(this, void 0, void 0, function* () {
            e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class lt extends s.E {
        constructor(e, r, o, h) {
          super(), this.id = e, this.dispatcher = o, this.setEventedParent(h), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = s.e({ type: "raster" }, r), s.e(this, s.M(r, ["url", "scheme", "tileSize"]));
        }
        load() {
          return s._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new s.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const e = yield it(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, e && (s.e(this, e), e.bounds && (this.tileBounds = new Kt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new s.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (e) {
              this._tileJSONRequest = null, this.fire(new s.j(e));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(e) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load();
        }
        setTiles(e) {
          return this.setSourceProperty(() => {
            this._options.tiles = e;
          }), this;
        }
        setUrl(e) {
          return this.setSourceProperty(() => {
            this.url = e, this._options.url = e;
          }), this;
        }
        serialize() {
          return s.e({}, this._options);
        }
        hasTile(e) {
          return !this.tileBounds || this.tileBounds.contains(e.canonical);
        }
        loadTile(e) {
          return s._(this, void 0, void 0, function* () {
            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            e.abortController = new AbortController();
            try {
              const o = yield Te.getImage(this.map._requestManager.transformRequest(r, "Tile"), e.abortController, this.map._refreshExpiredTiles);
              if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
              if (o && o.data) {
                this.map._refreshExpiredTiles && o.cacheControl && o.expires && e.setExpiryData({ cacheControl: o.cacheControl, expires: o.expires });
                const h = this.map.painter.context, p = h.gl, x = o.data;
                e.texture = this.map.painter.getTileTexture(x.width), e.texture ? e.texture.update(x, { useMipmap: !0 }) : (e.texture = new X(h, x, p.RGBA, { useMipmap: !0 }), e.texture.bind(p.LINEAR, p.CLAMP_TO_EDGE, p.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
              }
            } catch (o) {
              if (delete e.abortController, e.aborted) e.state = "unloaded";
              else if (o) throw e.state = "errored", o;
            }
          });
        }
        abortTile(e) {
          return s._(this, void 0, void 0, function* () {
            e.abortController && (e.abortController.abort(), delete e.abortController);
          });
        }
        unloadTile(e) {
          return s._(this, void 0, void 0, function* () {
            e.texture && this.map.painter.saveTileTexture(e.texture);
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class xt extends lt {
        constructor(e, r, o, h) {
          super(e, r, o, h), this.type = "raster-dem", this.maxzoom = 22, this._options = s.e({ type: "raster-dem" }, r), this.encoding = r.encoding || "mapbox", this.redFactor = r.redFactor, this.greenFactor = r.greenFactor, this.blueFactor = r.blueFactor, this.baseShift = r.baseShift;
        }
        loadTile(e) {
          return s._(this, void 0, void 0, function* () {
            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), o = this.map._requestManager.transformRequest(r, "Tile");
            e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
            try {
              const h = yield Te.getImage(o, e.abortController, this.map._refreshExpiredTiles);
              if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
              if (h && h.data) {
                const p = h.data;
                this.map._refreshExpiredTiles && h.cacheControl && h.expires && e.setExpiryData({ cacheControl: h.cacheControl, expires: h.expires });
                const x = s.b(p) && s.U() ? p : yield this.readImageNow(p), A = { type: this.type, uid: e.uid, source: this.id, rawImageData: x, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!e.actor || e.state === "expired") {
                  e.actor = this.dispatcher.getActor();
                  const T = yield e.actor.sendAsync({ type: "LDT", data: A });
                  e.dem = T, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded";
                }
              }
            } catch (h) {
              if (delete e.abortController, e.aborted) e.state = "unloaded";
              else if (h) throw e.state = "errored", h;
            }
          });
        }
        readImageNow(e) {
          return s._(this, void 0, void 0, function* () {
            if (typeof VideoFrame < "u" && s.V()) {
              const r = e.width + 2, o = e.height + 2;
              try {
                return new s.R({ width: r, height: o }, yield s.W(e, -1, -1, r, o));
              } catch {
              }
            }
            return q.getImageData(e, 1);
          });
        }
        _getNeighboringTiles(e) {
          const r = e.canonical, o = Math.pow(2, r.z), h = (r.x - 1 + o) % o, p = r.x === 0 ? e.wrap - 1 : e.wrap, x = (r.x + 1 + o) % o, A = r.x + 1 === o ? e.wrap + 1 : e.wrap, T = {};
          return T[new s.S(e.overscaledZ, p, r.z, h, r.y).key] = { backfilled: !1 }, T[new s.S(e.overscaledZ, A, r.z, x, r.y).key] = { backfilled: !1 }, r.y > 0 && (T[new s.S(e.overscaledZ, p, r.z, h, r.y - 1).key] = { backfilled: !1 }, T[new s.S(e.overscaledZ, e.wrap, r.z, r.x, r.y - 1).key] = { backfilled: !1 }, T[new s.S(e.overscaledZ, A, r.z, x, r.y - 1).key] = { backfilled: !1 }), r.y + 1 < o && (T[new s.S(e.overscaledZ, p, r.z, h, r.y + 1).key] = { backfilled: !1 }, T[new s.S(e.overscaledZ, e.wrap, r.z, r.x, r.y + 1).key] = { backfilled: !1 }, T[new s.S(e.overscaledZ, A, r.z, x, r.y + 1).key] = { backfilled: !1 }), T;
        }
        unloadTile(e) {
          return s._(this, void 0, void 0, function* () {
            e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
          });
        }
      }
      class At extends s.E {
        constructor(e, r, o, h) {
          super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = o.getActor(), this.setEventedParent(h), this._data = r.data, this._options = s.e({}, r), this._collectResourceTiming = r.collectResourceTiming, r.maxzoom !== void 0 && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type), r.attribution && (this.attribution = r.attribution), this.promoteId = r.promoteId;
          const p = s.X / this.tileSize;
          r.clusterMaxZoom !== void 0 && this.maxzoom <= r.clusterMaxZoom && s.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${r.clusterMaxZoom}".`), this.workerOptions = s.e({ source: this.id, cluster: r.cluster || !1, geojsonVtOptions: { buffer: (r.buffer !== void 0 ? r.buffer : 128) * p, tolerance: (r.tolerance !== void 0 ? r.tolerance : 0.375) * p, extent: s.X, maxZoom: this.maxzoom, lineMetrics: r.lineMetrics || !1, generateId: r.generateId || !1 }, superclusterOptions: { maxZoom: r.clusterMaxZoom !== void 0 ? r.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, r.clusterMinPoints || 2), extent: s.X, radius: (r.clusterRadius || 50) * p, log: !1, generateId: r.generateId || !1 }, clusterProperties: r.clusterProperties, filter: r.filter }, r.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        load() {
          return s._(this, void 0, void 0, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        setData(e) {
          return this._data = e, this._updateWorkerData(), this;
        }
        updateData(e) {
          return this._updateWorkerData(e), this;
        }
        getData() {
          return s._(this, void 0, void 0, function* () {
            const e = s.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: e });
          });
        }
        setClusterOptions(e) {
          return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = e.clusterRadius), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(e) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
        }
        getClusterChildren(e) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
        }
        getClusterLeaves(e, r, o) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: r, offset: o } });
        }
        _updateWorkerData(e) {
          return s._(this, void 0, void 0, function* () {
            const r = s.e({ type: this.type }, this.workerOptions);
            e ? r.dataDiff = e : typeof this._data == "string" ? (r.request = this.map._requestManager.transformRequest(q.resolveURL(this._data), "Source"), r.request.collectResourceTiming = this._collectResourceTiming) : r.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new s.k("dataloading", { dataType: "source" }));
            try {
              const o = yield this.actor.sendAsync({ type: "LD", data: r });
              if (this._pendingLoads--, this._removed || o.abandoned) return void this.fire(new s.k("dataabort", { dataType: "source" }));
              let h = null;
              o.resourceTiming && o.resourceTiming[this.id] && (h = o.resourceTiming[this.id].slice(0));
              const p = { dataType: "source" };
              this._collectResourceTiming && h && h.length > 0 && s.e(p, { resourceTiming: h }), this.fire(new s.k("data", Object.assign(Object.assign({}, p), { sourceDataType: "metadata" }))), this.fire(new s.k("data", Object.assign(Object.assign({}, p), { sourceDataType: "content" })));
            } catch (o) {
              if (this._pendingLoads--, this._removed) return void this.fire(new s.k("dataabort", { dataType: "source" }));
              this.fire(new s.j(o));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(e) {
          return s._(this, void 0, void 0, function* () {
            const r = e.actor ? "RT" : "LT";
            e.actor = this.actor;
            const o = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            e.abortController = new AbortController();
            const h = yield this.actor.sendAsync({ type: r, data: o }, e.abortController);
            delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(h, this.map.painter, r === "RT");
          });
        }
        abortTile(e) {
          return s._(this, void 0, void 0, function* () {
            e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0;
          });
        }
        unloadTile(e) {
          return s._(this, void 0, void 0, function* () {
            e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return s.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      var Et = s.Y([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class jt extends s.E {
        constructor(e, r, o, h) {
          super(), this.id = e, this.dispatcher = o, this.coordinates = r.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(h), this.options = r;
        }
        load(e) {
          return s._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new s.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
            try {
              const r = yield Te.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = !0, r && r.data && (this.image = r.data, e && (this.coordinates = e), this._finishLoading());
            } catch (r) {
              this._request = null, this._loaded = !0, this.fire(new s.j(r));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e) {
          return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new s.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(e) {
          this.coordinates = e;
          const r = e.map(s.Z.fromLngLat);
          this.tileID = function(h) {
            let p = 1 / 0, x = 1 / 0, A = -1 / 0, T = -1 / 0;
            for (const Z of h) p = Math.min(p, Z.x), x = Math.min(x, Z.y), A = Math.max(A, Z.x), T = Math.max(T, Z.y);
            const P = Math.max(A - p, T - x), F = Math.max(0, Math.floor(-Math.log(P) / Math.LN2)), N = Math.pow(2, F);
            return new s.a1(F, Math.floor((p + A) / 2 * N), Math.floor((x + T) / 2 * N));
          }(r), this.minzoom = this.maxzoom = this.tileID.z;
          const o = r.map((h) => this.tileID.getTilePoint(h)._round());
          return this._boundsArray = new s.$(), this._boundsArray.emplaceBack(o[0].x, o[0].y, 0, 0), this._boundsArray.emplaceBack(o[1].x, o[1].y, s.X, 0), this._boundsArray.emplaceBack(o[3].x, o[3].y, 0, s.X), this._boundsArray.emplaceBack(o[2].x, o[2].y, s.X, s.X), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new s.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) return;
          const e = this.map.painter.context, r = e.gl;
          this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, Et.members)), this.boundsSegments || (this.boundsSegments = s.a0.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new X(e, this.image, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
          let o = !1;
          for (const h in this.tiles) {
            const p = this.tiles[h];
            p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, o = !0);
          }
          o && this.fire(new s.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(e) {
          return s._(this, void 0, void 0, function* () {
            this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class ni extends jt {
        constructor(e, r, o, h) {
          super(e, r, o, h), this.roundZoom = !0, this.type = "video", this.options = r;
        }
        load() {
          return s._(this, void 0, void 0, function* () {
            this._loaded = !1;
            const e = this.options;
            this.urls = [];
            for (const r of e.urls) this.urls.push(this.map._requestManager.transformRequest(r, "Source").url);
            try {
              const r = yield s.a3(this.urls);
              if (this._loaded = !0, !r) return;
              this.video = r, this.video.loop = !0, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (r) {
              this.fire(new s.j(r));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(e) {
          if (this.video) {
            const r = this.video.seekable;
            e < r.start(0) || e > r.end(0) ? this.fire(new s.j(new s.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${r.start(0)} and ${r.end(0)}-second mark.`))) : this.video.currentTime = e;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e) {
          this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
          const e = this.map.painter.context, r = e.gl;
          this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, Et.members)), this.boundsSegments || (this.boundsSegments = s.a0.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, r.RGBA, r.UNSIGNED_BYTE, this.video)) : (this.texture = new X(e, this.video, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
          let o = !1;
          for (const h in this.tiles) {
            const p = this.tiles[h];
            p.state !== "loaded" && (p.state = "loaded", p.texture = this.texture, o = !0);
          }
          o && this.fire(new s.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class ii extends jt {
        constructor(e, r, o, h) {
          super(e, r, o, h), r.coordinates ? Array.isArray(r.coordinates) && r.coordinates.length === 4 && !r.coordinates.some((p) => !Array.isArray(p) || p.length !== 2 || p.some((x) => typeof x != "number")) || this.fire(new s.j(new s.a2(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.j(new s.a2(`sources.${e}`, null, 'missing required property "coordinates"'))), r.animate && typeof r.animate != "boolean" && this.fire(new s.j(new s.a2(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), r.canvas ? typeof r.canvas == "string" || r.canvas instanceof HTMLCanvasElement || this.fire(new s.j(new s.a2(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.j(new s.a2(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = r, this.animate = r.animate === void 0 || r.animate;
        }
        load() {
          return s._(this, void 0, void 0, function* () {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e) {
          this.map = e, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let e = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
          const r = this.map.painter.context, o = r.gl;
          this.boundsBuffer || (this.boundsBuffer = r.createVertexBuffer(this._boundsArray, Et.members)), this.boundsSegments || (this.boundsSegments = s.a0.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new X(r, this.canvas, o.RGBA, { premultiply: !0 });
          let h = !1;
          for (const p in this.tiles) {
            const x = this.tiles[p];
            x.state !== "loaded" && (x.state = "loaded", x.texture = this.texture, h = !0);
          }
          h && this.fire(new s.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
          return !1;
        }
      }
      const yi = {}, xi = (c) => {
        switch (c) {
          case "geojson":
            return At;
          case "image":
            return jt;
          case "raster":
            return lt;
          case "raster-dem":
            return xt;
          case "vector":
            return Rt;
          case "video":
            return ni;
          case "canvas":
            return ii;
        }
        return yi[c];
      }, pt = "RTLPluginLoaded";
      class Jt extends s.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = ot();
        }
        _syncState(e) {
          return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch((r) => {
            throw this.status = "error", r;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(e) {
          return s._(this, arguments, void 0, function* (r, o = !1) {
            if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            if (this.url = q.resolveURL(r), !this.url) throw new Error(`requested url ${r} is invalid`);
            if (this.status === "unavailable") {
              if (!o) return this._requestImport();
              this.status = "deferred", this._syncState(this.status);
            } else if (this.status === "requested") return this._requestImport();
          });
        }
        _requestImport() {
          return s._(this, void 0, void 0, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new s.k(pt));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let ai = null;
      function kt() {
        return ai || (ai = new Jt()), ai;
      }
      class Zi {
        constructor(e, r) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = s.a4(), this.uses = 0, this.tileSize = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(e) {
          const r = e + this.timeAdded;
          r < this.fadeEndTime || (this.fadeEndTime = r);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(e) {
          this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(e, r, o) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
            e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function(h, p) {
              const x = {};
              if (!p) return x;
              for (const A of h) {
                const T = A.layerIds.map((P) => p.getLayer(P)).filter(Boolean);
                if (T.length !== 0) {
                  A.layers = T, A.stateDependentLayerIds && (A.stateDependentLayers = A.stateDependentLayerIds.map((P) => T.filter((F) => F.id === P)[0]));
                  for (const P of T) x[P.id] = A;
                }
              }
              return x;
            }(e.buckets, r.style), this.hasSymbolBuckets = !1;
            for (const h in this.buckets) {
              const p = this.buckets[h];
              if (p instanceof s.a6) {
                if (this.hasSymbolBuckets = !0, !o) break;
                p.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const h in this.buckets) {
              const p = this.buckets[h];
              if (p instanceof s.a6 && p.hasRTLText) {
                this.hasRTLText = !0, kt().lazyLoad();
                break;
              }
            }
            this.queryPadding = 0;
            for (const h in this.buckets) {
              const p = this.buckets[h];
              this.queryPadding = Math.max(this.queryPadding, r.style.getLayer(h).queryRadius(p));
            }
            e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
          } else this.collisionBoxArray = new s.a5();
        }
        unloadVectorData() {
          for (const e in this.buckets) this.buckets[e].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(e) {
          return this.buckets[e.id];
        }
        upload(e) {
          for (const o in this.buckets) {
            const h = this.buckets[o];
            h.uploadPending() && h.upload(e);
          }
          const r = e.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new X(e, this.imageAtlas.image, r.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new X(e, this.glyphAtlasImage, r.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(e) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
        }
        queryRenderedFeatures(e, r, o, h, p, x, A, T, P, F) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: h, cameraQueryGeometry: p, scale: x, tileSize: this.tileSize, pixelPosMatrix: F, transform: T, params: A, queryPadding: this.queryPadding * P }, e, r, o) : {};
        }
        querySourceFeatures(e, r) {
          const o = this.latestFeatureIndex;
          if (!o || !o.rawTileData) return;
          const h = o.loadVTLayers(), p = r && r.sourceLayer ? r.sourceLayer : "", x = h._geojsonTileLayer || h[p];
          if (!x) return;
          const A = s.a7(r && r.filter), { z: T, x: P, y: F } = this.tileID.canonical, N = { z: T, x: P, y: F };
          for (let Z = 0; Z < x.length; Z++) {
            const G = x.feature(Z);
            if (A.needGeometry) {
              const ae = s.a8(G, !0);
              if (!A.filter(new s.z(this.tileID.overscaledZ), ae, this.tileID.canonical)) continue;
            } else if (!A.filter(new s.z(this.tileID.overscaledZ), G)) continue;
            const V = o.getId(G, p), W = new s.a9(G, T, P, F, V);
            W.tile = N, e.push(W);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(e) {
          const r = this.expirationTime;
          if (e.cacheControl) {
            const o = s.aa(e.cacheControl);
            o["max-age"] && (this.expirationTime = Date.now() + 1e3 * o["max-age"]);
          } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
          if (this.expirationTime) {
            const o = Date.now();
            let h = !1;
            if (this.expirationTime > o) h = !1;
            else if (r) if (this.expirationTime < r) h = !0;
            else {
              const p = this.expirationTime - r;
              p ? this.expirationTime = o + Math.max(p, 3e4) : h = !0;
            }
            else h = !0;
            h ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(e, r) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
          const o = this.latestFeatureIndex.loadVTLayers();
          for (const h in this.buckets) {
            if (!r.style.hasLayer(h)) continue;
            const p = this.buckets[h], x = p.layers[0].sourceLayer || "_geojsonTileLayer", A = o[x], T = e[x];
            if (!A || !T || Object.keys(T).length === 0) continue;
            p.update(T, A, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const P = r && r.style && r.style.getLayer(h);
            P && (this.queryPadding = Math.max(this.queryPadding, P.queryRadius(p)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < q.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(e) {
          this.symbolFadeHoldUntil = q.now() + e;
        }
        setDependencies(e, r) {
          const o = {};
          for (const h of r) o[h] = !0;
          this.dependencies[e] = o;
        }
        hasDependency(e, r) {
          for (const o of e) {
            const h = this.dependencies[o];
            if (h) {
              for (const p of r) if (h[p]) return !0;
            }
          }
          return !1;
        }
      }
      class ft {
        constructor(e, r) {
          this.max = e, this.onRemove = r, this.reset();
        }
        reset() {
          for (const e in this.data) for (const r of this.data[e]) r.timeout && clearTimeout(r.timeout), this.onRemove(r.value);
          return this.data = {}, this.order = [], this;
        }
        add(e, r, o) {
          const h = e.wrapped().key;
          this.data[h] === void 0 && (this.data[h] = []);
          const p = { value: r, timeout: void 0 };
          if (o !== void 0 && (p.timeout = setTimeout(() => {
            this.remove(e, p);
          }, o)), this.data[h].push(p), this.order.push(h), this.order.length > this.max) {
            const x = this._getAndRemoveByKey(this.order[0]);
            x && this.onRemove(x);
          }
          return this;
        }
        has(e) {
          return e.wrapped().key in this.data;
        }
        getAndRemove(e) {
          return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
        }
        _getAndRemoveByKey(e) {
          const r = this.data[e].shift();
          return r.timeout && clearTimeout(r.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), r.value;
        }
        getByKey(e) {
          const r = this.data[e];
          return r ? r[0].value : null;
        }
        get(e) {
          return this.has(e) ? this.data[e.wrapped().key][0].value : null;
        }
        remove(e, r) {
          if (!this.has(e)) return this;
          const o = e.wrapped().key, h = r === void 0 ? 0 : this.data[o].indexOf(r), p = this.data[o][h];
          return this.data[o].splice(h, 1), p.timeout && clearTimeout(p.timeout), this.data[o].length === 0 && delete this.data[o], this.onRemove(p.value), this.order.splice(this.order.indexOf(o), 1), this;
        }
        setMaxSize(e) {
          for (this.max = e; this.order.length > this.max; ) {
            const r = this._getAndRemoveByKey(this.order[0]);
            r && this.onRemove(r);
          }
          return this;
        }
        filter(e) {
          const r = [];
          for (const o in this.data) for (const h of this.data[o]) e(h.value) || r.push(h);
          for (const o of r) this.remove(o.value.tileID, o);
        }
      }
      class ri {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(e, r, o) {
          const h = String(r);
          if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][h] = this.stateChanges[e][h] || {}, s.e(this.stateChanges[e][h], o), this.deletedStates[e] === null) {
            this.deletedStates[e] = {};
            for (const p in this.state[e]) p !== h && (this.deletedStates[e][p] = null);
          } else if (this.deletedStates[e] && this.deletedStates[e][h] === null) {
            this.deletedStates[e][h] = {};
            for (const p in this.state[e][h]) o[p] || (this.deletedStates[e][h][p] = null);
          } else for (const p in o) this.deletedStates[e] && this.deletedStates[e][h] && this.deletedStates[e][h][p] === null && delete this.deletedStates[e][h][p];
        }
        removeFeatureState(e, r, o) {
          if (this.deletedStates[e] === null) return;
          const h = String(r);
          if (this.deletedStates[e] = this.deletedStates[e] || {}, o && r !== void 0) this.deletedStates[e][h] !== null && (this.deletedStates[e][h] = this.deletedStates[e][h] || {}, this.deletedStates[e][h][o] = null);
          else if (r !== void 0) if (this.stateChanges[e] && this.stateChanges[e][h]) for (o in this.deletedStates[e][h] = {}, this.stateChanges[e][h]) this.deletedStates[e][h][o] = null;
          else this.deletedStates[e][h] = null;
          else this.deletedStates[e] = null;
        }
        getState(e, r) {
          const o = String(r), h = s.e({}, (this.state[e] || {})[o], (this.stateChanges[e] || {})[o]);
          if (this.deletedStates[e] === null) return {};
          if (this.deletedStates[e]) {
            const p = this.deletedStates[e][r];
            if (p === null) return {};
            for (const x in p) delete h[x];
          }
          return h;
        }
        initializeTileState(e, r) {
          e.setFeatureState(this.state, r);
        }
        coalesceChanges(e, r) {
          const o = {};
          for (const h in this.stateChanges) {
            this.state[h] = this.state[h] || {};
            const p = {};
            for (const x in this.stateChanges[h]) this.state[h][x] || (this.state[h][x] = {}), s.e(this.state[h][x], this.stateChanges[h][x]), p[x] = this.state[h][x];
            o[h] = p;
          }
          for (const h in this.deletedStates) {
            this.state[h] = this.state[h] || {};
            const p = {};
            if (this.deletedStates[h] === null) for (const x in this.state[h]) p[x] = {}, this.state[h][x] = {};
            else for (const x in this.deletedStates[h]) {
              if (this.deletedStates[h][x] === null) this.state[h][x] = {};
              else for (const A of Object.keys(this.deletedStates[h][x])) delete this.state[h][x][A];
              p[x] = this.state[h][x];
            }
            o[h] = o[h] || {}, s.e(o[h], p);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(o).length !== 0) for (const h in e) e[h].setFeatureState(o, r);
        }
      }
      class Lt extends s.E {
        constructor(e, r, o) {
          super(), this.id = e, this.dispatcher = o, this.on("data", (h) => this._dataHandler(h)), this.on("dataloading", () => {
            this._sourceErrored = !1;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((h, p, x, A) => {
            const T = new (xi(p.type))(h, p, x, A);
            if (T.id !== h) throw new Error(`Expected Source id to be ${h} instead of ${T.id}`);
            return T;
          })(e, r, o, this), this._tiles = {}, this._cache = new ft(0, (h) => this._unloadTile(h)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ri(), this._didEmitContent = !1, this._updated = !1;
        }
        onAdd(e) {
          this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
        }
        onRemove(e) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded || !this._source.loaded()) return !1;
          if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
          if (!this._updated) return !1;
          for (const e in this._tiles) {
            const r = this._tiles[e];
            if (r.state !== "loaded" && r.state !== "errored") return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const e = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(e, r, o) {
          return s._(this, void 0, void 0, function* () {
            try {
              yield this._source.loadTile(e), this._tileLoaded(e, r, o);
            } catch (h) {
              e.state = "errored", h.status !== 404 ? this._source.fire(new s.j(h, { tile: e })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(e) {
          this._source.unloadTile && this._source.unloadTile(e);
        }
        _abortTile(e) {
          this._source.abortTile && this._source.abortTile(e), this._source.fire(new s.k("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(e) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const r in this._tiles) {
            const o = this._tiles[r];
            o.upload(e), o.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((e) => e.tileID).sort(Si).map((e) => e.key);
        }
        getRenderableIds(e) {
          const r = [];
          for (const o in this._tiles) this._isIdRenderable(o, e) && r.push(this._tiles[o]);
          return e ? r.sort((o, h) => {
            const p = o.tileID, x = h.tileID, A = new s.P(p.canonical.x, p.canonical.y)._rotate(this.transform.angle), T = new s.P(x.canonical.x, x.canonical.y)._rotate(this.transform.angle);
            return p.overscaledZ - x.overscaledZ || T.y - A.y || T.x - A.x;
          }).map((o) => o.tileID.key) : r.map((o) => o.tileID).sort(Si).map((o) => o.key);
        }
        hasRenderableParent(e) {
          const r = this.findLoadedParent(e, 0);
          return !!r && this._isIdRenderable(r.tileID.key);
        }
        _isIdRenderable(e, r) {
          return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (r || !this._tiles[e].holdingForFade());
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const e in this._tiles) this._tiles[e].state !== "errored" && this._reloadTile(e, "reloading");
          }
        }
        _reloadTile(e, r) {
          return s._(this, void 0, void 0, function* () {
            const o = this._tiles[e];
            o && (o.state !== "loading" && (o.state = r), yield this._loadTile(o, e, r));
          });
        }
        _tileLoaded(e, r, o) {
          e.timeAdded = q.now(), o === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(r, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new s.k("data", { dataType: "source", tile: e, coord: e.tileID }));
        }
        _backfillDEM(e) {
          const r = this.getRenderableIds();
          for (let h = 0; h < r.length; h++) {
            const p = r[h];
            if (e.neighboringTiles && e.neighboringTiles[p]) {
              const x = this.getTileByID(p);
              o(e, x), o(x, e);
            }
          }
          function o(h, p) {
            h.needsHillshadePrepare = !0, h.needsTerrainPrepare = !0;
            let x = p.tileID.canonical.x - h.tileID.canonical.x;
            const A = p.tileID.canonical.y - h.tileID.canonical.y, T = Math.pow(2, h.tileID.canonical.z), P = p.tileID.key;
            x === 0 && A === 0 || Math.abs(A) > 1 || (Math.abs(x) > 1 && (Math.abs(x + T) === 1 ? x += T : Math.abs(x - T) === 1 && (x -= T)), p.dem && h.dem && (h.dem.backfillBorder(p.dem, x, A), h.neighboringTiles && h.neighboringTiles[P] && (h.neighboringTiles[P].backfilled = !0)));
          }
        }
        getTile(e) {
          return this.getTileByID(e.key);
        }
        getTileByID(e) {
          return this._tiles[e];
        }
        _retainLoadedChildren(e, r, o, h) {
          for (const p in this._tiles) {
            let x = this._tiles[p];
            if (h[p] || !x.hasData() || x.tileID.overscaledZ <= r || x.tileID.overscaledZ > o) continue;
            let A = x.tileID;
            for (; x && x.tileID.overscaledZ > r + 1; ) {
              const P = x.tileID.scaledTo(x.tileID.overscaledZ - 1);
              x = this._tiles[P.key], x && x.hasData() && (A = P);
            }
            let T = A;
            for (; T.overscaledZ > r; ) if (T = T.scaledTo(T.overscaledZ - 1), e[T.key]) {
              h[A.key] = A;
              break;
            }
          }
        }
        findLoadedParent(e, r) {
          if (e.key in this._loadedParentTiles) {
            const o = this._loadedParentTiles[e.key];
            return o && o.tileID.overscaledZ >= r ? o : null;
          }
          for (let o = e.overscaledZ - 1; o >= r; o--) {
            const h = e.scaledTo(o), p = this._getLoadedTile(h);
            if (p) return p;
          }
        }
        findLoadedSibling(e) {
          return this._getLoadedTile(e);
        }
        _getLoadedTile(e) {
          const r = this._tiles[e.key];
          return r && r.hasData() ? r : this._cache.getByKey(e.wrapped().key);
        }
        updateCacheSize(e) {
          const r = Math.ceil(e.width / this._source.tileSize) + 1, o = Math.ceil(e.height / this._source.tileSize) + 1, h = Math.floor(r * o * (this._maxTileCacheZoomLevels === null ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), p = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, h) : h;
          this._cache.setMaxSize(p);
        }
        handleWrapJump(e) {
          const r = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
          if (this._prevLng = e, r) {
            const o = {};
            for (const h in this._tiles) {
              const p = this._tiles[h];
              p.tileID = p.tileID.unwrapTo(p.tileID.wrap + r), o[p.tileID.key] = p;
            }
            this._tiles = o;
            for (const h in this._timers) clearTimeout(this._timers[h]), delete this._timers[h];
            for (const h in this._tiles) this._setTileReloadTimer(h, this._tiles[h]);
          }
        }
        _updateCoveredAndRetainedTiles(e, r, o, h, p, x) {
          const A = {}, T = {}, P = Object.keys(e), F = q.now();
          for (const N of P) {
            const Z = e[N], G = this._tiles[N];
            if (!G || G.fadeEndTime !== 0 && G.fadeEndTime <= F) continue;
            const V = this.findLoadedParent(Z, r), W = this.findLoadedSibling(Z), ae = V || W || null;
            ae && (this._addTile(ae.tileID), A[ae.tileID.key] = ae.tileID), T[N] = Z;
          }
          this._retainLoadedChildren(T, h, o, e);
          for (const N in A) e[N] || (this._coveredTiles[N] = !0, e[N] = A[N]);
          if (x) {
            const N = {}, Z = {};
            for (const G of p) this._tiles[G.key].hasData() ? N[G.key] = G : Z[G.key] = G;
            for (const G in Z) {
              const V = Z[G].children(this._source.maxzoom);
              this._tiles[V[0].key] && this._tiles[V[1].key] && this._tiles[V[2].key] && this._tiles[V[3].key] && (N[V[0].key] = e[V[0].key] = V[0], N[V[1].key] = e[V[1].key] = V[1], N[V[2].key] = e[V[2].key] = V[2], N[V[3].key] = e[V[3].key] = V[3], delete Z[G]);
            }
            for (const G in Z) {
              const V = Z[G], W = this.findLoadedParent(V, this._source.minzoom), ae = this.findLoadedSibling(V), oe = W || ae || null;
              if (oe) {
                N[oe.tileID.key] = e[oe.tileID.key] = oe.tileID;
                for (const de in N) N[de].isChildOf(oe.tileID) && delete N[de];
              }
            }
            for (const G in this._tiles) N[G] || (this._coveredTiles[G] = !0);
          }
        }
        update(e, r) {
          if (!this._sourceLoaded || this._paused) return;
          let o;
          this.transform = e, this.terrain = r, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? o = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((F) => new s.S(F.canonical.z, F.wrap, F.canonical.z, F.canonical.x, F.canonical.y)) : (o = e.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: r }), this._source.hasTile && (o = o.filter((F) => this._source.hasTile(F)))) : o = [];
          const h = e.coveringZoomLevel(this._source), p = Math.max(h - Lt.maxOverzooming, this._source.minzoom), x = Math.max(h + Lt.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const F = {};
            for (const N of o) if (N.canonical.z > this._source.minzoom) {
              const Z = N.scaledTo(N.canonical.z - 1);
              F[Z.key] = Z;
              const G = N.scaledTo(Math.max(this._source.minzoom, Math.min(N.canonical.z, 5)));
              F[G.key] = G;
            }
            o = o.concat(Object.values(F));
          }
          const A = o.length === 0 && !this._updated && this._didEmitContent;
          this._updated = !0, A && this.fire(new s.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const T = this._updateRetainedTiles(o, h);
          Gi(this._source.type) && this._updateCoveredAndRetainedTiles(T, p, x, h, o, r);
          for (const F in T) this._tiles[F].clearFadeHold();
          const P = s.ab(this._tiles, T);
          for (const F of P) {
            const N = this._tiles[F];
            N.hasSymbolBuckets && !N.holdingForFade() ? N.setHoldDuration(this.map._fadeDuration) : N.hasSymbolBuckets && !N.symbolFadeFinished() || this._removeTile(F);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
        }
        _updateRetainedTiles(e, r) {
          var o;
          const h = {}, p = {}, x = Math.max(r - Lt.maxOverzooming, this._source.minzoom), A = Math.max(r + Lt.maxUnderzooming, this._source.minzoom), T = {};
          for (const P of e) {
            const F = this._addTile(P);
            h[P.key] = P, F.hasData() || r < this._source.maxzoom && (T[P.key] = P);
          }
          this._retainLoadedChildren(T, r, A, h);
          for (const P of e) {
            let F = this._tiles[P.key];
            if (F.hasData()) continue;
            if (r + 1 > this._source.maxzoom) {
              const Z = P.children(this._source.maxzoom)[0], G = this.getTile(Z);
              if (G && G.hasData()) {
                h[Z.key] = Z;
                continue;
              }
            } else {
              const Z = P.children(this._source.maxzoom);
              if (h[Z[0].key] && h[Z[1].key] && h[Z[2].key] && h[Z[3].key]) continue;
            }
            let N = F.wasRequested();
            for (let Z = P.overscaledZ - 1; Z >= x; --Z) {
              const G = P.scaledTo(Z);
              if (p[G.key]) break;
              if (p[G.key] = !0, F = this.getTile(G), !F && N && (F = this._addTile(G)), F) {
                const V = F.hasData();
                if ((V || !(!((o = this.map) === null || o === void 0) && o.cancelPendingTileRequestsWhileZooming) || N) && (h[G.key] = G), N = F.wasRequested(), V) break;
              }
            }
          }
          return h;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const e in this._tiles) {
            const r = [];
            let o, h = this._tiles[e].tileID;
            for (; h.overscaledZ > 0; ) {
              if (h.key in this._loadedParentTiles) {
                o = this._loadedParentTiles[h.key];
                break;
              }
              r.push(h.key);
              const p = h.scaledTo(h.overscaledZ - 1);
              if (o = this._getLoadedTile(p), o) break;
              h = p;
            }
            for (const p of r) this._loadedParentTiles[p] = o;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const e in this._tiles) {
            const r = this._tiles[e].tileID, o = this._getLoadedTile(r);
            this._loadedSiblingTiles[r.key] = o;
          }
        }
        _addTile(e) {
          let r = this._tiles[e.key];
          if (r) return r;
          r = this._cache.getAndRemove(e), r && (this._setTileReloadTimer(e.key, r), r.tileID = e, this._state.initializeTileState(r, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, r)));
          const o = r;
          return r || (r = new Zi(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(r, e.key, r.state)), r.uses++, this._tiles[e.key] = r, o || this._source.fire(new s.k("dataloading", { tile: r, coord: r.tileID, dataType: "source" })), r;
        }
        _setTileReloadTimer(e, r) {
          e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
          const o = r.getExpiryTimeout();
          o && (this._timers[e] = setTimeout(() => {
            this._reloadTile(e, "expired"), delete this._timers[e];
          }, o));
        }
        _removeTile(e) {
          const r = this._tiles[e];
          r && (r.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), r.uses > 0 || (r.hasData() && r.state !== "reloading" ? this._cache.add(r.tileID, r, r.getExpiryTimeout()) : (r.aborted = !0, this._abortTile(r), this._unloadTile(r))));
        }
        _dataHandler(e) {
          const r = e.sourceDataType;
          e.dataType === "source" && r === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && r === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const e in this._tiles) this._removeTile(e);
          this._cache.reset();
        }
        tilesIn(e, r, o) {
          const h = [], p = this.transform;
          if (!p) return h;
          const x = o ? p.getCameraQueryGeometry(e) : e, A = e.map((V) => p.pointCoordinate(V, this.terrain)), T = x.map((V) => p.pointCoordinate(V, this.terrain)), P = this.getIds();
          let F = 1 / 0, N = 1 / 0, Z = -1 / 0, G = -1 / 0;
          for (const V of T) F = Math.min(F, V.x), N = Math.min(N, V.y), Z = Math.max(Z, V.x), G = Math.max(G, V.y);
          for (let V = 0; V < P.length; V++) {
            const W = this._tiles[P[V]];
            if (W.holdingForFade()) continue;
            const ae = W.tileID, oe = Math.pow(2, p.zoom - W.tileID.overscaledZ), de = r * W.queryPadding * s.X / W.tileSize / oe, ce = [ae.getTilePoint(new s.Z(F, N)), ae.getTilePoint(new s.Z(Z, G))];
            if (ce[0].x - de < s.X && ce[0].y - de < s.X && ce[1].x + de >= 0 && ce[1].y + de >= 0) {
              const we = A.map((ke) => ae.getTilePoint(ke)), Le = T.map((ke) => ae.getTilePoint(ke));
              h.push({ tile: W, tileID: ae, queryGeometry: we, cameraQueryGeometry: Le, scale: oe });
            }
          }
          return h;
        }
        getVisibleCoordinates(e) {
          const r = this.getRenderableIds(e).map((o) => this._tiles[o].tileID);
          for (const o of r) o.posMatrix = this.transform.calculatePosMatrix(o.toUnwrapped());
          return r;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (Gi(this._source.type)) {
            const e = q.now();
            for (const r in this._tiles) if (this._tiles[r].fadeEndTime >= e) return !0;
          }
          return !1;
        }
        setFeatureState(e, r, o) {
          this._state.updateState(e = e || "_geojsonTileLayer", r, o);
        }
        removeFeatureState(e, r, o) {
          this._state.removeFeatureState(e = e || "_geojsonTileLayer", r, o);
        }
        getFeatureState(e, r) {
          return this._state.getState(e = e || "_geojsonTileLayer", r);
        }
        setDependencies(e, r, o) {
          const h = this._tiles[e];
          h && h.setDependencies(r, o);
        }
        reloadTilesForDependencies(e, r) {
          for (const o in this._tiles) this._tiles[o].hasDependency(e, r) && this._reloadTile(o, "reloading");
          this._cache.filter((o) => !o.hasDependency(e, r));
        }
      }
      function Si(c, e) {
        const r = Math.abs(2 * c.wrap) - +(c.wrap < 0), o = Math.abs(2 * e.wrap) - +(e.wrap < 0);
        return c.overscaledZ - e.overscaledZ || o - r || e.canonical.y - c.canonical.y || e.canonical.x - c.canonical.x;
      }
      function Gi(c) {
        return c === "raster" || c === "image" || c === "video";
      }
      Lt.maxOverzooming = 10, Lt.maxUnderzooming = 3;
      class zt {
        constructor(e, r) {
          this.reset(e, r);
        }
        reset(e, r) {
          this.points = e || [], this._distances = [0];
          for (let o = 1; o < this.points.length; o++) this._distances[o] = this._distances[o - 1] + this.points[o].dist(this.points[o - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(r || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(e) {
          if (this.points.length === 1) return this.points[0];
          e = s.ac(e, 0, 1);
          let r = 1, o = this._distances[r];
          const h = e * this.paddedLength + this.padding;
          for (; o < h && r < this._distances.length; ) o = this._distances[++r];
          const p = r - 1, x = this._distances[p], A = o - x, T = A > 0 ? (h - x) / A : 0;
          return this.points[p].mult(1 - T).add(this.points[r].mult(T));
        }
      }
      function cr(c, e) {
        let r = !0;
        return c === "always" || c !== "never" && e !== "never" || (r = !1), r;
      }
      class Ni {
        constructor(e, r, o) {
          const h = this.boxCells = [], p = this.circleCells = [];
          this.xCellCount = Math.ceil(e / o), this.yCellCount = Math.ceil(r / o);
          for (let x = 0; x < this.xCellCount * this.yCellCount; x++) h.push([]), p.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = r, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / r, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e, r, o, h, p) {
          this._forEachCell(r, o, h, p, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(r), this.bboxes.push(o), this.bboxes.push(h), this.bboxes.push(p);
        }
        insertCircle(e, r, o, h) {
          this._forEachCell(r - h, o - h, r + h, o + h, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(r), this.circles.push(o), this.circles.push(h);
        }
        _insertBoxCell(e, r, o, h, p, x) {
          this.boxCells[p].push(x);
        }
        _insertCircleCell(e, r, o, h, p, x) {
          this.circleCells[p].push(x);
        }
        _query(e, r, o, h, p, x, A) {
          if (o < 0 || e > this.width || h < 0 || r > this.height) return [];
          const T = [];
          if (e <= 0 && r <= 0 && this.width <= o && this.height <= h) {
            if (p) return [{ key: null, x1: e, y1: r, x2: o, y2: h }];
            for (let P = 0; P < this.boxKeys.length; P++) T.push({ key: this.boxKeys[P], x1: this.bboxes[4 * P], y1: this.bboxes[4 * P + 1], x2: this.bboxes[4 * P + 2], y2: this.bboxes[4 * P + 3] });
            for (let P = 0; P < this.circleKeys.length; P++) {
              const F = this.circles[3 * P], N = this.circles[3 * P + 1], Z = this.circles[3 * P + 2];
              T.push({ key: this.circleKeys[P], x1: F - Z, y1: N - Z, x2: F + Z, y2: N + Z });
            }
          } else this._forEachCell(e, r, o, h, this._queryCell, T, { hitTest: p, overlapMode: x, seenUids: { box: {}, circle: {} } }, A);
          return T;
        }
        query(e, r, o, h) {
          return this._query(e, r, o, h, !1, null);
        }
        hitTest(e, r, o, h, p, x) {
          return this._query(e, r, o, h, !0, p, x).length > 0;
        }
        hitTestCircle(e, r, o, h, p) {
          const x = e - o, A = e + o, T = r - o, P = r + o;
          if (A < 0 || x > this.width || P < 0 || T > this.height) return !1;
          const F = [];
          return this._forEachCell(x, T, A, P, this._queryCellCircle, F, { hitTest: !0, overlapMode: h, circle: { x: e, y: r, radius: o }, seenUids: { box: {}, circle: {} } }, p), F.length > 0;
        }
        _queryCell(e, r, o, h, p, x, A, T) {
          const { seenUids: P, hitTest: F, overlapMode: N } = A, Z = this.boxCells[p];
          if (Z !== null) {
            const V = this.bboxes;
            for (const W of Z) if (!P.box[W]) {
              P.box[W] = !0;
              const ae = 4 * W, oe = this.boxKeys[W];
              if (e <= V[ae + 2] && r <= V[ae + 3] && o >= V[ae + 0] && h >= V[ae + 1] && (!T || T(oe)) && (!F || !cr(N, oe.overlapMode)) && (x.push({ key: oe, x1: V[ae], y1: V[ae + 1], x2: V[ae + 2], y2: V[ae + 3] }), F)) return !0;
            }
          }
          const G = this.circleCells[p];
          if (G !== null) {
            const V = this.circles;
            for (const W of G) if (!P.circle[W]) {
              P.circle[W] = !0;
              const ae = 3 * W, oe = this.circleKeys[W];
              if (this._circleAndRectCollide(V[ae], V[ae + 1], V[ae + 2], e, r, o, h) && (!T || T(oe)) && (!F || !cr(N, oe.overlapMode))) {
                const de = V[ae], ce = V[ae + 1], we = V[ae + 2];
                if (x.push({ key: oe, x1: de - we, y1: ce - we, x2: de + we, y2: ce + we }), F) return !0;
              }
            }
          }
          return !1;
        }
        _queryCellCircle(e, r, o, h, p, x, A, T) {
          const { circle: P, seenUids: F, overlapMode: N } = A, Z = this.boxCells[p];
          if (Z !== null) {
            const V = this.bboxes;
            for (const W of Z) if (!F.box[W]) {
              F.box[W] = !0;
              const ae = 4 * W, oe = this.boxKeys[W];
              if (this._circleAndRectCollide(P.x, P.y, P.radius, V[ae + 0], V[ae + 1], V[ae + 2], V[ae + 3]) && (!T || T(oe)) && !cr(N, oe.overlapMode)) return x.push(!0), !0;
            }
          }
          const G = this.circleCells[p];
          if (G !== null) {
            const V = this.circles;
            for (const W of G) if (!F.circle[W]) {
              F.circle[W] = !0;
              const ae = 3 * W, oe = this.circleKeys[W];
              if (this._circlesCollide(V[ae], V[ae + 1], V[ae + 2], P.x, P.y, P.radius) && (!T || T(oe)) && !cr(N, oe.overlapMode)) return x.push(!0), !0;
            }
          }
        }
        _forEachCell(e, r, o, h, p, x, A, T) {
          const P = this._convertToXCellCoord(e), F = this._convertToYCellCoord(r), N = this._convertToXCellCoord(o), Z = this._convertToYCellCoord(h);
          for (let G = P; G <= N; G++) for (let V = F; V <= Z; V++) if (p.call(this, e, r, o, h, this.xCellCount * V + G, x, A, T)) return;
        }
        _convertToXCellCoord(e) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
        }
        _convertToYCellCoord(e) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
        }
        _circlesCollide(e, r, o, h, p, x) {
          const A = h - e, T = p - r, P = o + x;
          return P * P > A * A + T * T;
        }
        _circleAndRectCollide(e, r, o, h, p, x, A) {
          const T = (x - h) / 2, P = Math.abs(e - (h + T));
          if (P > T + o) return !1;
          const F = (A - p) / 2, N = Math.abs(r - (p + F));
          if (N > F + o) return !1;
          if (P <= T || N <= F) return !0;
          const Z = P - T, G = N - F;
          return Z * Z + G * G <= o * o;
        }
      }
      function ie(c, e, r, o, h) {
        const p = s.H();
        return e ? (s.K(p, p, [1 / h, 1 / h, 1]), r || s.ad(p, p, o.angle)) : s.L(p, o.labelPlaneMatrix, c), p;
      }
      function ue(c, e, r, o, h) {
        if (e) {
          const p = s.ae(c);
          return s.K(p, p, [h, h, 1]), r || s.ad(p, p, -o.angle), p;
        }
        return o.glCoordMatrix;
      }
      function $(c, e, r, o) {
        let h;
        o ? (h = [c, e, o(c, e), 1], s.af(h, h, r)) : (h = [c, e, 0, 1], Qt(h, h, r));
        const p = h[3];
        return { point: new s.P(h[0] / p, h[1] / p), signedDistanceFromCamera: p, isOccluded: !1 };
      }
      function B(c, e) {
        return 0.5 + c / e * 0.5;
      }
      function j(c, e) {
        return c.x >= -e[0] && c.x <= e[0] && c.y >= -e[1] && c.y <= e[1];
      }
      function te(c, e, r, o, h, p, x, A, T, P, F, N, Z, G, V) {
        const W = o ? c.textSizeData : c.iconSizeData, ae = s.ag(W, r.transform.zoom), oe = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1], de = o ? c.text.dynamicLayoutVertexArray : c.icon.dynamicLayoutVertexArray;
        de.clear();
        const ce = c.lineVertexArray, we = o ? c.text.placedSymbolArray : c.icon.placedSymbolArray, Le = r.transform.width / r.transform.height;
        let ke = !1;
        for (let tt = 0; tt < we.length; tt++) {
          const ht = we.get(tt);
          if (ht.hidden || ht.writingMode === s.ah.vertical && !ke) {
            $t(ht.numGlyphs, de);
            continue;
          }
          ke = !1;
          const _t = $(ht.anchorX, ht.anchorY, e, V);
          if (!j(_t.point, oe)) {
            $t(ht.numGlyphs, de);
            continue;
          }
          const wt = B(r.transform.cameraToCenterDistance, _t.signedDistanceFromCamera), bt = s.ai(W, ae, ht), yt = x ? bt / wt : bt * wt, St = { getElevation: V, labelPlaneMatrix: h, lineVertexArray: ce, pitchWithMap: x, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: P, tileAnchorPoint: new s.P(ht.anchorX, ht.anchorY), unwrappedTileID: F, width: N, height: Z, translation: G }, Zt = Fe(St, ht, yt, !1, A, e, p, c.glyphOffsetArray, de, Le, T);
          ke = Zt.useVertical, (Zt.notEnoughRoom || ke || Zt.needsFlipping && Fe(St, ht, yt, !0, A, e, p, c.glyphOffsetArray, de, Le, T).notEnoughRoom) && $t(ht.numGlyphs, de);
        }
        o ? c.text.dynamicLayoutVertexBuffer.updateData(de) : c.icon.dynamicLayoutVertexBuffer.updateData(de);
      }
      function ge(c, e, r, o, h, p, x, A) {
        const T = p.glyphStartIndex + p.numGlyphs, P = p.lineStartIndex, F = p.lineStartIndex + p.lineLength, N = e.getoffsetX(p.glyphStartIndex), Z = e.getoffsetX(T - 1), G = gt(c * N, r, o, h, p.segment, P, F, A, x);
        if (!G) return null;
        const V = gt(c * Z, r, o, h, p.segment, P, F, A, x);
        return V ? A.projectionCache.anyProjectionOccluded ? null : { first: G, last: V } : null;
      }
      function Me(c, e, r, o) {
        return c === s.ah.horizontal && Math.abs(r.y - e.y) > Math.abs(r.x - e.x) * o ? { useVertical: !0 } : (c === s.ah.vertical ? e.y < r.y : e.x > r.x) ? { needsFlipping: !0 } : null;
      }
      function Fe(c, e, r, o, h, p, x, A, T, P, F) {
        const N = r / 24, Z = e.lineOffsetX * N, G = e.lineOffsetY * N;
        let V;
        if (e.numGlyphs > 1) {
          const W = e.glyphStartIndex + e.numGlyphs, ae = e.lineStartIndex, oe = e.lineStartIndex + e.lineLength, de = ge(N, A, Z, G, o, e, F, c);
          if (!de) return { notEnoughRoom: !0 };
          const ce = $(de.first.point.x, de.first.point.y, x, c.getElevation).point, we = $(de.last.point.x, de.last.point.y, x, c.getElevation).point;
          if (h && !o) {
            const Le = Me(e.writingMode, ce, we, P);
            if (Le) return Le;
          }
          V = [de.first];
          for (let Le = e.glyphStartIndex + 1; Le < W - 1; Le++) V.push(gt(N * A.getoffsetX(Le), Z, G, o, e.segment, ae, oe, c, F));
          V.push(de.last);
        } else {
          if (h && !o) {
            const ae = $(c.tileAnchorPoint.x, c.tileAnchorPoint.y, p, c.getElevation).point, oe = e.lineStartIndex + e.segment + 1, de = new s.P(c.lineVertexArray.getx(oe), c.lineVertexArray.gety(oe)), ce = $(de.x, de.y, p, c.getElevation), we = ce.signedDistanceFromCamera > 0 ? ce.point : function(ke, tt, ht, _t, wt, bt) {
              return Ne(ke, tt, ht, 1, wt, bt);
            }(c.tileAnchorPoint, de, ae, 0, p, c), Le = Me(e.writingMode, ae, we, P);
            if (Le) return Le;
          }
          const W = gt(N * A.getoffsetX(e.glyphStartIndex), Z, G, o, e.segment, e.lineStartIndex, e.lineStartIndex + e.lineLength, c, F);
          if (!W || c.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
          V = [W];
        }
        for (const W of V) s.aj(T, W.point, W.angle);
        return {};
      }
      function Ne(c, e, r, o, h, p) {
        const x = c.add(c.sub(e)._unit()), A = h !== void 0 ? $(x.x, x.y, h, p.getElevation).point : et(x.x, x.y, p).point, T = r.sub(A);
        return r.add(T._mult(o / T.mag()));
      }
      function De(c, e, r) {
        const o = e.projectionCache;
        if (o.projections[c]) return o.projections[c];
        const h = new s.P(e.lineVertexArray.getx(c), e.lineVertexArray.gety(c)), p = et(h.x, h.y, e);
        if (p.signedDistanceFromCamera > 0) return o.projections[c] = p.point, o.anyProjectionOccluded = o.anyProjectionOccluded || p.isOccluded, p.point;
        const x = c - r.direction;
        return function(A, T, P, F, N) {
          return Ne(A, T, P, F, void 0, N);
        }(r.distanceFromAnchor === 0 ? e.tileAnchorPoint : new s.P(e.lineVertexArray.getx(x), e.lineVertexArray.gety(x)), h, r.previousVertex, r.absOffsetX - r.distanceFromAnchor + 1, e);
      }
      function et(c, e, r) {
        const o = c + r.translation[0], h = e + r.translation[1];
        let p;
        return !r.pitchWithMap && r.projection.useSpecialProjectionForSymbols ? (p = r.projection.projectTileCoordinates(o, h, r.unwrappedTileID, r.getElevation), p.point.x = (0.5 * p.point.x + 0.5) * r.width, p.point.y = (0.5 * -p.point.y + 0.5) * r.height) : (p = $(o, h, r.labelPlaneMatrix, r.getElevation), p.isOccluded = !1), p;
      }
      function ut(c, e, r) {
        return c._unit()._perp()._mult(e * r);
      }
      function We(c, e, r, o, h, p, x, A, T) {
        if (A.projectionCache.offsets[c]) return A.projectionCache.offsets[c];
        const P = r.add(e);
        if (c + T.direction < o || c + T.direction >= h) return A.projectionCache.offsets[c] = P, P;
        const F = De(c + T.direction, A, T), N = ut(F.sub(r), x, T.direction), Z = r.add(N), G = F.add(N);
        return A.projectionCache.offsets[c] = s.ak(p, P, Z, G) || P, A.projectionCache.offsets[c];
      }
      function gt(c, e, r, o, h, p, x, A, T) {
        const P = o ? c - e : c + e;
        let F = P > 0 ? 1 : -1, N = 0;
        o && (F *= -1, N = Math.PI), F < 0 && (N += Math.PI);
        let Z, G = F > 0 ? p + h : p + h + 1;
        A.projectionCache.cachedAnchorPoint ? Z = A.projectionCache.cachedAnchorPoint : (Z = et(A.tileAnchorPoint.x, A.tileAnchorPoint.y, A).point, A.projectionCache.cachedAnchorPoint = Z);
        let V, W, ae = Z, oe = Z, de = 0, ce = 0;
        const we = Math.abs(P), Le = [];
        let ke;
        for (; de + ce <= we; ) {
          if (G += F, G < p || G >= x) return null;
          de += ce, oe = ae, W = V;
          const _t = { absOffsetX: we, direction: F, distanceFromAnchor: de, previousVertex: oe };
          if (ae = De(G, A, _t), r === 0) Le.push(oe), ke = ae.sub(oe);
          else {
            let wt;
            const bt = ae.sub(oe);
            wt = bt.mag() === 0 ? ut(De(G + F, A, _t).sub(ae), r, F) : ut(bt, r, F), W || (W = oe.add(wt)), V = We(G, wt, ae, p, x, W, r, A, _t), Le.push(W), ke = V.sub(W);
          }
          ce = ke.mag();
        }
        const tt = ke._mult((we - de) / ce)._add(W || oe), ht = N + Math.atan2(ae.y - oe.y, ae.x - oe.x);
        return Le.push(tt), { point: tt, angle: T ? ht : 0, path: Le };
      }
      const Mt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function $t(c, e) {
        for (let r = 0; r < c; r++) {
          const o = e.length;
          e.resize(o + 4), e.float32.set(Mt, 3 * o);
        }
      }
      function Qt(c, e, r) {
        const o = e[0], h = e[1];
        return c[0] = r[0] * o + r[4] * h + r[12], c[1] = r[1] * o + r[5] * h + r[13], c[3] = r[3] * o + r[7] * h + r[15], c;
      }
      const ei = 100;
      class pi {
        constructor(e, r, o = new Ni(e.width + 200, e.height + 200, 25), h = new Ni(e.width + 200, e.height + 200, 25)) {
          this.transform = e, this.mapProjection = r, this.grid = o, this.ignoredGrid = h, this.pitchFactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + ei, this.screenBottomBoundary = e.height + ei, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(e, r, o, h, p, x, A, T, P, F, N) {
          const Z = e.anchorPointX + T[0], G = e.anchorPointY + T[1], V = this.projectAndGetPerspectiveRatio(h, Z, G, p, F), W = o * V.perspectiveRatio;
          let ae;
          if (x || A) ae = this._projectCollisionBox(e, W, h, p, x, A, T, V, F, N);
          else {
            const Le = V.point.x + (N ? N.x * W : 0), ke = V.point.y + (N ? N.y * W : 0);
            ae = { allPointsOccluded: !1, box: [Le + e.x1 * W, ke + e.y1 * W, Le + e.x2 * W, ke + e.y2 * W] };
          }
          const [oe, de, ce, we] = ae.box;
          return this.mapProjection.useSpecialProjectionForSymbols && (x ? ae.allPointsOccluded : this.mapProjection.isOccluded(Z, G, p)) || V.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(oe, de, ce, we) || r !== "always" && this.grid.hitTest(oe, de, ce, we, r, P) ? { box: [oe, de, ce, we], placeable: !1, offscreen: !1 } : { box: [oe, de, ce, we], placeable: !0, offscreen: this.isOffscreen(oe, de, ce, we) };
        }
        placeCollisionCircles(e, r, o, h, p, x, A, T, P, F, N, Z, G, V, W, ae) {
          const oe = [], de = new s.P(r.anchorX, r.anchorY), ce = this.getPerspectiveRatio(x, de.x, de.y, A, ae), we = (N ? p / ce : p * ce) / s.ap, Le = { getElevation: ae, labelPlaneMatrix: T, lineVertexArray: o, pitchWithMap: N, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: this.mapProjection, tileAnchorPoint: de, unwrappedTileID: A, width: this.transform.width, height: this.transform.height, translation: W }, ke = ge(we, h, r.lineOffsetX * we, r.lineOffsetY * we, !1, r, !1, Le);
          let tt = !1, ht = !1, _t = !0;
          if (ke) {
            const wt = 0.5 * G * ce + V, bt = new s.P(-100, -100), yt = new s.P(this.screenRightBoundary, this.screenBottomBoundary), St = new zt(), Zt = ke.first, Ct = ke.last;
            let Dt = [];
            for (let ci = Zt.path.length - 1; ci >= 1; ci--) Dt.push(Zt.path[ci]);
            for (let ci = 1; ci < Ct.path.length; ci++) Dt.push(Ct.path[ci]);
            const Wt = 2.5 * wt;
            if (P) {
              const ci = this.projectPathToScreenSpace(Dt, Le, P);
              Dt = ci.some((gi) => gi.signedDistanceFromCamera <= 0) ? [] : ci.map((gi) => gi.point);
            }
            let di = [];
            if (Dt.length > 0) {
              const ci = Dt[0].clone(), gi = Dt[0].clone();
              for (let Ei = 1; Ei < Dt.length; Ei++) ci.x = Math.min(ci.x, Dt[Ei].x), ci.y = Math.min(ci.y, Dt[Ei].y), gi.x = Math.max(gi.x, Dt[Ei].x), gi.y = Math.max(gi.y, Dt[Ei].y);
              di = ci.x >= bt.x && gi.x <= yt.x && ci.y >= bt.y && gi.y <= yt.y ? [Dt] : gi.x < bt.x || ci.x > yt.x || gi.y < bt.y || ci.y > yt.y ? [] : s.al([Dt], bt.x, bt.y, yt.x, yt.y);
            }
            for (const ci of di) {
              St.reset(ci, 0.25 * wt);
              let gi = 0;
              gi = St.length <= 0.5 * wt ? 1 : Math.ceil(St.paddedLength / Wt) + 1;
              for (let Ei = 0; Ei < gi; Ei++) {
                const qi = Ei / Math.max(gi - 1, 1), ar = St.lerp(qi), Fi = ar.x + ei, _r = ar.y + ei;
                oe.push(Fi, _r, wt, 0);
                const Ui = Fi - wt, pr = _r - wt, Cr = Fi + wt, dn = _r + wt;
                if (_t = _t && this.isOffscreen(Ui, pr, Cr, dn), ht = ht || this.isInsideGrid(Ui, pr, Cr, dn), e !== "always" && this.grid.hitTestCircle(Fi, _r, wt, e, Z) && (tt = !0, !F)) return { circles: [], offscreen: !1, collisionDetected: tt };
              }
            }
          }
          return { circles: !F && tt || !ht || ce < this.perspectiveRatioCutoff ? [] : oe, offscreen: _t, collisionDetected: tt };
        }
        projectPathToScreenSpace(e, r, o) {
          return e.map((h) => $(h.x, h.y, o, r.getElevation));
        }
        queryRenderedSymbols(e) {
          if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          const r = [];
          let o = 1 / 0, h = 1 / 0, p = -1 / 0, x = -1 / 0;
          for (const F of e) {
            const N = new s.P(F.x + ei, F.y + ei);
            o = Math.min(o, N.x), h = Math.min(h, N.y), p = Math.max(p, N.x), x = Math.max(x, N.y), r.push(N);
          }
          const A = this.grid.query(o, h, p, x).concat(this.ignoredGrid.query(o, h, p, x)), T = {}, P = {};
          for (const F of A) {
            const N = F.key;
            if (T[N.bucketInstanceId] === void 0 && (T[N.bucketInstanceId] = {}), T[N.bucketInstanceId][N.featureIndex]) continue;
            const Z = [new s.P(F.x1, F.y1), new s.P(F.x2, F.y1), new s.P(F.x2, F.y2), new s.P(F.x1, F.y2)];
            s.am(r, Z) && (T[N.bucketInstanceId][N.featureIndex] = !0, P[N.bucketInstanceId] === void 0 && (P[N.bucketInstanceId] = []), P[N.bucketInstanceId].push(N.featureIndex));
          }
          return P;
        }
        insertCollisionBox(e, r, o, h, p, x) {
          (o ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: h, featureIndex: p, collisionGroupID: x, overlapMode: r }, e[0], e[1], e[2], e[3]);
        }
        insertCollisionCircles(e, r, o, h, p, x) {
          const A = o ? this.ignoredGrid : this.grid, T = { bucketInstanceId: h, featureIndex: p, collisionGroupID: x, overlapMode: r };
          for (let P = 0; P < e.length; P += 4) A.insertCircle(T, e[P], e[P + 1], e[P + 2]);
        }
        projectAndGetPerspectiveRatio(e, r, o, h, p) {
          let x;
          p ? (x = [r, o, p(r, o), 1], s.af(x, x, e)) : (x = [r, o, 0, 1], Qt(x, x, e));
          const A = x[3];
          return { point: new s.P((x[0] / A + 1) / 2 * this.transform.width + ei, (-x[1] / A + 1) / 2 * this.transform.height + ei), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / A * 0.5, isOccluded: !1, signedDistanceFromCamera: A };
        }
        getPerspectiveRatio(e, r, o, h, p) {
          const x = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(r, o, h, p) : $(r, o, e, p);
          return 0.5 + this.transform.cameraToCenterDistance / x.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(e, r, o, h) {
          return o < ei || e >= this.screenRightBoundary || h < ei || r > this.screenBottomBoundary;
        }
        isInsideGrid(e, r, o, h) {
          return o >= 0 && e < this.gridRightBoundary && h >= 0 && r < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const e = s.an([]);
          return s.J(e, e, [-100, -100, 0]), e;
        }
        _projectCollisionBox(e, r, o, h, p, x, A, T, P, F) {
          let N = new s.P(1, 0), Z = new s.P(0, 1);
          const G = new s.P(e.anchorPointX + A[0], e.anchorPointY + A[1]);
          if (x && !p) {
            const _t = this.projectAndGetPerspectiveRatio(o, G.x + 1, G.y, h, P).point.sub(T.point).unit(), wt = Math.atan(_t.y / _t.x) + (_t.x < 0 ? Math.PI : 0), bt = Math.sin(wt), yt = Math.cos(wt);
            N = new s.P(yt, bt), Z = new s.P(-bt, yt);
          } else if (!x && p) {
            const _t = -this.transform.angle, wt = Math.sin(_t), bt = Math.cos(_t);
            N = new s.P(bt, wt), Z = new s.P(-wt, bt);
          }
          let V = T.point, W = r;
          if (p) {
            V = G;
            const _t = this.transform.zoom - Math.floor(this.transform.zoom);
            W = Math.pow(2, -_t), W *= this.mapProjection.getPitchedTextCorrection(this.transform, G, h), F || (W *= s.ac(0.5 + T.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
          }
          F && (V = V.add(N.mult(F.x * W)).add(Z.mult(F.y * W)));
          const ae = e.x1 * W, oe = e.x2 * W, de = (ae + oe) / 2, ce = e.y1 * W, we = e.y2 * W, Le = (ce + we) / 2, ke = [{ offsetX: ae, offsetY: ce }, { offsetX: de, offsetY: ce }, { offsetX: oe, offsetY: ce }, { offsetX: oe, offsetY: Le }, { offsetX: oe, offsetY: we }, { offsetX: de, offsetY: we }, { offsetX: ae, offsetY: we }, { offsetX: ae, offsetY: Le }];
          let tt = [];
          for (const { offsetX: _t, offsetY: wt } of ke) tt.push(new s.P(V.x + N.x * _t + Z.x * wt, V.y + N.y * _t + Z.y * wt));
          let ht = !1;
          if (p) {
            const _t = tt.map((wt) => this.projectAndGetPerspectiveRatio(o, wt.x, wt.y, h, P));
            ht = _t.some((wt) => !wt.isOccluded), tt = _t.map((wt) => wt.point);
          } else ht = !0;
          return { box: s.ao(tt), allPointsOccluded: !ht };
        }
      }
      function fi(c, e, r) {
        return e * (s.X / (c.tileSize * Math.pow(2, r - c.tileID.overscaledZ)));
      }
      class Wi {
        constructor(e, r, o, h) {
          this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? r : -r))) : h && o ? 1 : 0, this.placed = o;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Oi {
        constructor(e, r, o, h, p) {
          this.text = new Wi(e ? e.text : null, r, o, p), this.icon = new Wi(e ? e.icon : null, r, h, p);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class mi {
        constructor(e, r, o) {
          this.text = e, this.icon = r, this.skipFade = o;
        }
      }
      class Bi {
        constructor() {
          this.invProjMatrix = s.H(), this.viewportMatrix = s.H(), this.circles = [];
        }
      }
      class Hi {
        constructor(e, r, o, h, p) {
          this.bucketInstanceId = e, this.featureIndex = r, this.sourceLayerIndex = o, this.bucketIndex = h, this.tileID = p;
        }
      }
      class mr {
        constructor(e) {
          this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[e]) {
            const r = ++this.maxGroupID;
            this.collisionGroups[e] = { ID: r, predicate: (o) => o.collisionGroupID === r };
          }
          return this.collisionGroups[e];
        }
      }
      function vr(c, e, r, o, h) {
        const { horizontalAlign: p, verticalAlign: x } = s.au(c);
        return new s.P(-(p - 0.5) * e + o[0] * h, -(x - 0.5) * r + o[1] * h);
      }
      class kr {
        constructor(e, r, o, h, p, x) {
          this.transform = e.clone(), this.terrain = o, this.collisionIndex = new pi(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = h, this.retainedQueryData = {}, this.collisionGroups = new mr(p), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = x, x && (x.prevPlacement = void 0), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(e) {
          const r = this.terrain;
          return r ? (o, h) => r.getElevation(e, o, h) : null;
        }
        getBucketParts(e, r, o, h) {
          const p = o.getBucket(r), x = o.latestFeatureIndex;
          if (!p || !x || r.id !== p.layerIds[0]) return;
          const A = o.collisionBoxArray, T = p.layers[0].layout, P = p.layers[0].paint, F = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), N = o.tileSize / s.X, Z = o.tileID.toUnwrapped(), G = this.transform.calculatePosMatrix(Z), V = T.get("text-pitch-alignment") === "map", W = T.get("text-rotation-alignment") === "map", ae = fi(o, 1, this.transform.zoom), oe = this.collisionIndex.mapProjection.translatePosition(this.transform, o, P.get("text-translate"), P.get("text-translate-anchor")), de = this.collisionIndex.mapProjection.translatePosition(this.transform, o, P.get("icon-translate"), P.get("icon-translate-anchor")), ce = ie(G, V, W, this.transform, ae);
          let we = null;
          if (V) {
            const ke = ue(G, V, W, this.transform, ae);
            we = s.L([], this.transform.labelPlaneMatrix, ke);
          }
          this.retainedQueryData[p.bucketInstanceId] = new Hi(p.bucketInstanceId, x, p.sourceLayerIndex, p.index, o.tileID);
          const Le = { bucket: p, layout: T, translationText: oe, translationIcon: de, posMatrix: G, unwrappedTileID: Z, textLabelPlaneMatrix: ce, labelToScreenMatrix: we, scale: F, textPixelRatio: N, holdingForFade: o.holdingForFade(), collisionBoxArray: A, partiallyEvaluatedTextSize: s.ag(p.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(p.sourceID) };
          if (h) for (const ke of p.sortKeyRanges) {
            const { sortKey: tt, symbolInstanceStart: ht, symbolInstanceEnd: _t } = ke;
            e.push({ sortKey: tt, symbolInstanceStart: ht, symbolInstanceEnd: _t, parameters: Le });
          }
          else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: p.symbolInstances.length, parameters: Le });
        }
        attemptAnchorPlacement(e, r, o, h, p, x, A, T, P, F, N, Z, G, V, W, ae, oe, de, ce) {
          const we = s.aq[e.textAnchor], Le = [e.textOffset0, e.textOffset1], ke = vr(we, o, h, Le, p), tt = this.collisionIndex.placeCollisionBox(r, Z, T, P, F, A, x, ae, N.predicate, ce, ke);
          if ((!de || this.collisionIndex.placeCollisionBox(de, Z, T, P, F, A, x, oe, N.predicate, ce, ke).placeable) && tt.placeable) {
            let ht;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[G.crossTileID] && this.prevPlacement.placements[G.crossTileID] && this.prevPlacement.placements[G.crossTileID].text && (ht = this.prevPlacement.variableOffsets[G.crossTileID].anchor), G.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[G.crossTileID] = { textOffset: Le, width: o, height: h, anchor: we, textBoxScale: p, prevAnchor: ht }, this.markUsedJustification(V, we, G, W), V.allowVerticalPlacement && (this.markUsedOrientation(V, W, G), this.placedOrientations[G.crossTileID] = W), { shift: ke, placedGlyphBoxes: tt };
          }
        }
        placeLayerBucketPart(e, r, o) {
          const { bucket: h, layout: p, translationText: x, translationIcon: A, posMatrix: T, unwrappedTileID: P, textLabelPlaneMatrix: F, labelToScreenMatrix: N, textPixelRatio: Z, holdingForFade: G, collisionBoxArray: V, partiallyEvaluatedTextSize: W, collisionGroup: ae } = e.parameters, oe = p.get("text-optional"), de = p.get("icon-optional"), ce = s.ar(p, "text-overlap", "text-allow-overlap"), we = ce === "always", Le = s.ar(p, "icon-overlap", "icon-allow-overlap"), ke = Le === "always", tt = p.get("text-rotation-alignment") === "map", ht = p.get("text-pitch-alignment") === "map", _t = p.get("icon-text-fit") !== "none", wt = p.get("symbol-z-order") === "viewport-y", bt = we && (ke || !h.hasIconData() || de), yt = ke && (we || !h.hasTextData() || oe);
          !h.collisionArrays && V && h.deserializeCollisionBoxes(V);
          const St = this._getTerrainElevationFunc(this.retainedQueryData[h.bucketInstanceId].tileID), Zt = (Ct, Dt, Wt) => {
            var di, ci;
            if (r[Ct.crossTileID]) return;
            if (G) return void (this.placements[Ct.crossTileID] = new mi(!1, !1, !1));
            let gi = !1, Ei = !1, qi = !0, ar = null, Fi = { box: null, placeable: !1, offscreen: null }, _r = { box: null, placeable: !1, offscreen: null }, Ui = null, pr = null, Cr = null, dn = 0, Ln = 0, sr = 0;
            Dt.textFeatureIndex ? dn = Dt.textFeatureIndex : Ct.useRuntimeCollisionCircles && (dn = Ct.featureIndex), Dt.verticalTextFeatureIndex && (Ln = Dt.verticalTextFeatureIndex);
            const xs = Dt.textBox;
            if (xs) {
              const Qr = (wr) => {
                let Ur = s.ah.horizontal;
                if (h.allowVerticalPlacement && !wr && this.prevPlacement) {
                  const tn = this.prevPlacement.placedOrientations[Ct.crossTileID];
                  tn && (this.placedOrientations[Ct.crossTileID] = tn, Ur = tn, this.markUsedOrientation(h, Ur, Ct));
                }
                return Ur;
              }, pn = (wr, Ur) => {
                if (h.allowVerticalPlacement && Ct.numVerticalGlyphVertices > 0 && Dt.verticalTextBox) {
                  for (const tn of h.writingModes) if (tn === s.ah.vertical ? (Fi = Ur(), _r = Fi) : Fi = wr(), Fi && Fi.placeable) break;
                } else Fi = wr();
              }, Br = Ct.textAnchorOffsetStartIndex, en = Ct.textAnchorOffsetEndIndex;
              if (en === Br) {
                const wr = (Ur, tn) => {
                  const Li = this.collisionIndex.placeCollisionBox(Ur, ce, Z, T, P, ht, tt, x, ae.predicate, St);
                  return Li && Li.placeable && (this.markUsedOrientation(h, tn, Ct), this.placedOrientations[Ct.crossTileID] = tn), Li;
                };
                pn(() => wr(xs, s.ah.horizontal), () => {
                  const Ur = Dt.verticalTextBox;
                  return h.allowVerticalPlacement && Ct.numVerticalGlyphVertices > 0 && Ur ? wr(Ur, s.ah.vertical) : { box: null, offscreen: null };
                }), Qr(Fi && Fi.placeable);
              } else {
                let wr = s.aq[(ci = (di = this.prevPlacement) === null || di === void 0 ? void 0 : di.variableOffsets[Ct.crossTileID]) === null || ci === void 0 ? void 0 : ci.anchor];
                const Ur = (Li, Ma, ws) => {
                  const Ya = Li.x2 - Li.x1, Co = Li.y2 - Li.y1, Tc = Ct.textBoxScale, ju = _t && Le === "never" ? Ma : null;
                  let Na = null, Ja = ce === "never" ? 1 : 2, Fl = "never";
                  wr && Ja++;
                  for (let dl = 0; dl < Ja; dl++) {
                    for (let Bl = Br; Bl < en; Bl++) {
                      const pl = h.textAnchorOffsets.get(Bl);
                      if (wr && pl.textAnchor !== wr) continue;
                      const Ka = this.attemptAnchorPlacement(pl, Li, Ya, Co, Tc, tt, ht, Z, T, P, ae, Fl, Ct, h, ws, x, A, ju, St);
                      if (Ka && (Na = Ka.placedGlyphBoxes, Na && Na.placeable)) return gi = !0, ar = Ka.shift, Na;
                    }
                    wr ? wr = null : Fl = ce;
                  }
                  return o && !Na && (Na = { box: this.collisionIndex.placeCollisionBox(xs, "always", Z, T, P, ht, tt, x, ae.predicate, St, new s.P(0, 0)).box, offscreen: !1, placeable: !1 }), Na;
                };
                pn(() => Ur(xs, Dt.iconBox, s.ah.horizontal), () => {
                  const Li = Dt.verticalTextBox;
                  return h.allowVerticalPlacement && (!Fi || !Fi.placeable) && Ct.numVerticalGlyphVertices > 0 && Li ? Ur(Li, Dt.verticalIconBox, s.ah.vertical) : { box: null, occluded: !0, offscreen: null };
                }), Fi && (gi = Fi.placeable, qi = Fi.offscreen);
                const tn = Qr(Fi && Fi.placeable);
                if (!gi && this.prevPlacement) {
                  const Li = this.prevPlacement.variableOffsets[Ct.crossTileID];
                  Li && (this.variableOffsets[Ct.crossTileID] = Li, this.markUsedJustification(h, Li.anchor, Ct, tn));
                }
              }
            }
            if (Ui = Fi, gi = Ui && Ui.placeable, qi = Ui && Ui.offscreen, Ct.useRuntimeCollisionCircles) {
              const Qr = h.text.placedSymbolArray.get(Ct.centerJustifiedTextSymbolIndex), pn = s.ai(h.textSizeData, W, Qr), Br = p.get("text-padding");
              pr = this.collisionIndex.placeCollisionCircles(ce, Qr, h.lineVertexArray, h.glyphOffsetArray, pn, T, P, F, N, o, ht, ae.predicate, Ct.collisionCircleDiameter, Br, x, St), pr.circles.length && pr.collisionDetected && !o && s.w("Collisions detected, but collision boxes are not shown"), gi = we || pr.circles.length > 0 && !pr.collisionDetected, qi = qi && pr.offscreen;
            }
            if (Dt.iconFeatureIndex && (sr = Dt.iconFeatureIndex), Dt.iconBox) {
              const Qr = (pn) => this.collisionIndex.placeCollisionBox(pn, Le, Z, T, P, ht, tt, A, ae.predicate, St, _t && ar ? ar : void 0);
              _r && _r.placeable && Dt.verticalIconBox ? (Cr = Qr(Dt.verticalIconBox), Ei = Cr.placeable) : (Cr = Qr(Dt.iconBox), Ei = Cr.placeable), qi = qi && Cr.offscreen;
            }
            const Mn = oe || Ct.numHorizontalGlyphVertices === 0 && Ct.numVerticalGlyphVertices === 0, hl = de || Ct.numIconVertices === 0;
            Mn || hl ? hl ? Mn || (Ei = Ei && gi) : gi = Ei && gi : Ei = gi = Ei && gi;
            const To = Ei && Cr.placeable;
            if (gi && Ui.placeable && this.collisionIndex.insertCollisionBox(Ui.box, ce, p.get("text-ignore-placement"), h.bucketInstanceId, _r && _r.placeable && Ln ? Ln : dn, ae.ID), To && this.collisionIndex.insertCollisionBox(Cr.box, Le, p.get("icon-ignore-placement"), h.bucketInstanceId, sr, ae.ID), pr && gi && this.collisionIndex.insertCollisionCircles(pr.circles, ce, p.get("text-ignore-placement"), h.bucketInstanceId, dn, ae.ID), o && this.storeCollisionData(h.bucketInstanceId, Wt, Dt, Ui, Cr, pr), Ct.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            if (h.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[Ct.crossTileID] = new mi(gi || bt, Ei || yt, qi || h.justReloaded), r[Ct.crossTileID] = !0;
          };
          if (wt) {
            if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
            const Ct = h.getSortedSymbolIndexes(this.transform.angle);
            for (let Dt = Ct.length - 1; Dt >= 0; --Dt) {
              const Wt = Ct[Dt];
              Zt(h.symbolInstances.get(Wt), h.collisionArrays[Wt], Wt);
            }
          } else for (let Ct = e.symbolInstanceStart; Ct < e.symbolInstanceEnd; Ct++) Zt(h.symbolInstances.get(Ct), h.collisionArrays[Ct], Ct);
          if (o && h.bucketInstanceId in this.collisionCircleArrays) {
            const Ct = this.collisionCircleArrays[h.bucketInstanceId];
            s.as(Ct.invProjMatrix, T), Ct.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          h.justReloaded = !1;
        }
        storeCollisionData(e, r, o, h, p, x) {
          if (o.textBox || o.iconBox) {
            let A, T;
            this.collisionBoxArrays.has(e) ? A = this.collisionBoxArrays.get(e) : (A = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, A)), A.has(r) ? T = A.get(r) : (T = { text: null, icon: null }, A.set(r, T)), o.textBox && (T.text = h.box), o.iconBox && (T.icon = p.box);
          }
          if (x) {
            let A = this.collisionCircleArrays[e];
            A === void 0 && (A = this.collisionCircleArrays[e] = new Bi());
            for (let T = 0; T < x.circles.length; T += 4) A.circles.push(x.circles[T + 0]), A.circles.push(x.circles[T + 1]), A.circles.push(x.circles[T + 2]), A.circles.push(x.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(e, r, o, h) {
          let p;
          p = h === s.ah.vertical ? o.verticalPlacedTextSymbolIndex : { left: o.leftJustifiedTextSymbolIndex, center: o.centerJustifiedTextSymbolIndex, right: o.rightJustifiedTextSymbolIndex }[s.at(r)];
          const x = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex];
          for (const A of x) A >= 0 && (e.text.placedSymbolArray.get(A).crossTileID = p >= 0 && A !== p ? 0 : o.crossTileID);
        }
        markUsedOrientation(e, r, o) {
          const h = r === s.ah.horizontal || r === s.ah.horizontalOnly ? r : 0, p = r === s.ah.vertical ? r : 0, x = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex];
          for (const A of x) e.text.placedSymbolArray.get(A).placedOrientation = h;
          o.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = p);
        }
        commit(e) {
          this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const r = this.prevPlacement;
          let o = !1;
          this.prevZoomAdjustment = r ? r.zoomAdjustment(this.transform.zoom) : 0;
          const h = r ? r.symbolFadeChange(e) : 1, p = r ? r.opacities : {}, x = r ? r.variableOffsets : {}, A = r ? r.placedOrientations : {};
          for (const T in this.placements) {
            const P = this.placements[T], F = p[T];
            F ? (this.opacities[T] = new Oi(F, h, P.text, P.icon), o = o || P.text !== F.text.placed || P.icon !== F.icon.placed) : (this.opacities[T] = new Oi(null, h, P.text, P.icon, P.skipFade), o = o || P.text || P.icon);
          }
          for (const T in p) {
            const P = p[T];
            if (!this.opacities[T]) {
              const F = new Oi(P, h, !1, !1);
              F.isHidden() || (this.opacities[T] = F, o = o || P.text.placed || P.icon.placed);
            }
          }
          for (const T in x) this.variableOffsets[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.variableOffsets[T] = x[T]);
          for (const T in A) this.placedOrientations[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.placedOrientations[T] = A[T]);
          if (r && r.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
          o ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = r ? r.lastPlacementChangeTime : e);
        }
        updateLayerOpacities(e, r) {
          const o = {};
          for (const h of r) {
            const p = h.getBucket(e);
            p && h.latestFeatureIndex && e.id === p.layerIds[0] && this.updateBucketOpacities(p, h.tileID, o, h.collisionBoxArray);
          }
        }
        updateBucketOpacities(e, r, o, h) {
          e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
          const p = e.layers[0], x = p.layout, A = new Oi(null, 0, !1, !1, !0), T = x.get("text-allow-overlap"), P = x.get("icon-allow-overlap"), F = p._unevaluatedLayout.hasValue("text-variable-anchor") || p._unevaluatedLayout.hasValue("text-variable-anchor-offset"), N = x.get("text-rotation-alignment") === "map", Z = x.get("text-pitch-alignment") === "map", G = x.get("icon-text-fit") !== "none", V = new Oi(null, 0, T && (P || !e.hasIconData() || x.get("icon-optional")), P && (T || !e.hasTextData() || x.get("text-optional")), !0);
          !e.collisionArrays && h && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(h);
          const W = (oe, de, ce) => {
            for (let we = 0; we < de / 4; we++) oe.opacityVertexArray.emplaceBack(ce);
            oe.hasVisibleVertices = oe.hasVisibleVertices || ce !== os;
          }, ae = this.collisionBoxArrays.get(e.bucketInstanceId);
          for (let oe = 0; oe < e.symbolInstances.length; oe++) {
            const de = e.symbolInstances.get(oe), { numHorizontalGlyphVertices: ce, numVerticalGlyphVertices: we, crossTileID: Le } = de;
            let ke = this.opacities[Le];
            o[Le] ? ke = A : ke || (ke = V, this.opacities[Le] = ke), o[Le] = !0;
            const tt = de.numIconVertices > 0, ht = this.placedOrientations[de.crossTileID], _t = ht === s.ah.vertical, wt = ht === s.ah.horizontal || ht === s.ah.horizontalOnly;
            if (ce > 0 || we > 0) {
              const yt = Wr(ke.text);
              W(e.text, ce, _t ? os : yt), W(e.text, we, wt ? os : yt);
              const St = ke.text.isHidden();
              [de.rightJustifiedTextSymbolIndex, de.centerJustifiedTextSymbolIndex, de.leftJustifiedTextSymbolIndex].forEach((Dt) => {
                Dt >= 0 && (e.text.placedSymbolArray.get(Dt).hidden = St || _t ? 1 : 0);
              }), de.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(de.verticalPlacedTextSymbolIndex).hidden = St || wt ? 1 : 0);
              const Zt = this.variableOffsets[de.crossTileID];
              Zt && this.markUsedJustification(e, Zt.anchor, de, ht);
              const Ct = this.placedOrientations[de.crossTileID];
              Ct && (this.markUsedJustification(e, "left", de, Ct), this.markUsedOrientation(e, Ct, de));
            }
            if (tt) {
              const yt = Wr(ke.icon), St = !(G && de.verticalPlacedIconSymbolIndex && _t);
              de.placedIconSymbolIndex >= 0 && (W(e.icon, de.numIconVertices, St ? yt : os), e.icon.placedSymbolArray.get(de.placedIconSymbolIndex).hidden = ke.icon.isHidden()), de.verticalPlacedIconSymbolIndex >= 0 && (W(e.icon, de.numVerticalIconVertices, St ? os : yt), e.icon.placedSymbolArray.get(de.verticalPlacedIconSymbolIndex).hidden = ke.icon.isHidden());
            }
            const bt = ae && ae.has(oe) ? ae.get(oe) : { text: null, icon: null };
            if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
              const yt = e.collisionArrays[oe];
              if (yt) {
                let St = new s.P(0, 0);
                if (yt.textBox || yt.verticalTextBox) {
                  let Zt = !0;
                  if (F) {
                    const Ct = this.variableOffsets[Le];
                    Ct ? (St = vr(Ct.anchor, Ct.width, Ct.height, Ct.textOffset, Ct.textBoxScale), N && St._rotate(Z ? this.transform.angle : -this.transform.angle)) : Zt = !1;
                  }
                  if (yt.textBox || yt.verticalTextBox) {
                    let Ct;
                    yt.textBox && (Ct = _t), yt.verticalTextBox && (Ct = wt), Oa(e.textCollisionBox.collisionVertexArray, ke.text.placed, !Zt || Ct, bt.text, St.x, St.y);
                  }
                }
                if (yt.iconBox || yt.verticalIconBox) {
                  const Zt = !!(!wt && yt.verticalIconBox);
                  let Ct;
                  yt.iconBox && (Ct = Zt), yt.verticalIconBox && (Ct = !Zt), Oa(e.iconCollisionBox.collisionVertexArray, ke.icon.placed, Ct, bt.icon, G ? St.x : 0, G ? St.y : 0);
                }
              }
            }
          }
          if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
          if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
          if (e.bucketInstanceId in this.collisionCircleArrays) {
            const oe = this.collisionCircleArrays[e.bucketInstanceId];
            e.placementInvProjMatrix = oe.invProjMatrix, e.placementViewportMatrix = oe.viewportMatrix, e.collisionCircleArray = oe.circles, delete this.collisionCircleArrays[e.bucketInstanceId];
          }
        }
        symbolFadeChange(e) {
          return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e) {
          return Math.max(0, (this.transform.zoom - e) / 1.5);
        }
        hasTransitions(e) {
          return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e, r) {
          const o = this.zoomAtLastRecencyCheck === r ? 1 - this.zoomAdjustment(r) : 1;
          return this.zoomAtLastRecencyCheck = r, this.commitTime + this.fadeDuration * o > e;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function Oa(c, e, r, o, h, p) {
        o && o.length !== 0 || (o = [0, 0, 0, 0]);
        const x = o[0] - ei, A = o[1] - ei, T = o[2] - ei, P = o[3] - ei;
        c.emplaceBack(e ? 1 : 0, r ? 1 : 0, h || 0, p || 0, x, A), c.emplaceBack(e ? 1 : 0, r ? 1 : 0, h || 0, p || 0, T, A), c.emplaceBack(e ? 1 : 0, r ? 1 : 0, h || 0, p || 0, T, P), c.emplaceBack(e ? 1 : 0, r ? 1 : 0, h || 0, p || 0, x, P);
      }
      const ji = Math.pow(2, 25), Zo = Math.pow(2, 24), ss = Math.pow(2, 17), Hr = Math.pow(2, 16), sn = Math.pow(2, 9), Go = Math.pow(2, 8), mn = Math.pow(2, 1);
      function Wr(c) {
        if (c.opacity === 0 && !c.placed) return 0;
        if (c.opacity === 1 && c.placed) return 4294967295;
        const e = c.placed ? 1 : 0, r = Math.floor(127 * c.opacity);
        return r * ji + e * Zo + r * ss + e * Hr + r * sn + e * Go + r * mn + e;
      }
      const os = 0;
      function Rn() {
        return { isOccluded: (c, e, r) => !1, getPitchedTextCorrection: (c, e, r) => 1, get useSpecialProjectionForSymbols() {
          return !1;
        }, projectTileCoordinates(c, e, r, o) {
          throw new Error("Not implemented.");
        }, translatePosition: (c, e, r, o) => function(h, p, x, A, T = !1) {
          if (!x[0] && !x[1]) return [0, 0];
          const P = T ? A === "map" ? h.angle : 0 : A === "viewport" ? -h.angle : 0;
          if (P) {
            const F = Math.sin(P), N = Math.cos(P);
            x = [x[0] * N - x[1] * F, x[0] * F + x[1] * N];
          }
          return [T ? x[0] : fi(p, x[0], h.zoom), T ? x[1] : fi(p, x[1], h.zoom)];
        }(c, e, r, o), getCircleRadiusCorrection: (c) => 1 };
      }
      class br {
        constructor(e) {
          this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(e, r, o, h, p) {
          const x = this._bucketParts;
          for (; this._currentTileIndex < e.length; ) if (r.getBucketParts(x, h, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, p()) return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, x.sort((A, T) => A.sortKey - T.sortKey)); this._currentPartIndex < x.length; ) if (r.placeLayerBucketPart(x[this._currentPartIndex], this._seenCrossTileIDs, o), this._currentPartIndex++, p()) return !0;
          return !1;
        }
      }
      class rr {
        constructor(e, r, o, h, p, x, A, T) {
          this.placement = new kr(e, Rn(), r, x, A, T), this._currentPlacementIndex = o.length - 1, this._forceFullPlacement = h, this._showCollisionBoxes = p, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(e, r, o) {
          const h = q.now(), p = () => !this._forceFullPlacement && q.now() - h > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const x = r[e[this._currentPlacementIndex]], A = this.placement.collisionIndex.transform.zoom;
            if (x.type === "symbol" && (!x.minzoom || x.minzoom <= A) && (!x.maxzoom || x.maxzoom > A)) {
              if (this._inProgressLayer || (this._inProgressLayer = new br(x)), this._inProgressLayer.continuePlacement(o[x.source], this.placement, this._showCollisionBoxes, x, p)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(e) {
          return this.placement.commit(e), this.placement;
        }
      }
      const gn = 512 / s.X / 2;
      class hr {
        constructor(e, r, o) {
          this.tileID = e, this.bucketInstanceId = o, this._symbolsByKey = {};
          const h = /* @__PURE__ */ new Map();
          for (let p = 0; p < r.length; p++) {
            const x = r.get(p), A = x.key, T = h.get(A);
            T ? T.push(x) : h.set(A, [x]);
          }
          for (const [p, x] of h) {
            const A = { positions: x.map((T) => ({ x: Math.floor(T.anchorX * gn), y: Math.floor(T.anchorY * gn) })), crossTileIDs: x.map((T) => T.crossTileID) };
            if (A.positions.length > 128) {
              const T = new s.av(A.positions.length, 16, Uint16Array);
              for (const { x: P, y: F } of A.positions) T.add(P, F);
              T.finish(), delete A.positions, A.index = T;
            }
            this._symbolsByKey[p] = A;
          }
        }
        getScaledCoordinates(e, r) {
          const { x: o, y: h, z: p } = this.tileID.canonical, { x, y: A, z: T } = r.canonical, P = gn / Math.pow(2, T - p), F = (A * s.X + e.anchorY) * P, N = h * s.X * gn;
          return { x: Math.floor((x * s.X + e.anchorX) * P - o * s.X * gn), y: Math.floor(F - N) };
        }
        findMatches(e, r, o) {
          const h = this.tileID.canonical.z < r.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - r.canonical.z);
          for (let p = 0; p < e.length; p++) {
            const x = e.get(p);
            if (x.crossTileID) continue;
            const A = this._symbolsByKey[x.key];
            if (!A) continue;
            const T = this.getScaledCoordinates(x, r);
            if (A.index) {
              const P = A.index.range(T.x - h, T.y - h, T.x + h, T.y + h).sort();
              for (const F of P) {
                const N = A.crossTileIDs[F];
                if (!o[N]) {
                  o[N] = !0, x.crossTileID = N;
                  break;
                }
              }
            } else if (A.positions) for (let P = 0; P < A.positions.length; P++) {
              const F = A.positions[P], N = A.crossTileIDs[P];
              if (Math.abs(F.x - T.x) <= h && Math.abs(F.y - T.y) <= h && !o[N]) {
                o[N] = !0, x.crossTileID = N;
                break;
              }
            }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(({ crossTileIDs: e }) => e);
        }
      }
      class ks {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class on {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e) {
          const r = Math.round((e - this.lng) / 360);
          if (r !== 0) for (const o in this.indexes) {
            const h = this.indexes[o], p = {};
            for (const x in h) {
              const A = h[x];
              A.tileID = A.tileID.unwrapTo(A.tileID.wrap + r), p[A.tileID.key] = A;
            }
            this.indexes[o] = p;
          }
          this.lng = e;
        }
        addBucket(e, r, o) {
          if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
            if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === r.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
          }
          for (let p = 0; p < r.symbolInstances.length; p++) r.symbolInstances.get(p).crossTileID = 0;
          this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
          const h = this.usedCrossTileIDs[e.overscaledZ];
          for (const p in this.indexes) {
            const x = this.indexes[p];
            if (Number(p) > e.overscaledZ) for (const A in x) {
              const T = x[A];
              T.tileID.isChildOf(e) && T.findMatches(r.symbolInstances, e, h);
            }
            else {
              const A = x[e.scaledTo(Number(p)).key];
              A && A.findMatches(r.symbolInstances, e, h);
            }
          }
          for (let p = 0; p < r.symbolInstances.length; p++) {
            const x = r.symbolInstances.get(p);
            x.crossTileID || (x.crossTileID = o.generate(), h[x.crossTileID] = !0);
          }
          return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new hr(e, r.symbolInstances, r.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(e, r) {
          for (const o of r.getCrossTileIDsLists()) for (const h of o) delete this.usedCrossTileIDs[e][h];
        }
        removeStaleBuckets(e) {
          let r = !1;
          for (const o in this.indexes) {
            const h = this.indexes[o];
            for (const p in h) e[h[p].bucketInstanceId] || (this.removeBucketCrossTileIDs(o, h[p]), delete h[p], r = !0);
          }
          return r;
        }
      }
      class Ho {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new ks(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e, r, o) {
          let h = this.layerIndexes[e.id];
          h === void 0 && (h = this.layerIndexes[e.id] = new on());
          let p = !1;
          const x = {};
          h.handleWrapJump(o);
          for (const A of r) {
            const T = A.getBucket(e);
            T && e.id === T.layerIds[0] && (T.bucketInstanceId || (T.bucketInstanceId = ++this.maxBucketInstanceId), h.addBucket(A.tileID, T, this.crossTileIDs) && (p = !0), x[T.bucketInstanceId] = !0);
          }
          return h.removeStaleBuckets(x) && (p = !0), p;
        }
        pruneUnusedLayers(e) {
          const r = {};
          e.forEach((o) => {
            r[o] = !0;
          });
          for (const o in this.layerIndexes) r[o] || delete this.layerIndexes[o];
        }
      }
      const Ar = (c, e) => s.t(c, e && e.filter((r) => r.identifier !== "source.canvas")), Qs = s.aw();
      class Or extends s.E {
        constructor(e, r = {}) {
          super(), this._rtlPluginLoaded = () => {
            for (const o in this.sourceCaches) {
              const h = this.sourceCaches[o].getSource().type;
              h !== "vector" && h !== "geojson" || this.sourceCaches[o].reload();
            }
          }, this.map = e, this.dispatcher = new rt(Ke(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", (o, h) => this.getGlyphs(o, h)), this.dispatcher.registerMessageHandler("GI", (o, h) => this.getImages(o, h)), this.imageManager = new xe(), this.imageManager.setEventedParent(this), this.glyphManager = new Ze(e._requestManager, r.localIdeographFontFamily), this.lineAtlas = new _e(256, 512), this.crossTileSymbolIndex = new Ho(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new s.ax(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", s.ay()), kt().on(pt, this._rtlPluginLoaded), this.on("data", (o) => {
            if (o.dataType !== "source" || o.sourceDataType !== "metadata") return;
            const h = this.sourceCaches[o.sourceId];
            if (!h) return;
            const p = h.getSource();
            if (p && p.vectorLayerIds) for (const x in this._layers) {
              const A = this._layers[x];
              A.source === p.id && this._validateLayer(A);
            }
          });
        }
        loadURL(e, r = {}, o) {
          this.fire(new s.k("dataloading", { dataType: "style" })), r.validate = typeof r.validate != "boolean" || r.validate;
          const h = this.map._requestManager.transformRequest(e, "Style");
          this._loadStyleRequest = new AbortController();
          const p = this._loadStyleRequest;
          s.h(h, this._loadStyleRequest).then((x) => {
            this._loadStyleRequest = null, this._load(x.data, r, o);
          }).catch((x) => {
            this._loadStyleRequest = null, x && !p.signal.aborted && this.fire(new s.j(x));
          });
        }
        loadJSON(e, r = {}, o) {
          this.fire(new s.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), q.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, r.validate = r.validate !== !1, this._load(e, r, o);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new s.k("dataloading", { dataType: "style" })), this._load(Qs, { validate: !1 });
        }
        _load(e, r, o) {
          var h;
          const p = r.transformStyle ? r.transformStyle(o, e) : e;
          if (!r.validate || !Ar(this, s.u(p))) {
            this._loaded = !0, this.stylesheet = p;
            for (const x in p.sources) this.addSource(x, p.sources[x], { validate: !1 });
            p.sprite ? this._loadSprite(p.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(p.glyphs), this._createLayers(), this.light = new Qe(this.stylesheet.light), this.sky = new Q(this.stylesheet.sky), this.map.setTerrain((h = this.stylesheet.terrain) !== null && h !== void 0 ? h : null), this.fire(new s.k("data", { dataType: "style" })), this.fire(new s.k("style.load"));
          }
        }
        _createLayers() {
          const e = s.az(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", e), this._order = e.map((r) => r.id), this._layers = {}, this._serializedLayers = null;
          for (const r of e) {
            const o = s.aA(r);
            o.setEventedParent(this, { layer: { id: r.id } }), this._layers[r.id] = o;
          }
        }
        _loadSprite(e, r = !1, o = void 0) {
          let h;
          this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(p, x, A, T) {
            return s._(this, void 0, void 0, function* () {
              const P = me(p), F = A > 1 ? "@2x" : "", N = {}, Z = {};
              for (const { id: G, url: V } of P) {
                const W = x.transformRequest(ve(V, F, ".json"), "SpriteJSON");
                N[G] = s.h(W, T);
                const ae = x.transformRequest(ve(V, F, ".png"), "SpriteImage");
                Z[G] = Te.getImage(ae, T);
              }
              return yield Promise.all([...Object.values(N), ...Object.values(Z)]), function(G, V) {
                return s._(this, void 0, void 0, function* () {
                  const W = {};
                  for (const ae in G) {
                    W[ae] = {};
                    const oe = q.getImageCanvasContext((yield V[ae]).data), de = (yield G[ae]).data;
                    for (const ce in de) {
                      const { width: we, height: Le, x: ke, y: tt, sdf: ht, pixelRatio: _t, stretchX: wt, stretchY: bt, content: yt, textFitWidth: St, textFitHeight: Zt } = de[ce];
                      W[ae][ce] = { data: null, pixelRatio: _t, sdf: ht, stretchX: wt, stretchY: bt, content: yt, textFitWidth: St, textFitHeight: Zt, spriteData: { width: we, height: Le, x: ke, y: tt, context: oe } };
                    }
                  }
                  return W;
                });
              }(N, Z);
            });
          }(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((p) => {
            if (this._spriteRequest = null, p) for (const x in p) {
              this._spritesImagesIds[x] = [];
              const A = this._spritesImagesIds[x] ? this._spritesImagesIds[x].filter((T) => !(T in p)) : [];
              for (const T of A) this.imageManager.removeImage(T), this._changedImages[T] = !0;
              for (const T in p[x]) {
                const P = x === "default" ? T : `${x}:${T}`;
                this._spritesImagesIds[x].push(P), P in this.imageManager.images ? this.imageManager.updateImage(P, p[x][T], !1) : this.imageManager.addImage(P, p[x][T]), r && (this._changedImages[P] = !0);
              }
            }
          }).catch((p) => {
            this._spriteRequest = null, h = p, this.fire(new s.j(h));
          }).finally(() => {
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), r && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.k("data", { dataType: "style" })), o && o(h);
          });
        }
        _unloadSprite() {
          for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.k("data", { dataType: "style" }));
        }
        _validateLayer(e) {
          const r = this.sourceCaches[e.source];
          if (!r) return;
          const o = e.sourceLayer;
          if (!o) return;
          const h = r.getSource();
          (h.type === "geojson" || h.vectorLayerIds && h.vectorLayerIds.indexOf(o) === -1) && this.fire(new s.j(new Error(`Source layer "${o}" does not exist on source "${h.id}" as specified by style layer "${e.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
          for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(e, r = !1) {
          const o = this._serializedAllLayers();
          if (!e || e.length === 0) return Object.values(r ? s.aB(o) : o);
          const h = [];
          for (const p of e) if (o[p]) {
            const x = r ? s.aB(o[p]) : o[p];
            h.push(x);
          }
          return h;
        }
        _serializedAllLayers() {
          let e = this._serializedLayers;
          if (e) return e;
          e = this._serializedLayers = {};
          const r = Object.keys(this._layers);
          for (const o of r) {
            const h = this._layers[o];
            h.type !== "custom" && (e[o] = h.serialize());
          }
          return e;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition() || this.sky && this.sky.hasTransition()) return !0;
          for (const e in this.sourceCaches) if (this.sourceCaches[e].hasTransition()) return !0;
          for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading.");
        }
        update(e) {
          if (!this._loaded) return;
          const r = this._changed;
          if (r) {
            const h = Object.keys(this._updatedLayers), p = Object.keys(this._removedLayers);
            (h.length || p.length) && this._updateWorkerLayers(h, p);
            for (const x in this._updatedSources) {
              const A = this._updatedSources[x];
              if (A === "reload") this._reloadSource(x);
              else {
                if (A !== "clear") throw new Error(`Invalid action ${A}`);
                this._clearSource(x);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const x in this._updatedPaintProps) this._layers[x].updateTransitions(e);
            this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
          }
          const o = {};
          for (const h in this.sourceCaches) {
            const p = this.sourceCaches[h];
            o[h] = p.used, p.used = !1;
          }
          for (const h of this._order) {
            const p = this._layers[h];
            p.recalculate(e, this._availableImages), !p.isHidden(e.zoom) && p.source && (this.sourceCaches[p.source].used = !0);
          }
          for (const h in o) {
            const p = this.sourceCaches[h];
            !!o[h] != !!p.used && p.fire(new s.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: h }));
          }
          this.light.recalculate(e), this.sky.recalculate(e), this.z = e.zoom, r && this.fire(new s.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const e = Object.keys(this._changedImages);
          if (e.length) {
            for (const r in this.sourceCaches) this.sourceCaches[r].reloadTilesForDependencies(["icons", "patterns"], e);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = !1;
          }
        }
        _updateWorkerLayers(e, r) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, !1), removedIds: r });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
        }
        setState(e, r = {}) {
          var o;
          this._checkLoaded();
          const h = this.serialize();
          if (e = r.transformStyle ? r.transformStyle(h, e) : e, ((o = r.validate) === null || o === void 0 || o) && Ar(this, s.u(e))) return !1;
          (e = s.aB(e)).layers = s.az(e.layers);
          const p = s.aC(h, e), x = this._getOperationsToPerform(p);
          if (x.unimplemented.length > 0) throw new Error(`Unimplemented: ${x.unimplemented.join(", ")}.`);
          if (x.operations.length === 0) return !1;
          for (const A of x.operations) A();
          return this.stylesheet = e, this._serializedLayers = null, !0;
        }
        _getOperationsToPerform(e) {
          const r = [], o = [];
          for (const h of e) switch (h.command) {
            case "setCenter":
            case "setZoom":
            case "setBearing":
            case "setPitch":
              continue;
            case "addLayer":
              r.push(() => this.addLayer.apply(this, h.args));
              break;
            case "removeLayer":
              r.push(() => this.removeLayer.apply(this, h.args));
              break;
            case "setPaintProperty":
              r.push(() => this.setPaintProperty.apply(this, h.args));
              break;
            case "setLayoutProperty":
              r.push(() => this.setLayoutProperty.apply(this, h.args));
              break;
            case "setFilter":
              r.push(() => this.setFilter.apply(this, h.args));
              break;
            case "addSource":
              r.push(() => this.addSource.apply(this, h.args));
              break;
            case "removeSource":
              r.push(() => this.removeSource.apply(this, h.args));
              break;
            case "setLayerZoomRange":
              r.push(() => this.setLayerZoomRange.apply(this, h.args));
              break;
            case "setLight":
              r.push(() => this.setLight.apply(this, h.args));
              break;
            case "setGeoJSONSourceData":
              r.push(() => this.setGeoJSONSourceData.apply(this, h.args));
              break;
            case "setGlyphs":
              r.push(() => this.setGlyphs.apply(this, h.args));
              break;
            case "setSprite":
              r.push(() => this.setSprite.apply(this, h.args));
              break;
            case "setSky":
              r.push(() => this.setSky.apply(this, h.args));
              break;
            case "setTerrain":
              r.push(() => this.map.setTerrain.apply(this, h.args));
              break;
            case "setTransition":
              r.push(() => {
              });
              break;
            default:
              o.push(h.command);
          }
          return { operations: r, unimplemented: o };
        }
        addImage(e, r) {
          if (this.getImage(e)) return this.fire(new s.j(new Error(`An image named "${e}" already exists.`)));
          this.imageManager.addImage(e, r), this._afterImageUpdated(e);
        }
        updateImage(e, r) {
          this.imageManager.updateImage(e, r);
        }
        getImage(e) {
          return this.imageManager.getImage(e);
        }
        removeImage(e) {
          if (!this.getImage(e)) return this.fire(new s.j(new Error(`An image named "${e}" does not exist.`)));
          this.imageManager.removeImage(e), this._afterImageUpdated(e);
        }
        _afterImageUpdated(e) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(e, r, o = {}) {
          if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
          if (!r.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(r).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(r.type) >= 0 && this._validate(s.u.source, `sources.${e}`, r, null, o)) return;
          this.map && this.map._collectResourceTiming && (r.collectResourceTiming = !0);
          const h = this.sourceCaches[e] = new Lt(e, r, this.dispatcher);
          h.style = this, h.setEventedParent(this, () => ({ isSourceLoaded: h.loaded(), source: h.serialize(), sourceId: e })), h.onAdd(this.map), this._changed = !0;
        }
        removeSource(e) {
          if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
          for (const o in this._layers) if (this._layers[o].source === e) return this.fire(new s.j(new Error(`Source "${e}" cannot be removed while layer "${o}" is using it.`)));
          const r = this.sourceCaches[e];
          delete this.sourceCaches[e], delete this._updatedSources[e], r.fire(new s.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), r.setEventedParent(null), r.onRemove(this.map), this._changed = !0;
        }
        setGeoJSONSourceData(e, r) {
          if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
          const o = this.sourceCaches[e].getSource();
          if (o.type !== "geojson") throw new Error(`geojsonSource.type is ${o.type}, which is !== 'geojson`);
          o.setData(r), this._changed = !0;
        }
        getSource(e) {
          return this.sourceCaches[e] && this.sourceCaches[e].getSource();
        }
        addLayer(e, r, o = {}) {
          this._checkLoaded();
          const h = e.id;
          if (this.getLayer(h)) return void this.fire(new s.j(new Error(`Layer "${h}" already exists on this map.`)));
          let p;
          if (e.type === "custom") {
            if (Ar(this, s.aD(e))) return;
            p = s.aA(e);
          } else {
            if ("source" in e && typeof e.source == "object" && (this.addSource(h, e.source), e = s.aB(e), e = s.e(e, { source: h })), this._validate(s.u.layer, `layers.${h}`, e, { arrayIndex: -1 }, o)) return;
            p = s.aA(e), this._validateLayer(p), p.setEventedParent(this, { layer: { id: h } });
          }
          const x = r ? this._order.indexOf(r) : this._order.length;
          if (r && x === -1) this.fire(new s.j(new Error(`Cannot add layer "${h}" before non-existing layer "${r}".`)));
          else {
            if (this._order.splice(x, 0, h), this._layerOrderChanged = !0, this._layers[h] = p, this._removedLayers[h] && p.source && p.type !== "custom") {
              const A = this._removedLayers[h];
              delete this._removedLayers[h], A.type !== p.type ? this._updatedSources[p.source] = "clear" : (this._updatedSources[p.source] = "reload", this.sourceCaches[p.source].pause());
            }
            this._updateLayer(p), p.onAdd && p.onAdd(this.map);
          }
        }
        moveLayer(e, r) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new s.j(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
          if (e === r) return;
          const o = this._order.indexOf(e);
          this._order.splice(o, 1);
          const h = r ? this._order.indexOf(r) : this._order.length;
          r && h === -1 ? this.fire(new s.j(new Error(`Cannot move layer "${e}" before non-existing layer "${r}".`))) : (this._order.splice(h, 0, e), this._layerOrderChanged = !0);
        }
        removeLayer(e) {
          this._checkLoaded();
          const r = this._layers[e];
          if (!r) return void this.fire(new s.j(new Error(`Cannot remove non-existing layer "${e}".`)));
          r.setEventedParent(null);
          const o = this._order.indexOf(e);
          this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = r, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], r.onRemove && r.onRemove(this.map);
        }
        getLayer(e) {
          return this._layers[e];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(e) {
          return e in this._layers;
        }
        setLayerZoomRange(e, r, o) {
          this._checkLoaded();
          const h = this.getLayer(e);
          h ? h.minzoom === r && h.maxzoom === o || (r != null && (h.minzoom = r), o != null && (h.maxzoom = o), this._updateLayer(h)) : this.fire(new s.j(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
        }
        setFilter(e, r, o = {}) {
          this._checkLoaded();
          const h = this.getLayer(e);
          if (h) {
            if (!s.aE(h.filter, r)) return r == null ? (h.filter = void 0, void this._updateLayer(h)) : void (this._validate(s.u.filter, `layers.${h.id}.filter`, r, null, o) || (h.filter = s.aB(r), this._updateLayer(h)));
          } else this.fire(new s.j(new Error(`Cannot filter non-existing layer "${e}".`)));
        }
        getFilter(e) {
          return s.aB(this.getLayer(e).filter);
        }
        setLayoutProperty(e, r, o, h = {}) {
          this._checkLoaded();
          const p = this.getLayer(e);
          p ? s.aE(p.getLayoutProperty(r), o) || (p.setLayoutProperty(r, o, h), this._updateLayer(p)) : this.fire(new s.j(new Error(`Cannot style non-existing layer "${e}".`)));
        }
        getLayoutProperty(e, r) {
          const o = this.getLayer(e);
          if (o) return o.getLayoutProperty(r);
          this.fire(new s.j(new Error(`Cannot get style of non-existing layer "${e}".`)));
        }
        setPaintProperty(e, r, o, h = {}) {
          this._checkLoaded();
          const p = this.getLayer(e);
          p ? s.aE(p.getPaintProperty(r), o) || (p.setPaintProperty(r, o, h) && this._updateLayer(p), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new s.j(new Error(`Cannot style non-existing layer "${e}".`)));
        }
        getPaintProperty(e, r) {
          return this.getLayer(e).getPaintProperty(r);
        }
        setFeatureState(e, r) {
          this._checkLoaded();
          const o = e.source, h = e.sourceLayer, p = this.sourceCaches[o];
          if (p === void 0) return void this.fire(new s.j(new Error(`The source '${o}' does not exist in the map's style.`)));
          const x = p.getSource().type;
          x === "geojson" && h ? this.fire(new s.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : x !== "vector" || h ? (e.id === void 0 && this.fire(new s.j(new Error("The feature id parameter must be provided."))), p.setFeatureState(h, e.id, r)) : this.fire(new s.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(e, r) {
          this._checkLoaded();
          const o = e.source, h = this.sourceCaches[o];
          if (h === void 0) return void this.fire(new s.j(new Error(`The source '${o}' does not exist in the map's style.`)));
          const p = h.getSource().type, x = p === "vector" ? e.sourceLayer : void 0;
          p !== "vector" || x ? r && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new s.j(new Error("A feature id is required to remove its specific state property."))) : h.removeFeatureState(x, e.id, r) : this.fire(new s.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(e) {
          this._checkLoaded();
          const r = e.source, o = e.sourceLayer, h = this.sourceCaches[r];
          if (h !== void 0) return h.getSource().type !== "vector" || o ? (e.id === void 0 && this.fire(new s.j(new Error("The feature id parameter must be provided."))), h.getFeatureState(o, e.id)) : void this.fire(new s.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new s.j(new Error(`The source '${r}' does not exist in the map's style.`)));
        }
        getTransition() {
          return s.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded) return;
          const e = s.aF(this.sourceCaches, (p) => p.serialize()), r = this._serializeByIds(this._order, !0), o = this.map.getTerrain() || void 0, h = this.stylesheet;
          return s.aG({ version: h.version, name: h.name, metadata: h.metadata, light: h.light, sky: h.sky, center: h.center, zoom: h.zoom, bearing: h.bearing, pitch: h.pitch, sprite: h.sprite, glyphs: h.glyphs, transition: h.transition, sources: e, layers: r, terrain: o }, (p) => p !== void 0);
        }
        _updateLayer(e) {
          this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0;
        }
        _flattenAndSortRenderedFeatures(e) {
          const r = (x) => this._layers[x].type === "fill-extrusion", o = {}, h = [];
          for (let x = this._order.length - 1; x >= 0; x--) {
            const A = this._order[x];
            if (r(A)) {
              o[A] = x;
              for (const T of e) {
                const P = T[A];
                if (P) for (const F of P) h.push(F);
              }
            }
          }
          h.sort((x, A) => A.intersectionZ - x.intersectionZ);
          const p = [];
          for (let x = this._order.length - 1; x >= 0; x--) {
            const A = this._order[x];
            if (r(A)) for (let T = h.length - 1; T >= 0; T--) {
              const P = h[T].feature;
              if (o[P.layer.id] < x) break;
              p.push(P), h.pop();
            }
            else for (const T of e) {
              const P = T[A];
              if (P) for (const F of P) p.push(F.feature);
            }
          }
          return p;
        }
        queryRenderedFeatures(e, r, o) {
          r && r.filter && this._validate(s.u.filter, "queryRenderedFeatures.filter", r.filter, null, r);
          const h = {};
          if (r && r.layers) {
            if (!Array.isArray(r.layers)) return this.fire(new s.j(new Error("parameters.layers must be an Array."))), [];
            for (const A of r.layers) {
              const T = this._layers[A];
              if (!T) return this.fire(new s.j(new Error(`The layer '${A}' does not exist in the map's style and cannot be queried for features.`))), [];
              h[T.source] = !0;
            }
          }
          const p = [];
          r.availableImages = this._availableImages;
          const x = this._serializedAllLayers();
          for (const A in this.sourceCaches) r.layers && !h[A] || p.push(mt(this.sourceCaches[A], this._layers, x, e, r, o));
          return this.placement && p.push(function(A, T, P, F, N, Z, G) {
            const V = {}, W = Z.queryRenderedSymbols(F), ae = [];
            for (const oe of Object.keys(W).map(Number)) ae.push(G[oe]);
            ae.sort(Pt);
            for (const oe of ae) {
              const de = oe.featureIndex.lookupSymbolFeatures(W[oe.bucketInstanceId], T, oe.bucketIndex, oe.sourceLayerIndex, N.filter, N.layers, N.availableImages, A);
              for (const ce in de) {
                const we = V[ce] = V[ce] || [], Le = de[ce];
                Le.sort((ke, tt) => {
                  const ht = oe.featureSortOrder;
                  if (ht) {
                    const _t = ht.indexOf(ke.featureIndex);
                    return ht.indexOf(tt.featureIndex) - _t;
                  }
                  return tt.featureIndex - ke.featureIndex;
                });
                for (const ke of Le) we.push(ke);
              }
            }
            for (const oe in V) V[oe].forEach((de) => {
              const ce = de.feature, we = P[A[oe].source].getFeatureState(ce.layer["source-layer"], ce.id);
              ce.source = ce.layer.source, ce.layer["source-layer"] && (ce.sourceLayer = ce.layer["source-layer"]), ce.state = we;
            });
            return V;
          }(this._layers, x, this.sourceCaches, e, r, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(p);
        }
        querySourceFeatures(e, r) {
          r && r.filter && this._validate(s.u.filter, "querySourceFeatures.filter", r.filter, null, r);
          const o = this.sourceCaches[e];
          return o ? function(h, p) {
            const x = h.getRenderableIds().map((P) => h.getTileByID(P)), A = [], T = {};
            for (let P = 0; P < x.length; P++) {
              const F = x[P], N = F.tileID.canonical.key;
              T[N] || (T[N] = !0, F.querySourceFeatures(A, p));
            }
            return A;
          }(o, r) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(e, r = {}) {
          this._checkLoaded();
          const o = this.light.getLight();
          let h = !1;
          for (const x in e) if (!s.aE(e[x], o[x])) {
            h = !0;
            break;
          }
          if (!h) return;
          const p = { now: q.now(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(e, r), this.light.updateTransitions(p);
        }
        getSky() {
          var e;
          return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
        }
        setSky(e, r = {}) {
          const o = this.getSky();
          let h = !1;
          if (!e && !o) return;
          if (e && !o) h = !0;
          else if (!e && o) h = !0;
          else for (const x in e) if (!s.aE(e[x], o[x])) {
            h = !0;
            break;
          }
          if (!h) return;
          const p = { now: q.now(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = e, this.sky.setSky(e, r), this.sky.updateTransitions(p);
        }
        _validate(e, r, o, h, p = {}) {
          return (!p || p.validate !== !1) && Ar(this, e.call(s.u, s.e({ key: r, style: this.serialize(), value: o, styleSpec: s.v }, h)));
        }
        _remove(e = !0) {
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), kt().off(pt, this._rtlPluginLoaded);
          for (const r in this._layers) this._layers[r].setEventedParent(null);
          for (const r in this.sourceCaches) {
            const o = this.sourceCaches[r];
            o.setEventedParent(null), o.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
        }
        _clearSource(e) {
          this.sourceCaches[e].clearTiles();
        }
        _reloadSource(e) {
          this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
        }
        _updateSources(e) {
          for (const r in this.sourceCaches) this.sourceCaches[r].update(e, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const e in this.sourceCaches) this._reloadSource(e);
        }
        _updatePlacement(e, r, o, h, p = !1) {
          let x = !1, A = !1;
          const T = {};
          for (const P of this._order) {
            const F = this._layers[P];
            if (F.type !== "symbol") continue;
            if (!T[F.source]) {
              const Z = this.sourceCaches[F.source];
              T[F.source] = Z.getRenderableIds(!0).map((G) => Z.getTileByID(G)).sort((G, V) => V.tileID.overscaledZ - G.tileID.overscaledZ || (G.tileID.isLessThan(V.tileID) ? -1 : 1));
            }
            const N = this.crossTileSymbolIndex.addLayer(F, T[F.source], e.center.lng);
            x = x || N;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((p = p || this._layerOrderChanged || o === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(q.now(), e.zoom)) && (this.pauseablePlacement = new rr(e, this.map.terrain, this._order, p, r, o, h, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, T), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(q.now()), A = !0), x && this.pauseablePlacement.placement.setStale()), A || x) for (const P of this._order) {
            const F = this._layers[P];
            F.type === "symbol" && this.placement.updateLayerOpacities(F, T[F.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(q.now());
        }
        _releaseSymbolFadeTiles() {
          for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
        }
        getImages(e, r) {
          return s._(this, void 0, void 0, function* () {
            const o = yield this.imageManager.getImages(r.icons);
            this._updateTilesForChangedImages();
            const h = this.sourceCaches[r.source];
            return h && h.setDependencies(r.tileID.key, r.type, r.icons), o;
          });
        }
        getGlyphs(e, r) {
          return s._(this, void 0, void 0, function* () {
            const o = yield this.glyphManager.getGlyphs(r.stacks), h = this.sourceCaches[r.source];
            return h && h.setDependencies(r.tileID.key, r.type, [""]), o;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(e, r = {}) {
          this._checkLoaded(), e && this._validate(s.u.glyphs, "glyphs", e, null, r) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
        }
        addSprite(e, r, o = {}, h) {
          this._checkLoaded();
          const p = [{ id: e, url: r }], x = [...me(this.stylesheet.sprite), ...p];
          this._validate(s.u.sprite, "sprite", x, null, o) || (this.stylesheet.sprite = x, this._loadSprite(p, !0, h));
        }
        removeSprite(e) {
          this._checkLoaded();
          const r = me(this.stylesheet.sprite);
          if (r.find((o) => o.id === e)) {
            if (this._spritesImagesIds[e]) for (const o of this._spritesImagesIds[e]) this.imageManager.removeImage(o), this._changedImages[o] = !0;
            r.splice(r.findIndex((o) => o.id === e), 1), this.stylesheet.sprite = r.length > 0 ? r : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.k("data", { dataType: "style" }));
          } else this.fire(new s.j(new Error(`Sprite "${e}" doesn't exists on this map.`)));
        }
        getSprite() {
          return me(this.stylesheet.sprite);
        }
        setSprite(e, r = {}, o) {
          this._checkLoaded(), e && this._validate(s.u.sprite, "sprite", e, null, r) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, o) : (this._unloadSprite(), o && o(null)));
        }
      }
      var na = s.Y([{ name: "a_pos", type: "Int16", components: 2 }]);
      const aa = { prelude: Ri(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: Ri(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: Ri(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Ri(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Ri("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Ri(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,get_elevation(floor(a_pos*0.5)),1);gl_Position=u_matrix*pos;}`), heatmapTexture: Ri(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Ri("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Ri("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Ri("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: Ri(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: Ri(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: Ri(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: Ri(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Ri(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Ri(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Ri(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ri(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: Ri(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Ri(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Ri(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Ri(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Ri(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: Ri(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Ri(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Ri(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Ri("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;varying vec2 v_texture_pos;varying float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture2D(u_texture,v_texture_pos);if (v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);gl_FragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {gl_FragColor=surface_color;}}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform mat4 u_fog_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Ri("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Ri("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);}"), sky: Ri("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform float u_horizon;uniform float u_sky_horizon_blend;void main() {float y=gl_FragCoord.y;if (y > u_horizon) {float blend=y-u_horizon;if (blend < u_sky_horizon_blend) {gl_FragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {gl_FragColor=u_sky_color;}}}", "attribute vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
      function Ri(c, e) {
        const r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o = e.match(/attribute ([\w]+) ([\w]+)/g), h = c.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), p = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), x = p ? p.concat(h) : h, A = {};
        return { fragmentSource: c = c.replace(r, (T, P, F, N, Z) => (A[Z] = !0, P === "define" ? `
#ifndef HAS_UNIFORM_u_${Z}
varying ${F} ${N} ${Z};
#else
uniform ${F} ${N} u_${Z};
#endif
` : `
#ifdef HAS_UNIFORM_u_${Z}
    ${F} ${N} ${Z} = u_${Z};
#endif
`)), vertexSource: e = e.replace(r, (T, P, F, N, Z) => {
          const G = N === "float" ? "vec2" : "vec4", V = Z.match(/color/) ? "color" : G;
          return A[Z] ? P === "define" ? `
#ifndef HAS_UNIFORM_u_${Z}
uniform lowp float u_${Z}_t;
attribute ${F} ${G} a_${Z};
varying ${F} ${N} ${Z};
#else
uniform ${F} ${N} u_${Z};
#endif
` : V === "vec4" ? `
#ifndef HAS_UNIFORM_u_${Z}
    ${Z} = a_${Z};
#else
    ${F} ${N} ${Z} = u_${Z};
#endif
` : `
#ifndef HAS_UNIFORM_u_${Z}
    ${Z} = unpack_mix_${V}(a_${Z}, u_${Z}_t);
#else
    ${F} ${N} ${Z} = u_${Z};
#endif
` : P === "define" ? `
#ifndef HAS_UNIFORM_u_${Z}
uniform lowp float u_${Z}_t;
attribute ${F} ${G} a_${Z};
#else
uniform ${F} ${N} u_${Z};
#endif
` : V === "vec4" ? `
#ifndef HAS_UNIFORM_u_${Z}
    ${F} ${N} ${Z} = a_${Z};
#else
    ${F} ${N} ${Z} = u_${Z};
#endif
` : `
#ifndef HAS_UNIFORM_u_${Z}
    ${F} ${N} ${Z} = unpack_mix_${V}(a_${Z}, u_${Z}_t);
#else
    ${F} ${N} ${Z} = u_${Z};
#endif
`;
        }), staticAttributes: o, staticUniforms: x };
      }
      class eo {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(e, r, o, h, p, x, A, T, P) {
          this.context = e;
          let F = this.boundPaintVertexBuffers.length !== h.length;
          for (let N = 0; !F && N < h.length; N++) this.boundPaintVertexBuffers[N] !== h[N] && (F = !0);
          !this.vao || this.boundProgram !== r || this.boundLayoutVertexBuffer !== o || F || this.boundIndexBuffer !== p || this.boundVertexOffset !== x || this.boundDynamicVertexBuffer !== A || this.boundDynamicVertexBuffer2 !== T || this.boundDynamicVertexBuffer3 !== P ? this.freshBind(r, o, h, p, x, A, T, P) : (e.bindVertexArray.set(this.vao), A && A.bind(), p && p.dynamicDraw && p.bind(), T && T.bind(), P && P.bind());
        }
        freshBind(e, r, o, h, p, x, A, T) {
          const P = e.numAttributes, F = this.context, N = F.gl;
          this.vao && this.destroy(), this.vao = F.createVertexArray(), F.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = r, this.boundPaintVertexBuffers = o, this.boundIndexBuffer = h, this.boundVertexOffset = p, this.boundDynamicVertexBuffer = x, this.boundDynamicVertexBuffer2 = A, this.boundDynamicVertexBuffer3 = T, r.enableAttributes(N, e);
          for (const Z of o) Z.enableAttributes(N, e);
          x && x.enableAttributes(N, e), A && A.enableAttributes(N, e), T && T.enableAttributes(N, e), r.bind(), r.setVertexAttribPointers(N, e, p);
          for (const Z of o) Z.bind(), Z.setVertexAttribPointers(N, e, p);
          x && (x.bind(), x.setVertexAttribPointers(N, e, p)), h && h.bind(), A && (A.bind(), A.setVertexAttribPointers(N, e, p)), T && (T.bind(), T.setVertexAttribPointers(N, e, p)), F.currentNumAttributes = P;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const Wo = (c, e, r, o, h) => ({ u_matrix: c, u_texture: 0, u_ele_delta: e, u_fog_matrix: r, u_fog_color: o ? o.properties.get("fog-color") : s.aM.white, u_fog_ground_blend: o ? o.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: o ? o.calculateFogBlendOpacity(h) : 0, u_horizon_color: o ? o.properties.get("horizon-color") : s.aM.white, u_horizon_fog_blend: o ? o.properties.get("horizon-fog-blend") : 1 });
      function ja(c) {
        const e = [];
        for (let r = 0; r < c.length; r++) {
          if (c[r] === null) continue;
          const o = c[r].split(" ");
          e.push(o.pop());
        }
        return e;
      }
      class Xo {
        constructor(e, r, o, h, p, x) {
          const A = e.gl;
          this.program = A.createProgram();
          const T = ja(r.staticAttributes), P = o ? o.getBinderAttributes() : [], F = T.concat(P), N = aa.prelude.staticUniforms ? ja(aa.prelude.staticUniforms) : [], Z = r.staticUniforms ? ja(r.staticUniforms) : [], G = o ? o.getBinderUniforms() : [], V = N.concat(Z).concat(G), W = [];
          for (const ke of V) W.indexOf(ke) < 0 && W.push(ke);
          const ae = o ? o.defines() : [];
          p && ae.push("#define OVERDRAW_INSPECTOR;"), x && ae.push("#define TERRAIN3D;");
          const oe = ae.concat(aa.prelude.fragmentSource, r.fragmentSource).join(`
`), de = ae.concat(aa.prelude.vertexSource, r.vertexSource).join(`
`), ce = A.createShader(A.FRAGMENT_SHADER);
          if (A.isContextLost()) return void (this.failedToCreate = !0);
          if (A.shaderSource(ce, oe), A.compileShader(ce), !A.getShaderParameter(ce, A.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${A.getShaderInfoLog(ce)}`);
          A.attachShader(this.program, ce);
          const we = A.createShader(A.VERTEX_SHADER);
          if (A.isContextLost()) return void (this.failedToCreate = !0);
          if (A.shaderSource(we, de), A.compileShader(we), !A.getShaderParameter(we, A.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${A.getShaderInfoLog(we)}`);
          A.attachShader(this.program, we), this.attributes = {};
          const Le = {};
          this.numAttributes = F.length;
          for (let ke = 0; ke < this.numAttributes; ke++) F[ke] && (A.bindAttribLocation(this.program, ke, F[ke]), this.attributes[F[ke]] = ke);
          if (A.linkProgram(this.program), !A.getProgramParameter(this.program, A.LINK_STATUS)) throw new Error(`Program failed to link: ${A.getProgramInfoLog(this.program)}`);
          A.deleteShader(we), A.deleteShader(ce);
          for (let ke = 0; ke < W.length; ke++) {
            const tt = W[ke];
            if (tt && !Le[tt]) {
              const ht = A.getUniformLocation(this.program, tt);
              ht && (Le[tt] = ht);
            }
          }
          this.fixedUniforms = h(e, Le), this.terrainUniforms = ((ke, tt) => ({ u_depth: new s.aH(ke, tt.u_depth), u_terrain: new s.aH(ke, tt.u_terrain), u_terrain_dim: new s.aI(ke, tt.u_terrain_dim), u_terrain_matrix: new s.aJ(ke, tt.u_terrain_matrix), u_terrain_unpack: new s.aK(ke, tt.u_terrain_unpack), u_terrain_exaggeration: new s.aI(ke, tt.u_terrain_exaggeration) }))(e, Le), this.binderUniforms = o ? o.getUniforms(e, Le) : [];
        }
        draw(e, r, o, h, p, x, A, T, P, F, N, Z, G, V, W, ae, oe, de) {
          const ce = e.gl;
          if (this.failedToCreate) return;
          if (e.program.set(this.program), e.setDepthMode(o), e.setStencilMode(h), e.setColorMode(p), e.setCullFace(x), T) {
            e.activeTexture.set(ce.TEXTURE2), ce.bindTexture(ce.TEXTURE_2D, T.depthTexture), e.activeTexture.set(ce.TEXTURE3), ce.bindTexture(ce.TEXTURE_2D, T.texture);
            for (const Le in this.terrainUniforms) this.terrainUniforms[Le].set(T[Le]);
          }
          for (const Le in this.fixedUniforms) this.fixedUniforms[Le].set(A[Le]);
          W && W.setUniforms(e, this.binderUniforms, G, { zoom: V });
          let we = 0;
          switch (r) {
            case ce.LINES:
              we = 2;
              break;
            case ce.TRIANGLES:
              we = 3;
              break;
            case ce.LINE_STRIP:
              we = 1;
          }
          for (const Le of Z.get()) {
            const ke = Le.vaos || (Le.vaos = {});
            (ke[P] || (ke[P] = new eo())).bind(e, this, F, W ? W.getPaintVertexBuffers() : [], N, Le.vertexOffset, ae, oe, de), ce.drawElements(r, Le.primitiveLength * we, ce.UNSIGNED_SHORT, Le.primitiveOffset * we * 2);
          }
        }
      }
      function ls(c, e, r) {
        const o = 1 / fi(r, 1, e.transform.tileZoom), h = Math.pow(2, r.tileID.overscaledZ), p = r.tileSize * Math.pow(2, e.transform.tileZoom) / h, x = p * (r.tileID.canonical.x + r.tileID.wrap * h), A = p * r.tileID.canonical.y;
        return { u_image: 0, u_texsize: r.imageAtlasTexture.size, u_scale: [o, c.fromScale, c.toScale], u_fade: c.t, u_pixel_coord_upper: [x >> 16, A >> 16], u_pixel_coord_lower: [65535 & x, 65535 & A] };
      }
      const Ps = (c, e, r, o) => {
        const h = e.style.light, p = h.properties.get("position"), x = [p.x, p.y, p.z], A = function() {
          var P = new s.A(9);
          return s.A != Float32Array && (P[1] = 0, P[2] = 0, P[3] = 0, P[5] = 0, P[6] = 0, P[7] = 0), P[0] = 1, P[4] = 1, P[8] = 1, P;
        }();
        h.properties.get("anchor") === "viewport" && function(P, F) {
          var N = Math.sin(F), Z = Math.cos(F);
          P[0] = Z, P[1] = N, P[2] = 0, P[3] = -N, P[4] = Z, P[5] = 0, P[6] = 0, P[7] = 0, P[8] = 1;
        }(A, -e.transform.angle), function(P, F, N) {
          var Z = F[0], G = F[1], V = F[2];
          P[0] = Z * N[0] + G * N[3] + V * N[6], P[1] = Z * N[1] + G * N[4] + V * N[7], P[2] = Z * N[2] + G * N[5] + V * N[8];
        }(x, x, A);
        const T = h.properties.get("color");
        return { u_matrix: c, u_lightpos: x, u_lightintensity: h.properties.get("intensity"), u_lightcolor: [T.r, T.g, T.b], u_vertical_gradient: +r, u_opacity: o };
      }, to = (c, e, r, o, h, p, x) => s.e(Ps(c, e, r, o), ls(p, e, x), { u_height_factor: -Math.pow(2, h.overscaledZ) / x.tileSize / 8 }), us = (c) => ({ u_matrix: c }), xa = (c, e, r, o) => s.e(us(c), ls(r, e, o)), io = (c, e) => ({ u_matrix: c, u_world: e }), Ls = (c, e, r, o, h) => s.e(xa(c, e, r, o), { u_world: h }), El = (c, e, r, o) => {
        const h = c.transform;
        let p, x;
        if (o.paint.get("circle-pitch-alignment") === "map") {
          const A = fi(r, 1, h.zoom);
          p = !0, x = [A, A];
        } else p = !1, x = h.pixelsToGLUnits;
        return { u_camera_to_center_distance: h.cameraToCenterDistance, u_scale_with_map: +(o.paint.get("circle-pitch-scale") === "map"), u_matrix: c.translatePosMatrix(e.posMatrix, r, o.paint.get("circle-translate"), o.paint.get("circle-translate-anchor")), u_pitch_with_map: +p, u_device_pixel_ratio: c.pixelRatio, u_extrude_scale: x };
      }, xr = (c, e, r) => ({ u_matrix: c, u_inv_matrix: e, u_camera_to_center_distance: r.cameraToCenterDistance, u_viewport_size: [r.width, r.height] }), Ms = (c, e, r = 1) => ({ u_matrix: c, u_color: e, u_overlay: 0, u_overlay_scale: r }), jr = (c) => ({ u_matrix: c }), si = (c, e, r, o) => ({ u_matrix: c, u_extrude_scale: fi(e, 1, r), u_intensity: o }), ro = (c, e, r, o) => {
        const h = s.H();
        s.aP(h, 0, c.width, c.height, 0, 0, 1);
        const p = c.context.gl;
        return { u_matrix: h, u_world: [p.drawingBufferWidth, p.drawingBufferHeight], u_image: r, u_color_ramp: o, u_opacity: e.paint.get("heatmap-opacity") };
      };
      function no(c, e) {
        const r = Math.pow(2, e.canonical.z), o = e.canonical.y;
        return [new s.Z(0, o / r).toLngLat().lat, new s.Z(0, (o + 1) / r).toLngLat().lat];
      }
      const Tn = (c, e, r, o) => {
        const h = c.transform;
        return { u_matrix: Tl(c, e, r, o), u_ratio: 1 / fi(e, 1, h.zoom), u_device_pixel_ratio: c.pixelRatio, u_units_to_pixels: [1 / h.pixelsToGLUnits[0], 1 / h.pixelsToGLUnits[1]] };
      }, Yo = (c, e, r, o, h) => s.e(Tn(c, e, r, h), { u_image: 0, u_image_height: o }), qa = (c, e, r, o, h) => {
        const p = c.transform, x = so(e, p);
        return { u_matrix: Tl(c, e, r, h), u_texsize: e.imageAtlasTexture.size, u_ratio: 1 / fi(e, 1, p.zoom), u_device_pixel_ratio: c.pixelRatio, u_image: 0, u_scale: [x, o.fromScale, o.toScale], u_fade: o.t, u_units_to_pixels: [1 / p.pixelsToGLUnits[0], 1 / p.pixelsToGLUnits[1]] };
      }, ao = (c, e, r, o, h, p) => {
        const x = c.lineAtlas, A = so(e, c.transform), T = r.layout.get("line-cap") === "round", P = x.getDash(o.from, T), F = x.getDash(o.to, T), N = P.width * h.fromScale, Z = F.width * h.toScale;
        return s.e(Tn(c, e, r, p), { u_patternscale_a: [A / N, -P.height / 2], u_patternscale_b: [A / Z, -F.height / 2], u_sdfgamma: x.width / (256 * Math.min(N, Z) * c.pixelRatio) / 2, u_image: 0, u_tex_y_a: P.y, u_tex_y_b: F.y, u_mix: h.t });
      };
      function so(c, e) {
        return 1 / fi(c, 1, e.tileZoom);
      }
      function Tl(c, e, r, o) {
        return c.translatePosMatrix(o ? o.posMatrix : e.tileID.posMatrix, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
      }
      const tu = (c, e, r, o, h) => {
        return { u_matrix: c, u_tl_parent: e, u_scale_parent: r, u_buffer_scale: 1, u_fade_t: o.mix, u_opacity: o.opacity * h.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: h.paint.get("raster-brightness-min"), u_brightness_high: h.paint.get("raster-brightness-max"), u_saturation_factor: (x = h.paint.get("raster-saturation"), x > 0 ? 1 - 1 / (1.001 - x) : -x), u_contrast_factor: (p = h.paint.get("raster-contrast"), p > 0 ? 1 / (1 - p) : 1 + p), u_spin_weights: iu(h.paint.get("raster-hue-rotate")) };
        var p, x;
      };
      function iu(c) {
        c *= Math.PI / 180;
        const e = Math.sin(c), r = Math.cos(c);
        return [(2 * r + 1) / 3, (-Math.sqrt(3) * e - r + 1) / 3, (Math.sqrt(3) * e - r + 1) / 3];
      }
      const oo = (c, e, r, o, h, p, x, A, T, P, F, N, Z, G) => {
        const V = x.transform;
        return { u_is_size_zoom_constant: +(c === "constant" || c === "source"), u_is_size_feature_constant: +(c === "constant" || c === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: V.cameraToCenterDistance, u_pitch: V.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +r, u_aspect_ratio: V.width / V.height, u_fade_change: x.options.fadeDuration ? x.symbolFadeChange : 1, u_matrix: A, u_label_plane_matrix: T, u_coord_matrix: P, u_is_text: +N, u_pitch_with_map: +o, u_is_along_line: h, u_is_variable_anchor: p, u_texsize: Z, u_texture: 0, u_translation: F, u_pitched_scale: G };
      }, sa = (c, e, r, o, h, p, x, A, T, P, F, N, Z, G, V) => {
        const W = x.transform;
        return s.e(oo(c, e, r, o, h, p, x, A, T, P, F, N, Z, V), { u_gamma_scale: o ? Math.cos(W._pitch) * W.cameraToCenterDistance : 1, u_device_pixel_ratio: x.pixelRatio, u_is_halo: +G });
      }, wa = (c, e, r, o, h, p, x, A, T, P, F, N, Z, G) => s.e(sa(c, e, r, o, h, p, x, A, T, P, F, !0, N, !0, G), { u_texsize_icon: Z, u_texture_icon: 1 }), lo = (c, e, r) => ({ u_matrix: c, u_opacity: e, u_color: r }), Ua = (c, e, r, o, h, p) => s.e(function(x, A, T, P) {
        const F = T.imageManager.getPattern(x.from.toString()), N = T.imageManager.getPattern(x.to.toString()), { width: Z, height: G } = T.imageManager.getPixelSize(), V = Math.pow(2, P.tileID.overscaledZ), W = P.tileSize * Math.pow(2, T.transform.tileZoom) / V, ae = W * (P.tileID.canonical.x + P.tileID.wrap * V), oe = W * P.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: F.tl, u_pattern_br_a: F.br, u_pattern_tl_b: N.tl, u_pattern_br_b: N.br, u_texsize: [Z, G], u_mix: A.t, u_pattern_size_a: F.displaySize, u_pattern_size_b: N.displaySize, u_scale_a: A.fromScale, u_scale_b: A.toScale, u_tile_units_to_pixels: 1 / fi(P, 1, T.transform.tileZoom), u_pixel_coord_upper: [ae >> 16, oe >> 16], u_pixel_coord_lower: [65535 & ae, 65535 & oe] };
      }(o, p, r, h), { u_matrix: c, u_opacity: e }), Ns = { fillExtrusion: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_lightpos: new s.aN(c, e.u_lightpos), u_lightintensity: new s.aI(c, e.u_lightintensity), u_lightcolor: new s.aN(c, e.u_lightcolor), u_vertical_gradient: new s.aI(c, e.u_vertical_gradient), u_opacity: new s.aI(c, e.u_opacity) }), fillExtrusionPattern: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_lightpos: new s.aN(c, e.u_lightpos), u_lightintensity: new s.aI(c, e.u_lightintensity), u_lightcolor: new s.aN(c, e.u_lightcolor), u_vertical_gradient: new s.aI(c, e.u_vertical_gradient), u_height_factor: new s.aI(c, e.u_height_factor), u_image: new s.aH(c, e.u_image), u_texsize: new s.aO(c, e.u_texsize), u_pixel_coord_upper: new s.aO(c, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.aO(c, e.u_pixel_coord_lower), u_scale: new s.aN(c, e.u_scale), u_fade: new s.aI(c, e.u_fade), u_opacity: new s.aI(c, e.u_opacity) }), fill: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix) }), fillPattern: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_image: new s.aH(c, e.u_image), u_texsize: new s.aO(c, e.u_texsize), u_pixel_coord_upper: new s.aO(c, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.aO(c, e.u_pixel_coord_lower), u_scale: new s.aN(c, e.u_scale), u_fade: new s.aI(c, e.u_fade) }), fillOutline: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_world: new s.aO(c, e.u_world) }), fillOutlinePattern: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_world: new s.aO(c, e.u_world), u_image: new s.aH(c, e.u_image), u_texsize: new s.aO(c, e.u_texsize), u_pixel_coord_upper: new s.aO(c, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.aO(c, e.u_pixel_coord_lower), u_scale: new s.aN(c, e.u_scale), u_fade: new s.aI(c, e.u_fade) }), circle: (c, e) => ({ u_camera_to_center_distance: new s.aI(c, e.u_camera_to_center_distance), u_scale_with_map: new s.aH(c, e.u_scale_with_map), u_pitch_with_map: new s.aH(c, e.u_pitch_with_map), u_extrude_scale: new s.aO(c, e.u_extrude_scale), u_device_pixel_ratio: new s.aI(c, e.u_device_pixel_ratio), u_matrix: new s.aJ(c, e.u_matrix) }), collisionBox: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_pixel_extrude_scale: new s.aO(c, e.u_pixel_extrude_scale) }), collisionCircle: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_inv_matrix: new s.aJ(c, e.u_inv_matrix), u_camera_to_center_distance: new s.aI(c, e.u_camera_to_center_distance), u_viewport_size: new s.aO(c, e.u_viewport_size) }), debug: (c, e) => ({ u_color: new s.aL(c, e.u_color), u_matrix: new s.aJ(c, e.u_matrix), u_overlay: new s.aH(c, e.u_overlay), u_overlay_scale: new s.aI(c, e.u_overlay_scale) }), clippingMask: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix) }), heatmap: (c, e) => ({ u_extrude_scale: new s.aI(c, e.u_extrude_scale), u_intensity: new s.aI(c, e.u_intensity), u_matrix: new s.aJ(c, e.u_matrix) }), heatmapTexture: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_world: new s.aO(c, e.u_world), u_image: new s.aH(c, e.u_image), u_color_ramp: new s.aH(c, e.u_color_ramp), u_opacity: new s.aI(c, e.u_opacity) }), hillshade: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_image: new s.aH(c, e.u_image), u_latrange: new s.aO(c, e.u_latrange), u_light: new s.aO(c, e.u_light), u_shadow: new s.aL(c, e.u_shadow), u_highlight: new s.aL(c, e.u_highlight), u_accent: new s.aL(c, e.u_accent) }), hillshadePrepare: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_image: new s.aH(c, e.u_image), u_dimension: new s.aO(c, e.u_dimension), u_zoom: new s.aI(c, e.u_zoom), u_unpack: new s.aK(c, e.u_unpack) }), line: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_ratio: new s.aI(c, e.u_ratio), u_device_pixel_ratio: new s.aI(c, e.u_device_pixel_ratio), u_units_to_pixels: new s.aO(c, e.u_units_to_pixels) }), lineGradient: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_ratio: new s.aI(c, e.u_ratio), u_device_pixel_ratio: new s.aI(c, e.u_device_pixel_ratio), u_units_to_pixels: new s.aO(c, e.u_units_to_pixels), u_image: new s.aH(c, e.u_image), u_image_height: new s.aI(c, e.u_image_height) }), linePattern: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_texsize: new s.aO(c, e.u_texsize), u_ratio: new s.aI(c, e.u_ratio), u_device_pixel_ratio: new s.aI(c, e.u_device_pixel_ratio), u_image: new s.aH(c, e.u_image), u_units_to_pixels: new s.aO(c, e.u_units_to_pixels), u_scale: new s.aN(c, e.u_scale), u_fade: new s.aI(c, e.u_fade) }), lineSDF: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_ratio: new s.aI(c, e.u_ratio), u_device_pixel_ratio: new s.aI(c, e.u_device_pixel_ratio), u_units_to_pixels: new s.aO(c, e.u_units_to_pixels), u_patternscale_a: new s.aO(c, e.u_patternscale_a), u_patternscale_b: new s.aO(c, e.u_patternscale_b), u_sdfgamma: new s.aI(c, e.u_sdfgamma), u_image: new s.aH(c, e.u_image), u_tex_y_a: new s.aI(c, e.u_tex_y_a), u_tex_y_b: new s.aI(c, e.u_tex_y_b), u_mix: new s.aI(c, e.u_mix) }), raster: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_tl_parent: new s.aO(c, e.u_tl_parent), u_scale_parent: new s.aI(c, e.u_scale_parent), u_buffer_scale: new s.aI(c, e.u_buffer_scale), u_fade_t: new s.aI(c, e.u_fade_t), u_opacity: new s.aI(c, e.u_opacity), u_image0: new s.aH(c, e.u_image0), u_image1: new s.aH(c, e.u_image1), u_brightness_low: new s.aI(c, e.u_brightness_low), u_brightness_high: new s.aI(c, e.u_brightness_high), u_saturation_factor: new s.aI(c, e.u_saturation_factor), u_contrast_factor: new s.aI(c, e.u_contrast_factor), u_spin_weights: new s.aN(c, e.u_spin_weights) }), symbolIcon: (c, e) => ({ u_is_size_zoom_constant: new s.aH(c, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.aH(c, e.u_is_size_feature_constant), u_size_t: new s.aI(c, e.u_size_t), u_size: new s.aI(c, e.u_size), u_camera_to_center_distance: new s.aI(c, e.u_camera_to_center_distance), u_pitch: new s.aI(c, e.u_pitch), u_rotate_symbol: new s.aH(c, e.u_rotate_symbol), u_aspect_ratio: new s.aI(c, e.u_aspect_ratio), u_fade_change: new s.aI(c, e.u_fade_change), u_matrix: new s.aJ(c, e.u_matrix), u_label_plane_matrix: new s.aJ(c, e.u_label_plane_matrix), u_coord_matrix: new s.aJ(c, e.u_coord_matrix), u_is_text: new s.aH(c, e.u_is_text), u_pitch_with_map: new s.aH(c, e.u_pitch_with_map), u_is_along_line: new s.aH(c, e.u_is_along_line), u_is_variable_anchor: new s.aH(c, e.u_is_variable_anchor), u_texsize: new s.aO(c, e.u_texsize), u_texture: new s.aH(c, e.u_texture), u_translation: new s.aO(c, e.u_translation), u_pitched_scale: new s.aI(c, e.u_pitched_scale) }), symbolSDF: (c, e) => ({ u_is_size_zoom_constant: new s.aH(c, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.aH(c, e.u_is_size_feature_constant), u_size_t: new s.aI(c, e.u_size_t), u_size: new s.aI(c, e.u_size), u_camera_to_center_distance: new s.aI(c, e.u_camera_to_center_distance), u_pitch: new s.aI(c, e.u_pitch), u_rotate_symbol: new s.aH(c, e.u_rotate_symbol), u_aspect_ratio: new s.aI(c, e.u_aspect_ratio), u_fade_change: new s.aI(c, e.u_fade_change), u_matrix: new s.aJ(c, e.u_matrix), u_label_plane_matrix: new s.aJ(c, e.u_label_plane_matrix), u_coord_matrix: new s.aJ(c, e.u_coord_matrix), u_is_text: new s.aH(c, e.u_is_text), u_pitch_with_map: new s.aH(c, e.u_pitch_with_map), u_is_along_line: new s.aH(c, e.u_is_along_line), u_is_variable_anchor: new s.aH(c, e.u_is_variable_anchor), u_texsize: new s.aO(c, e.u_texsize), u_texture: new s.aH(c, e.u_texture), u_gamma_scale: new s.aI(c, e.u_gamma_scale), u_device_pixel_ratio: new s.aI(c, e.u_device_pixel_ratio), u_is_halo: new s.aH(c, e.u_is_halo), u_translation: new s.aO(c, e.u_translation), u_pitched_scale: new s.aI(c, e.u_pitched_scale) }), symbolTextAndIcon: (c, e) => ({ u_is_size_zoom_constant: new s.aH(c, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.aH(c, e.u_is_size_feature_constant), u_size_t: new s.aI(c, e.u_size_t), u_size: new s.aI(c, e.u_size), u_camera_to_center_distance: new s.aI(c, e.u_camera_to_center_distance), u_pitch: new s.aI(c, e.u_pitch), u_rotate_symbol: new s.aH(c, e.u_rotate_symbol), u_aspect_ratio: new s.aI(c, e.u_aspect_ratio), u_fade_change: new s.aI(c, e.u_fade_change), u_matrix: new s.aJ(c, e.u_matrix), u_label_plane_matrix: new s.aJ(c, e.u_label_plane_matrix), u_coord_matrix: new s.aJ(c, e.u_coord_matrix), u_is_text: new s.aH(c, e.u_is_text), u_pitch_with_map: new s.aH(c, e.u_pitch_with_map), u_is_along_line: new s.aH(c, e.u_is_along_line), u_is_variable_anchor: new s.aH(c, e.u_is_variable_anchor), u_texsize: new s.aO(c, e.u_texsize), u_texsize_icon: new s.aO(c, e.u_texsize_icon), u_texture: new s.aH(c, e.u_texture), u_texture_icon: new s.aH(c, e.u_texture_icon), u_gamma_scale: new s.aI(c, e.u_gamma_scale), u_device_pixel_ratio: new s.aI(c, e.u_device_pixel_ratio), u_is_halo: new s.aH(c, e.u_is_halo), u_translation: new s.aO(c, e.u_translation), u_pitched_scale: new s.aI(c, e.u_pitched_scale) }), background: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_opacity: new s.aI(c, e.u_opacity), u_color: new s.aL(c, e.u_color) }), backgroundPattern: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_opacity: new s.aI(c, e.u_opacity), u_image: new s.aH(c, e.u_image), u_pattern_tl_a: new s.aO(c, e.u_pattern_tl_a), u_pattern_br_a: new s.aO(c, e.u_pattern_br_a), u_pattern_tl_b: new s.aO(c, e.u_pattern_tl_b), u_pattern_br_b: new s.aO(c, e.u_pattern_br_b), u_texsize: new s.aO(c, e.u_texsize), u_mix: new s.aI(c, e.u_mix), u_pattern_size_a: new s.aO(c, e.u_pattern_size_a), u_pattern_size_b: new s.aO(c, e.u_pattern_size_b), u_scale_a: new s.aI(c, e.u_scale_a), u_scale_b: new s.aI(c, e.u_scale_b), u_pixel_coord_upper: new s.aO(c, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.aO(c, e.u_pixel_coord_lower), u_tile_units_to_pixels: new s.aI(c, e.u_tile_units_to_pixels) }), terrain: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_texture: new s.aH(c, e.u_texture), u_ele_delta: new s.aI(c, e.u_ele_delta), u_fog_matrix: new s.aJ(c, e.u_fog_matrix), u_fog_color: new s.aL(c, e.u_fog_color), u_fog_ground_blend: new s.aI(c, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new s.aI(c, e.u_fog_ground_blend_opacity), u_horizon_color: new s.aL(c, e.u_horizon_color), u_horizon_fog_blend: new s.aI(c, e.u_horizon_fog_blend) }), terrainDepth: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_ele_delta: new s.aI(c, e.u_ele_delta) }), terrainCoords: (c, e) => ({ u_matrix: new s.aJ(c, e.u_matrix), u_texture: new s.aH(c, e.u_texture), u_terrain_coords_id: new s.aI(c, e.u_terrain_coords_id), u_ele_delta: new s.aI(c, e.u_ele_delta) }), sky: (c, e) => ({ u_sky_color: new s.aL(c, e.u_sky_color), u_horizon_color: new s.aL(c, e.u_horizon_color), u_horizon: new s.aI(c, e.u_horizon), u_sky_horizon_blend: new s.aI(c, e.u_sky_horizon_blend) }) };
      class ln {
        constructor(e, r, o) {
          this.context = e;
          const h = e.gl;
          this.buffer = h.createBuffer(), this.dynamicDraw = !!o, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), h.bufferData(h.ELEMENT_ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? h.DYNAMIC_DRAW : h.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e) {
          const r = this.context.gl;
          if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), r.bufferSubData(r.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Cl = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class uo {
        constructor(e, r, o, h) {
          this.length = r.length, this.attributes = o, this.itemSize = r.bytesPerElement, this.dynamicDraw = h, this.context = e;
          const p = e.gl;
          this.buffer = p.createBuffer(), e.bindVertexBuffer.set(this.buffer), p.bufferData(p.ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? p.DYNAMIC_DRAW : p.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e) {
          if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
          const r = this.context.gl;
          this.bind(), r.bufferSubData(r.ARRAY_BUFFER, 0, e.arrayBuffer);
        }
        enableAttributes(e, r) {
          for (let o = 0; o < this.attributes.length; o++) {
            const h = r.attributes[this.attributes[o].name];
            h !== void 0 && e.enableVertexAttribArray(h);
          }
        }
        setVertexAttribPointers(e, r, o) {
          for (let h = 0; h < this.attributes.length; h++) {
            const p = this.attributes[h], x = r.attributes[p.name];
            x !== void 0 && e.vertexAttribPointer(x, p.components, e[Cl[p.type]], !1, this.itemSize, p.offset + this.itemSize * (o || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Aa = /* @__PURE__ */ new WeakMap();
      function oa(c) {
        var e;
        if (Aa.has(c)) return Aa.get(c);
        {
          const r = (e = c.getParameter(c.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
          return Aa.set(c, r), r;
        }
      }
      class Ii {
        constructor(e) {
          this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(e) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class la extends Ii {
        getDefault() {
          return s.aM.transparent;
        }
        set(e) {
          const r = this.current;
          (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
        }
      }
      class ru extends Ii {
        getDefault() {
          return 1;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
        }
      }
      class Cn extends Ii {
        getDefault() {
          return 0;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
        }
      }
      class ua extends Ii {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
        }
      }
      class co extends Ii {
        getDefault() {
          return !0;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
        }
      }
      class zs extends Ii {
        getDefault() {
          return 255;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
        }
      }
      class Dl extends Ii {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e) {
          const r = this.current;
          (e.func !== r.func || e.ref !== r.ref || e.mask !== r.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
        }
      }
      class cs extends Ii {
        getDefault() {
          const e = this.gl;
          return [e.KEEP, e.KEEP, e.KEEP];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
        }
      }
      class Il extends Ii {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.STENCIL_TEST) : r.disable(r.STENCIL_TEST), this.current = e, this.dirty = !1;
        }
      }
      class ho extends Ii {
        getDefault() {
          return [0, 1];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
        }
      }
      class po extends Ii {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.DEPTH_TEST) : r.disable(r.DEPTH_TEST), this.current = e, this.dirty = !1;
        }
      }
      class Jo extends Ii {
        getDefault() {
          return this.gl.LESS;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
        }
      }
      class On extends Ii {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.BLEND) : r.disable(r.BLEND), this.current = e, this.dirty = !1;
        }
      }
      class fo extends Ii {
        getDefault() {
          const e = this.gl;
          return [e.ONE, e.ZERO];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
        }
      }
      class Ko extends Ii {
        getDefault() {
          return s.aM.transparent;
        }
        set(e) {
          const r = this.current;
          (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
        }
      }
      class Qo extends Ii {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
        }
      }
      class Fs extends Ii {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.CULL_FACE) : r.disable(r.CULL_FACE), this.current = e, this.dirty = !1;
        }
      }
      class mo extends Ii {
        getDefault() {
          return this.gl.BACK;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
        }
      }
      class Sa extends Ii {
        getDefault() {
          return this.gl.CCW;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
        }
      }
      class el extends Ii {
        getDefault() {
          return null;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
        }
      }
      class hs extends Ii {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
        }
      }
      class go extends Ii {
        getDefault() {
          const e = this.gl;
          return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
        }
      }
      class I extends Ii {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindFramebuffer(r.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class K extends Ii {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindRenderbuffer(r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class Ee extends Ii {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindTexture(r.TEXTURE_2D, e), this.current = e, this.dirty = !1;
        }
      }
      class Re extends Ii {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindBuffer(r.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class Ye extends Ii {
        getDefault() {
          return null;
        }
        set(e) {
          const r = this.gl;
          r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class ct extends Ii {
        getDefault() {
          return null;
        }
        set(e) {
          var r;
          if (e === this.current && !this.dirty) return;
          const o = this.gl;
          oa(o) ? o.bindVertexArray(e) : (r = o.getExtension("OES_vertex_array_object")) === null || r === void 0 || r.bindVertexArrayOES(e), this.current = e, this.dirty = !1;
        }
      }
      class It extends Ii {
        getDefault() {
          return 4;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
        }
      }
      class Ut extends Ii {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
        }
      }
      class ui extends Ii {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
        }
      }
      class bi extends Ii {
        constructor(e, r) {
          super(e), this.context = e, this.parent = r;
        }
        getDefault() {
          return null;
        }
      }
      class Ti extends bi {
        setDirty() {
          this.dirty = !0;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
        }
      }
      class ki extends bi {
        set(e) {
          if (e === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class nr extends bi {
        set(e) {
          if (e === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class Sr {
        constructor(e, r, o, h, p) {
          this.context = e, this.width = r, this.height = o;
          const x = e.gl, A = this.framebuffer = x.createFramebuffer();
          if (this.colorAttachment = new Ti(e, A), h) this.depthAttachment = p ? new nr(e, A) : new ki(e, A);
          else if (p) throw new Error("Stencil cannot be set without depth");
          if (x.checkFramebufferStatus(x.FRAMEBUFFER) !== x.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const e = this.context.gl, r = this.colorAttachment.get();
          if (r && e.deleteTexture(r), this.depthAttachment) {
            const o = this.depthAttachment.get();
            o && e.deleteRenderbuffer(o);
          }
          e.deleteFramebuffer(this.framebuffer);
        }
      }
      class Ci {
        constructor(e, r, o) {
          this.blendFunction = e, this.blendColor = r, this.mask = o;
        }
      }
      Ci.Replace = [1, 0], Ci.disabled = new Ci(Ci.Replace, s.aM.transparent, [!1, !1, !1, !1]), Ci.unblended = new Ci(Ci.Replace, s.aM.transparent, [!0, !0, !0, !0]), Ci.alphaBlended = new Ci([1, 771], s.aM.transparent, [!0, !0, !0, !0]);
      class Xr {
        constructor(e) {
          var r, o;
          if (this.gl = e, this.clearColor = new la(this), this.clearDepth = new ru(this), this.clearStencil = new Cn(this), this.colorMask = new ua(this), this.depthMask = new co(this), this.stencilMask = new zs(this), this.stencilFunc = new Dl(this), this.stencilOp = new cs(this), this.stencilTest = new Il(this), this.depthRange = new ho(this), this.depthTest = new po(this), this.depthFunc = new Jo(this), this.blend = new On(this), this.blendFunc = new fo(this), this.blendColor = new Ko(this), this.blendEquation = new Qo(this), this.cullFace = new Fs(this), this.cullFaceSide = new mo(this), this.frontFace = new Sa(this), this.program = new el(this), this.activeTexture = new hs(this), this.viewport = new go(this), this.bindFramebuffer = new I(this), this.bindRenderbuffer = new K(this), this.bindTexture = new Ee(this), this.bindVertexBuffer = new Re(this), this.bindElementBuffer = new Ye(this), this.bindVertexArray = new ct(this), this.pixelStoreUnpack = new It(this), this.pixelStoreUnpackPremultiplyAlpha = new Ut(this), this.pixelStoreUnpackFlipY = new ui(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), oa(e)) {
            this.HALF_FLOAT = e.HALF_FLOAT;
            const h = e.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (r = e.RGBA16F) !== null && r !== void 0 ? r : h == null ? void 0 : h.RGBA16F_EXT, this.RGB16F = (o = e.RGB16F) !== null && o !== void 0 ? o : h == null ? void 0 : h.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
          } else {
            e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
            const h = e.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = h == null ? void 0 : h.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(e, r) {
          return new ln(this, e, r);
        }
        createVertexBuffer(e, r, o) {
          return new uo(this, e, r, o);
        }
        createRenderbuffer(e, r, o) {
          const h = this.gl, p = h.createRenderbuffer();
          return this.bindRenderbuffer.set(p), h.renderbufferStorage(h.RENDERBUFFER, e, r, o), this.bindRenderbuffer.set(null), p;
        }
        createFramebuffer(e, r, o, h) {
          return new Sr(this, e, r, o, h);
        }
        clear({ color: e, depth: r, stencil: o }) {
          const h = this.gl;
          let p = 0;
          e && (p |= h.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), r !== void 0 && (p |= h.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(r), this.depthMask.set(!0)), o !== void 0 && (p |= h.STENCIL_BUFFER_BIT, this.clearStencil.set(o), this.stencilMask.set(255)), h.clear(p);
        }
        setCullFace(e) {
          e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
        }
        setDepthMode(e) {
          e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
        }
        setStencilMode(e) {
          e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(e) {
          s.aE(e.blendFunction, Ci.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
        }
        createVertexArray() {
          var e;
          return oa(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
        }
        deleteVertexArray(e) {
          var r;
          return oa(this.gl) ? this.gl.deleteVertexArray(e) : (r = this.gl.getExtension("OES_vertex_array_object")) === null || r === void 0 ? void 0 : r.deleteVertexArrayOES(e);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      class oi {
        constructor(e, r, o) {
          this.func = e, this.mask = r, this.range = o;
        }
      }
      oi.ReadOnly = !1, oi.ReadWrite = !0, oi.disabled = new oi(519, oi.ReadOnly, [0, 1]);
      const _n = 7680;
      class Mi {
        constructor(e, r, o, h, p, x) {
          this.test = e, this.ref = r, this.mask = o, this.fail = h, this.depthFail = p, this.pass = x;
        }
      }
      Mi.disabled = new Mi({ func: 519, mask: 0 }, 0, 0, _n, _n, _n);
      class zi {
        constructor(e, r, o) {
          this.enable = e, this.mode = r, this.frontFace = o;
        }
      }
      let Ea;
      function Va(c, e, r, o, h) {
        const p = c.context, x = p.gl, A = c.useProgram("collisionBox"), T = [];
        let P = 0, F = 0;
        for (let oe = 0; oe < o.length; oe++) {
          const de = o[oe], ce = e.getTile(de).getBucket(r);
          if (!ce) continue;
          const we = h ? ce.textCollisionBox : ce.iconCollisionBox, Le = ce.collisionCircleArray;
          if (Le.length > 0) {
            const ke = s.H();
            s.aQ(ke, ce.placementInvProjMatrix, c.transform.glCoordMatrix), s.aQ(ke, ke, ce.placementViewportMatrix), T.push({ circleArray: Le, circleOffset: F, transform: de.posMatrix, invTransform: ke, coord: de }), P += Le.length / 4, F = P;
          }
          we && A.draw(p, x.LINES, oi.disabled, Mi.disabled, c.colorModeForRenderPass(), zi.disabled, { u_matrix: de.posMatrix, u_pixel_extrude_scale: [1 / (N = c.transform).width, 1 / N.height] }, c.style.map.terrain && c.style.map.terrain.getTerrainData(de), r.id, we.layoutVertexBuffer, we.indexBuffer, we.segments, null, c.transform.zoom, null, null, we.collisionVertexBuffer);
        }
        var N;
        if (!h || !T.length) return;
        const Z = c.useProgram("collisionCircle"), G = new s.aR();
        G.resize(4 * P), G._trim();
        let V = 0;
        for (const oe of T) for (let de = 0; de < oe.circleArray.length / 4; de++) {
          const ce = 4 * de, we = oe.circleArray[ce + 0], Le = oe.circleArray[ce + 1], ke = oe.circleArray[ce + 2], tt = oe.circleArray[ce + 3];
          G.emplace(V++, we, Le, ke, tt, 0), G.emplace(V++, we, Le, ke, tt, 1), G.emplace(V++, we, Le, ke, tt, 2), G.emplace(V++, we, Le, ke, tt, 3);
        }
        (!Ea || Ea.length < 2 * P) && (Ea = function(oe) {
          const de = 2 * oe, ce = new s.aT();
          ce.resize(de), ce._trim();
          for (let we = 0; we < de; we++) {
            const Le = 6 * we;
            ce.uint16[Le + 0] = 4 * we + 0, ce.uint16[Le + 1] = 4 * we + 1, ce.uint16[Le + 2] = 4 * we + 2, ce.uint16[Le + 3] = 4 * we + 2, ce.uint16[Le + 4] = 4 * we + 3, ce.uint16[Le + 5] = 4 * we + 0;
          }
          return ce;
        }(P));
        const W = p.createIndexBuffer(Ea, !0), ae = p.createVertexBuffer(G, s.aS.members, !0);
        for (const oe of T) {
          const de = xr(oe.transform, oe.invTransform, c.transform);
          Z.draw(p, x.TRIANGLES, oi.disabled, Mi.disabled, c.colorModeForRenderPass(), zi.disabled, de, c.style.map.terrain && c.style.map.terrain.getTerrainData(oe.coord), r.id, ae, W, s.a0.simpleSegment(0, 2 * oe.circleOffset, oe.circleArray.length, oe.circleArray.length / 2), null, c.transform.zoom, null, null, null);
        }
        ae.destroy(), W.destroy();
      }
      zi.disabled = new zi(!1, 1029, 2305), zi.backCCW = new zi(!0, 1029, 2305);
      const $a = s.an(new Float32Array(16));
      function ds(c, e, r, o, h, p) {
        const { horizontalAlign: x, verticalAlign: A } = s.au(c);
        return new s.P((-(x - 0.5) * e / h + o[0]) * p, (-(A - 0.5) * r / h + o[1]) * p);
      }
      function ca(c, e, r, o, h, p) {
        const x = e.tileAnchorPoint.add(new s.P(e.translation[0], e.translation[1]));
        if (e.pitchWithMap) {
          let A = o.mult(p);
          r || (A = A.rotate(-h));
          const T = x.add(A);
          return $(T.x, T.y, e.labelPlaneMatrix, e.getElevation).point;
        }
        if (r) {
          const A = et(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(c), T = Math.atan(A.y / A.x) + (A.x < 0 ? Math.PI : 0);
          return c.add(o.rotate(T));
        }
        return c.add(o);
      }
      function Ta(c, e, r, o, h, p, x, A, T, P, F, N, Z, G) {
        const V = c.text.placedSymbolArray, W = c.text.dynamicLayoutVertexArray, ae = c.icon.dynamicLayoutVertexArray, oe = {};
        W.clear();
        for (let de = 0; de < V.length; de++) {
          const ce = V.get(de), we = ce.hidden || !ce.crossTileID || c.allowVerticalPlacement && !ce.placedOrientation ? null : o[ce.crossTileID];
          if (we) {
            const Le = new s.P(ce.anchorX, ce.anchorY), ke = { getElevation: G, width: h.width, height: h.height, labelPlaneMatrix: p, lineVertexArray: null, pitchWithMap: r, projection: F, projectionCache: null, tileAnchorPoint: Le, translation: N, unwrappedTileID: Z }, tt = r ? $(Le.x, Le.y, x, G) : et(Le.x, Le.y, ke), ht = B(h.cameraToCenterDistance, tt.signedDistanceFromCamera);
            let _t = s.ai(c.textSizeData, T, ce) * ht / s.ap;
            r && (_t *= c.tilePixelRatio / A);
            const { width: wt, height: bt, anchor: yt, textOffset: St, textBoxScale: Zt } = we, Ct = ds(yt, wt, bt, St, Zt, _t), Dt = F.getPitchedTextCorrection(h, Le.add(new s.P(N[0], N[1])), Z), Wt = ca(tt.point, ke, e, Ct, h.angle, Dt), di = c.allowVerticalPlacement && ce.placedOrientation === s.ah.vertical ? Math.PI / 2 : 0;
            for (let ci = 0; ci < ce.numGlyphs; ci++) s.aj(W, Wt, di);
            P && ce.associatedIconIndex >= 0 && (oe[ce.associatedIconIndex] = { shiftedAnchor: Wt, angle: di });
          } else $t(ce.numGlyphs, W);
        }
        if (P) {
          ae.clear();
          const de = c.icon.placedSymbolArray;
          for (let ce = 0; ce < de.length; ce++) {
            const we = de.get(ce);
            if (we.hidden) $t(we.numGlyphs, ae);
            else {
              const Le = oe[ce];
              if (Le) for (let ke = 0; ke < we.numGlyphs; ke++) s.aj(ae, Le.shiftedAnchor, Le.angle);
              else $t(we.numGlyphs, ae);
            }
          }
          c.icon.dynamicLayoutVertexBuffer.updateData(ae);
        }
        c.text.dynamicLayoutVertexBuffer.updateData(W);
      }
      function qr(c, e, r) {
        return r.iconsInText && e ? "symbolTextAndIcon" : c ? "symbolSDF" : "symbolIcon";
      }
      function Yr(c, e, r, o, h, p, x, A, T, P, F, N) {
        const Z = c.context, G = Z.gl, V = c.transform, W = Rn(), ae = A === "map", oe = T === "map", de = A !== "viewport" && r.layout.get("symbol-placement") !== "point", ce = ae && !oe && !de, we = !oe && de, Le = !r.layout.get("symbol-sort-key").isConstant();
        let ke = !1;
        const tt = c.depthModeForSublayer(0, oi.ReadOnly), ht = r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset"), _t = [], wt = W.getCircleRadiusCorrection(V);
        for (const bt of o) {
          const yt = e.getTile(bt), St = yt.getBucket(r);
          if (!St) continue;
          const Zt = h ? St.text : St.icon;
          if (!Zt || !Zt.segments.get().length || !Zt.hasVisibleVertices) continue;
          const Ct = Zt.programConfigurations.get(r.id), Dt = h || St.sdfIcons, Wt = h ? St.textSizeData : St.iconSizeData, di = oe || V.pitch !== 0, ci = c.useProgram(qr(Dt, h, St), Ct), gi = s.ag(Wt, V.zoom), Ei = c.style.map.terrain && c.style.map.terrain.getTerrainData(bt);
          let qi, ar, Fi, _r, Ui = [0, 0], pr = null;
          if (h) ar = yt.glyphAtlasTexture, Fi = G.LINEAR, qi = yt.glyphAtlasTexture.size, St.iconsInText && (Ui = yt.imageAtlasTexture.size, pr = yt.imageAtlasTexture, _r = di || c.options.rotating || c.options.zooming || Wt.kind === "composite" || Wt.kind === "camera" ? G.LINEAR : G.NEAREST);
          else {
            const Li = r.layout.get("icon-size").constantOr(0) !== 1 || St.iconsNeedLinear;
            ar = yt.imageAtlasTexture, Fi = Dt || c.options.rotating || c.options.zooming || Li || di ? G.LINEAR : G.NEAREST, qi = yt.imageAtlasTexture.size;
          }
          const Cr = fi(yt, 1, c.transform.zoom), dn = we ? bt.posMatrix : $a, Ln = ie(dn, oe, ae, c.transform, Cr), sr = ue(dn, oe, ae, c.transform, Cr), xs = ue(bt.posMatrix, oe, ae, c.transform, Cr), Mn = W.translatePosition(c.transform, yt, p, x), hl = ht && St.hasTextData(), To = r.layout.get("icon-text-fit") !== "none" && hl && St.hasIconData();
          if (de) {
            const Li = c.style.map.terrain ? (ws, Ya) => c.style.map.terrain.getElevation(bt, ws, Ya) : null, Ma = r.layout.get("text-rotation-alignment") === "map";
            te(St, bt.posMatrix, c, h, Ln, xs, oe, P, Ma, W, bt.toUnwrapped(), V.width, V.height, Mn, Li);
          }
          const Qr = bt.posMatrix, pn = h && ht || To, Br = de || pn ? $a : Ln, en = sr, wr = Dt && r.paint.get(h ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let Ur;
          Ur = Dt ? St.iconsInText ? wa(Wt.kind, gi, ce, oe, de, pn, c, Qr, Br, en, Mn, qi, Ui, wt) : sa(Wt.kind, gi, ce, oe, de, pn, c, Qr, Br, en, Mn, h, qi, !0, wt) : oo(Wt.kind, gi, ce, oe, de, pn, c, Qr, Br, en, Mn, h, qi, wt);
          const tn = { program: ci, buffers: Zt, uniformValues: Ur, atlasTexture: ar, atlasTextureIcon: pr, atlasInterpolation: Fi, atlasInterpolationIcon: _r, isSDF: Dt, hasHalo: wr };
          if (Le && St.canOverlap) {
            ke = !0;
            const Li = Zt.segments.get();
            for (const Ma of Li) _t.push({ segments: new s.a0([Ma]), sortKey: Ma.sortKey, state: tn, terrainData: Ei });
          } else _t.push({ segments: Zt.segments, sortKey: 0, state: tn, terrainData: Ei });
        }
        ke && _t.sort((bt, yt) => bt.sortKey - yt.sortKey);
        for (const bt of _t) {
          const yt = bt.state;
          if (Z.activeTexture.set(G.TEXTURE0), yt.atlasTexture.bind(yt.atlasInterpolation, G.CLAMP_TO_EDGE), yt.atlasTextureIcon && (Z.activeTexture.set(G.TEXTURE1), yt.atlasTextureIcon && yt.atlasTextureIcon.bind(yt.atlasInterpolationIcon, G.CLAMP_TO_EDGE)), yt.isSDF) {
            const St = yt.uniformValues;
            yt.hasHalo && (St.u_is_halo = 1, ps(yt.buffers, bt.segments, r, c, yt.program, tt, F, N, St, bt.terrainData)), St.u_is_halo = 0;
          }
          ps(yt.buffers, bt.segments, r, c, yt.program, tt, F, N, yt.uniformValues, bt.terrainData);
        }
      }
      function ps(c, e, r, o, h, p, x, A, T, P) {
        const F = o.context;
        h.draw(F, F.gl.TRIANGLES, p, x, A, zi.disabled, T, P, r.id, c.layoutVertexBuffer, c.indexBuffer, e, r.paint, o.transform.zoom, c.programConfigurations.get(r.id), c.dynamicLayoutVertexBuffer, c.opacityVertexBuffer);
      }
      function fs(c, e, r, o) {
        const h = c.context, p = h.gl, x = Mi.disabled, A = new Ci([p.ONE, p.ONE], s.aM.transparent, [!0, !0, !0, !0]), T = e.getBucket(r);
        if (!T) return;
        const P = o.key;
        let F = r.heatmapFbos.get(P);
        F || (F = Za(h, e.tileSize, e.tileSize), r.heatmapFbos.set(P, F)), h.bindFramebuffer.set(F.framebuffer), h.viewport.set([0, 0, e.tileSize, e.tileSize]), h.clear({ color: s.aM.transparent });
        const N = T.programConfigurations.get(r.id), Z = c.useProgram("heatmap", N), G = c.style.map.terrain.getTerrainData(o);
        Z.draw(h, p.TRIANGLES, oi.disabled, x, A, zi.disabled, si(o.posMatrix, e, c.transform.zoom, r.paint.get("heatmap-intensity")), G, r.id, T.layoutVertexBuffer, T.indexBuffer, T.segments, r.paint, c.transform.zoom, N);
      }
      function jn(c, e, r) {
        const o = c.context, h = o.gl;
        o.setColorMode(c.colorModeForRenderPass());
        const p = zr(o, e), x = r.key, A = e.heatmapFbos.get(x);
        A && (o.activeTexture.set(h.TEXTURE0), h.bindTexture(h.TEXTURE_2D, A.colorAttachment.get()), o.activeTexture.set(h.TEXTURE1), p.bind(h.LINEAR, h.CLAMP_TO_EDGE), c.useProgram("heatmapTexture").draw(o, h.TRIANGLES, oi.disabled, Mi.disabled, c.colorModeForRenderPass(), zi.disabled, ro(c, e, 0, 1), null, e.id, c.rasterBoundsBuffer, c.quadTriangleIndexBuffer, c.rasterBoundsSegments, e.paint, c.transform.zoom), A.destroy(), e.heatmapFbos.delete(x));
      }
      function Za(c, e, r) {
        var o, h;
        const p = c.gl, x = p.createTexture();
        p.bindTexture(p.TEXTURE_2D, x), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.LINEAR), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.LINEAR);
        const A = (o = c.HALF_FLOAT) !== null && o !== void 0 ? o : p.UNSIGNED_BYTE, T = (h = c.RGBA16F) !== null && h !== void 0 ? h : p.RGBA;
        p.texImage2D(p.TEXTURE_2D, 0, T, e, r, 0, p.RGBA, A, null);
        const P = c.createFramebuffer(e, r, !1, !1);
        return P.colorAttachment.set(x), P;
      }
      function zr(c, e) {
        return e.colorRampTexture || (e.colorRampTexture = new X(c, e.colorRamp, c.gl.RGBA)), e.colorRampTexture;
      }
      function ms(c, e, r, o, h) {
        if (!r || !o || !o.imageAtlas) return;
        const p = o.imageAtlas.patternPositions;
        let x = p[r.to.toString()], A = p[r.from.toString()];
        if (!x && A && (x = A), !A && x && (A = x), !x || !A) {
          const T = h.getPaintProperty(e);
          x = p[T], A = p[T];
        }
        x && A && c.setConstantPatternPositions(x, A);
      }
      function Ga(c, e, r, o, h, p, x) {
        const A = c.context.gl, T = "fill-pattern", P = r.paint.get(T), F = P && P.constantOr(1), N = r.getCrossfadeParameters();
        let Z, G, V, W, ae;
        x ? (G = F && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", Z = A.LINES) : (G = F ? "fillPattern" : "fill", Z = A.TRIANGLES);
        const oe = P.constantOr(null);
        for (const de of o) {
          const ce = e.getTile(de);
          if (F && !ce.patternsLoaded()) continue;
          const we = ce.getBucket(r);
          if (!we) continue;
          const Le = we.programConfigurations.get(r.id), ke = c.useProgram(G, Le), tt = c.style.map.terrain && c.style.map.terrain.getTerrainData(de);
          F && (c.context.activeTexture.set(A.TEXTURE0), ce.imageAtlasTexture.bind(A.LINEAR, A.CLAMP_TO_EDGE), Le.updatePaintBuffers(N)), ms(Le, T, oe, ce, r);
          const ht = tt ? de : null, _t = c.translatePosMatrix(ht ? ht.posMatrix : de.posMatrix, ce, r.paint.get("fill-translate"), r.paint.get("fill-translate-anchor"));
          if (x) {
            W = we.indexBuffer2, ae = we.segments2;
            const wt = [A.drawingBufferWidth, A.drawingBufferHeight];
            V = G === "fillOutlinePattern" && F ? Ls(_t, c, N, ce, wt) : io(_t, wt);
          } else W = we.indexBuffer, ae = we.segments, V = F ? xa(_t, c, N, ce) : us(_t);
          ke.draw(c.context, Z, h, c.stencilModeForClipping(de), p, zi.disabled, V, tt, r.id, we.layoutVertexBuffer, W, ae, r.paint, c.transform.zoom, Le);
        }
      }
      function Bs(c, e, r, o, h, p, x) {
        const A = c.context, T = A.gl, P = "fill-extrusion-pattern", F = r.paint.get(P), N = F.constantOr(1), Z = r.getCrossfadeParameters(), G = r.paint.get("fill-extrusion-opacity"), V = F.constantOr(null);
        for (const W of o) {
          const ae = e.getTile(W), oe = ae.getBucket(r);
          if (!oe) continue;
          const de = c.style.map.terrain && c.style.map.terrain.getTerrainData(W), ce = oe.programConfigurations.get(r.id), we = c.useProgram(N ? "fillExtrusionPattern" : "fillExtrusion", ce);
          N && (c.context.activeTexture.set(T.TEXTURE0), ae.imageAtlasTexture.bind(T.LINEAR, T.CLAMP_TO_EDGE), ce.updatePaintBuffers(Z)), ms(ce, P, V, ae, r);
          const Le = c.translatePosMatrix(W.posMatrix, ae, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor")), ke = r.paint.get("fill-extrusion-vertical-gradient"), tt = N ? to(Le, c, ke, G, W, Z, ae) : Ps(Le, c, ke, G);
          we.draw(A, A.gl.TRIANGLES, h, p, x, zi.backCCW, tt, de, r.id, oe.layoutVertexBuffer, oe.indexBuffer, oe.segments, r.paint, c.transform.zoom, ce, c.style.map.terrain && oe.centroidVertexBuffer);
        }
      }
      function Jr(c, e, r, o, h, p, x) {
        const A = c.context, T = A.gl, P = r.fbo;
        if (!P) return;
        const F = c.useProgram("hillshade"), N = c.style.map.terrain && c.style.map.terrain.getTerrainData(e);
        A.activeTexture.set(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, P.colorAttachment.get()), F.draw(A, T.TRIANGLES, h, p, x, zi.disabled, ((Z, G, V, W) => {
          const ae = V.paint.get("hillshade-shadow-color"), oe = V.paint.get("hillshade-highlight-color"), de = V.paint.get("hillshade-accent-color");
          let ce = V.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          V.paint.get("hillshade-illumination-anchor") === "viewport" && (ce -= Z.transform.angle);
          const we = !Z.options.moving;
          return { u_matrix: W ? W.posMatrix : Z.transform.calculatePosMatrix(G.tileID.toUnwrapped(), we), u_image: 0, u_latrange: no(0, G.tileID), u_light: [V.paint.get("hillshade-exaggeration"), ce], u_shadow: ae, u_highlight: oe, u_accent: de };
        })(c, r, o, N ? e : null), N, o.id, c.rasterBoundsBuffer, c.quadTriangleIndexBuffer, c.rasterBoundsSegments);
      }
      function Ca(c, e, r, o, h, p) {
        const x = c.context, A = x.gl, T = e.dem;
        if (T && T.data) {
          const P = T.dim, F = T.stride, N = T.getPixels();
          if (x.activeTexture.set(A.TEXTURE1), x.pixelStoreUnpackPremultiplyAlpha.set(!1), e.demTexture = e.demTexture || c.getTileTexture(F), e.demTexture) {
            const G = e.demTexture;
            G.update(N, { premultiply: !1 }), G.bind(A.NEAREST, A.CLAMP_TO_EDGE);
          } else e.demTexture = new X(x, N, A.RGBA, { premultiply: !1 }), e.demTexture.bind(A.NEAREST, A.CLAMP_TO_EDGE);
          x.activeTexture.set(A.TEXTURE0);
          let Z = e.fbo;
          if (!Z) {
            const G = new X(x, { width: P, height: P, data: null }, A.RGBA);
            G.bind(A.LINEAR, A.CLAMP_TO_EDGE), Z = e.fbo = x.createFramebuffer(P, P, !0, !1), Z.colorAttachment.set(G.texture);
          }
          x.bindFramebuffer.set(Z.framebuffer), x.viewport.set([0, 0, P, P]), c.useProgram("hillshadePrepare").draw(x, A.TRIANGLES, o, h, p, zi.disabled, ((G, V) => {
            const W = V.stride, ae = s.H();
            return s.aP(ae, 0, s.X, -s.X, 0, 0, 1), s.J(ae, ae, [0, -s.X, 0]), { u_matrix: ae, u_image: 1, u_dimension: [W, W], u_zoom: G.overscaledZ, u_unpack: V.getUnpackVector() };
          })(e.tileID, T), null, r.id, c.rasterBoundsBuffer, c.quadTriangleIndexBuffer, c.rasterBoundsSegments), e.needsHillshadePrepare = !1;
        }
      }
      function kl(c, e, r, o, h, p) {
        const x = o.paint.get("raster-fade-duration");
        if (!p && x > 0) {
          const A = q.now(), T = (A - c.timeAdded) / x, P = e ? (A - e.timeAdded) / x : -1, F = r.getSource(), N = h.coveringZoomLevel({ tileSize: F.tileSize, roundZoom: F.roundZoom }), Z = !e || Math.abs(e.tileID.overscaledZ - N) > Math.abs(c.tileID.overscaledZ - N), G = Z && c.refreshedUponExpiration ? 1 : s.ac(Z ? T : 1 - P, 0, 1);
          return c.refreshedUponExpiration && T >= 1 && (c.refreshedUponExpiration = !1), e ? { opacity: 1, mix: 1 - G } : { opacity: G, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const tl = new s.aM(1, 0, 0, 1), Di = new s.aM(0, 1, 0, 1), un = new s.aM(0, 0, 1, 1), ha = new s.aM(1, 0, 1, 1), Ha = new s.aM(0, 1, 1, 1);
      function cn(c, e, r, o) {
        Wa(c, 0, e + r / 2, c.transform.width, r, o);
      }
      function Da(c, e, r, o) {
        Wa(c, e - r / 2, 0, r, c.transform.height, o);
      }
      function Wa(c, e, r, o, h, p) {
        const x = c.context, A = x.gl;
        A.enable(A.SCISSOR_TEST), A.scissor(e * c.pixelRatio, r * c.pixelRatio, o * c.pixelRatio, h * c.pixelRatio), x.clear({ color: p }), A.disable(A.SCISSOR_TEST);
      }
      function qn(c, e, r) {
        const o = c.context, h = o.gl, p = r.posMatrix, x = c.useProgram("debug"), A = oi.disabled, T = Mi.disabled, P = c.colorModeForRenderPass(), F = "$debug", N = c.style.map.terrain && c.style.map.terrain.getTerrainData(r);
        o.activeTexture.set(h.TEXTURE0);
        const Z = e.getTileByID(r.key).latestRawTileData, G = Math.floor((Z && Z.byteLength || 0) / 1024), V = e.getTile(r).tileSize, W = 512 / Math.min(V, 512) * (r.overscaledZ / c.transform.zoom) * 0.5;
        let ae = r.canonical.toString();
        r.overscaledZ !== r.canonical.z && (ae += ` => ${r.overscaledZ}`), function(oe, de) {
          oe.initDebugOverlayCanvas();
          const ce = oe.debugOverlayCanvas, we = oe.context.gl, Le = oe.debugOverlayCanvas.getContext("2d");
          Le.clearRect(0, 0, ce.width, ce.height), Le.shadowColor = "white", Le.shadowBlur = 2, Le.lineWidth = 1.5, Le.strokeStyle = "white", Le.textBaseline = "top", Le.font = "bold 36px Open Sans, sans-serif", Le.fillText(de, 5, 5), Le.strokeText(de, 5, 5), oe.debugOverlayTexture.update(ce), oe.debugOverlayTexture.bind(we.LINEAR, we.CLAMP_TO_EDGE);
        }(c, `${ae} ${G}kB`), x.draw(o, h.TRIANGLES, A, T, Ci.alphaBlended, zi.disabled, Ms(p, s.aM.transparent, W), null, F, c.debugBuffer, c.quadTriangleIndexBuffer, c.debugSegments), x.draw(o, h.LINE_STRIP, A, T, P, zi.disabled, Ms(p, s.aM.red), N, F, c.debugBuffer, c.tileBorderIndexBuffer, c.debugSegments);
      }
      function Rs(c, e, r) {
        const o = c.context, h = o.gl, p = c.colorModeForRenderPass(), x = new oi(h.LEQUAL, oi.ReadWrite, c.depthRangeFor3D), A = c.useProgram("terrain"), T = e.getTerrainMesh();
        o.bindFramebuffer.set(null), o.viewport.set([0, 0, c.width, c.height]);
        for (const P of r) {
          const F = c.renderToTexture.getTexture(P), N = e.getTerrainData(P.tileID);
          o.activeTexture.set(h.TEXTURE0), h.bindTexture(h.TEXTURE_2D, F.texture);
          const Z = c.transform.calculatePosMatrix(P.tileID.toUnwrapped()), G = e.getMeshFrameDelta(c.transform.zoom), V = c.transform.calculateFogMatrix(P.tileID.toUnwrapped()), W = Wo(Z, G, V, c.style.sky, c.transform.pitch);
          A.draw(o, h.TRIANGLES, x, Mi.disabled, p, zi.backCCW, W, N, "terrain", T.vertexBuffer, T.indexBuffer, T.segments);
        }
      }
      class gs {
        constructor(e, r, o) {
          this.vertexBuffer = e, this.indexBuffer = r, this.segments = o;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }
      class da {
        constructor(e, r) {
          this.context = new Xr(e), this.transform = r, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: s.an(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Lt.maxUnderzooming + Lt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Ho();
        }
        resize(e, r, o) {
          if (this.width = Math.floor(e * o), this.height = Math.floor(r * o), this.pixelRatio = o, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const h of this.style._order) this.style._layers[h].resize();
        }
        setup() {
          const e = this.context, r = new s.aX();
          r.emplaceBack(0, 0), r.emplaceBack(s.X, 0), r.emplaceBack(0, s.X), r.emplaceBack(s.X, s.X), this.tileExtentBuffer = e.createVertexBuffer(r, na.members), this.tileExtentSegments = s.a0.simpleSegment(0, 0, 4, 2);
          const o = new s.aX();
          o.emplaceBack(0, 0), o.emplaceBack(s.X, 0), o.emplaceBack(0, s.X), o.emplaceBack(s.X, s.X), this.debugBuffer = e.createVertexBuffer(o, na.members), this.debugSegments = s.a0.simpleSegment(0, 0, 4, 5);
          const h = new s.$();
          h.emplaceBack(0, 0, 0, 0), h.emplaceBack(s.X, 0, s.X, 0), h.emplaceBack(0, s.X, 0, s.X), h.emplaceBack(s.X, s.X, s.X, s.X), this.rasterBoundsBuffer = e.createVertexBuffer(h, Et.members), this.rasterBoundsSegments = s.a0.simpleSegment(0, 0, 4, 2);
          const p = new s.aX();
          p.emplaceBack(0, 0), p.emplaceBack(1, 0), p.emplaceBack(0, 1), p.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(p, na.members), this.viewportSegments = s.a0.simpleSegment(0, 0, 4, 2);
          const x = new s.aZ();
          x.emplaceBack(0), x.emplaceBack(1), x.emplaceBack(3), x.emplaceBack(2), x.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(x);
          const A = new s.aY();
          A.emplaceBack(0, 1, 2), A.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(A);
          const T = this.context.gl;
          this.stencilClearMode = new Mi({ func: T.ALWAYS, mask: 0 }, 0, 255, T.ZERO, T.ZERO, T.ZERO);
        }
        clearStencil() {
          const e = this.context, r = e.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const o = s.H();
          s.aP(o, 0, this.width, this.height, 0, 0, 1), s.K(o, o, [r.drawingBufferWidth, r.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, r.TRIANGLES, oi.disabled, this.stencilClearMode, Ci.disabled, zi.disabled, jr(o), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(e, r) {
          if (this.currentStencilSource === e.source || !e.isTileClipped() || !r || !r.length) return;
          this.currentStencilSource = e.source;
          const o = this.context, h = o.gl;
          this.nextStencilID + r.length > 256 && this.clearStencil(), o.setColorMode(Ci.disabled), o.setDepthMode(oi.disabled);
          const p = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const x of r) {
            const A = this._tileClippingMaskIDs[x.key] = this.nextStencilID++, T = this.style.map.terrain && this.style.map.terrain.getTerrainData(x);
            p.draw(o, h.TRIANGLES, oi.disabled, new Mi({ func: h.ALWAYS, mask: 0 }, A, 255, h.KEEP, h.KEEP, h.REPLACE), Ci.disabled, zi.disabled, jr(x.posMatrix), T, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const e = this.nextStencilID++, r = this.context.gl;
          return new Mi({ func: r.NOTEQUAL, mask: 255 }, e, 255, r.KEEP, r.KEEP, r.REPLACE);
        }
        stencilModeForClipping(e) {
          const r = this.context.gl;
          return new Mi({ func: r.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, r.KEEP, r.KEEP, r.REPLACE);
        }
        stencilConfigForOverlap(e) {
          const r = this.context.gl, o = e.sort((x, A) => A.overscaledZ - x.overscaledZ), h = o[o.length - 1].overscaledZ, p = o[0].overscaledZ - h + 1;
          if (p > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + p > 256 && this.clearStencil();
            const x = {};
            for (let A = 0; A < p; A++) x[A + h] = new Mi({ func: r.GEQUAL, mask: 255 }, A + this.nextStencilID, 255, r.KEEP, r.KEEP, r.REPLACE);
            return this.nextStencilID += p, [x, o];
          }
          return [{ [h]: Mi.disabled }, o];
        }
        colorModeForRenderPass() {
          const e = this.context.gl;
          return this._showOverdrawInspector ? new Ci([e.CONSTANT_COLOR, e.ONE], new s.aM(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Ci.unblended : Ci.alphaBlended;
        }
        depthModeForSublayer(e, r, o) {
          if (!this.opaquePassEnabledForLayer()) return oi.disabled;
          const h = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
          return new oi(o || this.context.gl.LEQUAL, r, [h, h]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(e, r) {
          this.style = e, this.options = r, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(q.now()), this.imageManager.beginFrame();
          const o = this.style._order, h = this.style.sourceCaches, p = {}, x = {}, A = {};
          for (const T in h) {
            const P = h[T];
            P.used && P.prepare(this.context), p[T] = P.getVisibleCoordinates(), x[T] = p[T].slice().reverse(), A[T] = P.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let T = 0; T < o.length; T++) if (this.style._layers[o[T]].is3D()) {
            this.opaquePassCutoff = T;
            break;
          }
          this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const T of o) {
            const P = this.style._layers[T];
            if (!P.hasOffscreenPass() || P.isHidden(this.transform.zoom)) continue;
            const F = x[P.source];
            (P.type === "custom" || F.length) && this.renderLayer(this, h[P.source], P, F);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: r.showOverdrawInspector ? s.aM.black : s.aM.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(T, P) {
            const F = T.context, N = F.gl, Z = ((oe, de, ce) => ({ u_sky_color: oe.properties.get("sky-color"), u_horizon_color: oe.properties.get("horizon-color"), u_horizon: (de.height / 2 + de.getHorizon()) * ce, u_sky_horizon_blend: oe.properties.get("sky-horizon-blend") * de.height / 2 * ce }))(P, T.style.map.transform, T.pixelRatio), G = new oi(N.LEQUAL, oi.ReadWrite, [0, 1]), V = Mi.disabled, W = T.colorModeForRenderPass(), ae = T.useProgram("sky");
            if (!P.mesh) {
              const oe = new s.aX();
              oe.emplaceBack(-1, -1), oe.emplaceBack(1, -1), oe.emplaceBack(1, 1), oe.emplaceBack(-1, 1);
              const de = new s.aY();
              de.emplaceBack(0, 1, 2), de.emplaceBack(0, 2, 3), P.mesh = new gs(F.createVertexBuffer(oe, na.members), F.createIndexBuffer(de), s.a0.simpleSegment(0, 0, oe.length, de.length));
            }
            ae.draw(F, N.TRIANGLES, G, V, W, zi.disabled, Z, void 0, "sky", P.mesh.vertexBuffer, P.mesh.indexBuffer, P.mesh.segments);
          }(this, this.style.sky), this._showOverdrawInspector = r.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = o.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const T = this.style._layers[o[this.currentLayer]], P = h[T.source], F = p[T.source];
            this._renderTileClippingMasks(T, F), this.renderLayer(this, P, T, F);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o.length; this.currentLayer++) {
            const T = this.style._layers[o[this.currentLayer]], P = h[T.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(T)) continue;
            const F = (T.type === "symbol" ? A : x)[T.source];
            this._renderTileClippingMasks(T, p[T.source]), this.renderLayer(this, P, T, F);
          }
          if (this.options.showTileBoundaries) {
            const T = function(P, F) {
              let N = null;
              const Z = Object.values(P._layers).flatMap((ae) => ae.source && !ae.isHidden(F) ? [P.sourceCaches[ae.source]] : []), G = Z.filter((ae) => ae.getSource().type === "vector"), V = Z.filter((ae) => ae.getSource().type !== "vector"), W = (ae) => {
                (!N || N.getSource().maxzoom < ae.getSource().maxzoom) && (N = ae);
              };
              return G.forEach((ae) => W(ae)), N || V.forEach((ae) => W(ae)), N;
            }(this.style, this.transform.zoom);
            T && function(P, F, N) {
              for (let Z = 0; Z < N.length; Z++) qn(P, F, N[Z]);
            }(this, T, T.getVisibleCoordinates());
          }
          this.options.showPadding && function(T) {
            const P = T.transform.padding;
            cn(T, T.transform.height - (P.top || 0), 3, tl), cn(T, P.bottom || 0, 3, Di), Da(T, P.left || 0, 3, un), Da(T, T.transform.width - (P.right || 0), 3, ha);
            const F = T.transform.centerPoint;
            (function(N, Z, G, V) {
              Wa(N, Z - 1, G - 10, 2, 20, V), Wa(N, Z - 10, G - 1, 20, 2, V);
            })(T, F.x, T.transform.height - F.y, Ha);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(e) {
          if (!this.style || !this.style.map || !this.style.map.terrain) return;
          const r = this.terrainFacilitator.matrix, o = this.transform.modelViewProjectionMatrix;
          let h = this.terrainFacilitator.dirty;
          h || (h = e ? !s.a_(r, o) : !s.a$(r, o)), h || (h = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), h && (s.b0(r, o), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(p, x) {
            const A = p.context, T = A.gl, P = Ci.unblended, F = new oi(T.LEQUAL, oi.ReadWrite, [0, 1]), N = x.getTerrainMesh(), Z = x.sourceCache.getRenderableTiles(), G = p.useProgram("terrainDepth");
            A.bindFramebuffer.set(x.getFramebuffer("depth").framebuffer), A.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), A.clear({ color: s.aM.transparent, depth: 1 });
            for (const V of Z) {
              const W = x.getTerrainData(V.tileID), ae = { u_matrix: p.transform.calculatePosMatrix(V.tileID.toUnwrapped()), u_ele_delta: x.getMeshFrameDelta(p.transform.zoom) };
              G.draw(A, T.TRIANGLES, F, Mi.disabled, P, zi.backCCW, ae, W, "terrain", N.vertexBuffer, N.indexBuffer, N.segments);
            }
            A.bindFramebuffer.set(null), A.viewport.set([0, 0, p.width, p.height]);
          }(this, this.style.map.terrain), function(p, x) {
            const A = p.context, T = A.gl, P = Ci.unblended, F = new oi(T.LEQUAL, oi.ReadWrite, [0, 1]), N = x.getTerrainMesh(), Z = x.getCoordsTexture(), G = x.sourceCache.getRenderableTiles(), V = p.useProgram("terrainCoords");
            A.bindFramebuffer.set(x.getFramebuffer("coords").framebuffer), A.viewport.set([0, 0, p.width / devicePixelRatio, p.height / devicePixelRatio]), A.clear({ color: s.aM.transparent, depth: 1 }), x.coordsIndex = [];
            for (const W of G) {
              const ae = x.getTerrainData(W.tileID);
              A.activeTexture.set(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, Z.texture);
              const oe = { u_matrix: p.transform.calculatePosMatrix(W.tileID.toUnwrapped()), u_terrain_coords_id: (255 - x.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: x.getMeshFrameDelta(p.transform.zoom) };
              V.draw(A, T.TRIANGLES, F, Mi.disabled, P, zi.backCCW, oe, ae, "terrain", N.vertexBuffer, N.indexBuffer, N.segments), x.coordsIndex.push(W.tileID.key);
            }
            A.bindFramebuffer.set(null), A.viewport.set([0, 0, p.width, p.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(e, r, o, h) {
          if (!o.isHidden(this.transform.zoom) && (o.type === "background" || o.type === "custom" || (h || []).length)) switch (this.id = o.id, o.type) {
            case "symbol":
              (function(p, x, A, T, P) {
                if (p.renderPass !== "translucent") return;
                const F = Mi.disabled, N = p.colorModeForRenderPass();
                (A._unevaluatedLayout.hasValue("text-variable-anchor") || A._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(Z, G, V, W, ae, oe, de, ce, we) {
                  const Le = G.transform, ke = Rn(), tt = ae === "map", ht = oe === "map";
                  for (const _t of Z) {
                    const wt = W.getTile(_t), bt = wt.getBucket(V);
                    if (!bt || !bt.text || !bt.text.segments.get().length) continue;
                    const yt = s.ag(bt.textSizeData, Le.zoom), St = fi(wt, 1, G.transform.zoom), Zt = ie(_t.posMatrix, ht, tt, G.transform, St), Ct = V.layout.get("icon-text-fit") !== "none" && bt.hasIconData();
                    if (yt) {
                      const Dt = Math.pow(2, Le.zoom - wt.tileID.overscaledZ), Wt = G.style.map.terrain ? (ci, gi) => G.style.map.terrain.getElevation(_t, ci, gi) : null, di = ke.translatePosition(Le, wt, de, ce);
                      Ta(bt, tt, ht, we, Le, Zt, _t.posMatrix, Dt, yt, Ct, ke, di, _t.toUnwrapped(), Wt);
                    }
                  }
                }(T, p, A, x, A.layout.get("text-rotation-alignment"), A.layout.get("text-pitch-alignment"), A.paint.get("text-translate"), A.paint.get("text-translate-anchor"), P), A.paint.get("icon-opacity").constantOr(1) !== 0 && Yr(p, x, A, T, !1, A.paint.get("icon-translate"), A.paint.get("icon-translate-anchor"), A.layout.get("icon-rotation-alignment"), A.layout.get("icon-pitch-alignment"), A.layout.get("icon-keep-upright"), F, N), A.paint.get("text-opacity").constantOr(1) !== 0 && Yr(p, x, A, T, !0, A.paint.get("text-translate"), A.paint.get("text-translate-anchor"), A.layout.get("text-rotation-alignment"), A.layout.get("text-pitch-alignment"), A.layout.get("text-keep-upright"), F, N), x.map.showCollisionBoxes && (Va(p, x, A, T, !0), Va(p, x, A, T, !1));
              })(e, r, o, h, this.style.placement.variableOffsets);
              break;
            case "circle":
              (function(p, x, A, T) {
                if (p.renderPass !== "translucent") return;
                const P = A.paint.get("circle-opacity"), F = A.paint.get("circle-stroke-width"), N = A.paint.get("circle-stroke-opacity"), Z = !A.layout.get("circle-sort-key").isConstant();
                if (P.constantOr(1) === 0 && (F.constantOr(1) === 0 || N.constantOr(1) === 0)) return;
                const G = p.context, V = G.gl, W = p.depthModeForSublayer(0, oi.ReadOnly), ae = Mi.disabled, oe = p.colorModeForRenderPass(), de = [];
                for (let ce = 0; ce < T.length; ce++) {
                  const we = T[ce], Le = x.getTile(we), ke = Le.getBucket(A);
                  if (!ke) continue;
                  const tt = ke.programConfigurations.get(A.id), ht = p.useProgram("circle", tt), _t = ke.layoutVertexBuffer, wt = ke.indexBuffer, bt = p.style.map.terrain && p.style.map.terrain.getTerrainData(we), yt = { programConfiguration: tt, program: ht, layoutVertexBuffer: _t, indexBuffer: wt, uniformValues: El(p, we, Le, A), terrainData: bt };
                  if (Z) {
                    const St = ke.segments.get();
                    for (const Zt of St) de.push({ segments: new s.a0([Zt]), sortKey: Zt.sortKey, state: yt });
                  } else de.push({ segments: ke.segments, sortKey: 0, state: yt });
                }
                Z && de.sort((ce, we) => ce.sortKey - we.sortKey);
                for (const ce of de) {
                  const { programConfiguration: we, program: Le, layoutVertexBuffer: ke, indexBuffer: tt, uniformValues: ht, terrainData: _t } = ce.state;
                  Le.draw(G, V.TRIANGLES, W, ae, oe, zi.disabled, ht, _t, A.id, ke, tt, ce.segments, A.paint, p.transform.zoom, we);
                }
              })(e, r, o, h);
              break;
            case "heatmap":
              (function(p, x, A, T) {
                if (A.paint.get("heatmap-opacity") === 0) return;
                const P = p.context;
                if (p.style.map.terrain) {
                  for (const F of T) {
                    const N = x.getTile(F);
                    x.hasRenderableParent(F) || (p.renderPass === "offscreen" ? fs(p, N, A, F) : p.renderPass === "translucent" && jn(p, A, F));
                  }
                  P.viewport.set([0, 0, p.width, p.height]);
                } else p.renderPass === "offscreen" ? function(F, N, Z, G) {
                  const V = F.context, W = V.gl, ae = Mi.disabled, oe = new Ci([W.ONE, W.ONE], s.aM.transparent, [!0, !0, !0, !0]);
                  (function(de, ce, we) {
                    const Le = de.gl;
                    de.activeTexture.set(Le.TEXTURE1), de.viewport.set([0, 0, ce.width / 4, ce.height / 4]);
                    let ke = we.heatmapFbos.get(s.aU);
                    ke ? (Le.bindTexture(Le.TEXTURE_2D, ke.colorAttachment.get()), de.bindFramebuffer.set(ke.framebuffer)) : (ke = Za(de, ce.width / 4, ce.height / 4), we.heatmapFbos.set(s.aU, ke));
                  })(V, F, Z), V.clear({ color: s.aM.transparent });
                  for (let de = 0; de < G.length; de++) {
                    const ce = G[de];
                    if (N.hasRenderableParent(ce)) continue;
                    const we = N.getTile(ce), Le = we.getBucket(Z);
                    if (!Le) continue;
                    const ke = Le.programConfigurations.get(Z.id), tt = F.useProgram("heatmap", ke), { zoom: ht } = F.transform;
                    tt.draw(V, W.TRIANGLES, oi.disabled, ae, oe, zi.disabled, si(ce.posMatrix, we, ht, Z.paint.get("heatmap-intensity")), null, Z.id, Le.layoutVertexBuffer, Le.indexBuffer, Le.segments, Z.paint, F.transform.zoom, ke);
                  }
                  V.viewport.set([0, 0, F.width, F.height]);
                }(p, x, A, T) : p.renderPass === "translucent" && function(F, N) {
                  const Z = F.context, G = Z.gl;
                  Z.setColorMode(F.colorModeForRenderPass());
                  const V = N.heatmapFbos.get(s.aU);
                  V && (Z.activeTexture.set(G.TEXTURE0), G.bindTexture(G.TEXTURE_2D, V.colorAttachment.get()), Z.activeTexture.set(G.TEXTURE1), zr(Z, N).bind(G.LINEAR, G.CLAMP_TO_EDGE), F.useProgram("heatmapTexture").draw(Z, G.TRIANGLES, oi.disabled, Mi.disabled, F.colorModeForRenderPass(), zi.disabled, ro(F, N, 0, 1), null, N.id, F.viewportBuffer, F.quadTriangleIndexBuffer, F.viewportSegments, N.paint, F.transform.zoom));
                }(p, A);
              })(e, r, o, h);
              break;
            case "line":
              (function(p, x, A, T) {
                if (p.renderPass !== "translucent") return;
                const P = A.paint.get("line-opacity"), F = A.paint.get("line-width");
                if (P.constantOr(1) === 0 || F.constantOr(1) === 0) return;
                const N = p.depthModeForSublayer(0, oi.ReadOnly), Z = p.colorModeForRenderPass(), G = A.paint.get("line-dasharray"), V = A.paint.get("line-pattern"), W = V.constantOr(1), ae = A.paint.get("line-gradient"), oe = A.getCrossfadeParameters(), de = W ? "linePattern" : G ? "lineSDF" : ae ? "lineGradient" : "line", ce = p.context, we = ce.gl;
                let Le = !0;
                for (const ke of T) {
                  const tt = x.getTile(ke);
                  if (W && !tt.patternsLoaded()) continue;
                  const ht = tt.getBucket(A);
                  if (!ht) continue;
                  const _t = ht.programConfigurations.get(A.id), wt = p.context.program.get(), bt = p.useProgram(de, _t), yt = Le || bt.program !== wt, St = p.style.map.terrain && p.style.map.terrain.getTerrainData(ke), Zt = V.constantOr(null);
                  if (Zt && tt.imageAtlas) {
                    const Wt = tt.imageAtlas, di = Wt.patternPositions[Zt.to.toString()], ci = Wt.patternPositions[Zt.from.toString()];
                    di && ci && _t.setConstantPatternPositions(di, ci);
                  }
                  const Ct = St ? ke : null, Dt = W ? qa(p, tt, A, oe, Ct) : G ? ao(p, tt, A, G, oe, Ct) : ae ? Yo(p, tt, A, ht.lineClipsArray.length, Ct) : Tn(p, tt, A, Ct);
                  if (W) ce.activeTexture.set(we.TEXTURE0), tt.imageAtlasTexture.bind(we.LINEAR, we.CLAMP_TO_EDGE), _t.updatePaintBuffers(oe);
                  else if (G && (yt || p.lineAtlas.dirty)) ce.activeTexture.set(we.TEXTURE0), p.lineAtlas.bind(ce);
                  else if (ae) {
                    const Wt = ht.gradients[A.id];
                    let di = Wt.texture;
                    if (A.gradientVersion !== Wt.version) {
                      let ci = 256;
                      if (A.stepInterpolant) {
                        const gi = x.getSource().maxzoom, Ei = ke.canonical.z === gi ? Math.ceil(1 << p.transform.maxZoom - ke.canonical.z) : 1;
                        ci = s.ac(s.aV(ht.maxLineLength / s.X * 1024 * Ei), 256, ce.maxTextureSize);
                      }
                      Wt.gradient = s.aW({ expression: A.gradientExpression(), evaluationKey: "lineProgress", resolution: ci, image: Wt.gradient || void 0, clips: ht.lineClipsArray }), Wt.texture ? Wt.texture.update(Wt.gradient) : Wt.texture = new X(ce, Wt.gradient, we.RGBA), Wt.version = A.gradientVersion, di = Wt.texture;
                    }
                    ce.activeTexture.set(we.TEXTURE0), di.bind(A.stepInterpolant ? we.NEAREST : we.LINEAR, we.CLAMP_TO_EDGE);
                  }
                  bt.draw(ce, we.TRIANGLES, N, p.stencilModeForClipping(ke), Z, zi.disabled, Dt, St, A.id, ht.layoutVertexBuffer, ht.indexBuffer, ht.segments, A.paint, p.transform.zoom, _t, ht.layoutVertexBuffer2), Le = !1;
                }
              })(e, r, o, h);
              break;
            case "fill":
              (function(p, x, A, T) {
                const P = A.paint.get("fill-color"), F = A.paint.get("fill-opacity");
                if (F.constantOr(1) === 0) return;
                const N = p.colorModeForRenderPass(), Z = A.paint.get("fill-pattern"), G = p.opaquePassEnabledForLayer() && !Z.constantOr(1) && P.constantOr(s.aM.transparent).a === 1 && F.constantOr(0) === 1 ? "opaque" : "translucent";
                if (p.renderPass === G) {
                  const V = p.depthModeForSublayer(1, p.renderPass === "opaque" ? oi.ReadWrite : oi.ReadOnly);
                  Ga(p, x, A, T, V, N, !1);
                }
                if (p.renderPass === "translucent" && A.paint.get("fill-antialias")) {
                  const V = p.depthModeForSublayer(A.getPaintProperty("fill-outline-color") ? 2 : 0, oi.ReadOnly);
                  Ga(p, x, A, T, V, N, !0);
                }
              })(e, r, o, h);
              break;
            case "fill-extrusion":
              (function(p, x, A, T) {
                const P = A.paint.get("fill-extrusion-opacity");
                if (P !== 0 && p.renderPass === "translucent") {
                  const F = new oi(p.context.gl.LEQUAL, oi.ReadWrite, p.depthRangeFor3D);
                  if (P !== 1 || A.paint.get("fill-extrusion-pattern").constantOr(1)) Bs(p, x, A, T, F, Mi.disabled, Ci.disabled), Bs(p, x, A, T, F, p.stencilModeFor3D(), p.colorModeForRenderPass());
                  else {
                    const N = p.colorModeForRenderPass();
                    Bs(p, x, A, T, F, Mi.disabled, N);
                  }
                }
              })(e, r, o, h);
              break;
            case "hillshade":
              (function(p, x, A, T) {
                if (p.renderPass !== "offscreen" && p.renderPass !== "translucent") return;
                const P = p.context, F = p.depthModeForSublayer(0, oi.ReadOnly), N = p.colorModeForRenderPass(), [Z, G] = p.renderPass === "translucent" ? p.stencilConfigForOverlap(T) : [{}, T];
                for (const V of G) {
                  const W = x.getTile(V);
                  W.needsHillshadePrepare !== void 0 && W.needsHillshadePrepare && p.renderPass === "offscreen" ? Ca(p, W, A, F, Mi.disabled, N) : p.renderPass === "translucent" && Jr(p, V, W, A, F, Z[V.overscaledZ], N);
                }
                P.viewport.set([0, 0, p.width, p.height]);
              })(e, r, o, h);
              break;
            case "raster":
              (function(p, x, A, T) {
                if (p.renderPass !== "translucent" || A.paint.get("raster-opacity") === 0 || !T.length) return;
                const P = p.context, F = P.gl, N = x.getSource(), Z = p.useProgram("raster"), G = p.colorModeForRenderPass(), [V, W] = N instanceof jt ? [{}, T] : p.stencilConfigForOverlap(T), ae = W[W.length - 1].overscaledZ, oe = !p.options.moving;
                for (const de of W) {
                  const ce = p.depthModeForSublayer(de.overscaledZ - ae, A.paint.get("raster-opacity") === 1 ? oi.ReadWrite : oi.ReadOnly, F.LESS), we = x.getTile(de);
                  we.registerFadeDuration(A.paint.get("raster-fade-duration"));
                  const Le = x.findLoadedParent(de, 0), ke = x.findLoadedSibling(de), tt = kl(we, Le || ke || null, x, A, p.transform, p.style.map.terrain);
                  let ht, _t;
                  const wt = A.paint.get("raster-resampling") === "nearest" ? F.NEAREST : F.LINEAR;
                  P.activeTexture.set(F.TEXTURE0), we.texture.bind(wt, F.CLAMP_TO_EDGE, F.LINEAR_MIPMAP_NEAREST), P.activeTexture.set(F.TEXTURE1), Le ? (Le.texture.bind(wt, F.CLAMP_TO_EDGE, F.LINEAR_MIPMAP_NEAREST), ht = Math.pow(2, Le.tileID.overscaledZ - we.tileID.overscaledZ), _t = [we.tileID.canonical.x * ht % 1, we.tileID.canonical.y * ht % 1]) : we.texture.bind(wt, F.CLAMP_TO_EDGE, F.LINEAR_MIPMAP_NEAREST), we.texture.useMipmap && P.extTextureFilterAnisotropic && p.transform.pitch > 20 && F.texParameterf(F.TEXTURE_2D, P.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, P.extTextureFilterAnisotropicMax);
                  const bt = p.style.map.terrain && p.style.map.terrain.getTerrainData(de), yt = bt ? de : null, St = yt ? yt.posMatrix : p.transform.calculatePosMatrix(de.toUnwrapped(), oe), Zt = tu(St, _t || [0, 0], ht || 1, tt, A);
                  N instanceof jt ? Z.draw(P, F.TRIANGLES, ce, Mi.disabled, G, zi.disabled, Zt, bt, A.id, N.boundsBuffer, p.quadTriangleIndexBuffer, N.boundsSegments) : Z.draw(P, F.TRIANGLES, ce, V[de.overscaledZ], G, zi.disabled, Zt, bt, A.id, p.rasterBoundsBuffer, p.quadTriangleIndexBuffer, p.rasterBoundsSegments);
                }
              })(e, r, o, h);
              break;
            case "background":
              (function(p, x, A, T) {
                const P = A.paint.get("background-color"), F = A.paint.get("background-opacity");
                if (F === 0) return;
                const N = p.context, Z = N.gl, G = p.transform, V = G.tileSize, W = A.paint.get("background-pattern");
                if (p.isPatternMissing(W)) return;
                const ae = !W && P.a === 1 && F === 1 && p.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (p.renderPass !== ae) return;
                const oe = Mi.disabled, de = p.depthModeForSublayer(0, ae === "opaque" ? oi.ReadWrite : oi.ReadOnly), ce = p.colorModeForRenderPass(), we = p.useProgram(W ? "backgroundPattern" : "background"), Le = T || G.coveringTiles({ tileSize: V, terrain: p.style.map.terrain });
                W && (N.activeTexture.set(Z.TEXTURE0), p.imageManager.bind(p.context));
                const ke = A.getCrossfadeParameters();
                for (const tt of Le) {
                  const ht = T ? tt.posMatrix : p.transform.calculatePosMatrix(tt.toUnwrapped()), _t = W ? Ua(ht, F, p, W, { tileID: tt, tileSize: V }, ke) : lo(ht, F, P), wt = p.style.map.terrain && p.style.map.terrain.getTerrainData(tt);
                  we.draw(N, Z.TRIANGLES, de, oe, ce, zi.disabled, _t, wt, A.id, p.tileExtentBuffer, p.quadTriangleIndexBuffer, p.tileExtentSegments);
                }
              })(e, 0, o, h);
              break;
            case "custom":
              (function(p, x, A) {
                const T = p.context, P = A.implementation;
                if (p.renderPass === "offscreen") {
                  const F = P.prerender;
                  F && (p.setCustomLayerDefaults(), T.setColorMode(p.colorModeForRenderPass()), F.call(P, T.gl, p.transform.customLayerMatrix()), T.setDirty(), p.setBaseState());
                } else if (p.renderPass === "translucent") {
                  p.setCustomLayerDefaults(), T.setColorMode(p.colorModeForRenderPass()), T.setStencilMode(Mi.disabled);
                  const F = P.renderingMode === "3d" ? new oi(p.context.gl.LEQUAL, oi.ReadWrite, p.depthRangeFor3D) : p.depthModeForSublayer(0, oi.ReadOnly);
                  T.setDepthMode(F), P.render(T.gl, p.transform.customLayerMatrix(), { farZ: p.transform.farZ, nearZ: p.transform.nearZ, fov: p.transform._fov, modelViewProjectionMatrix: p.transform.modelViewProjectionMatrix, projectionMatrix: p.transform.projectionMatrix }), T.setDirty(), p.setBaseState(), T.bindFramebuffer.set(null);
                }
              })(e, 0, o);
          }
        }
        translatePosMatrix(e, r, o, h, p) {
          if (!o[0] && !o[1]) return e;
          const x = p ? h === "map" ? this.transform.angle : 0 : h === "viewport" ? -this.transform.angle : 0;
          if (x) {
            const P = Math.sin(x), F = Math.cos(x);
            o = [o[0] * F - o[1] * P, o[0] * P + o[1] * F];
          }
          const A = [p ? o[0] : fi(r, o[0], this.transform.zoom), p ? o[1] : fi(r, o[1], this.transform.zoom), 0], T = new Float32Array(16);
          return s.J(T, e, A), T;
        }
        saveTileTexture(e) {
          const r = this._tileTextures[e.size[0]];
          r ? r.push(e) : this._tileTextures[e.size[0]] = [e];
        }
        getTileTexture(e) {
          const r = this._tileTextures[e];
          return r && r.length > 0 ? r.pop() : null;
        }
        isPatternMissing(e) {
          if (!e) return !1;
          if (!e.from || !e.to) return !0;
          const r = this.imageManager.getPattern(e.from.toString()), o = this.imageManager.getPattern(e.to.toString());
          return !r || !o;
        }
        useProgram(e, r) {
          this.cache = this.cache || {};
          const o = e + (r ? r.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[o] || (this.cache[o] = new Xo(this.context, aa[e], r, Ns[e], this._showOverdrawInspector, this.style.map.terrain)), this.cache[o];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new X(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: e, drawingBufferHeight: r } = this.context.gl;
          return this.width !== e || this.height !== r;
        }
      }
      class Kr {
        constructor(e, r) {
          this.points = e, this.planes = r;
        }
        static fromInvProjectionMatrix(e, r, o) {
          const h = Math.pow(2, o), p = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((A) => {
            const T = 1 / (A = s.af([], A, e))[3] / r * h;
            return s.b1(A, A, [T, T, 1 / A[3], T]);
          }), x = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((A) => {
            const T = function(Z, G) {
              var V = G[0], W = G[1], ae = G[2], oe = V * V + W * W + ae * ae;
              return oe > 0 && (oe = 1 / Math.sqrt(oe)), Z[0] = G[0] * oe, Z[1] = G[1] * oe, Z[2] = G[2] * oe, Z;
            }([], function(Z, G, V) {
              var W = G[0], ae = G[1], oe = G[2], de = V[0], ce = V[1], we = V[2];
              return Z[0] = ae * we - oe * ce, Z[1] = oe * de - W * we, Z[2] = W * ce - ae * de, Z;
            }([], Ie([], p[A[0]], p[A[1]]), Ie([], p[A[2]], p[A[1]]))), P = -((F = T)[0] * (N = p[A[1]])[0] + F[1] * N[1] + F[2] * N[2]);
            var F, N;
            return T.concat(P);
          });
          return new Kr(p, x);
        }
      }
      class yn {
        constructor(e, r) {
          this.min = e, this.max = r, this.center = function(o, h, p) {
            return o[0] = 0.5 * h[0], o[1] = 0.5 * h[1], o[2] = 0.5 * h[2], o;
          }([], function(o, h, p) {
            return o[0] = h[0] + p[0], o[1] = h[1] + p[1], o[2] = h[2] + p[2], o;
          }([], this.min, this.max));
        }
        quadrant(e) {
          const r = [e % 2 == 0, e < 2], o = qe(this.min), h = qe(this.max);
          for (let p = 0; p < r.length; p++) o[p] = r[p] ? this.min[p] : this.center[p], h[p] = r[p] ? this.center[p] : this.max[p];
          return h[2] = this.max[2], new yn(o, h);
        }
        distanceX(e) {
          return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
        }
        distanceY(e) {
          return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
        }
        intersects(e) {
          const r = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let o = !0;
          for (let h = 0; h < e.planes.length; h++) {
            const p = e.planes[h];
            let x = 0;
            for (let A = 0; A < r.length; A++) s.b2(p, r[A]) >= 0 && x++;
            if (x === 0) return 0;
            x !== r.length && (o = !1);
          }
          if (o) return 2;
          for (let h = 0; h < 3; h++) {
            let p = Number.MAX_VALUE, x = -Number.MAX_VALUE;
            for (let A = 0; A < e.points.length; A++) {
              const T = e.points[A][h] - this.min[h];
              p = Math.min(p, T), x = Math.max(x, T);
            }
            if (x < 0 || p > this.max[h] - this.min[h]) return 0;
          }
          return 1;
        }
      }
      class Un {
        constructor(e = 0, r = 0, o = 0, h = 0) {
          if (isNaN(e) || e < 0 || isNaN(r) || r < 0 || isNaN(o) || o < 0 || isNaN(h) || h < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e, this.bottom = r, this.left = o, this.right = h;
        }
        interpolate(e, r, o) {
          return r.top != null && e.top != null && (this.top = s.y.number(e.top, r.top, o)), r.bottom != null && e.bottom != null && (this.bottom = s.y.number(e.bottom, r.bottom, o)), r.left != null && e.left != null && (this.left = s.y.number(e.left, r.left, o)), r.right != null && e.right != null && (this.right = s.y.number(e.right, r.right, o)), this;
        }
        getCenter(e, r) {
          const o = s.ac((this.left + e - this.right) / 2, 0, e), h = s.ac((this.top + r - this.bottom) / 2, 0, r);
          return new s.P(o, h);
        }
        equals(e) {
          return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
        }
        clone() {
          return new Un(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const _s = 85.051129;
      class Vn {
        constructor(e, r, o, h, p) {
          this.tileSize = 512, this._renderWorldCopies = p === void 0 || !!p, this._minZoom = e || 0, this._maxZoom = r || 22, this._minPitch = o ?? 0, this._maxPitch = h ?? 60, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new s.N(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new Un(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {}, this.minElevationForCurrentTile = 0;
        }
        clone() {
          const e = new Vn(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return e.apply(this), e;
        }
        apply(e) {
          this.tileSize = e.tileSize, this.latRange = e.latRange, this.lngRange = e.lngRange, this.width = e.width, this.height = e.height, this._center = e._center, this._elevation = e._elevation, this.minElevationForCurrentTile = e.minElevationForCurrentTile, this.zoom = e.zoom, this.angle = e.angle, this._fov = e._fov, this._pitch = e._pitch, this._unmodified = e._unmodified, this._edgeInsets = e._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(e) {
          this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(e) {
          this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(e) {
          this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(e) {
          this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(e) {
          e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new s.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(e) {
          const r = -s.b3(e, -180, 180) * Math.PI / 180;
          this.angle !== r && (this._unmodified = !1, this.angle = r, this._calcMatrices(), this.rotationMatrix = function() {
            var o = new s.A(4);
            return s.A != Float32Array && (o[1] = 0, o[2] = 0), o[0] = 1, o[3] = 1, o;
          }(), function(o, h, p) {
            var x = h[0], A = h[1], T = h[2], P = h[3], F = Math.sin(p), N = Math.cos(p);
            o[0] = x * N + T * F, o[1] = A * N + P * F, o[2] = x * -F + T * N, o[3] = A * -F + P * N;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(e) {
          const r = s.ac(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== r && (this._unmodified = !1, this._pitch = r, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(e) {
          e = Math.max(0.01, Math.min(60, e)), this._fov !== e && (this._unmodified = !1, this._fov = e / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(e) {
          const r = Math.min(Math.max(e, this.minZoom), this.maxZoom);
          this._zoom !== r && (this._unmodified = !1, this._zoom = r, this.tileZoom = Math.max(0, Math.floor(r)), this.scale = this.zoomScale(r), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(e) {
          e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(e) {
          e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(e) {
          this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(e) {
          return this._edgeInsets.equals(e);
        }
        interpolatePadding(e, r, o) {
          this._unmodified = !1, this._edgeInsets.interpolate(e, r, o), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(e) {
          const r = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
          return Math.max(0, r);
        }
        getVisibleUnwrappedCoordinates(e) {
          const r = [new s.b4(0, e)];
          if (this._renderWorldCopies) {
            const o = this.pointCoordinate(new s.P(0, 0)), h = this.pointCoordinate(new s.P(this.width, 0)), p = this.pointCoordinate(new s.P(this.width, this.height)), x = this.pointCoordinate(new s.P(0, this.height)), A = Math.floor(Math.min(o.x, h.x, p.x, x.x)), T = Math.floor(Math.max(o.x, h.x, p.x, x.x)), P = 1;
            for (let F = A - P; F <= T + P; F++) F !== 0 && r.push(new s.b4(F, e));
          }
          return r;
        }
        coveringTiles(e) {
          var r, o;
          let h = this.coveringZoomLevel(e);
          const p = h;
          if (e.minzoom !== void 0 && h < e.minzoom) return [];
          e.maxzoom !== void 0 && h > e.maxzoom && (h = e.maxzoom);
          const x = this.pointCoordinate(this.getCameraPoint()), A = s.Z.fromLngLat(this.center), T = Math.pow(2, h), P = [T * x.x, T * x.y, 0], F = [T * A.x, T * A.y, 0], N = Kr.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, h);
          let Z = e.minzoom || 0;
          !e.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (Z = h);
          const G = e.terrain ? 2 / Math.min(this.tileSize, e.tileSize) * this.tileSize : 3, V = (ce) => ({ aabb: new yn([ce * T, 0, 0], [(ce + 1) * T, T, 0]), zoom: 0, x: 0, y: 0, wrap: ce, fullyVisible: !1 }), W = [], ae = [], oe = h, de = e.reparseOverscaled ? p : h;
          if (this._renderWorldCopies) for (let ce = 1; ce <= 3; ce++) W.push(V(-ce)), W.push(V(ce));
          for (W.push(V(0)); W.length > 0; ) {
            const ce = W.pop(), we = ce.x, Le = ce.y;
            let ke = ce.fullyVisible;
            if (!ke) {
              const bt = ce.aabb.intersects(N);
              if (bt === 0) continue;
              ke = bt === 2;
            }
            const tt = e.terrain ? P : F, ht = ce.aabb.distanceX(tt), _t = ce.aabb.distanceY(tt), wt = Math.max(Math.abs(ht), Math.abs(_t));
            if (ce.zoom === oe || wt > G + (1 << oe - ce.zoom) - 2 && ce.zoom >= Z) {
              const bt = oe - ce.zoom, yt = P[0] - 0.5 - (we << bt), St = P[1] - 0.5 - (Le << bt);
              ae.push({ tileID: new s.S(ce.zoom === oe ? de : ce.zoom, ce.wrap, ce.zoom, we, Le), distanceSq: Ae([F[0] - 0.5 - we, F[1] - 0.5 - Le]), tileDistanceToCamera: Math.sqrt(yt * yt + St * St) });
            } else for (let bt = 0; bt < 4; bt++) {
              const yt = (we << 1) + bt % 2, St = (Le << 1) + (bt >> 1), Zt = ce.zoom + 1;
              let Ct = ce.aabb.quadrant(bt);
              if (e.terrain) {
                const Dt = new s.S(Zt, ce.wrap, Zt, yt, St), Wt = e.terrain.getMinMaxElevation(Dt), di = (r = Wt.minElevation) !== null && r !== void 0 ? r : this.elevation, ci = (o = Wt.maxElevation) !== null && o !== void 0 ? o : this.elevation;
                Ct = new yn([Ct.min[0], Ct.min[1], di], [Ct.max[0], Ct.max[1], ci]);
              }
              W.push({ aabb: Ct, zoom: Zt, x: yt, y: St, wrap: ce.wrap, fullyVisible: ke });
            }
          }
          return ae.sort((ce, we) => ce.distanceSq - we.distanceSq).map((ce) => ce.tileID);
        }
        resize(e, r) {
          this.width = e, this.height = r, this.pixelsToGLUnits = [2 / e, -2 / r], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(e) {
          return Math.pow(2, e);
        }
        scaleZoom(e) {
          return Math.log(e) / Math.LN2;
        }
        project(e) {
          const r = s.ac(e.lat, -85.051129, _s);
          return new s.P(s.O(e.lng) * this.worldSize, s.Q(r) * this.worldSize);
        }
        unproject(e) {
          return new s.Z(e.x / this.worldSize, e.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(e) {
          const r = this.elevation, o = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, h = this.pointLocation(this.centerPoint, e), p = e.getElevationForLngLatZoom(h, this.tileZoom);
          if (!(this.elevation - p)) return;
          const x = o + r - p, A = Math.cos(this._pitch) * this.cameraToCenterDistance / x / s.b5(1, h.lat), T = this.scaleZoom(A / this.tileSize);
          this._elevation = p, this._center = h, this.zoom = T;
        }
        setLocationAtPoint(e, r) {
          const o = this.pointCoordinate(r), h = this.pointCoordinate(this.centerPoint), p = this.locationCoordinate(e), x = new s.Z(p.x - (o.x - h.x), p.y - (o.y - h.y));
          this.center = this.coordinateLocation(x), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(e, r) {
          return r ? this.coordinatePoint(this.locationCoordinate(e), r.getElevationForLngLatZoom(e, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(e));
        }
        pointLocation(e, r) {
          return this.coordinateLocation(this.pointCoordinate(e, r));
        }
        locationCoordinate(e) {
          return s.Z.fromLngLat(e);
        }
        coordinateLocation(e) {
          return e && e.toLngLat();
        }
        pointCoordinate(e, r) {
          if (r) {
            const Z = r.pointCoordinate(e);
            if (Z != null) return Z;
          }
          const o = [e.x, e.y, 0, 1], h = [e.x, e.y, 1, 1];
          s.af(o, o, this.pixelMatrixInverse), s.af(h, h, this.pixelMatrixInverse);
          const p = o[3], x = h[3], A = o[1] / p, T = h[1] / x, P = o[2] / p, F = h[2] / x, N = P === F ? 0 : (0 - P) / (F - P);
          return new s.Z(s.y.number(o[0] / p, h[0] / x, N) / this.worldSize, s.y.number(A, T, N) / this.worldSize);
        }
        coordinatePoint(e, r = 0, o = this.pixelMatrix) {
          const h = [e.x * this.worldSize, e.y * this.worldSize, r, 1];
          return s.af(h, h, o), new s.P(h[0] / h[3], h[1] / h[3]);
        }
        getBounds() {
          const e = Math.max(0, this.height / 2 - this.getHorizon());
          return new Y().extend(this.pointLocation(new s.P(0, e))).extend(this.pointLocation(new s.P(this.width, e))).extend(this.pointLocation(new s.P(this.width, this.height))).extend(this.pointLocation(new s.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new Y([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(e) {
          e ? (this.lngRange = [e.getWest(), e.getEast()], this.latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, _s]);
        }
        calculateTileMatrix(e) {
          const r = e.canonical, o = this.worldSize / this.zoomScale(r.z), h = r.x + Math.pow(2, r.z) * e.wrap, p = s.an(new Float64Array(16));
          return s.J(p, p, [h * o, r.y * o, 0]), s.K(p, p, [o / s.X, o / s.X, 1]), p;
        }
        calculatePosMatrix(e, r = !1) {
          const o = e.key, h = r ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (h[o]) return h[o];
          const p = this.calculateTileMatrix(e);
          return s.L(p, r ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, p), h[o] = new Float32Array(p), h[o];
        }
        calculateFogMatrix(e) {
          const r = e.key, o = this._fogMatrixCache;
          if (o[r]) return o[r];
          const h = this.calculateTileMatrix(e);
          return s.L(h, this.fogMatrix, h), o[r] = new Float32Array(h), o[r];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        getConstrained(e, r) {
          r = s.ac(+r, this.minZoom, this.maxZoom);
          const o = { center: new s.N(e.lng, e.lat), zoom: r };
          let h = this.lngRange;
          if (!this._renderWorldCopies && h === null) {
            const ce = 179.9999999999;
            h = [-ce, ce];
          }
          const p = this.tileSize * this.zoomScale(o.zoom);
          let x = 0, A = p, T = 0, P = p, F = 0, N = 0;
          const { x: Z, y: G } = this.size;
          if (this.latRange) {
            const ce = this.latRange;
            x = s.Q(ce[1]) * p, A = s.Q(ce[0]) * p, A - x < G && (F = G / (A - x));
          }
          h && (T = s.b3(s.O(h[0]) * p, 0, p), P = s.b3(s.O(h[1]) * p, 0, p), P < T && (P += p), P - T < Z && (N = Z / (P - T)));
          const { x: V, y: W } = this.project.call({ worldSize: p }, e);
          let ae, oe;
          const de = Math.max(N || 0, F || 0);
          if (de) {
            const ce = new s.P(N ? (P + T) / 2 : V, F ? (A + x) / 2 : W);
            return o.center = this.unproject.call({ worldSize: p }, ce).wrap(), o.zoom += this.scaleZoom(de), o;
          }
          if (this.latRange) {
            const ce = G / 2;
            W - ce < x && (oe = x + ce), W + ce > A && (oe = A - ce);
          }
          if (h) {
            const ce = (T + P) / 2;
            let we = V;
            this._renderWorldCopies && (we = s.b3(V, ce - p / 2, ce + p / 2));
            const Le = Z / 2;
            we - Le < T && (ae = T + Le), we + Le > P && (ae = P - Le);
          }
          if (ae !== void 0 || oe !== void 0) {
            const ce = new s.P(ae ?? V, oe ?? W);
            o.center = this.unproject.call({ worldSize: p }, ce).wrap();
          }
          return o;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = !0;
          const e = this._unmodified, { center: r, zoom: o } = this.getConstrained(this.center, this.zoom);
          this.center = r, this.zoom = o, this._unmodified = e, this._constraining = !1;
        }
        _calcMatrices() {
          if (!this.height) return;
          const e = this.centerOffset, r = this.point.x, o = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = s.b5(1, this.center.lat) * this.worldSize;
          let h = s.an(new Float64Array(16));
          s.K(h, h, [this.width / 2, -this.height / 2, 1]), s.J(h, h, [1, -1, 0]), this.labelPlaneMatrix = h, h = s.an(new Float64Array(16)), s.K(h, h, [1, -1, 1]), s.J(h, h, [-1, -1, 0]), s.K(h, h, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h;
          const p = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), x = Math.min(this.elevation, this.minElevationForCurrentTile), A = p - x * this._pixelPerMeter / Math.cos(this._pitch), T = x < 0 ? A : p, P = Math.PI / 2 + this._pitch, F = this._fov * (0.5 + e.y / this.height), N = Math.sin(F) * T / Math.sin(s.ac(Math.PI - P - F, 0.01, Math.PI - 0.01)), Z = this.getHorizon(), G = 2 * Math.atan(Z / this.cameraToCenterDistance) * (0.5 + e.y / (2 * Z)), V = Math.sin(G) * T / Math.sin(s.ac(Math.PI - P - G, 0.01, Math.PI - 0.01)), W = Math.min(N, V);
          this.farZ = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * W + T), this.nearZ = this.height / 50, h = new Float64Array(16), s.b6(h, this._fov, this.width / this.height, this.nearZ, this.farZ), h[8] = 2 * -e.x / this.width, h[9] = 2 * e.y / this.height, this.projectionMatrix = s.ae(h), s.K(h, h, [1, -1, 1]), s.J(h, h, [0, 0, -this.cameraToCenterDistance]), s.b7(h, h, this._pitch), s.ad(h, h, this.angle), s.J(h, h, [-r, -o, 0]), this.mercatorMatrix = s.K([], h, [this.worldSize, this.worldSize, this.worldSize]), s.K(h, h, [1, 1, this._pixelPerMeter]), this.pixelMatrix = s.L(new Float64Array(16), this.labelPlaneMatrix, h), s.J(h, h, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = h, this.invModelViewProjectionMatrix = s.as([], h), this.fogMatrix = new Float64Array(16), s.b6(this.fogMatrix, this._fov, this.width / this.height, p, this.farZ), this.fogMatrix[8] = 2 * -e.x / this.width, this.fogMatrix[9] = 2 * e.y / this.height, s.K(this.fogMatrix, this.fogMatrix, [1, -1, 1]), s.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.cameraToCenterDistance]), s.b7(this.fogMatrix, this.fogMatrix, this._pitch), s.ad(this.fogMatrix, this.fogMatrix, this.angle), s.J(this.fogMatrix, this.fogMatrix, [-r, -o, 0]), s.K(this.fogMatrix, this.fogMatrix, [1, 1, this._pixelPerMeter]), s.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.elevation]), this.pixelMatrix3D = s.L(new Float64Array(16), this.labelPlaneMatrix, h);
          const ae = this.width % 2 / 2, oe = this.height % 2 / 2, de = Math.cos(this.angle), ce = Math.sin(this.angle), we = r - Math.round(r) + de * ae + ce * oe, Le = o - Math.round(o) + de * oe + ce * ae, ke = new Float64Array(h);
          if (s.J(ke, ke, [we > 0.5 ? we - 1 : we, Le > 0.5 ? Le - 1 : Le, 0]), this.alignedModelViewProjectionMatrix = ke, h = s.as(new Float64Array(16), this.pixelMatrix), !h) throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = h, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse) return 1;
          const e = this.pointCoordinate(new s.P(0, 0)), r = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
          return s.af(r, r, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new s.P(0, e));
        }
        getCameraQueryGeometry(e) {
          const r = this.getCameraPoint();
          if (e.length === 1) return [e[0], r];
          {
            let o = r.x, h = r.y, p = r.x, x = r.y;
            for (const A of e) o = Math.min(o, A.x), h = Math.min(h, A.y), p = Math.max(p, A.x), x = Math.max(x, A.y);
            return [new s.P(o, h), new s.P(p, h), new s.P(p, x), new s.P(o, x), new s.P(o, h)];
          }
        }
        lngLatToCameraDepth(e, r) {
          const o = this.locationCoordinate(e), h = [o.x * this.worldSize, o.y * this.worldSize, r, 1];
          return s.af(h, h, this.modelViewProjectionMatrix), h[2] / h[3];
        }
      }
      function $n(c, e) {
        let r, o = !1, h = null, p = null;
        const x = () => {
          h = null, o && (c.apply(p, r), h = setTimeout(x, e), o = !1);
        };
        return (...A) => (o = !0, p = this, r = A, h || x(), h);
      }
      class ys {
        constructor(e) {
          this._getCurrentHash = () => {
            const r = window.location.hash.replace("#", "");
            if (this._hashName) {
              let o;
              return r.split("&").map((h) => h.split("=")).forEach((h) => {
                h[0] === this._hashName && (o = h);
              }), (o && o[1] || "").split("/");
            }
            return r.split("/");
          }, this._onHashChange = () => {
            const r = this._getCurrentHash();
            if (r.length >= 3 && !r.some((o) => isNaN(o))) {
              const o = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(r[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+r[2], +r[1]], zoom: +r[0], bearing: o, pitch: +(r[4] || 0) }), !0;
            }
            return !1;
          }, this._updateHashUnthrottled = () => {
            const r = window.location.href.replace(/(#.*)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, r);
          }, this._removeHash = () => {
            const r = this._getCurrentHash();
            if (r.length === 0) return;
            const o = r.join("/");
            let h = o;
            h.split("&").length > 0 && (h = h.split("&")[0]), this._hashName && (h = `${this._hashName}=${o}`);
            let p = window.location.hash.replace(h, "");
            p.startsWith("#&") ? p = p.slice(0, 1) + p.slice(2) : p === "#" && (p = "");
            let x = window.location.href.replace(/(#.+)?$/, p);
            x = x.replace("&&", "&"), window.history.replaceState(window.history.state, null, x);
          }, this._updateHash = $n(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
        }
        addTo(e) {
          return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(e) {
          const r = this._map.getCenter(), o = Math.round(100 * this._map.getZoom()) / 100, h = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), p = Math.pow(10, h), x = Math.round(r.lng * p) / p, A = Math.round(r.lat * p) / p, T = this._map.getBearing(), P = this._map.getPitch();
          let F = "";
          if (F += e ? `/${x}/${A}/${o}` : `${o}/${A}/${x}`, (T || P) && (F += "/" + Math.round(10 * T) / 10), P && (F += `/${Math.round(P)}`), this._hashName) {
            const N = this._hashName;
            let Z = !1;
            const G = window.location.hash.slice(1).split("&").map((V) => {
              const W = V.split("=")[0];
              return W === N ? (Z = !0, `${W}=${F}`) : V;
            }).filter((V) => V);
            return Z || G.push(`${N}=${F}`), `#${G.join("&")}`;
          }
          return `#${F}`;
        }
      }
      const hn = { linearity: 0.3, easing: s.b8(0, 0, 0.3, 1) }, pa = s.e({ deceleration: 2500, maxSpeed: 1400 }, hn), tr = s.e({ deceleration: 20, maxSpeed: 1400 }, hn), Yi = s.e({ deceleration: 1e3, maxSpeed: 360 }, hn), dr = s.e({ deceleration: 1e3, maxSpeed: 90 }, hn);
      class Er {
        constructor(e) {
          this._map = e, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(e) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: q.now(), settings: e });
        }
        _drainInertiaBuffer() {
          const e = this._inertiaBuffer, r = q.now();
          for (; e.length > 0 && r - e[0].time > 160; ) e.shift();
        }
        _onMoveEnd(e) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          const r = { zoom: 0, bearing: 0, pitch: 0, pan: new s.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: p } of this._inertiaBuffer) r.zoom += p.zoomDelta || 0, r.bearing += p.bearingDelta || 0, r.pitch += p.pitchDelta || 0, p.panDelta && r.pan._add(p.panDelta), p.around && (r.around = p.around), p.pinchAround && (r.pinchAround = p.pinchAround);
          const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, h = {};
          if (r.pan.mag()) {
            const p = Zn(r.pan.mag(), o, s.e({}, pa, e || {}));
            h.offset = r.pan.mult(p.amount / r.pan.mag()), h.center = this._map.transform.center, Dn(h, p);
          }
          if (r.zoom) {
            const p = Zn(r.zoom, o, tr);
            h.zoom = this._map.transform.zoom + p.amount, Dn(h, p);
          }
          if (r.bearing) {
            const p = Zn(r.bearing, o, Yi);
            h.bearing = this._map.transform.bearing + s.ac(p.amount, -179, 179), Dn(h, p);
          }
          if (r.pitch) {
            const p = Zn(r.pitch, o, dr);
            h.pitch = this._map.transform.pitch + p.amount, Dn(h, p);
          }
          if (h.zoom || h.bearing) {
            const p = r.pinchAround === void 0 ? r.around : r.pinchAround;
            h.around = p ? this._map.unproject(p) : this._map.getCenter();
          }
          return this.clear(), s.e(h, { noMoveStart: !0 });
        }
      }
      function Dn(c, e) {
        (!c.duration || c.duration < e.duration) && (c.duration = e.duration, c.easing = e.easing);
      }
      function Zn(c, e, r) {
        const { maxSpeed: o, linearity: h, deceleration: p } = r, x = s.ac(c * h / (e / 1e3), -o, o), A = Math.abs(x) / (p * h);
        return { easing: r.easing, duration: 1e3 * A, amount: x * (A / 2) };
      }
      class Tr extends s.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e, r, o, h = {}) {
          const p = O.mousePos(r.getCanvas(), o), x = r.unproject(p);
          super(e, s.e({ point: p, lngLat: x, originalEvent: o }, h)), this._defaultPrevented = !1, this.target = r;
        }
      }
      class Ia extends s.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e, r, o) {
          const h = e === "touchend" ? o.changedTouches : o.touches, p = O.touchPos(r.getCanvasContainer(), h), x = p.map((T) => r.unproject(T)), A = p.reduce((T, P, F, N) => T.add(P.div(N.length)), new s.P(0, 0));
          super(e, { points: p, point: A, lngLats: x, lngLat: r.unproject(A), originalEvent: o }), this._defaultPrevented = !1;
        }
      }
      class nu extends s.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e, r, o) {
          super(e, { originalEvent: o }), this._defaultPrevented = !1;
        }
      }
      class au {
        constructor(e, r) {
          this._map = e, this._clickTolerance = r.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(e) {
          return this._firePreventable(new nu(e.type, this._map, e));
        }
        mousedown(e, r) {
          return this._mousedownPos = r, this._firePreventable(new Tr(e.type, this._map, e));
        }
        mouseup(e) {
          this._map.fire(new Tr(e.type, this._map, e));
        }
        click(e, r) {
          this._mousedownPos && this._mousedownPos.dist(r) >= this._clickTolerance || this._map.fire(new Tr(e.type, this._map, e));
        }
        dblclick(e) {
          return this._firePreventable(new Tr(e.type, this._map, e));
        }
        mouseover(e) {
          this._map.fire(new Tr(e.type, this._map, e));
        }
        mouseout(e) {
          this._map.fire(new Tr(e.type, this._map, e));
        }
        touchstart(e) {
          return this._firePreventable(new Ia(e.type, this._map, e));
        }
        touchmove(e) {
          this._map.fire(new Ia(e.type, this._map, e));
        }
        touchend(e) {
          this._map.fire(new Ia(e.type, this._map, e));
        }
        touchcancel(e) {
          this._map.fire(new Ia(e.type, this._map, e));
        }
        _firePreventable(e) {
          if (this._map.fire(e), e.defaultPrevented) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class gr {
        constructor(e) {
          this._map = e;
        }
        reset() {
          this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
        }
        mousemove(e) {
          this._map.fire(new Tr(e.type, this._map, e));
        }
        mousedown() {
          this._delayContextMenu = !0, this._ignoreContextMenu = !1;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Tr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e) {
          this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Tr(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Gn {
        constructor(e) {
          this._map = e;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(e) {
          return this.transform.pointLocation(s.P.convert(e), this._map.terrain);
        }
      }
      class vn {
        constructor(e, r) {
          this._map = e, this._tr = new Gn(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = r.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(e, r) {
          this.isEnabled() && e.shiftKey && e.button === 0 && (O.disableDrag(), this._startPos = this._lastPos = r, this._active = !0);
        }
        mousemoveWindow(e, r) {
          if (!this._active) return;
          const o = r;
          if (this._lastPos.equals(o) || !this._box && o.dist(this._startPos) < this._clickTolerance) return;
          const h = this._startPos;
          this._lastPos = o, this._box || (this._box = O.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
          const p = Math.min(h.x, o.x), x = Math.max(h.x, o.x), A = Math.min(h.y, o.y), T = Math.max(h.y, o.y);
          O.setTransform(this._box, `translate(${p}px,${A}px)`), this._box.style.width = x - p + "px", this._box.style.height = T - A + "px";
        }
        mouseupWindow(e, r) {
          if (!this._active || e.button !== 0) return;
          const o = this._startPos, h = r;
          if (this.reset(), O.suppressClick(), o.x !== h.x || o.y !== h.y) return this._map.fire(new s.k("boxzoomend", { originalEvent: e })), { cameraAnimation: (p) => p.fitScreenCoordinates(o, h, this._tr.bearing, { linear: !0 }) };
          this._fireEvent("boxzoomcancel", e);
        }
        keydown(e) {
          this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
        }
        reset() {
          this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (O.remove(this._box), this._box = null), O.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(e, r) {
          return this._map.fire(new s.k(e, { originalEvent: r }));
        }
      }
      function _o(c, e) {
        if (c.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${c.length}, points ${e.length}`);
        const r = {};
        for (let o = 0; o < c.length; o++) r[c[o].identifier] = e[o];
        return r;
      }
      class il {
        constructor(e) {
          this.reset(), this.numTouches = e.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }
        touchstart(e, r, o) {
          (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), o.length === this.numTouches && (this.centroid = function(h) {
            const p = new s.P(0, 0);
            for (const x of h) p._add(x);
            return p.div(h.length);
          }(r), this.touches = _o(o, r)));
        }
        touchmove(e, r, o) {
          if (this.aborted || !this.centroid) return;
          const h = _o(o, r);
          for (const p in this.touches) {
            const x = h[p];
            (!x || x.dist(this.touches[p]) > 30) && (this.aborted = !0);
          }
        }
        touchend(e, r, o) {
          if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), o.length === 0) {
            const h = !this.aborted && this.centroid;
            if (this.reset(), h) return h;
          }
        }
      }
      class Os {
        constructor(e) {
          this.singleTap = new il(e), this.numTaps = e.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(e, r, o) {
          this.singleTap.touchstart(e, r, o);
        }
        touchmove(e, r, o) {
          this.singleTap.touchmove(e, r, o);
        }
        touchend(e, r, o) {
          const h = this.singleTap.touchend(e, r, o);
          if (h) {
            const p = e.timeStamp - this.lastTime < 500, x = !this.lastTap || this.lastTap.dist(h) < 30;
            if (p && x || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = h, this.count === this.numTaps) return this.reset(), h;
          }
        }
      }
      class Fr {
        constructor(e) {
          this._tr = new Gn(e), this._zoomIn = new Os({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Os({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e, r, o) {
          this._zoomIn.touchstart(e, r, o), this._zoomOut.touchstart(e, r, o);
        }
        touchmove(e, r, o) {
          this._zoomIn.touchmove(e, r, o), this._zoomOut.touchmove(e, r, o);
        }
        touchend(e, r, o) {
          const h = this._zoomIn.touchend(e, r, o), p = this._zoomOut.touchend(e, r, o), x = this._tr;
          return h ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (A) => A.easeTo({ duration: 300, zoom: x.zoom + 1, around: x.unproject(h) }, { originalEvent: e }) }) : p ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (A) => A.easeTo({ duration: 300, zoom: x.zoom - 1, around: x.unproject(p) }, { originalEvent: e }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Pr {
        constructor(e) {
          this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
        }
        reset(e) {
          this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e);
        }
        _move(...e) {
          const r = this._moveFunction(...e);
          if (r.bearingDelta || r.pitchDelta || r.around || r.panDelta) return this._active = !0, r;
        }
        dragStart(e, r) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = r.length ? r[0] : r, this._activateOnStart && this._lastPoint && (this._active = !0));
        }
        dragMove(e, r) {
          if (!this.isEnabled()) return;
          const o = this._lastPoint;
          if (!o) return;
          if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
          const h = r.length ? r[0] : r;
          return !this._moved && h.dist(o) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = h, this._move(o, h));
        }
        dragEnd(e) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && O.suppressClick(), this.reset(e));
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const yo = { 0: 1, 2: 2 };
      class js {
        constructor(e) {
          this._correctEvent = e.checkCorrectEvent;
        }
        startMove(e) {
          const r = O.mouseButton(e);
          this._eventButton = r;
        }
        endMove(e) {
          delete this._eventButton;
        }
        isValidStartEvent(e) {
          return this._correctEvent(e);
        }
        isValidMoveEvent(e) {
          return !function(r, o) {
            const h = yo[o];
            return r.buttons === void 0 || (r.buttons & h) !== h;
          }(e, this._eventButton);
        }
        isValidEndEvent(e) {
          return O.mouseButton(e) === this._eventButton;
        }
      }
      class Pl {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(e) {
          return e.targetTouches.length === 1;
        }
        _isSameTouchEvent(e) {
          return e.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(e) {
          this._firstTouch = e.targetTouches[0].identifier;
        }
        endMove(e) {
          delete this._firstTouch;
        }
        isValidStartEvent(e) {
          return this._isOneFingerTouch(e);
        }
        isValidMoveEvent(e) {
          return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
        }
        isValidEndEvent(e) {
          return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
        }
      }
      const qs = (c) => {
        c.mousedown = c.dragStart, c.mousemoveWindow = c.dragMove, c.mouseup = c.dragEnd, c.contextmenu = (e) => {
          e.preventDefault();
        };
      }, vo = ({ enable: c, clickTolerance: e, bearingDegreesPerPixelMoved: r = 0.8 }) => {
        const o = new js({ checkCorrectEvent: (h) => O.mouseButton(h) === 0 && h.ctrlKey || O.mouseButton(h) === 2 });
        return new Pr({ clickTolerance: e, move: (h, p) => ({ bearingDelta: (p.x - h.x) * r }), moveStateManager: o, enable: c, assignEvents: qs });
      }, rl = ({ enable: c, clickTolerance: e, pitchDegreesPerPixelMoved: r = -0.5 }) => {
        const o = new js({ checkCorrectEvent: (h) => O.mouseButton(h) === 0 && h.ctrlKey || O.mouseButton(h) === 2 });
        return new Pr({ clickTolerance: e, move: (h, p) => ({ pitchDelta: (p.y - h.y) * r }), moveStateManager: o, enable: c, assignEvents: qs });
      };
      class vs {
        constructor(e, r) {
          this._clickTolerance = e.clickTolerance || 1, this._map = r, this.reset();
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new s.P(0, 0);
        }
        _shouldBePrevented(e) {
          return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(e, r, o) {
          return this._calculateTransform(e, r, o);
        }
        touchmove(e, r, o) {
          if (this._active) {
            if (!this._shouldBePrevented(o.length)) return e.preventDefault(), this._calculateTransform(e, r, o);
            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
          }
        }
        touchend(e, r, o) {
          this._calculateTransform(e, r, o), this._active && this._shouldBePrevented(o.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(e, r, o) {
          o.length > 0 && (this._active = !0);
          const h = _o(o, r), p = new s.P(0, 0), x = new s.P(0, 0);
          let A = 0;
          for (const P in h) {
            const F = h[P], N = this._touches[P];
            N && (p._add(F), x._add(F.sub(N)), A++, h[P] = F);
          }
          if (this._touches = h, this._shouldBePrevented(A) || !x.mag()) return;
          const T = x.div(A);
          return this._sum._add(T), this._sum.mag() < this._clickTolerance ? void 0 : { around: p.div(A), panDelta: T };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class bo {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, delete this._firstTwoTouches;
        }
        touchstart(e, r, o) {
          this._firstTwoTouches || o.length < 2 || (this._firstTwoTouches = [o[0].identifier, o[1].identifier], this._start([r[0], r[1]]));
        }
        touchmove(e, r, o) {
          if (!this._firstTwoTouches) return;
          e.preventDefault();
          const [h, p] = this._firstTwoTouches, x = Us(o, r, h), A = Us(o, r, p);
          if (!x || !A) return;
          const T = this._aroundCenter ? null : x.add(A).div(2);
          return this._move([x, A], T, e);
        }
        touchend(e, r, o) {
          if (!this._firstTwoTouches) return;
          const [h, p] = this._firstTwoTouches, x = Us(o, r, h), A = Us(o, r, p);
          x && A || (this._active && O.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e) {
          this._enabled = !0, this._aroundCenter = !!e && e.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function Us(c, e, r) {
        for (let o = 0; o < c.length; o++) if (c[o].identifier === r) return e[o];
      }
      function xo(c, e) {
        return Math.log(c / e) / Math.LN2;
      }
      class nl extends bo {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(e) {
          this._startDistance = this._distance = e[0].dist(e[1]);
        }
        _move(e, r) {
          const o = this._distance;
          if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(xo(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: xo(this._distance, o), pinchAround: r };
        }
      }
      function su(c, e) {
        return 180 * c.angleWith(e) / Math.PI;
      }
      class ou extends bo {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(e) {
          this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
        }
        _move(e, r, o) {
          const h = this._vector;
          if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: su(this._vector, h), pinchAround: r };
        }
        _isBelowThreshold(e) {
          this._minDiameter = Math.min(this._minDiameter, e.mag());
          const r = 25 / (Math.PI * this._minDiameter) * 360, o = su(e, this._startVector);
          return Math.abs(o) < r;
        }
      }
      function al(c) {
        return Math.abs(c.y) > Math.abs(c.x);
      }
      class wo extends bo {
        constructor(e) {
          super(), this._currentTouchCount = 0, this._map = e;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(e, r, o) {
          super.touchstart(e, r, o), this._currentTouchCount = o.length;
        }
        _start(e) {
          this._lastPoints = e, al(e[0].sub(e[1])) && (this._valid = !1);
        }
        _move(e, r, o) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
          const h = e[0].sub(this._lastPoints[0]), p = e[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(h, p, o.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, { pitchDelta: (h.y + p.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(e, r, o) {
          if (this._valid !== void 0) return this._valid;
          const h = e.mag() >= 2, p = r.mag() >= 2;
          if (!h && !p) return;
          if (!h || !p) return this._firstMove === void 0 && (this._firstMove = o), o - this._firstMove < 100 && void 0;
          const x = e.y > 0 == r.y > 0;
          return al(e) && al(r) && x;
        }
      }
      const zu = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Hn {
        constructor(e) {
          this._tr = new Gn(e);
          const r = zu;
          this._panStep = r.panStep, this._bearingStep = r.bearingStep, this._pitchStep = r.pitchStep, this._rotationDisabled = !1;
        }
        reset() {
          this._active = !1;
        }
        keydown(e) {
          if (e.altKey || e.ctrlKey || e.metaKey) return;
          let r = 0, o = 0, h = 0, p = 0, x = 0;
          switch (e.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              r = 1;
              break;
            case 189:
            case 109:
            case 173:
              r = -1;
              break;
            case 37:
              e.shiftKey ? o = -1 : (e.preventDefault(), p = -1);
              break;
            case 39:
              e.shiftKey ? o = 1 : (e.preventDefault(), p = 1);
              break;
            case 38:
              e.shiftKey ? h = 1 : (e.preventDefault(), x = -1);
              break;
            case 40:
              e.shiftKey ? h = -1 : (e.preventDefault(), x = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (o = 0, h = 0), { cameraAnimation: (A) => {
            const T = this._tr;
            A.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ka, zoom: r ? Math.round(T.zoom) + r * (e.shiftKey ? 2 : 1) : T.zoom, bearing: T.bearing + o * this._bearingStep, pitch: T.pitch + h * this._pitchStep, offset: [-p * this._panStep, -x * this._panStep], center: T.center }, { originalEvent: e });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function ka(c) {
        return c * (2 - c);
      }
      const lu = 4.000244140625;
      class In {
        constructor(e, r) {
          this._onTimeout = (o) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(o);
          }, this._map = e, this._tr = new Gn(e), this._triggerRenderFrame = r, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(e) {
          this._defaultZoomRate = e;
        }
        setWheelZoomRate(e) {
          this._wheelZoomRate = e;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        _shouldBePrevented(e) {
          return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
        }
        wheel(e) {
          if (!this.isEnabled()) return;
          if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
          let r = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
          const o = q.now(), h = o - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = o, r !== 0 && r % lu == 0 ? this._type = "wheel" : r !== 0 && Math.abs(r) < 4 ? this._type = "trackpad" : h > 400 ? (this._type = null, this._lastValue = r, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(h * r) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, r += this._lastValue)), e.shiftKey && r && (r /= 4), this._type && (this._lastWheelEvent = e, this._delta -= r, this._active || this._start(e)), e.preventDefault();
        }
        _start(e) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const r = O.mousePos(this._map.getCanvas(), e), o = this._tr;
          this._around = r.y > o.transform.height / 2 - o.transform.getHorizon() ? s.N.convert(this._aroundCenter ? o.center : o.unproject(r)) : s.N.convert(o.center), this._aroundPoint = o.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive())) return;
          const e = this._tr.transform;
          if (this._delta !== 0) {
            const T = this._type === "wheel" && Math.abs(this._delta) > lu ? this._wheelZoomRate : this._defaultZoomRate;
            let P = 2 / (1 + Math.exp(-Math.abs(this._delta * T)));
            this._delta < 0 && P !== 0 && (P = 1 / P);
            const F = typeof this._targetZoom == "number" ? e.zoomScale(this._targetZoom) : e.scale;
            this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, e.scaleZoom(F * P))), this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const r = typeof this._targetZoom == "number" ? this._targetZoom : e.zoom, o = this._startZoom, h = this._easing;
          let p, x = !1;
          const A = q.now() - this._lastWheelEventTime;
          if (this._type === "wheel" && o && h && A) {
            const T = Math.min(A / 200, 1), P = h(T);
            p = s.y.number(o, r, P), T < 1 ? this._frameId || (this._frameId = !0) : x = !0;
          } else p = r, x = !0;
          return this._active = !0, x && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !x, zoomDelta: p - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(e) {
          let r = s.b9;
          if (this._prevEase) {
            const o = this._prevEase, h = (q.now() - o.start) / o.duration, p = o.easing(h + 0.01) - o.easing(h), x = 0.27 / Math.sqrt(p * p + 1e-4) * 0.01, A = Math.sqrt(0.0729 - x * x);
            r = s.b8(x, A, 0.25, 1);
          }
          return this._prevEase = { start: q.now(), duration: e, easing: r }, r;
        }
        reset() {
          this._active = !1, this._zooming = !1, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class Xa {
        constructor(e, r) {
          this._clickZoom = e, this._tapZoom = r;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class sl {
        constructor(e) {
          this._tr = new Gn(e), this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(e, r) {
          return e.preventDefault(), { cameraAnimation: (o) => {
            o.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(r) }, { originalEvent: e });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Sc {
        constructor() {
          this._tap = new Os({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(e, r, o) {
          if (!this._swipePoint) if (this._tapTime) {
            const h = r[0], p = e.timeStamp - this._tapTime < 500, x = this._tapPoint.dist(h) < 30;
            p && x ? o.length > 0 && (this._swipePoint = h, this._swipeTouch = o[0].identifier) : this.reset();
          } else this._tap.touchstart(e, r, o);
        }
        touchmove(e, r, o) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (o[0].identifier !== this._swipeTouch) return;
              const h = r[0], p = h.y - this._swipePoint.y;
              return this._swipePoint = h, e.preventDefault(), this._active = !0, { zoomDelta: p / 128 };
            }
          } else this._tap.touchmove(e, r, o);
        }
        touchend(e, r, o) {
          if (this._tapTime) this._swipePoint && o.length === 0 && this.reset();
          else {
            const h = this._tap.touchend(e, r, o);
            h && (this._tapTime = e.timeStamp, this._tapPoint = h);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Fu {
        constructor(e, r, o) {
          this._el = e, this._mousePan = r, this._touchPan = o;
        }
        enable(e) {
          this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class uu {
        constructor(e, r, o) {
          this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = r, this._mousePitch = o;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class cu {
        constructor(e, r, o, h) {
          this._el = e, this._touchZoom = r, this._touchRotate = o, this._tapDragZoom = h, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(e) {
          this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class Ao {
        constructor(e, r) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = r, this._enabled = !1;
        }
        isActive() {
          return !1;
        }
        reset() {
        }
        _setupUI() {
          if (this._container) return;
          const e = this._map.getCanvasContainer();
          e.classList.add("maplibregl-cooperative-gestures"), this._container = O.create("div", "maplibregl-cooperative-gesture-screen", e);
          let r = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (r = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const o = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), h = document.createElement("div");
          h.className = "maplibregl-desktop-message", h.textContent = r, this._container.appendChild(h);
          const p = document.createElement("div");
          p.className = "maplibregl-mobile-message", p.textContent = o, this._container.appendChild(p), this._container.setAttribute("aria-hidden", "true");
        }
        _destroyUI() {
          this._container && (O.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(e) {
          return e[this._bypassKey];
        }
        notifyGestureBlocked(e, r) {
          this._enabled && (this._map.fire(new s.k("cooperativegestureprevented", { gestureType: e, originalEvent: r })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const Wn = (c) => c.zoom || c.drag || c.pitch || c.rotate;
      class Ot extends s.k {
      }
      function fa(c) {
        return c.panDelta && c.panDelta.mag() || c.zoomDelta || c.bearingDelta || c.pitchDelta;
      }
      class kn {
        constructor(e, r) {
          this.handleWindowEvent = (h) => {
            this.handleEvent(h, `${h.type}Window`);
          }, this.handleEvent = (h, p) => {
            if (h.type === "blur") return void this.stop(!0);
            this._updatingCamera = !0;
            const x = h.type === "renderFrame" ? void 0 : h, A = { needsRenderFrame: !1 }, T = {}, P = {}, F = h.touches, N = F ? this._getMapTouches(F) : void 0, Z = N ? O.touchPos(this._map.getCanvas(), N) : O.mousePos(this._map.getCanvas(), h);
            for (const { handlerName: W, handler: ae, allowed: oe } of this._handlers) {
              if (!ae.isEnabled()) continue;
              let de;
              this._blockedByActive(P, oe, W) ? ae.reset() : ae[p || h.type] && (de = ae[p || h.type](h, Z, N), this.mergeHandlerResult(A, T, de, W, x), de && de.needsRenderFrame && this._triggerRenderFrame()), (de || ae.isActive()) && (P[W] = ae);
            }
            const G = {};
            for (const W in this._previousActiveHandlers) P[W] || (G[W] = x);
            this._previousActiveHandlers = P, (Object.keys(G).length || fa(A)) && (this._changes.push([A, T, G]), this._triggerRenderFrame()), (Object.keys(P).length || fa(A)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: V } = A;
            V && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], V(this._map));
          }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Er(e), this._bearingSnap = r.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(r);
          const o = this._el;
          this._listeners = [[o, "touchstart", { passive: !0 }], [o, "touchmove", { passive: !1 }], [o, "touchend", void 0], [o, "touchcancel", void 0], [o, "mousedown", void 0], [o, "mousemove", void 0], [o, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [o, "mouseover", void 0], [o, "mouseout", void 0], [o, "dblclick", void 0], [o, "click", void 0], [o, "keydown", { capture: !1 }], [o, "keyup", void 0], [o, "wheel", { passive: !1 }], [o, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [h, p, x] of this._listeners) O.addEventListener(h, p, h === document ? this.handleWindowEvent : this.handleEvent, x);
        }
        destroy() {
          for (const [e, r, o] of this._listeners) O.removeEventListener(e, r, e === document ? this.handleWindowEvent : this.handleEvent, o);
        }
        _addDefaultHandlers(e) {
          const r = this._map, o = r.getCanvasContainer();
          this._add("mapEvent", new au(r, e));
          const h = r.boxZoom = new vn(r, e);
          this._add("boxZoom", h), e.interactive && e.boxZoom && h.enable();
          const p = r.cooperativeGestures = new Ao(r, e.cooperativeGestures);
          this._add("cooperativeGestures", p), e.cooperativeGestures && p.enable();
          const x = new Fr(r), A = new sl(r);
          r.doubleClickZoom = new Xa(A, x), this._add("tapZoom", x), this._add("clickZoom", A), e.interactive && e.doubleClickZoom && r.doubleClickZoom.enable();
          const T = new Sc();
          this._add("tapDragZoom", T);
          const P = r.touchPitch = new wo(r);
          this._add("touchPitch", P), e.interactive && e.touchPitch && r.touchPitch.enable(e.touchPitch);
          const F = vo(e), N = rl(e);
          r.dragRotate = new uu(e, F, N), this._add("mouseRotate", F, ["mousePitch"]), this._add("mousePitch", N, ["mouseRotate"]), e.interactive && e.dragRotate && r.dragRotate.enable();
          const Z = (({ enable: de, clickTolerance: ce }) => {
            const we = new js({ checkCorrectEvent: (Le) => O.mouseButton(Le) === 0 && !Le.ctrlKey });
            return new Pr({ clickTolerance: ce, move: (Le, ke) => ({ around: ke, panDelta: ke.sub(Le) }), activateOnStart: !0, moveStateManager: we, enable: de, assignEvents: qs });
          })(e), G = new vs(e, r);
          r.dragPan = new Fu(o, Z, G), this._add("mousePan", Z), this._add("touchPan", G, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && r.dragPan.enable(e.dragPan);
          const V = new ou(), W = new nl();
          r.touchZoomRotate = new cu(o, W, V, T), this._add("touchRotate", V, ["touchPan", "touchZoom"]), this._add("touchZoom", W, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && r.touchZoomRotate.enable(e.touchZoomRotate);
          const ae = r.scrollZoom = new In(r, () => this._triggerRenderFrame());
          this._add("scrollZoom", ae, ["mousePan"]), e.interactive && e.scrollZoom && r.scrollZoom.enable(e.scrollZoom);
          const oe = r.keyboard = new Hn(r);
          this._add("keyboard", oe), e.interactive && e.keyboard && r.keyboard.enable(), this._add("blockableMapEvent", new gr(r));
        }
        _add(e, r, o) {
          this._handlers.push({ handlerName: e, handler: r, allowed: o }), this._handlersById[e] = r;
        }
        stop(e) {
          if (!this._updatingCamera) {
            for (const { handler: r } of this._handlers) r.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: e } of this._handlers) if (e.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!Wn(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(e, r, o) {
          for (const h in e) if (h !== o && (!r || r.indexOf(h) < 0)) return !0;
          return !1;
        }
        _getMapTouches(e) {
          const r = [];
          for (const o of e) this._el.contains(o.target) && r.push(o);
          return r;
        }
        mergeHandlerResult(e, r, o, h, p) {
          if (!o) return;
          s.e(e, o);
          const x = { handlerName: h, originalEvent: o.originalEvent || p };
          o.zoomDelta !== void 0 && (r.zoom = x), o.panDelta !== void 0 && (r.drag = x), o.pitchDelta !== void 0 && (r.pitch = x), o.bearingDelta !== void 0 && (r.rotate = x);
        }
        _applyChanges() {
          const e = {}, r = {}, o = {};
          for (const [h, p, x] of this._changes) h.panDelta && (e.panDelta = (e.panDelta || new s.P(0, 0))._add(h.panDelta)), h.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + h.zoomDelta), h.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + h.bearingDelta), h.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + h.pitchDelta), h.around !== void 0 && (e.around = h.around), h.pinchAround !== void 0 && (e.pinchAround = h.pinchAround), h.noInertia && (e.noInertia = h.noInertia), s.e(r, p), s.e(o, x);
          this._updateMapTransform(e, r, o), this._changes = [];
        }
        _updateMapTransform(e, r, o) {
          const h = this._map, p = h._getTransformForUpdate(), x = h.terrain;
          if (!(fa(e) || x && this._terrainMovement)) return this._fireEvents(r, o, !0);
          let { panDelta: A, zoomDelta: T, bearingDelta: P, pitchDelta: F, around: N, pinchAround: Z } = e;
          Z !== void 0 && (N = Z), h._stop(!0), N = N || h.transform.centerPoint;
          const G = p.pointLocation(A ? N.sub(A) : N);
          P && (p.bearing += P), F && (p.pitch += F), T && (p.zoom += T), x ? this._terrainMovement || !r.drag && !r.zoom ? r.drag && this._terrainMovement ? p.center = p.pointLocation(p.centerPoint.sub(A)) : p.setLocationAtPoint(G, N) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, p.setLocationAtPoint(G, N)) : p.setLocationAtPoint(G, N), h._applyUpdatedTransform(p), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(r, o, !0);
        }
        _fireEvents(e, r, o) {
          const h = Wn(this._eventsInProgress), p = Wn(e), x = {};
          for (const N in e) {
            const { originalEvent: Z } = e[N];
            this._eventsInProgress[N] || (x[`${N}start`] = Z), this._eventsInProgress[N] = e[N];
          }
          !h && p && this._fireEvent("movestart", p.originalEvent);
          for (const N in x) this._fireEvent(N, x[N]);
          p && this._fireEvent("move", p.originalEvent);
          for (const N in e) {
            const { originalEvent: Z } = e[N];
            this._fireEvent(N, Z);
          }
          const A = {};
          let T;
          for (const N in this._eventsInProgress) {
            const { handlerName: Z, originalEvent: G } = this._eventsInProgress[N];
            this._handlersById[Z].isActive() || (delete this._eventsInProgress[N], T = r[Z] || G, A[`${N}end`] = T);
          }
          for (const N in A) this._fireEvent(N, A[N]);
          const P = Wn(this._eventsInProgress), F = (h || p) && !P;
          if (F && this._terrainMovement) {
            this._map._elevationFreeze = !1, this._terrainMovement = !1;
            const N = this._map._getTransformForUpdate();
            N.recalculateZoom(this._map.terrain), this._map._applyUpdatedTransform(N);
          }
          if (o && F) {
            this._updatingCamera = !0;
            const N = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), Z = (G) => G !== 0 && -this._bearingSnap < G && G < this._bearingSnap;
            !N || !N.essential && q.prefersReducedMotion ? (this._map.fire(new s.k("moveend", { originalEvent: T })), Z(this._map.getBearing()) && this._map.resetNorth()) : (Z(N.bearing || this._map.getBearing()) && (N.bearing = 0), N.freezeElevation = !0, this._map.easeTo(N, { originalEvent: T })), this._updatingCamera = !1;
          }
        }
        _fireEvent(e, r) {
          this._map.fire(new s.k(e, r ? { originalEvent: r } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e) => {
            delete this._frameId, this.handleEvent(new Ot("renderFrame", { timeStamp: e })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      class Pa extends s.E {
        constructor(e, r) {
          super(), this._renderFrameCallback = () => {
            const o = Math.min((q.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(o)), o < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = r.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new s.N(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e, r) {
          return this.jumpTo({ center: e }, r);
        }
        panBy(e, r, o) {
          return e = s.P.convert(e).mult(-1), this.panTo(this.transform.center, s.e({ offset: e }, r), o);
        }
        panTo(e, r, o) {
          return this.easeTo(s.e({ center: e }, r), o);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e, r) {
          return this.jumpTo({ zoom: e }, r), this;
        }
        zoomTo(e, r, o) {
          return this.easeTo(s.e({ zoom: e }, r), o);
        }
        zoomIn(e, r) {
          return this.zoomTo(this.getZoom() + 1, e, r), this;
        }
        zoomOut(e, r) {
          return this.zoomTo(this.getZoom() - 1, e, r), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e, r) {
          return this.jumpTo({ bearing: e }, r), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e, r) {
          return this.jumpTo({ padding: e }, r), this;
        }
        rotateTo(e, r, o) {
          return this.easeTo(s.e({ bearing: e }, r), o);
        }
        resetNorth(e, r) {
          return this.rotateTo(0, s.e({ duration: 1e3 }, e), r), this;
        }
        resetNorthPitch(e, r) {
          return this.easeTo(s.e({ bearing: 0, pitch: 0, duration: 1e3 }, e), r), this;
        }
        snapToNorth(e, r) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, r) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e, r) {
          return this.jumpTo({ pitch: e }, r), this;
        }
        cameraForBounds(e, r) {
          e = Y.convert(e).adjustAntiMeridian();
          const o = r && r.bearing || 0;
          return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), o, r);
        }
        _cameraForBoxAndBearing(e, r, o, h) {
          const p = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (h = s.e({ padding: p, offset: [0, 0], maxZoom: this.transform.maxZoom }, h)).padding == "number") {
            const bt = h.padding;
            h.padding = { top: bt, bottom: bt, right: bt, left: bt };
          }
          h.padding = s.e(p, h.padding);
          const x = this.transform, A = x.padding, T = new Y(e, r), P = x.project(T.getNorthWest()), F = x.project(T.getNorthEast()), N = x.project(T.getSouthEast()), Z = x.project(T.getSouthWest()), G = s.ba(-o), V = P.rotate(G), W = F.rotate(G), ae = N.rotate(G), oe = Z.rotate(G), de = new s.P(Math.max(V.x, W.x, oe.x, ae.x), Math.max(V.y, W.y, oe.y, ae.y)), ce = new s.P(Math.min(V.x, W.x, oe.x, ae.x), Math.min(V.y, W.y, oe.y, ae.y)), we = de.sub(ce), Le = (x.width - (A.left + A.right + h.padding.left + h.padding.right)) / we.x, ke = (x.height - (A.top + A.bottom + h.padding.top + h.padding.bottom)) / we.y;
          if (ke < 0 || Le < 0) return void s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const tt = Math.min(x.scaleZoom(x.scale * Math.min(Le, ke)), h.maxZoom), ht = s.P.convert(h.offset), _t = new s.P((h.padding.left - h.padding.right) / 2, (h.padding.top - h.padding.bottom) / 2).rotate(s.ba(o)), wt = ht.add(_t).mult(x.scale / x.zoomScale(tt));
          return { center: x.unproject(P.add(N).div(2).sub(wt)), zoom: tt, bearing: o };
        }
        fitBounds(e, r, o) {
          return this._fitInternal(this.cameraForBounds(e, r), r, o);
        }
        fitScreenCoordinates(e, r, o, h, p) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(s.P.convert(e)), this.transform.pointLocation(s.P.convert(r)), o, h), h, p);
        }
        _fitInternal(e, r, o) {
          return e ? (delete (r = s.e(e, r)).padding, r.linear ? this.easeTo(r, o) : this.flyTo(r, o)) : this;
        }
        jumpTo(e, r) {
          this.stop();
          const o = this._getTransformForUpdate();
          let h = !1, p = !1, x = !1;
          return "zoom" in e && o.zoom !== +e.zoom && (h = !0, o.zoom = +e.zoom), e.center !== void 0 && (o.center = s.N.convert(e.center)), "bearing" in e && o.bearing !== +e.bearing && (p = !0, o.bearing = +e.bearing), "pitch" in e && o.pitch !== +e.pitch && (x = !0, o.pitch = +e.pitch), e.padding == null || o.isPaddingEqual(e.padding) || (o.padding = e.padding), this._applyUpdatedTransform(o), this.fire(new s.k("movestart", r)).fire(new s.k("move", r)), h && this.fire(new s.k("zoomstart", r)).fire(new s.k("zoom", r)).fire(new s.k("zoomend", r)), p && this.fire(new s.k("rotatestart", r)).fire(new s.k("rotate", r)).fire(new s.k("rotateend", r)), x && this.fire(new s.k("pitchstart", r)).fire(new s.k("pitch", r)).fire(new s.k("pitchend", r)), this.fire(new s.k("moveend", r));
        }
        calculateCameraOptionsFromTo(e, r, o, h = 0) {
          const p = s.Z.fromLngLat(e, r), x = s.Z.fromLngLat(o, h), A = x.x - p.x, T = x.y - p.y, P = x.z - p.z, F = Math.hypot(A, T, P);
          if (F === 0) throw new Error("Can't calculate camera options with same From and To");
          const N = Math.hypot(A, T), Z = this.transform.scaleZoom(this.transform.cameraToCenterDistance / F / this.transform.tileSize), G = 180 * Math.atan2(A, -T) / Math.PI;
          let V = 180 * Math.acos(N / F) / Math.PI;
          return V = P < 0 ? 90 - V : 90 + V, { center: x.toLngLat(), zoom: Z, pitch: V, bearing: G };
        }
        easeTo(e, r) {
          var o;
          this._stop(!1, e.easeId), ((e = s.e({ offset: [0, 0], duration: 500, easing: s.b9 }, e)).animate === !1 || !e.essential && q.prefersReducedMotion) && (e.duration = 0);
          const h = this._getTransformForUpdate(), p = h.zoom, x = h.bearing, A = h.pitch, T = h.padding, P = "bearing" in e ? this._normalizeBearing(e.bearing, x) : x, F = "pitch" in e ? +e.pitch : A, N = "padding" in e ? e.padding : h.padding, Z = s.P.convert(e.offset);
          let G = h.centerPoint.add(Z);
          const V = h.pointLocation(G), { center: W, zoom: ae } = h.getConstrained(s.N.convert(e.center || V), (o = e.zoom) !== null && o !== void 0 ? o : p);
          this._normalizeCenter(W, h);
          const oe = h.project(V), de = h.project(W).sub(oe), ce = h.zoomScale(ae - p);
          let we, Le;
          e.around && (we = s.N.convert(e.around), Le = h.locationPoint(we));
          const ke = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || ae !== p, this._rotating = this._rotating || x !== P, this._pitching = this._pitching || F !== A, this._padding = !h.isPaddingEqual(N), this._easeId = e.easeId, this._prepareEase(r, e.noMoveStart, ke), this.terrain && this._prepareElevation(W), this._ease((tt) => {
            if (this._zooming && (h.zoom = s.y.number(p, ae, tt)), this._rotating && (h.bearing = s.y.number(x, P, tt)), this._pitching && (h.pitch = s.y.number(A, F, tt)), this._padding && (h.interpolatePadding(T, N, tt), G = h.centerPoint.add(Z)), this.terrain && !e.freezeElevation && this._updateElevation(tt), we) h.setLocationAtPoint(we, Le);
            else {
              const ht = h.zoomScale(h.zoom - p), _t = ae > p ? Math.min(2, ce) : Math.max(0.5, ce), wt = Math.pow(_t, 1 - tt), bt = h.unproject(oe.add(de.mult(tt * wt)).mult(ht));
              h.setLocationAtPoint(h.renderWorldCopies ? bt.wrap() : bt, G);
            }
            this._applyUpdatedTransform(h), this._fireMoveEvents(r);
          }, (tt) => {
            this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r, tt);
          }, e), this;
        }
        _prepareEase(e, r, o = {}) {
          this._moving = !0, r || o.moving || this.fire(new s.k("movestart", e)), this._zooming && !o.zooming && this.fire(new s.k("zoomstart", e)), this._rotating && !o.rotating && this.fire(new s.k("rotatestart", e)), this._pitching && !o.pitching && this.fire(new s.k("pitchstart", e));
        }
        _prepareElevation(e) {
          this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0;
        }
        _updateElevation(e) {
          this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const r = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (e < 1 && r !== this._elevationTarget) {
            const o = this._elevationTarget - this._elevationStart;
            this._elevationStart += e * (o - (r - (o * e + this._elevationStart)) / (1 - e)), this._elevationTarget = r;
          }
          this.transform.elevation = s.y.number(this._elevationStart, this._elevationTarget, e);
        }
        _finalizeElevation() {
          this._elevationFreeze = !1, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(e) {
          const r = e.getCameraPosition(), o = this.terrain.getElevationForLngLatZoom(r.lngLat, e.zoom);
          if (r.altitude < o) {
            const h = this.calculateCameraOptionsFromTo(r.lngLat, o, e.center, e.elevation);
            return { pitch: h.pitch, zoom: h.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(e) {
          const r = [];
          if (this.terrain && r.push((h) => this._elevateCameraIfInsideTerrain(h)), this.transformCameraUpdate && r.push((h) => this.transformCameraUpdate(h)), !r.length) return;
          const o = e.clone();
          for (const h of r) {
            const p = o.clone(), { center: x, zoom: A, pitch: T, bearing: P, elevation: F } = h(p);
            x && (p.center = x), A !== void 0 && (p.zoom = A), T !== void 0 && (p.pitch = T), P !== void 0 && (p.bearing = P), F !== void 0 && (p.elevation = F), o.apply(p);
          }
          this.transform.apply(o);
        }
        _fireMoveEvents(e) {
          this.fire(new s.k("move", e)), this._zooming && this.fire(new s.k("zoom", e)), this._rotating && this.fire(new s.k("rotate", e)), this._pitching && this.fire(new s.k("pitch", e));
        }
        _afterEase(e, r) {
          if (this._easeId && r && this._easeId === r) return;
          delete this._easeId;
          const o = this._zooming, h = this._rotating, p = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new s.k("zoomend", e)), h && this.fire(new s.k("rotateend", e)), p && this.fire(new s.k("pitchend", e)), this.fire(new s.k("moveend", e));
        }
        flyTo(e, r) {
          var o;
          if (!e.essential && q.prefersReducedMotion) {
            const Dt = s.M(e, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(Dt, r);
          }
          this.stop(), e = s.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: s.b9 }, e);
          const h = this._getTransformForUpdate(), p = h.zoom, x = h.bearing, A = h.pitch, T = h.padding, P = "bearing" in e ? this._normalizeBearing(e.bearing, x) : x, F = "pitch" in e ? +e.pitch : A, N = "padding" in e ? e.padding : h.padding, Z = s.P.convert(e.offset);
          let G = h.centerPoint.add(Z);
          const V = h.pointLocation(G), { center: W, zoom: ae } = h.getConstrained(s.N.convert(e.center || V), (o = e.zoom) !== null && o !== void 0 ? o : p);
          this._normalizeCenter(W, h);
          const oe = h.zoomScale(ae - p), de = h.project(V), ce = h.project(W).sub(de);
          let we = e.curve;
          const Le = Math.max(h.width, h.height), ke = Le / oe, tt = ce.mag();
          if ("minZoom" in e) {
            const Dt = s.ac(Math.min(e.minZoom, p, ae), h.minZoom, h.maxZoom), Wt = Le / h.zoomScale(Dt - p);
            we = Math.sqrt(Wt / tt * 2);
          }
          const ht = we * we;
          function _t(Dt) {
            const Wt = (ke * ke - Le * Le + (Dt ? -1 : 1) * ht * ht * tt * tt) / (2 * (Dt ? ke : Le) * ht * tt);
            return Math.log(Math.sqrt(Wt * Wt + 1) - Wt);
          }
          function wt(Dt) {
            return (Math.exp(Dt) - Math.exp(-Dt)) / 2;
          }
          function bt(Dt) {
            return (Math.exp(Dt) + Math.exp(-Dt)) / 2;
          }
          const yt = _t(!1);
          let St = function(Dt) {
            return bt(yt) / bt(yt + we * Dt);
          }, Zt = function(Dt) {
            return Le * ((bt(yt) * (wt(Wt = yt + we * Dt) / bt(Wt)) - wt(yt)) / ht) / tt;
            var Wt;
          }, Ct = (_t(!0) - yt) / we;
          if (Math.abs(tt) < 1e-6 || !isFinite(Ct)) {
            if (Math.abs(Le - ke) < 1e-6) return this.easeTo(e, r);
            const Dt = ke < Le ? -1 : 1;
            Ct = Math.abs(Math.log(ke / Le)) / we, Zt = () => 0, St = (Wt) => Math.exp(Dt * we * Wt);
          }
          return e.duration = "duration" in e ? +e.duration : 1e3 * Ct / ("screenSpeed" in e ? +e.screenSpeed / we : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = x !== P, this._pitching = F !== A, this._padding = !h.isPaddingEqual(N), this._prepareEase(r, !1), this.terrain && this._prepareElevation(W), this._ease((Dt) => {
            const Wt = Dt * Ct, di = 1 / St(Wt);
            h.zoom = Dt === 1 ? ae : p + h.scaleZoom(di), this._rotating && (h.bearing = s.y.number(x, P, Dt)), this._pitching && (h.pitch = s.y.number(A, F, Dt)), this._padding && (h.interpolatePadding(T, N, Dt), G = h.centerPoint.add(Z)), this.terrain && !e.freezeElevation && this._updateElevation(Dt);
            const ci = Dt === 1 ? W : h.unproject(de.add(ce.mult(Zt(Wt))).mult(di));
            h.setLocationAtPoint(h.renderWorldCopies ? ci.wrap() : ci, G), this._applyUpdatedTransform(h), this._fireMoveEvents(r);
          }, () => {
            this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r);
          }, e), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(e, r) {
          var o;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const h = this._onEaseEnd;
            delete this._onEaseEnd, h.call(this, r);
          }
          return e || (o = this.handlers) === null || o === void 0 || o.stop(!1), this;
        }
        _ease(e, r, o) {
          o.animate === !1 || o.duration === 0 ? (e(1), r()) : (this._easeStart = q.now(), this._easeOptions = o, this._onEaseFrame = e, this._onEaseEnd = r, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(e, r) {
          e = s.b3(e, -180, 180);
          const o = Math.abs(e - r);
          return Math.abs(e - 360 - r) < o && (e -= 360), Math.abs(e + 360 - r) < o && (e += 360), e;
        }
        _normalizeCenter(e, r) {
          if (!r.renderWorldCopies || r.lngRange) return;
          const o = e.lng - r.center.lng;
          e.lng += o > 180 ? -360 : o < -180 ? 360 : 0;
        }
        queryTerrainElevation(e) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(s.N.convert(e), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      const So = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
      class Vs {
        constructor(e = So) {
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (r) => {
            !r || r.sourceDataType !== "metadata" && r.sourceDataType !== "visibility" && r.dataType !== "style" && r.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = e;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e) {
          return this._map = e, this._compact = this.options.compact, this._container = O.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = O.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = O.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          O.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(e, r) {
          const o = this._map._getUIString(`AttributionControl.${r}`);
          e.title = o, e.setAttribute("aria-label", o);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let e = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((h) => typeof h != "string" ? "" : h)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const h = this._map.style.stylesheet;
            this.styleOwner = h.owner, this.styleId = h.id;
          }
          const r = this._map.style.sourceCaches;
          for (const h in r) {
            const p = r[h];
            if (p.used || p.usedForTerrain) {
              const x = p.getSource();
              x.attribution && e.indexOf(x.attribution) < 0 && e.push(x.attribution);
            }
          }
          e = e.filter((h) => String(h).trim()), e.sort((h, p) => h.length - p.length), e = e.filter((h, p) => {
            for (let x = p + 1; x < e.length; x++) if (e[x].indexOf(h) >= 0) return !1;
            return !0;
          });
          const o = e.join(" | ");
          o !== this._attribHTML && (this._attribHTML = o, e.length ? (this._innerContainer.innerHTML = o, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }
      class La {
        constructor(e = {}) {
          this._updateCompact = () => {
            const r = this._container.children;
            if (r.length) {
              const o = r[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && o.classList.add("maplibregl-compact") : o.classList.remove("maplibregl-compact");
            }
          }, this.options = e;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(e) {
          this._map = e, this._compact = this.options && this.options.compact, this._container = O.create("div", "maplibregl-ctrl");
          const r = O.create("a", "maplibregl-ctrl-logo");
          return r.target = "_blank", r.rel = "noopener nofollow", r.href = "https://maplibre.org/", r.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), r.setAttribute("rel", "noopener nofollow"), this._container.appendChild(r), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          O.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class vi {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(e) {
          const r = ++this._id;
          return this._queue.push({ callback: e, id: r, cancelled: !1 }), r;
        }
        remove(e) {
          const r = this._currentlyRunning, o = r ? this._queue.concat(r) : this._queue;
          for (const h of o) if (h.id === e) return void (h.cancelled = !0);
        }
        run(e = 0) {
          if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
          const r = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const o of r) if (!o.cancelled && (o.callback(e), this._cleared)) break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      var hu = s.Y([{ name: "a_pos3d", type: "Int16", components: 3 }]);
      class Ec extends s.E {
        constructor(e) {
          super(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, e.usedForTerrain = !0, e.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
        }
        update(e, r) {
          this.sourceCache.update(e, r), this._renderableTilesKeys = [];
          const o = {};
          for (const h of e.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: r })) o[h.key] = !0, this._renderableTilesKeys.push(h.key), this._tiles[h.key] || (h.posMatrix = new Float64Array(16), s.aP(h.posMatrix, 0, s.X, 0, s.X, 0, 1), this._tiles[h.key] = new Zi(h, this.tileSize));
          for (const h in this._tiles) o[h] || delete this._tiles[h];
        }
        freeRtt(e) {
          for (const r in this._tiles) {
            const o = this._tiles[r];
            (!e || o.tileID.equals(e) || o.tileID.isChildOf(e) || e.isChildOf(o.tileID)) && (o.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((e) => this.getTileByID(e));
        }
        getTileByID(e) {
          return this._tiles[e];
        }
        getTerrainCoords(e) {
          const r = {};
          for (const o of this._renderableTilesKeys) {
            const h = this._tiles[o].tileID;
            if (h.canonical.equals(e.canonical)) {
              const p = e.clone();
              p.posMatrix = new Float64Array(16), s.aP(p.posMatrix, 0, s.X, 0, s.X, 0, 1), r[o] = p;
            } else if (h.canonical.isChildOf(e.canonical)) {
              const p = e.clone();
              p.posMatrix = new Float64Array(16);
              const x = h.canonical.z - e.canonical.z, A = h.canonical.x - (h.canonical.x >> x << x), T = h.canonical.y - (h.canonical.y >> x << x), P = s.X >> x;
              s.aP(p.posMatrix, 0, P, 0, P, 0, 1), s.J(p.posMatrix, p.posMatrix, [-A * P, -T * P, 0]), r[o] = p;
            } else if (e.canonical.isChildOf(h.canonical)) {
              const p = e.clone();
              p.posMatrix = new Float64Array(16);
              const x = e.canonical.z - h.canonical.z, A = e.canonical.x - (e.canonical.x >> x << x), T = e.canonical.y - (e.canonical.y >> x << x), P = s.X >> x;
              s.aP(p.posMatrix, 0, s.X, 0, s.X, 0, 1), s.J(p.posMatrix, p.posMatrix, [A * P, T * P, 0]), s.K(p.posMatrix, p.posMatrix, [1 / 2 ** x, 1 / 2 ** x, 0]), r[o] = p;
            }
          }
          return r;
        }
        getSourceTile(e, r) {
          const o = this.sourceCache._source;
          let h = e.overscaledZ - this.deltaZoom;
          if (h > o.maxzoom && (h = o.maxzoom), h < o.minzoom) return null;
          this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(h).key);
          let p = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
          if ((!p || !p.dem) && r) for (; h >= o.minzoom && (!p || !p.dem); ) p = this.sourceCache.getTileByID(e.scaledTo(h--).key);
          return p;
        }
        tilesAfterTime(e = Date.now()) {
          return Object.values(this._tiles).filter((r) => r.timeAdded >= e);
        }
      }
      class Ll {
        constructor(e, r, o) {
          this.painter = e, this.sourceCache = new Ec(r), this.options = o, this.exaggeration = typeof o.exaggeration == "number" ? o.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(e, r, o, h = s.X) {
          var p;
          if (!(r >= 0 && r < h && o >= 0 && o < h)) return 0;
          const x = this.getTerrainData(e), A = (p = x.tile) === null || p === void 0 ? void 0 : p.dem;
          if (!A) return 0;
          const T = function(V, W, ae) {
            var oe = W[0], de = W[1];
            return V[0] = ae[0] * oe + ae[4] * de + ae[12], V[1] = ae[1] * oe + ae[5] * de + ae[13], V;
          }([], [r / h * s.X, o / h * s.X], x.u_terrain_matrix), P = [T[0] * A.dim, T[1] * A.dim], F = Math.floor(P[0]), N = Math.floor(P[1]), Z = P[0] - F, G = P[1] - N;
          return A.get(F, N) * (1 - Z) * (1 - G) + A.get(F + 1, N) * Z * (1 - G) + A.get(F, N + 1) * (1 - Z) * G + A.get(F + 1, N + 1) * Z * G;
        }
        getElevationForLngLatZoom(e, r) {
          if (!s.bb(r, e.wrap())) return 0;
          const { tileID: o, mercatorX: h, mercatorY: p } = this._getOverscaledTileIDFromLngLatZoom(e, r);
          return this.getElevation(o, h % s.X, p % s.X, s.X);
        }
        getElevation(e, r, o, h = s.X) {
          return this.getDEMElevation(e, r, o, h) * this.exaggeration;
        }
        getTerrainData(e) {
          if (!this._emptyDemTexture) {
            const h = this.painter.context, p = new s.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new X(h, p, h.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new X(h, new s.R({ width: 1, height: 1 }), h.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(h.gl.NEAREST, h.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.an([]);
          }
          const r = this.sourceCache.getSourceTile(e, !0);
          if (r && r.dem && (!r.demTexture || r.needsTerrainPrepare)) {
            const h = this.painter.context;
            r.demTexture = this.painter.getTileTexture(r.dem.stride), r.demTexture ? r.demTexture.update(r.dem.getPixels(), { premultiply: !1 }) : r.demTexture = new X(h, r.dem.getPixels(), h.gl.RGBA, { premultiply: !1 }), r.demTexture.bind(h.gl.NEAREST, h.gl.CLAMP_TO_EDGE), r.needsTerrainPrepare = !1;
          }
          const o = r && r + r.tileID.key + e.key;
          if (o && !this._demMatrixCache[o]) {
            const h = this.sourceCache.sourceCache._source.maxzoom;
            let p = e.canonical.z - r.tileID.canonical.z;
            e.overscaledZ > e.canonical.z && (e.canonical.z >= h ? p = e.canonical.z - h : s.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const x = e.canonical.x - (e.canonical.x >> p << p), A = e.canonical.y - (e.canonical.y >> p << p), T = s.bc(new Float64Array(16), [1 / (s.X << p), 1 / (s.X << p), 0]);
            s.J(T, T, [x * s.X, A * s.X, 0]), this._demMatrixCache[e.key] = { matrix: T, coord: e };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: r && r.dem && r.dem.dim || 1, u_terrain_matrix: o ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: r && r.dem && r.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (r && r.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: r };
        }
        getFramebuffer(e) {
          const r = this.painter, o = r.width / devicePixelRatio, h = r.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === o && this._fbo.height === h || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new X(r.context, { width: o, height: h, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new X(r.context, { width: o, height: h, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = r.context.createFramebuffer(o, h, !0, !1), this._fbo.depthAttachment.set(r.context.createRenderbuffer(r.context.gl.DEPTH_COMPONENT16, o, h))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const e = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          const r = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let p = 0, x = 0; p < this._coordsTextureSize; p++) for (let A = 0; A < this._coordsTextureSize; A++, x += 4) r[x + 0] = 255 & A, r[x + 1] = 255 & p, r[x + 2] = A >> 8 << 4 | p >> 8, r[x + 3] = 0;
          const o = new s.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(r.buffer)), h = new X(e, o, e.gl.RGBA, { premultiply: !1 });
          return h.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = h, h;
        }
        pointCoordinate(e) {
          this.painter.maybeDrawDepthAndCoords(!0);
          const r = new Uint8Array(4), o = this.painter.context, h = o.gl, p = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), x = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), A = Math.round(this.painter.height / devicePixelRatio);
          o.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), h.readPixels(p, A - x - 1, 1, 1, h.RGBA, h.UNSIGNED_BYTE, r), o.bindFramebuffer.set(null);
          const T = r[0] + (r[2] >> 4 << 8), P = r[1] + ((15 & r[2]) << 8), F = this.coordsIndex[255 - r[3]], N = F && this.sourceCache.getTileByID(F);
          if (!N) return null;
          const Z = this._coordsTextureSize, G = (1 << N.tileID.canonical.z) * Z;
          return new s.Z((N.tileID.canonical.x * Z + T) / G + N.tileID.wrap, (N.tileID.canonical.y * Z + P) / G, this.getElevation(N.tileID, T, P, Z));
        }
        depthAtPoint(e) {
          const r = new Uint8Array(4), o = this.painter.context, h = o.gl;
          return o.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), h.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, h.RGBA, h.UNSIGNED_BYTE, r), o.bindFramebuffer.set(null), (r[0] / 16777216 + r[1] / 65536 + r[2] / 256 + r[3]) / 256;
        }
        getTerrainMesh() {
          if (this._mesh) return this._mesh;
          const e = this.painter.context, r = new s.bd(), o = new s.aY(), h = this.meshSize, p = s.X / h, x = h * h;
          for (let N = 0; N <= h; N++) for (let Z = 0; Z <= h; Z++) r.emplaceBack(Z * p, N * p, 0);
          for (let N = 0; N < x; N += h + 1) for (let Z = 0; Z < h; Z++) o.emplaceBack(Z + N, h + Z + N + 1, h + Z + N + 2), o.emplaceBack(Z + N, h + Z + N + 2, Z + N + 1);
          const A = r.length, T = A + 2 * (h + 1);
          for (const N of [0, 1]) for (let Z = 0; Z <= h; Z++) for (const G of [0, 1]) r.emplaceBack(Z * p, N * s.X, G);
          for (let N = 0; N < 2 * h; N += 2) o.emplaceBack(T + N, T + N + 1, T + N + 3), o.emplaceBack(T + N, T + N + 3, T + N + 2), o.emplaceBack(A + N, A + N + 3, A + N + 1), o.emplaceBack(A + N, A + N + 2, A + N + 3);
          const P = r.length, F = P + 2 * (h + 1);
          for (const N of [0, 1]) for (let Z = 0; Z <= h; Z++) for (const G of [0, 1]) r.emplaceBack(N * s.X, Z * p, G);
          for (let N = 0; N < 2 * h; N += 2) o.emplaceBack(P + N, P + N + 1, P + N + 3), o.emplaceBack(P + N, P + N + 3, P + N + 2), o.emplaceBack(F + N, F + N + 3, F + N + 1), o.emplaceBack(F + N, F + N + 2, F + N + 3);
          return this._mesh = new gs(e.createVertexBuffer(r, hu.members), e.createIndexBuffer(o), s.a0.simpleSegment(0, 0, r.length, o.length)), this._mesh;
        }
        getMeshFrameDelta(e) {
          return 2 * Math.PI * s.be / Math.pow(2, e) / 5;
        }
        getMinTileElevationForLngLatZoom(e, r) {
          var o;
          const { tileID: h } = this._getOverscaledTileIDFromLngLatZoom(e, r);
          return (o = this.getMinMaxElevation(h).minElevation) !== null && o !== void 0 ? o : 0;
        }
        getMinMaxElevation(e) {
          const r = this.getTerrainData(e).tile, o = { minElevation: null, maxElevation: null };
          return r && r.dem && (o.minElevation = r.dem.min * this.exaggeration, o.maxElevation = r.dem.max * this.exaggeration), o;
        }
        _getOverscaledTileIDFromLngLatZoom(e, r) {
          const o = s.Z.fromLngLat(e.wrap()), h = (1 << r) * s.X, p = o.x * h, x = o.y * h, A = Math.floor(p / s.X), T = Math.floor(x / s.X);
          return { tileID: new s.S(r, 0, r, A, T), mercatorX: p, mercatorY: x };
        }
      }
      class Bu {
        constructor(e, r, o) {
          this._context = e, this._size = r, this._tileSize = o, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
        }
        _createObject(e) {
          const r = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), o = new X(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return o.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), r.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), r.colorAttachment.set(o.texture), { id: e, fbo: r, texture: o, stamp: -1, inUse: !1 };
        }
        getObjectForId(e) {
          return this._objects[e];
        }
        useObject(e) {
          e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((r) => e.id !== r), this._recentlyUsed.push(e.id);
        }
        stampObject(e) {
          e.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const r of this._recentlyUsed) if (!this._objects[r].inUse) return this._objects[r];
          if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const e = this._createObject(this._objects.length);
          return this._objects.push(e), e;
        }
        freeObject(e) {
          e.inUse = !1;
        }
        freeAllObjects() {
          for (const e of this._objects) this.freeObject(e);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((e) => !e.inUse) === !1;
        }
      }
      const $s = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
      class du {
        constructor(e, r) {
          this.painter = e, this.terrain = r, this.pool = new Bu(e.context, 30, r.sourceCache.tileSize * r.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(e) {
          return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(e, r) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((o) => !e._layers[o].isHidden(r)), this._coordsDescendingInv = {};
          for (const o in e.sourceCaches) {
            this._coordsDescendingInv[o] = {};
            const h = e.sourceCaches[o].getVisibleCoordinates();
            for (const p of h) {
              const x = this.terrain.sourceCache.getTerrainCoords(p);
              for (const A in x) this._coordsDescendingInv[o][A] || (this._coordsDescendingInv[o][A] = []), this._coordsDescendingInv[o][A].push(x[A]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const o of e._order) {
            const h = e._layers[o], p = h.source;
            if ($s[h.type] && !this._coordsDescendingInvStr[p]) {
              this._coordsDescendingInvStr[p] = {};
              for (const x in this._coordsDescendingInv[p]) this._coordsDescendingInvStr[p][x] = this._coordsDescendingInv[p][x].map((A) => A.key).sort().join();
            }
          }
          for (const o of this._renderableTiles) for (const h in this._coordsDescendingInvStr) {
            const p = this._coordsDescendingInvStr[h][o.tileID.key];
            p && p !== o.rttCoords[h] && (o.rtt = []);
          }
        }
        renderLayer(e) {
          if (e.isHidden(this.painter.transform.zoom)) return !1;
          const r = e.type, o = this.painter, h = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
          if ($s[r] && (this._prevType && $s[this._prevType] || this._stacks.push([]), this._prevType = r, this._stacks[this._stacks.length - 1].push(e.id), !h)) return !0;
          if ($s[this._prevType] || $s[r] && h) {
            this._prevType = r;
            const p = this._stacks.length - 1, x = this._stacks[p] || [];
            for (const A of this._renderableTiles) {
              if (this.pool.isFull() && (Rs(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(A), A.rtt[p]) {
                const P = this.pool.getObjectForId(A.rtt[p].id);
                if (P.stamp === A.rtt[p].stamp) {
                  this.pool.useObject(P);
                  continue;
                }
              }
              const T = this.pool.getOrCreateFreeObject();
              this.pool.useObject(T), this.pool.stampObject(T), A.rtt[p] = { id: T.id, stamp: T.stamp }, o.context.bindFramebuffer.set(T.fbo.framebuffer), o.context.clear({ color: s.aM.transparent, stencil: 0 }), o.currentStencilSource = void 0;
              for (let P = 0; P < x.length; P++) {
                const F = o.style._layers[x[P]], N = F.source ? this._coordsDescendingInv[F.source][A.tileID.key] : [A.tileID];
                o.context.viewport.set([0, 0, T.fbo.width, T.fbo.height]), o._renderTileClippingMasks(F, N), o.renderLayer(o, o.style.sourceCaches[F.source], F, N), F.source && (A.rttCoords[F.source] = this._coordsDescendingInvStr[F.source][A.tileID.key]);
              }
            }
            return Rs(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), $s[r];
          }
          return !1;
        }
      }
      const pu = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, ol = D, Ml = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: So, maplibreLogo: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, refreshExpiredTiles: !0, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], zoom: 0, bearing: 0, pitch: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0 }, Zs = (c) => {
        c.touchstart = c.dragStart, c.touchmoveWindow = c.dragMove, c.touchend = c.dragEnd;
      }, fu = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class Ru {
        constructor(e, r, o = !1) {
          this.mousedown = (x) => {
            this.startMouse(s.e({}, x, { ctrlKey: !0, preventDefault: () => x.preventDefault() }), O.mousePos(this.element, x)), O.addEventListener(window, "mousemove", this.mousemove), O.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (x) => {
            this.moveMouse(x, O.mousePos(this.element, x));
          }, this.mouseup = (x) => {
            this.mouseRotate.dragEnd(x), this.mousePitch && this.mousePitch.dragEnd(x), this.offTemp();
          }, this.touchstart = (x) => {
            x.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = O.touchPos(this.element, x.targetTouches)[0], this.startTouch(x, this._startPos), O.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), O.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (x) => {
            x.targetTouches.length !== 1 ? this.reset() : (this._lastPos = O.touchPos(this.element, x.targetTouches)[0], this.moveTouch(x, this._lastPos));
          }, this.touchend = (x) => {
            x.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const h = e.dragRotate._mouseRotate.getClickTolerance(), p = e.dragRotate._mousePitch.getClickTolerance();
          this.element = r, this.mouseRotate = vo({ clickTolerance: h, enable: !0 }), this.touchRotate = (({ enable: x, clickTolerance: A, bearingDegreesPerPixelMoved: T = 0.8 }) => {
            const P = new Pl();
            return new Pr({ clickTolerance: A, move: (F, N) => ({ bearingDelta: (N.x - F.x) * T }), moveStateManager: P, enable: x, assignEvents: Zs });
          })({ clickTolerance: h, enable: !0 }), this.map = e, o && (this.mousePitch = rl({ clickTolerance: p, enable: !0 }), this.touchPitch = (({ enable: x, clickTolerance: A, pitchDegreesPerPixelMoved: T = -0.5 }) => {
            const P = new Pl();
            return new Pr({ clickTolerance: A, move: (F, N) => ({ pitchDelta: (N.y - F.y) * T }), moveStateManager: P, enable: x, assignEvents: Zs });
          })({ clickTolerance: p, enable: !0 })), O.addEventListener(r, "mousedown", this.mousedown), O.addEventListener(r, "touchstart", this.touchstart, { passive: !1 }), O.addEventListener(r, "touchcancel", this.reset);
        }
        startMouse(e, r) {
          this.mouseRotate.dragStart(e, r), this.mousePitch && this.mousePitch.dragStart(e, r), O.disableDrag();
        }
        startTouch(e, r) {
          this.touchRotate.dragStart(e, r), this.touchPitch && this.touchPitch.dragStart(e, r), O.disableDrag();
        }
        moveMouse(e, r) {
          const o = this.map, { bearingDelta: h } = this.mouseRotate.dragMove(e, r) || {};
          if (h && o.setBearing(o.getBearing() + h), this.mousePitch) {
            const { pitchDelta: p } = this.mousePitch.dragMove(e, r) || {};
            p && o.setPitch(o.getPitch() + p);
          }
        }
        moveTouch(e, r) {
          const o = this.map, { bearingDelta: h } = this.touchRotate.dragMove(e, r) || {};
          if (h && o.setBearing(o.getBearing() + h), this.touchPitch) {
            const { pitchDelta: p } = this.touchPitch.dragMove(e, r) || {};
            p && o.setPitch(o.getPitch() + p);
          }
        }
        off() {
          const e = this.element;
          O.removeEventListener(e, "mousedown", this.mousedown), O.removeEventListener(e, "touchstart", this.touchstart, { passive: !1 }), O.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), O.removeEventListener(window, "touchend", this.touchend), O.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          O.enableDrag(), O.removeEventListener(window, "mousemove", this.mousemove), O.removeEventListener(window, "mouseup", this.mouseup), O.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), O.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let Pn;
      function Ji(c, e, r) {
        const o = new s.N(c.lng, c.lat);
        if (c = new s.N(c.lng, c.lat), e) {
          const h = new s.N(c.lng - 360, c.lat), p = new s.N(c.lng + 360, c.lat), x = r.locationPoint(c).distSqr(e);
          r.locationPoint(h).distSqr(e) < x ? c = h : r.locationPoint(p).distSqr(e) < x && (c = p);
        }
        for (; Math.abs(c.lng - r.center.lng) > 180; ) {
          const h = r.locationPoint(c);
          if (h.x >= 0 && h.y >= 0 && h.x <= r.width && h.y <= r.height) break;
          c.lng > r.center.lng ? c.lng -= 360 : c.lng += 360;
        }
        return c.lng !== o.lng && r.locationPoint(c).y > r.height / 2 - r.getHorizon() ? c : o;
      }
      const Eo = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function Nl(c, e, r) {
        const o = c.classList;
        for (const h in Eo) o.remove(`maplibregl-${r}-anchor-${h}`);
        o.add(`maplibregl-${r}-anchor-${e}`);
      }
      class zl extends s.E {
        constructor(e) {
          if (super(), this._onKeyPress = (r) => {
            const o = r.code, h = r.charCode || r.keyCode;
            o !== "Space" && o !== "Enter" && h !== 32 && h !== 13 || this.togglePopup();
          }, this._onMapClick = (r) => {
            const o = r.originalEvent.target, h = this._element;
            this._popup && (o === h || h.contains(o)) && this.togglePopup();
          }, this._update = (r) => {
            var o;
            if (!this._map) return;
            const h = this._map.loaded() && !this._map.isMoving();
            ((r == null ? void 0 : r.type) === "terrain" || (r == null ? void 0 : r.type) === "render" && !h) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? Ji(this._lngLat, this._flatPos, this._map.transform) : (o = this._lngLat) === null || o === void 0 ? void 0 : o.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
            let p = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? p = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (p = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let x = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? x = "rotateX(0deg)" : this._pitchAlignment === "map" && (x = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || r && r.type !== "moveend" || (this._pos = this._pos.round()), O.setTransform(this._element, `${Eo[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${x} ${p}`), q.frameAsync(new AbortController()).then(() => {
              this._updateOpacity(r && r.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (r) => {
            if (!this._isDragging) {
              const o = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = r.point.dist(this._pointerdownPos) >= o;
            }
            this._isDragging && (this._pos = r.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.k("dragstart"))), this.fire(new s.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (r) => {
            this._element.contains(r.originalEvent.target) && (r.preventDefault(), this._positionDelta = r.point.sub(this._pos).add(this._offset), this._pointerdownPos = r.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = s.P.convert(e && e.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = O.create("div");
            const r = O.createNS("http://www.w3.org/2000/svg", "svg"), o = 41, h = 27;
            r.setAttributeNS(null, "display", "block"), r.setAttributeNS(null, "height", `${o}px`), r.setAttributeNS(null, "width", `${h}px`), r.setAttributeNS(null, "viewBox", `0 0 ${h} ${o}`);
            const p = O.createNS("http://www.w3.org/2000/svg", "g");
            p.setAttributeNS(null, "stroke", "none"), p.setAttributeNS(null, "stroke-width", "1"), p.setAttributeNS(null, "fill", "none"), p.setAttributeNS(null, "fill-rule", "evenodd");
            const x = O.createNS("http://www.w3.org/2000/svg", "g");
            x.setAttributeNS(null, "fill-rule", "nonzero");
            const A = O.createNS("http://www.w3.org/2000/svg", "g");
            A.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), A.setAttributeNS(null, "fill", "#000000");
            const T = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const oe of T) {
              const de = O.createNS("http://www.w3.org/2000/svg", "ellipse");
              de.setAttributeNS(null, "opacity", "0.04"), de.setAttributeNS(null, "cx", "10.5"), de.setAttributeNS(null, "cy", "5.80029008"), de.setAttributeNS(null, "rx", oe.rx), de.setAttributeNS(null, "ry", oe.ry), A.appendChild(de);
            }
            const P = O.createNS("http://www.w3.org/2000/svg", "g");
            P.setAttributeNS(null, "fill", this._color);
            const F = O.createNS("http://www.w3.org/2000/svg", "path");
            F.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), P.appendChild(F);
            const N = O.createNS("http://www.w3.org/2000/svg", "g");
            N.setAttributeNS(null, "opacity", "0.25"), N.setAttributeNS(null, "fill", "#000000");
            const Z = O.createNS("http://www.w3.org/2000/svg", "path");
            Z.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), N.appendChild(Z);
            const G = O.createNS("http://www.w3.org/2000/svg", "g");
            G.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), G.setAttributeNS(null, "fill", "#FFFFFF");
            const V = O.createNS("http://www.w3.org/2000/svg", "g");
            V.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const W = O.createNS("http://www.w3.org/2000/svg", "circle");
            W.setAttributeNS(null, "fill", "#000000"), W.setAttributeNS(null, "opacity", "0.25"), W.setAttributeNS(null, "cx", "5.5"), W.setAttributeNS(null, "cy", "5.5"), W.setAttributeNS(null, "r", "5.4999962");
            const ae = O.createNS("http://www.w3.org/2000/svg", "circle");
            ae.setAttributeNS(null, "fill", "#FFFFFF"), ae.setAttributeNS(null, "cx", "5.5"), ae.setAttributeNS(null, "cy", "5.5"), ae.setAttributeNS(null, "r", "5.4999962"), V.appendChild(W), V.appendChild(ae), x.appendChild(A), x.appendChild(P), x.appendChild(N), x.appendChild(G), x.appendChild(V), r.appendChild(x), r.setAttributeNS(null, "height", o * this._scale + "px"), r.setAttributeNS(null, "width", h * this._scale + "px"), this._element.appendChild(r), this._offset = s.P.convert(e && e.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (r) => {
            r.preventDefault();
          }), this._element.addEventListener("mousedown", (r) => {
            r.preventDefault();
          }), Nl(this._element, this._anchor, "marker"), e && e.className) for (const r of e.className.split(" ")) this._element.classList.add(r);
          this._popup = null;
        }
        addTo(e) {
          return this.remove(), this._map = e, this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), O.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e) {
          return this._lngLat = s.N.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
            if (!("offset" in e.options)) {
              const h = Math.abs(13.5) / Math.SQRT2;
              e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [h, -1 * (38.1 - 13.5 + h)], "bottom-right": [-h, -1 * (38.1 - 13.5 + h)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(e) {
          return this._subpixelPositioning = e, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
        }
        _updateOpacity(e = !1) {
          var r, o;
          if (!(!((r = this._map) === null || r === void 0) && r.terrain)) return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
          if (e) this._opacityTimeout = null;
          else {
            if (this._opacityTimeout) return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const h = this._map, p = h.terrain.depthAtPoint(this._pos), x = h.terrain.getElevationForLngLatZoom(this._lngLat, h.transform.tileZoom);
          if (h.transform.lngLatToCameraDepth(this._lngLat, x) - p < 6e-3) return void (this._element.style.opacity = this._opacity);
          const A = -this._offset.y / h.transform._pixelPerMeter, T = Math.sin(h.getPitch() * Math.PI / 180) * A, P = h.terrain.depthAtPoint(new s.P(this._pos.x, this._pos.y - this._offset.y)), F = h.transform.lngLatToCameraDepth(this._lngLat, x + T) - P > 6e-3;
          !((o = this._popup) === null || o === void 0) && o.isOpen() && F && this._popup.remove(), this._element.style.opacity = F ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(e) {
          return this._offset = s.P.convert(e), this._update(), this;
        }
        addClassName(e) {
          this._element.classList.add(e);
        }
        removeClassName(e) {
          this._element.classList.remove(e);
        }
        toggleClassName(e) {
          return this._element.classList.toggle(e);
        }
        setDraggable(e) {
          return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e) {
          return this._rotation = e || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e) {
          return this._rotationAlignment = e || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(e) {
          return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(e, r) {
          return e === void 0 && r === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), r !== void 0 && (this._opacityWhenCovered = r), this._map && this._updateOpacity(!0), this;
        }
      }
      const Ou = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
      let ll = 0, ul = !1;
      const ma = { maxWidth: 100, unit: "metric" };
      function bs(c, e, r) {
        const o = r && r.maxWidth || 100, h = c._container.clientHeight / 2, p = c.unproject([0, h]), x = c.unproject([o, h]), A = p.distanceTo(x);
        if (r && r.unit === "imperial") {
          const T = 3.2808 * A;
          T > 5280 ? Gt(e, o, T / 5280, c._getUIString("ScaleControl.Miles")) : Gt(e, o, T, c._getUIString("ScaleControl.Feet"));
        } else r && r.unit === "nautical" ? Gt(e, o, A / 1852, c._getUIString("ScaleControl.NauticalMiles")) : A >= 1e3 ? Gt(e, o, A / 1e3, c._getUIString("ScaleControl.Kilometers")) : Gt(e, o, A, c._getUIString("ScaleControl.Meters"));
      }
      function Gt(c, e, r, o) {
        const h = function(p) {
          const x = Math.pow(10, `${Math.floor(p)}`.length - 1);
          let A = p / x;
          return A = A >= 10 ? 10 : A >= 5 ? 5 : A >= 3 ? 3 : A >= 2 ? 2 : A >= 1 ? 1 : function(T) {
            const P = Math.pow(10, Math.ceil(-Math.log(T) / Math.LN10));
            return Math.round(T * P) / P;
          }(A), x * A;
        }(r);
        c.style.width = e * (h / r) + "px", c.innerHTML = `${h}&nbsp;${o}`;
      }
      const li = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, cl = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function y(c) {
        if (c) {
          if (typeof c == "number") {
            const e = Math.round(Math.abs(c) / Math.SQRT2);
            return { center: new s.P(0, 0), top: new s.P(0, c), "top-left": new s.P(e, e), "top-right": new s.P(-e, e), bottom: new s.P(0, -c), "bottom-left": new s.P(e, -e), "bottom-right": new s.P(-e, -e), left: new s.P(c, 0), right: new s.P(-c, 0) };
          }
          if (c instanceof s.P || Array.isArray(c)) {
            const e = s.P.convert(c);
            return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
          }
          return { center: s.P.convert(c.center || [0, 0]), top: s.P.convert(c.top || [0, 0]), "top-left": s.P.convert(c["top-left"] || [0, 0]), "top-right": s.P.convert(c["top-right"] || [0, 0]), bottom: s.P.convert(c.bottom || [0, 0]), "bottom-left": s.P.convert(c["bottom-left"] || [0, 0]), "bottom-right": s.P.convert(c["bottom-right"] || [0, 0]), left: s.P.convert(c.left || [0, 0]), right: s.P.convert(c.right || [0, 0]) };
        }
        return y(new s.P(0, 0));
      }
      const S = D;
      g.AJAXError = s.bh, g.Evented = s.E, g.LngLat = s.N, g.MercatorCoordinate = s.Z, g.Point = s.P, g.addProtocol = s.bi, g.config = s.a, g.removeProtocol = s.bj, g.AttributionControl = Vs, g.BoxZoomHandler = vn, g.CanvasSource = ii, g.CooperativeGesturesHandler = Ao, g.DoubleClickZoomHandler = Xa, g.DragPanHandler = Fu, g.DragRotateHandler = uu, g.EdgeInsets = Un, g.FullscreenControl = class extends s.E {
        constructor(c = {}) {
          super(), this._onFullscreenChange = () => {
            var e;
            let r = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (; !((e = r == null ? void 0 : r.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) r = r.shadowRoot.fullscreenElement;
            r === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = !1, c && c.container && (c.container instanceof HTMLElement ? this._container = c.container : s.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(c) {
          return this._map = c, this._container || (this._container = this._map.getContainer()), this._controlContainer = O.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          O.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const c = this._fullscreenButton = O.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          O.create("span", "maplibregl-ctrl-icon", c).setAttribute("aria-hidden", "true"), c.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const c = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", c), this._fullscreenButton.title = c;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new s.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new s.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, g.GeoJSONSource = At, g.GeolocateControl = class extends s.E {
        constructor(c) {
          super(), this._onSuccess = (e) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new s.k("outofmaxbounds", e)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new s.k("geolocate", e)), this._finish();
            }
          }, this._updateCamera = (e) => {
            const r = new s.N(e.coords.longitude, e.coords.latitude), o = e.coords.accuracy, h = this._map.getBearing(), p = s.e({ bearing: h }, this.options.fitBoundsOptions), x = Y.fromLngLat(r, o);
            this._map.fitBounds(x, p, { geolocateSource: !0 });
          }, this._updateMarker = (e) => {
            if (e) {
              const r = new s.N(e.coords.longitude, e.coords.latitude);
              this._accuracyCircleMarker.setLngLat(r).addTo(this._map), this._userLocationDotMarker.setLngLat(r).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (e) => {
            if (this._map) {
              if (this.options.trackUserLocation) if (e.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (e.code === 3 && ul) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new s.k("error", e)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this._geolocateButton = O.create("button", "maplibregl-ctrl-geolocate", this._container), O.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
          }, this._finishSetupUI = (e) => {
            if (this._map) {
              if (e === !1) {
                s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
              } else {
                const r = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = !1, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = O.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new zl({ element: this._dotElement }), this._circleElement = O.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new zl({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (r) => {
                r.geolocateSource || this._watchState !== "ACTIVE_LOCK" || r.originalEvent && r.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new s.k("trackuserlocationend")), this.fire(new s.k("userlocationlostfocus")));
              });
            }
          }, this.options = s.e({}, Ou, c);
        }
        onAdd(c) {
          return this._map = c, this._container = O.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
            return s._(this, arguments, void 0, function* (e = !1) {
              if (Pn !== void 0 && !e) return Pn;
              if (window.navigator.permissions === void 0) return Pn = !!window.navigator.geolocation, Pn;
              try {
                Pn = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
              } catch {
                Pn = !!window.navigator.geolocation;
              }
              return Pn;
            });
          }().then((e) => this._finishSetupUI(e)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), O.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, ll = 0, ul = !1;
        }
        _isOutOfMapMaxBounds(c) {
          const e = this._map.getMaxBounds(), r = c.coords;
          return e && (r.longitude < e.getWest() || r.longitude > e.getEast() || r.latitude < e.getSouth() || r.latitude > e.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const c = this._map.getBounds(), e = c.getSouthEast(), r = c.getNorthEast(), o = e.distanceTo(r), h = Math.ceil(this._accuracy / (o / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${h}px`, this._circleElement.style.height = `${h}px`;
        }
        trigger() {
          if (!this._setup) return s.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new s.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                ll--, ul = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new s.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.k("trackuserlocationstart")), this.fire(new s.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let c;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ll++, ll > 1 ? (c = { maximumAge: 6e5, timeout: 0 }, ul = !0) : (c = this.options.positionOptions, ul = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, c);
            }
          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, g.Hash = ys, g.ImageSource = jt, g.KeyboardHandler = Hn, g.LngLatBounds = Y, g.LogoControl = La, g.Map = class extends Pa {
        constructor(c) {
          s.bf.mark(s.bg.create);
          const e = Object.assign(Object.assign({}, Ml), c);
          if (e.minZoom != null && e.maxZoom != null && e.minZoom > e.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (e.minPitch != null && e.maxPitch != null && e.minPitch > e.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (e.minPitch != null && e.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (e.maxPitch != null && e.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (super(new Vn(e.minZoom, e.maxZoom, e.minPitch, e.maxPitch, e.renderWorldCopies), { bearingSnap: e.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new vi(), this._controls = [], this._mapId = s.a4(), this._contextLost = (r) => {
            r.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new s.k("webglcontextlost", { originalEvent: r }));
          }, this._contextRestored = (r) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new s.k("webglcontextrestored", { originalEvent: r }));
          }, this._onMapScroll = (r) => {
            if (r.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = e.interactive, this._maxTileCacheSize = e.maxTileCacheSize, this._maxTileCacheZoomLevels = e.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat === !0, this._preserveDrawingBuffer = e.preserveDrawingBuffer === !0, this._antialias = e.antialias === !0, this._trackResize = e.trackResize === !0, this._bearingSnap = e.bearingSnap, this._refreshExpiredTiles = e.refreshExpiredTiles === !0, this._fadeDuration = e.fadeDuration, this._crossSourceCollisions = e.crossSourceCollisions === !0, this._collectResourceTiming = e.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, pu), e.locale), this._clickTolerance = e.clickTolerance, this._overridePixelRatio = e.pixelRatio, this._maxCanvasSize = e.maxCanvasSize, this.transformCameraUpdate = e.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = e.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Te.addThrottleControl(() => this.isMoving()), this._requestManager = new ze(e.transformRequest), typeof e.container == "string") {
            if (this._container = document.getElementById(e.container), !this._container) throw new Error(`Container '${e.container}' not found.`);
          } else {
            if (!(e.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = e.container;
          }
          if (e.maxBounds && this.setMaxBounds(e.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)).on("moveend", () => this._update(!1)).on("zoom", () => this._update(!0)).on("terrain", () => {
            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
          }).once("idle", () => {
            this._idleTriggered = !0;
          }), typeof window < "u") {
            addEventListener("online", this._onWindowOnline, !1);
            let r = !1;
            const o = $n((h) => {
              this._trackResize && !this._removed && (this.resize(h), this.redraw());
            }, 50);
            this._resizeObserver = new ResizeObserver((h) => {
              r ? o(h) : r = !0;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new kn(this, e), this._hash = e.hash && new ys(typeof e.hash == "string" && e.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e.center, zoom: e.zoom, bearing: e.bearing, pitch: e.pitch }), e.bounds && (this.resize(), this.fitBounds(e.bounds, s.e({}, e.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e.localIdeographFontFamily, this._validateStyle = e.validateStyle, e.style && this.setStyle(e.style, { localIdeographFontFamily: e.localIdeographFontFamily }), e.attributionControl && this.addControl(new Vs(typeof e.attributionControl == "boolean" ? void 0 : e.attributionControl)), e.maplibreLogo && this.addControl(new La(), e.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (r) => {
            this._update(r.dataType === "style"), this.fire(new s.k(`${r.dataType}data`, r));
          }), this.on("dataloading", (r) => {
            this.fire(new s.k(`${r.dataType}dataloading`, r));
          }), this.on("dataabort", (r) => {
            this.fire(new s.k("sourcedataabort", r));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(c, e) {
          if (e === void 0 && (e = c.getDefaultPosition ? c.getDefaultPosition() : "top-right"), !c || !c.onAdd) return this.fire(new s.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const r = c.onAdd(this);
          this._controls.push(c);
          const o = this._controlPositions[e];
          return e.indexOf("bottom") !== -1 ? o.insertBefore(r, o.firstChild) : o.appendChild(r), this;
        }
        removeControl(c) {
          if (!c || !c.onRemove) return this.fire(new s.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const e = this._controls.indexOf(c);
          return e > -1 && this._controls.splice(e, 1), c.onRemove(this), this;
        }
        hasControl(c) {
          return this._controls.indexOf(c) > -1;
        }
        calculateCameraOptionsFromTo(c, e, r, o) {
          return o == null && this.terrain && (o = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(c, e, r, o);
        }
        resize(c) {
          var e;
          const r = this._containerDimensions(), o = r[0], h = r[1], p = this._getClampedPixelRatio(o, h);
          if (this._resizeCanvas(o, h, p), this.painter.resize(o, h, p), this.painter.overLimit()) {
            const A = this.painter.context.gl;
            this._maxCanvasSize = [A.drawingBufferWidth, A.drawingBufferHeight];
            const T = this._getClampedPixelRatio(o, h);
            this._resizeCanvas(o, h, T), this.painter.resize(o, h, T);
          }
          this.transform.resize(o, h), (e = this._requestedCameraState) === null || e === void 0 || e.resize(o, h);
          const x = !this._moving;
          return x && (this.stop(), this.fire(new s.k("movestart", c)).fire(new s.k("move", c))), this.fire(new s.k("resize", c)), x && this.fire(new s.k("moveend", c)), this;
        }
        _getClampedPixelRatio(c, e) {
          const { 0: r, 1: o } = this._maxCanvasSize, h = this.getPixelRatio(), p = c * h, x = e * h;
          return Math.min(p > r ? r / p : 1, x > o ? o / x : 1) * h;
        }
        getPixelRatio() {
          var c;
          return (c = this._overridePixelRatio) !== null && c !== void 0 ? c : devicePixelRatio;
        }
        setPixelRatio(c) {
          this._overridePixelRatio = c, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(c) {
          return this.transform.setMaxBounds(Y.convert(c)), this._update();
        }
        setMinZoom(c) {
          if ((c = c ?? -2) >= -2 && c <= this.transform.maxZoom) return this.transform.minZoom = c, this._update(), this.getZoom() < c && this.setZoom(c), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(c) {
          if ((c = c ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = c, this._update(), this.getZoom() > c && this.setZoom(c), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(c) {
          if ((c = c ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (c >= 0 && c <= this.transform.maxPitch) return this.transform.minPitch = c, this._update(), this.getPitch() < c && this.setPitch(c), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(c) {
          if ((c = c ?? 60) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (c >= this.transform.minPitch) return this.transform.maxPitch = c, this._update(), this.getPitch() > c && this.setPitch(c), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(c) {
          return this.transform.renderWorldCopies = c, this._update();
        }
        project(c) {
          return this.transform.locationPoint(s.N.convert(c), this.style && this.terrain);
        }
        unproject(c) {
          return this.transform.pointLocation(s.P.convert(c), this.terrain);
        }
        isMoving() {
          var c;
          return this._moving || ((c = this.handlers) === null || c === void 0 ? void 0 : c.isMoving());
        }
        isZooming() {
          var c;
          return this._zooming || ((c = this.handlers) === null || c === void 0 ? void 0 : c.isZooming());
        }
        isRotating() {
          var c;
          return this._rotating || ((c = this.handlers) === null || c === void 0 ? void 0 : c.isRotating());
        }
        _createDelegatedListener(c, e, r) {
          if (c === "mouseenter" || c === "mouseover") {
            let o = !1;
            return { layers: e, listener: r, delegates: { mousemove: (p) => {
              const x = e.filter((T) => this.getLayer(T)), A = x.length !== 0 ? this.queryRenderedFeatures(p.point, { layers: x }) : [];
              A.length ? o || (o = !0, r.call(this, new Tr(c, this, p.originalEvent, { features: A }))) : o = !1;
            }, mouseout: () => {
              o = !1;
            } } };
          }
          if (c === "mouseleave" || c === "mouseout") {
            let o = !1;
            return { layers: e, listener: r, delegates: { mousemove: (x) => {
              const A = e.filter((T) => this.getLayer(T));
              (A.length !== 0 ? this.queryRenderedFeatures(x.point, { layers: A }) : []).length ? o = !0 : o && (o = !1, r.call(this, new Tr(c, this, x.originalEvent)));
            }, mouseout: (x) => {
              o && (o = !1, r.call(this, new Tr(c, this, x.originalEvent)));
            } } };
          }
          {
            const o = (h) => {
              const p = e.filter((A) => this.getLayer(A)), x = p.length !== 0 ? this.queryRenderedFeatures(h.point, { layers: p }) : [];
              x.length && (h.features = x, r.call(this, h), delete h.features);
            };
            return { layers: e, listener: r, delegates: { [c]: o } };
          }
        }
        _saveDelegatedListener(c, e) {
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[c] = this._delegatedListeners[c] || [], this._delegatedListeners[c].push(e);
        }
        _removeDelegatedListener(c, e, r) {
          if (!this._delegatedListeners || !this._delegatedListeners[c]) return;
          const o = this._delegatedListeners[c];
          for (let h = 0; h < o.length; h++) {
            const p = o[h];
            if (p.listener === r && p.layers.length === e.length && p.layers.every((x) => e.includes(x))) {
              for (const x in p.delegates) this.off(x, p.delegates[x]);
              return void o.splice(h, 1);
            }
          }
        }
        on(c, e, r) {
          if (r === void 0) return super.on(c, e);
          const o = this._createDelegatedListener(c, typeof e == "string" ? [e] : e, r);
          this._saveDelegatedListener(c, o);
          for (const h in o.delegates) this.on(h, o.delegates[h]);
          return this;
        }
        once(c, e, r) {
          if (r === void 0) return super.once(c, e);
          const o = typeof e == "string" ? [e] : e, h = this._createDelegatedListener(c, o, r);
          for (const p in h.delegates) {
            const x = h.delegates[p];
            h.delegates[p] = (...A) => {
              this._removeDelegatedListener(c, o, r), x(...A);
            };
          }
          this._saveDelegatedListener(c, h);
          for (const p in h.delegates) this.once(p, h.delegates[p]);
          return this;
        }
        off(c, e, r) {
          return r === void 0 ? super.off(c, e) : (this._removeDelegatedListener(c, typeof e == "string" ? [e] : e, r), this);
        }
        queryRenderedFeatures(c, e) {
          if (!this.style) return [];
          let r;
          const o = c instanceof s.P || Array.isArray(c), h = o ? c : [[0, 0], [this.transform.width, this.transform.height]];
          if (e = e || (o ? {} : c) || {}, h instanceof s.P || typeof h[0] == "number") r = [s.P.convert(h)];
          else {
            const p = s.P.convert(h[0]), x = s.P.convert(h[1]);
            r = [p, new s.P(x.x, p.y), x, new s.P(p.x, x.y), p];
          }
          return this.style.queryRenderedFeatures(r, e, this.transform);
        }
        querySourceFeatures(c, e) {
          return this.style.querySourceFeatures(c, e);
        }
        setStyle(c, e) {
          return (e = s.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && c ? (this._diffStyle(c, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(c, e));
        }
        setTransformRequest(c) {
          return this._requestManager.setTransformRequest(c), this;
        }
        _getUIString(c) {
          const e = this._locale[c];
          if (e == null) throw new Error(`Missing UI string '${c}'`);
          return e;
        }
        _updateStyle(c, e) {
          if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(c, e));
          const r = this.style && e.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!c)), c ? (this.style = new Or(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof c == "string" ? this.style.loadURL(c, e, r) : this.style.loadJSON(c, e, r), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Or(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(c, e) {
          if (typeof c == "string") {
            const r = this._requestManager.transformRequest(c, "Style");
            s.h(r, new AbortController()).then((o) => {
              this._updateDiff(o.data, e);
            }).catch((o) => {
              o && this.fire(new s.j(o));
            });
          } else typeof c == "object" && this._updateDiff(c, e);
        }
        _updateDiff(c, e) {
          try {
            this.style.setState(c, e) && this._update(!0);
          } catch (r) {
            s.w(`Unable to perform style diff: ${r.message || r.error || r}.  Rebuilding the style from scratch.`), this._updateStyle(c, e);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : s.w("There is no style added to the map.");
        }
        addSource(c, e) {
          return this._lazyInitEmptyStyle(), this.style.addSource(c, e), this._update(!0);
        }
        isSourceLoaded(c) {
          const e = this.style && this.style.sourceCaches[c];
          if (e !== void 0) return e.loaded();
          this.fire(new s.j(new Error(`There is no source with ID '${c}'`)));
        }
        setTerrain(c) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), c) {
            const e = this.style.sourceCaches[c.source];
            if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${c.source}`);
            this.terrain === null && e.reload();
            for (const r in this.style._layers) {
              const o = this.style._layers[r];
              o.type === "hillshade" && o.source === c.source && s.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new Ll(this.painter, e, c), this.painter.renderToTexture = new du(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (r) => {
              r.dataType === "style" ? this.terrain.sourceCache.freeRtt() : r.dataType === "source" && r.tile && (r.sourceId !== c.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(r.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new s.k("terrain", { terrain: c })), this;
        }
        getTerrain() {
          var c, e;
          return (e = (c = this.terrain) === null || c === void 0 ? void 0 : c.options) !== null && e !== void 0 ? e : null;
        }
        areTilesLoaded() {
          const c = this.style && this.style.sourceCaches;
          for (const e in c) {
            const r = c[e]._tiles;
            for (const o in r) {
              const h = r[o];
              if (h.state !== "loaded" && h.state !== "errored") return !1;
            }
          }
          return !0;
        }
        removeSource(c) {
          return this.style.removeSource(c), this._update(!0);
        }
        getSource(c) {
          return this.style.getSource(c);
        }
        addImage(c, e, r = {}) {
          const { pixelRatio: o = 1, sdf: h = !1, stretchX: p, stretchY: x, content: A, textFitWidth: T, textFitHeight: P } = r;
          if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || s.b(e))) {
            if (e.width === void 0 || e.height === void 0) return this.fire(new s.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: F, height: N, data: Z } = e, G = e;
              return this.style.addImage(c, { data: new s.R({ width: F, height: N }, new Uint8Array(Z)), pixelRatio: o, stretchX: p, stretchY: x, content: A, textFitWidth: T, textFitHeight: P, sdf: h, version: 0, userImage: G }), G.onAdd && G.onAdd(this, c), this;
            }
          }
          {
            const { width: F, height: N, data: Z } = q.getImageData(e);
            this.style.addImage(c, { data: new s.R({ width: F, height: N }, Z), pixelRatio: o, stretchX: p, stretchY: x, content: A, textFitWidth: T, textFitHeight: P, sdf: h, version: 0 });
          }
        }
        updateImage(c, e) {
          const r = this.style.getImage(c);
          if (!r) return this.fire(new s.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const o = e instanceof HTMLImageElement || s.b(e) ? q.getImageData(e) : e, { width: h, height: p, data: x } = o;
          if (h === void 0 || p === void 0) return this.fire(new s.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (h !== r.data.width || p !== r.data.height) return this.fire(new s.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const A = !(e instanceof HTMLImageElement || s.b(e));
          return r.data.replace(x, A), this.style.updateImage(c, r), this;
        }
        getImage(c) {
          return this.style.getImage(c);
        }
        hasImage(c) {
          return c ? !!this.style.getImage(c) : (this.fire(new s.j(new Error("Missing required image id"))), !1);
        }
        removeImage(c) {
          this.style.removeImage(c);
        }
        loadImage(c) {
          return Te.getImage(this._requestManager.transformRequest(c, "Image"), new AbortController());
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(c, e) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(c, e), this._update(!0);
        }
        moveLayer(c, e) {
          return this.style.moveLayer(c, e), this._update(!0);
        }
        removeLayer(c) {
          return this.style.removeLayer(c), this._update(!0);
        }
        getLayer(c) {
          return this.style.getLayer(c);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(c, e, r) {
          return this.style.setLayerZoomRange(c, e, r), this._update(!0);
        }
        setFilter(c, e, r = {}) {
          return this.style.setFilter(c, e, r), this._update(!0);
        }
        getFilter(c) {
          return this.style.getFilter(c);
        }
        setPaintProperty(c, e, r, o = {}) {
          return this.style.setPaintProperty(c, e, r, o), this._update(!0);
        }
        getPaintProperty(c, e) {
          return this.style.getPaintProperty(c, e);
        }
        setLayoutProperty(c, e, r, o = {}) {
          return this.style.setLayoutProperty(c, e, r, o), this._update(!0);
        }
        getLayoutProperty(c, e) {
          return this.style.getLayoutProperty(c, e);
        }
        setGlyphs(c, e = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(c, e), this._update(!0);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(c, e, r = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(c, e, r, (o) => {
            o || this._update(!0);
          }), this;
        }
        removeSprite(c) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(c), this._update(!0);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(c, e = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(c, e, (r) => {
            r || this._update(!0);
          }), this;
        }
        setLight(c, e = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(c, e), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(c) {
          return this._lazyInitEmptyStyle(), this.style.setSky(c), this._update(!0);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(c, e) {
          return this.style.setFeatureState(c, e), this._update();
        }
        removeFeatureState(c, e) {
          return this.style.removeFeatureState(c, e), this._update();
        }
        getFeatureState(c) {
          return this.style.getFeatureState(c);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let c = 0, e = 0;
          return this._container && (c = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [c, e];
        }
        _setupContainer() {
          const c = this._container;
          c.classList.add("maplibregl-map");
          const e = this._canvasContainer = O.create("div", "maplibregl-canvas-container", c);
          this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = O.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const r = this._containerDimensions(), o = this._getClampedPixelRatio(r[0], r[1]);
          this._resizeCanvas(r[0], r[1], o);
          const h = this._controlContainer = O.create("div", "maplibregl-control-container", c), p = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((x) => {
            p[x] = O.create("div", `maplibregl-ctrl-${x} `, h);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(c, e, r) {
          this._canvas.width = Math.floor(r * c), this._canvas.height = Math.floor(r * e), this._canvas.style.width = `${c}px`, this._canvas.style.height = `${e}px`;
        }
        _setupPainter() {
          const c = { alpha: !0, stencil: !0, depth: !0, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 };
          let e = null;
          this._canvas.addEventListener("webglcontextcreationerror", (o) => {
            e = { requestedAttributes: c }, o && (e.statusMessage = o.statusMessage, e.type = o.type);
          }, { once: !0 });
          const r = this._canvas.getContext("webgl2", c) || this._canvas.getContext("webgl", c);
          if (!r) {
            const o = "Failed to initialize WebGL";
            throw e ? (e.message = o, new Error(JSON.stringify(e))) : new Error(o);
          }
          this.painter = new da(r, this.transform), z.testSupport(r);
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(c) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || c, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(c) {
          return this._update(), this._renderTaskQueue.add(c);
        }
        _cancelRenderFrame(c) {
          this._renderTaskQueue.remove(c);
        }
        _render(c) {
          const e = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(c), this._removed) return;
          let r = !1;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const h = this.transform.zoom, p = q.now();
            this.style.zoomHistory.update(h, p);
            const x = new s.z(h, { now: p, fadeDuration: e, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), A = x.crossFadingFactor();
            A === 1 && A === this._crossFadingFactor || (r = !0, this._crossFadingFactor = A), this.style.update(x);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, e, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: e, showPadding: this.showPadding }), this.fire(new s.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, s.bf.mark(s.bg.load), this.fire(new s.k("load"))), this.style && (this.style.hasTransitions() || r) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const o = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return o || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.k("idle")), !this._loaded || this._fullyLoaded || o || (this._fullyLoaded = !0, s.bf.mark(s.bg.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var c;
          this._hash && this._hash.remove();
          for (const r of this._controls) r.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Te.removeThrottleControl(this._imageQueueHandle), (c = this._resizeObserver) === null || c === void 0 || c.disconnect();
          const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
          e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), O.remove(this._canvasContainer), O.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), s.bf.clearMetrics(), this._removed = !0, this.fire(new s.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController(), q.frameAsync(this._frameRequest).then((c) => {
            s.bf.frame(c), this._frameRequest = null, this._render(c);
          }).catch(() => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(c) {
          this._showTileBoundaries !== c && (this._showTileBoundaries = c, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(c) {
          this._showPadding !== c && (this._showPadding = c, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(c) {
          this._showCollisionBoxes !== c && (this._showCollisionBoxes = c, c ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(c) {
          this._showOverdrawInspector !== c && (this._showOverdrawInspector = c, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(c) {
          this._repaint !== c && (this._repaint = c, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(c) {
          this._vertices = c, this._update();
        }
        get version() {
          return ol;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, g.MapMouseEvent = Tr, g.MapTouchEvent = Ia, g.MapWheelEvent = nu, g.Marker = zl, g.NavigationControl = class {
        constructor(c) {
          this._updateZoomButtons = () => {
            const e = this._map.getZoom(), r = e === this._map.getMaxZoom(), o = e === this._map.getMinZoom();
            this._zoomInButton.disabled = r, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", r.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
          }, this._rotateCompassArrow = () => {
            const e = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = e;
          }, this._setButtonTitle = (e, r) => {
            const o = this._map._getUIString(`NavigationControl.${r}`);
            e.title = o, e.setAttribute("aria-label", o);
          }, this.options = s.e({}, fu, c), this._container = O.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e) => this._map.zoomIn({}, { originalEvent: e })), O.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e) => this._map.zoomOut({}, { originalEvent: e })), O.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
          }), this._compassIcon = O.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(c) {
          return this._map = c, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ru(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          O.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(c, e) {
          const r = O.create("button", c, this._container);
          return r.type = "button", r.addEventListener("click", e), r;
        }
      }, g.Popup = class extends s.E {
        constructor(c) {
          super(), this.remove = () => (this._content && O.remove(this._content), this._container && (O.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new s.k("close"))), this), this._onMouseUp = (e) => {
            this._update(e.point);
          }, this._onMouseMove = (e) => {
            this._update(e.point);
          }, this._onDrag = (e) => {
            this._update(e.point);
          }, this._update = (e) => {
            var r;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
            if (!this._container) {
              if (this._container = O.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = O.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const A of this.options.className.split(" ")) this._container.classList.add(A);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? Ji(this._lngLat, this._flatPos, this._map.transform) : (r = this._lngLat) === null || r === void 0 ? void 0 : r.wrap(), this._trackPointer && !e) return;
            const o = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationPoint(this._lngLat));
            let h = this.options.anchor;
            const p = y(this.options.offset);
            if (!h) {
              const A = this._container.offsetWidth, T = this._container.offsetHeight;
              let P;
              P = o.y + p.bottom.y < T ? ["top"] : o.y > this._map.transform.height - T ? ["bottom"] : [], o.x < A / 2 ? P.push("left") : o.x > this._map.transform.width - A / 2 && P.push("right"), h = P.length === 0 ? "bottom" : P.join("-");
            }
            let x = o.add(p[h]);
            this.options.subpixelPositioning || (x = x.round()), O.setTransform(this._container, `${Eo[h]} translate(${x.x}px,${x.y}px)`), Nl(this._container, h, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = s.e(Object.create(li), c);
        }
        addTo(c) {
          return this._map && this.remove(), this._map = c, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(c) {
          return this._lngLat = s.N.convert(c), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(c) {
          return this.setDOMContent(document.createTextNode(c));
        }
        setHTML(c) {
          const e = document.createDocumentFragment(), r = document.createElement("body");
          let o;
          for (r.innerHTML = c; o = r.firstChild, o; ) e.appendChild(o);
          return this.setDOMContent(e);
        }
        getMaxWidth() {
          var c;
          return (c = this._container) === null || c === void 0 ? void 0 : c.style.maxWidth;
        }
        setMaxWidth(c) {
          return this.options.maxWidth = c, this._update(), this;
        }
        setDOMContent(c) {
          if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else this._content = O.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(c), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(c) {
          return this._container && this._container.classList.add(c), this;
        }
        removeClassName(c) {
          return this._container && this._container.classList.remove(c), this;
        }
        setOffset(c) {
          return this.options.offset = c, this._update(), this;
        }
        toggleClassName(c) {
          if (this._container) return this._container.classList.toggle(c);
        }
        setSubpixelPositioning(c) {
          this.options.subpixelPositioning = c;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = O.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const c = this._container.querySelector(cl);
          c && c.focus();
        }
      }, g.RasterDEMTileSource = xt, g.RasterTileSource = lt, g.ScaleControl = class {
        constructor(c) {
          this._onMove = () => {
            bs(this._map, this._container, this.options);
          }, this.setUnit = (e) => {
            this.options.unit = e, bs(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, ma), c);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(c) {
          return this._map = c, this._container = O.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", c.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          O.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
      }, g.ScrollZoomHandler = In, g.Style = Or, g.TerrainControl = class {
        constructor(c) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = c;
        }
        onAdd(c) {
          return this._map = c, this._container = O.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = O.create("button", "maplibregl-ctrl-terrain", this._container), O.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          O.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
      }, g.TwoFingersTouchPitchHandler = wo, g.TwoFingersTouchRotateHandler = ou, g.TwoFingersTouchZoomHandler = nl, g.TwoFingersTouchZoomRotateHandler = cu, g.VectorTileSource = Rt, g.VideoSource = ni, g.addSourceType = (c, e) => s._(void 0, void 0, void 0, function* () {
        if (xi(c)) throw new Error(`A source type called "${c}" already exists.`);
        ((r, o) => {
          yi[r] = o;
        })(c, e);
      }), g.clearPrewarmedResources = function() {
        const c = $e;
        c && (c.isPreloaded() && c.numActive() === 1 ? (c.release(be), $e = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, g.getMaxParallelImageRequests = function() {
        return s.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, g.getRTLTextPluginStatus = function() {
        return kt().getRTLTextPluginStatus();
      }, g.getVersion = function() {
        return S;
      }, g.getWorkerCount = function() {
        return Ce.workerCount;
      }, g.getWorkerUrl = function() {
        return s.a.WORKER_URL;
      }, g.importScriptInWorkers = function(c) {
        return ot().broadcast("IS", c);
      }, g.prewarm = function() {
        Ke().acquire(be);
      }, g.setMaxParallelImageRequests = function(c) {
        s.a.MAX_PARALLEL_IMAGE_REQUESTS = c;
      }, g.setRTLTextPlugin = function(c, e) {
        return kt().setRTLTextPlugin(c, e);
      }, g.setWorkerCount = function(c) {
        Ce.workerCount = c;
      }, g.setWorkerUrl = function(c) {
        s.a.WORKER_URL = c;
      };
    });
    var v = l;
    return v;
  });
})(K0);
var bc = K0.exports;
(function(a) {
  if (a.TextEncoder && a.TextDecoder)
    return !1;
  function d(m = "utf-8") {
    if (m !== "utf-8")
      throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${m}') is invalid.`);
  }
  Object.defineProperty(d.prototype, "encoding", {
    value: "utf-8"
  }), d.prototype.encode = function(m, w = { stream: !1 }) {
    if (w.stream)
      throw new Error("Failed to encode: the 'stream' option is unsupported.");
    let v = 0;
    const g = m.length;
    let s = 0, D = Math.max(32, g + (g >> 1) + 7), k = new Uint8Array(D >> 3 << 3);
    for (; v < g; ) {
      let M = m.charCodeAt(v++);
      if (M >= 55296 && M <= 56319) {
        if (v < g) {
          const q = m.charCodeAt(v);
          (q & 64512) === 56320 && (++v, M = ((M & 1023) << 10) + (q & 1023) + 65536);
        }
        if (M >= 55296 && M <= 56319)
          continue;
      }
      if (s + 4 > k.length) {
        D += 8, D *= 1 + v / m.length * 2, D = D >> 3 << 3;
        const q = new Uint8Array(D);
        q.set(k), k = q;
      }
      if (M & 4294967168)
        if (!(M & 4294965248))
          k[s++] = M >> 6 & 31 | 192;
        else if (!(M & 4294901760))
          k[s++] = M >> 12 & 15 | 224, k[s++] = M >> 6 & 63 | 128;
        else if (!(M & 4292870144))
          k[s++] = M >> 18 & 7 | 240, k[s++] = M >> 12 & 63 | 128, k[s++] = M >> 6 & 63 | 128;
        else
          continue;
      else {
        k[s++] = M;
        continue;
      }
      k[s++] = M & 63 | 128;
    }
    return k.slice(0, s);
  };
  function l(m = "utf-8", w = { fatal: !1 }) {
    if (m !== "utf-8")
      throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${m}') is invalid.`);
    if (w.fatal)
      throw new Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.");
  }
  Object.defineProperty(l.prototype, "encoding", {
    value: "utf-8"
  }), Object.defineProperty(l.prototype, "fatal", { value: !1 }), Object.defineProperty(l.prototype, "ignoreBOM", {
    value: !1
  }), l.prototype.decode = function(m, w = { stream: !1 }) {
    if (w.stream)
      throw new Error("Failed to decode: the 'stream' option is unsupported.");
    const v = new Uint8Array(m);
    let g = 0;
    const s = v.length, D = [];
    for (; g < s; ) {
      const k = v[g++];
      if (k === 0)
        break;
      if (!(k & 128))
        D.push(k);
      else if ((k & 224) === 192) {
        const M = v[g++] & 63;
        D.push((k & 31) << 6 | M);
      } else if ((k & 240) === 224) {
        const M = v[g++] & 63, q = v[g++] & 63;
        D.push((k & 31) << 12 | M << 6 | q);
      } else if ((k & 248) === 240) {
        const M = v[g++] & 63, q = v[g++] & 63, O = v[g++] & 63;
        let z = (k & 7) << 18 | M << 12 | q << 6 | O;
        z > 65535 && (z -= 65536, D.push(z >>> 10 & 1023 | 55296), z = 56320 | z & 1023), D.push(z);
      }
    }
    return String.fromCharCode.apply(null, D);
  }, a.TextEncoder = d, a.TextDecoder = l;
})(typeof window < "u" ? window : typeof self < "u" ? self : void 0);
function zm(a, d = "utf8") {
  return new TextDecoder(d).decode(a);
}
const V2 = new TextEncoder();
function $2(a) {
  return V2.encode(a);
}
const Z2 = 1024 * 8, G2 = (() => {
  const a = new Uint8Array(4), d = new Uint32Array(a.buffer);
  return !((d[0] = 1) & a[0]);
})(), tp = {
  int8: globalThis.Int8Array,
  uint8: globalThis.Uint8Array,
  int16: globalThis.Int16Array,
  uint16: globalThis.Uint16Array,
  int32: globalThis.Int32Array,
  uint32: globalThis.Uint32Array,
  uint64: globalThis.BigUint64Array,
  int64: globalThis.BigInt64Array,
  float32: globalThis.Float32Array,
  float64: globalThis.Float64Array
};
class id {
  /**
   * @param data - The data to construct the IOBuffer with.
   * If data is a number, it will be the new buffer's length<br>
   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
   * @param options
   */
  constructor(d = Z2, l = {}) {
    let m = !1;
    typeof d == "number" ? d = new ArrayBuffer(d) : (m = !0, this.lastWrittenByte = d.byteLength);
    const w = l.offset ? l.offset >>> 0 : 0, v = d.byteLength - w;
    let g = w;
    (ArrayBuffer.isView(d) || d instanceof id) && (d.byteLength !== d.buffer.byteLength && (g = d.byteOffset + w), d = d.buffer), m ? this.lastWrittenByte = v : this.lastWrittenByte = 0, this.buffer = d, this.length = v, this.byteLength = v, this.byteOffset = g, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer, g, v), this._mark = 0, this._marks = [];
  }
  /**
   * Checks if the memory allocated to the buffer is sufficient to store more
   * bytes after the offset.
   * @param byteLength - The needed memory in bytes.
   * @returns `true` if there is sufficient space and `false` otherwise.
   */
  available(d = 1) {
    return this.offset + d <= this.length;
  }
  /**
   * Check if little-endian mode is used for reading and writing multi-byte
   * values.
   * @returns `true` if little-endian mode is used, `false` otherwise.
   */
  isLittleEndian() {
    return this.littleEndian;
  }
  /**
   * Set little-endian mode for reading and writing multi-byte values.
   */
  setLittleEndian() {
    return this.littleEndian = !0, this;
  }
  /**
   * Check if big-endian mode is used for reading and writing multi-byte values.
   * @returns `true` if big-endian mode is used, `false` otherwise.
   */
  isBigEndian() {
    return !this.littleEndian;
  }
  /**
   * Switches to big-endian mode for reading and writing multi-byte values.
   */
  setBigEndian() {
    return this.littleEndian = !1, this;
  }
  /**
   * Move the pointer n bytes forward.
   * @param n - Number of bytes to skip.
   */
  skip(d = 1) {
    return this.offset += d, this;
  }
  /**
   * Move the pointer n bytes backward.
   * @param n - Number of bytes to move back.
   */
  back(d = 1) {
    return this.offset -= d, this;
  }
  /**
   * Move the pointer to the given offset.
   * @param offset
   */
  seek(d) {
    return this.offset = d, this;
  }
  /**
   * Store the current pointer offset.
   * @see {@link IOBuffer#reset}
   */
  mark() {
    return this._mark = this.offset, this;
  }
  /**
   * Move the pointer back to the last pointer offset set by mark.
   * @see {@link IOBuffer#mark}
   */
  reset() {
    return this.offset = this._mark, this;
  }
  /**
   * Push the current pointer offset to the mark stack.
   * @see {@link IOBuffer#popMark}
   */
  pushMark() {
    return this._marks.push(this.offset), this;
  }
  /**
   * Pop the last pointer offset from the mark stack, and set the current
   * pointer offset to the popped value.
   * @see {@link IOBuffer#pushMark}
   */
  popMark() {
    const d = this._marks.pop();
    if (d === void 0)
      throw new Error("Mark stack empty");
    return this.seek(d), this;
  }
  /**
   * Move the pointer offset back to 0.
   */
  rewind() {
    return this.offset = 0, this;
  }
  /**
   * Make sure the buffer has sufficient memory to write a given byteLength at
   * the current pointer offset.
   * If the buffer's memory is insufficient, this method will create a new
   * buffer (a copy) with a length that is twice (byteLength + current offset).
   * @param byteLength
   */
  ensureAvailable(d = 1) {
    if (!this.available(d)) {
      const m = (this.offset + d) * 2, w = new Uint8Array(m);
      w.set(new Uint8Array(this.buffer)), this.buffer = w.buffer, this.length = this.byteLength = m, this._data = new DataView(this.buffer);
    }
    return this;
  }
  /**
   * Read a byte and return false if the byte's value is 0, or true otherwise.
   * Moves pointer forward by one byte.
   */
  readBoolean() {
    return this.readUint8() !== 0;
  }
  /**
   * Read a signed 8-bit integer and move pointer forward by 1 byte.
   */
  readInt8() {
    return this._data.getInt8(this.offset++);
  }
  /**
   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
   */
  readUint8() {
    return this._data.getUint8(this.offset++);
  }
  /**
   * Alias for {@link IOBuffer#readUint8}.
   */
  readByte() {
    return this.readUint8();
  }
  /**
   * Read `n` bytes and move pointer forward by `n` bytes.
   */
  readBytes(d = 1) {
    return this.readArray(d, "uint8");
  }
  /**
   * Creates an array of corresponding to the type `type` and size `size`.
   * For example type `uint8` will create a `Uint8Array`.
   * @param size - size of the resulting array
   * @param type - number type of elements to read
   */
  readArray(d, l) {
    const m = tp[l].BYTES_PER_ELEMENT * d, w = this.byteOffset + this.offset, v = this.buffer.slice(w, w + m);
    if (this.littleEndian === G2 && l !== "uint8" && l !== "int8") {
      const s = new Uint8Array(this.buffer.slice(w, w + m));
      s.reverse();
      const D = new tp[l](s.buffer);
      return this.offset += m, D.reverse(), D;
    }
    const g = new tp[l](v);
    return this.offset += m, g;
  }
  /**
   * Read a 16-bit signed integer and move pointer forward by 2 bytes.
   */
  readInt16() {
    const d = this._data.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, d;
  }
  /**
   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
   */
  readUint16() {
    const d = this._data.getUint16(this.offset, this.littleEndian);
    return this.offset += 2, d;
  }
  /**
   * Read a 32-bit signed integer and move pointer forward by 4 bytes.
   */
  readInt32() {
    const d = this._data.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, d;
  }
  /**
   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
   */
  readUint32() {
    const d = this._data.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, d;
  }
  /**
   * Read a 32-bit floating number and move pointer forward by 4 bytes.
   */
  readFloat32() {
    const d = this._data.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, d;
  }
  /**
   * Read a 64-bit floating number and move pointer forward by 8 bytes.
   */
  readFloat64() {
    const d = this._data.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, d;
  }
  /**
   * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
   */
  readBigInt64() {
    const d = this._data.getBigInt64(this.offset, this.littleEndian);
    return this.offset += 8, d;
  }
  /**
   * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
   */
  readBigUint64() {
    const d = this._data.getBigUint64(this.offset, this.littleEndian);
    return this.offset += 8, d;
  }
  /**
   * Read a 1-byte ASCII character and move pointer forward by 1 byte.
   */
  readChar() {
    return String.fromCharCode(this.readInt8());
  }
  /**
   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
   */
  readChars(d = 1) {
    let l = "";
    for (let m = 0; m < d; m++)
      l += this.readChar();
    return l;
  }
  /**
   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
   * forward by `n` bytes.
   */
  readUtf8(d = 1) {
    return zm(this.readBytes(d));
  }
  /**
   * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
   * forward by `n` bytes.
   * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
   */
  decodeText(d = 1, l = "utf-8") {
    return zm(this.readBytes(d), l);
  }
  /**
   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
   * forward by 1 byte.
   */
  writeBoolean(d) {
    return this.writeUint8(d ? 255 : 0), this;
  }
  /**
   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
   */
  writeInt8(d) {
    return this.ensureAvailable(1), this._data.setInt8(this.offset++, d), this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
   * byte.
   */
  writeUint8(d) {
    return this.ensureAvailable(1), this._data.setUint8(this.offset++, d), this._updateLastWrittenByte(), this;
  }
  /**
   * An alias for {@link IOBuffer#writeUint8}.
   */
  writeByte(d) {
    return this.writeUint8(d);
  }
  /**
   * Write all elements of `bytes` as uint8 values and move pointer forward by
   * `bytes.length` bytes.
   */
  writeBytes(d) {
    this.ensureAvailable(d.length);
    for (let l = 0; l < d.length; l++)
      this._data.setUint8(this.offset++, d[l]);
    return this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 16-bit signed integer and move pointer forward by 2
   * bytes.
   */
  writeInt16(d) {
    return this.ensureAvailable(2), this._data.setInt16(this.offset, d, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
   * bytes.
   */
  writeUint16(d) {
    return this.ensureAvailable(2), this._data.setUint16(this.offset, d, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit signed integer and move pointer forward by 4
   * bytes.
   */
  writeInt32(d) {
    return this.ensureAvailable(4), this._data.setInt32(this.offset, d, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
   * bytes.
   */
  writeUint32(d) {
    return this.ensureAvailable(4), this._data.setUint32(this.offset, d, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit floating number and move pointer forward by 4
   * bytes.
   */
  writeFloat32(d) {
    return this.ensureAvailable(4), this._data.setFloat32(this.offset, d, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit floating number and move pointer forward by 8
   * bytes.
   */
  writeFloat64(d) {
    return this.ensureAvailable(8), this._data.setFloat64(this.offset, d, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit signed bigint and move pointer forward by 8
   * bytes.
   */
  writeBigInt64(d) {
    return this.ensureAvailable(8), this._data.setBigInt64(this.offset, d, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
   * bytes.
   */
  writeBigUint64(d) {
    return this.ensureAvailable(8), this._data.setBigUint64(this.offset, d, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write the charCode of `str`'s first character as an 8-bit unsigned integer
   * and move pointer forward by 1 byte.
   */
  writeChar(d) {
    return this.writeUint8(d.charCodeAt(0));
  }
  /**
   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
   * and move pointer forward by `str.length` bytes.
   */
  writeChars(d) {
    for (let l = 0; l < d.length; l++)
      this.writeUint8(d.charCodeAt(l));
    return this;
  }
  /**
   * UTF-8 encode and write `str` to the current pointer offset and move pointer
   * forward according to the encoded length.
   */
  writeUtf8(d) {
    return this.writeBytes($2(d));
  }
  /**
   * Export a Uint8Array view of the internal buffer.
   * The view starts at the byte offset and its length
   * is calculated to stop at the last written byte or the original length.
   */
  toArray() {
    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
  }
  /**
   * Update the last written byte offset
   * @private
   */
  _updateLastWrittenByte() {
    this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset);
  }
}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const H2 = 4, Fm = 0, Bm = 1, W2 = 2;
function xc(a) {
  let d = a.length;
  for (; --d >= 0; )
    a[d] = 0;
}
const X2 = 0, eg = 1, Y2 = 2, J2 = 3, K2 = 258, Yp = 29, yh = 256, lh = yh + 1 + Yp, cc = 30, Jp = 19, tg = 2 * lh + 1, Tu = 15, ip = 16, Q2 = 7, Kp = 256, ig = 16, rg = 17, ng = 18, Ep = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), Jh = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), e_ = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), ag = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), t_ = 512, wl = new Array((lh + 2) * 2);
xc(wl);
const nh = new Array(cc * 2);
xc(nh);
const uh = new Array(t_);
xc(uh);
const ch = new Array(K2 - J2 + 1);
xc(ch);
const Qp = new Array(Yp);
xc(Qp);
const rd = new Array(cc);
xc(rd);
function rp(a, d, l, m, w) {
  this.static_tree = a, this.extra_bits = d, this.extra_base = l, this.elems = m, this.max_length = w, this.has_stree = a && a.length;
}
let sg, og, lg;
function np(a, d) {
  this.dyn_tree = a, this.max_code = 0, this.stat_desc = d;
}
const ug = (a) => a < 256 ? uh[a] : uh[256 + (a >>> 7)], hh = (a, d) => {
  a.pending_buf[a.pending++] = d & 255, a.pending_buf[a.pending++] = d >>> 8 & 255;
}, Fa = (a, d, l) => {
  a.bi_valid > ip - l ? (a.bi_buf |= d << a.bi_valid & 65535, hh(a, a.bi_buf), a.bi_buf = d >> ip - a.bi_valid, a.bi_valid += l - ip) : (a.bi_buf |= d << a.bi_valid & 65535, a.bi_valid += l);
}, Oo = (a, d, l) => {
  Fa(
    a,
    l[d * 2],
    l[d * 2 + 1]
    /*.Len*/
  );
}, cg = (a, d) => {
  let l = 0;
  do
    l |= a & 1, a >>>= 1, l <<= 1;
  while (--d > 0);
  return l >>> 1;
}, i_ = (a) => {
  a.bi_valid === 16 ? (hh(a, a.bi_buf), a.bi_buf = 0, a.bi_valid = 0) : a.bi_valid >= 8 && (a.pending_buf[a.pending++] = a.bi_buf & 255, a.bi_buf >>= 8, a.bi_valid -= 8);
}, r_ = (a, d) => {
  const l = d.dyn_tree, m = d.max_code, w = d.stat_desc.static_tree, v = d.stat_desc.has_stree, g = d.stat_desc.extra_bits, s = d.stat_desc.extra_base, D = d.stat_desc.max_length;
  let k, M, q, O, z, pe, le = 0;
  for (O = 0; O <= Tu; O++)
    a.bl_count[O] = 0;
  for (l[a.heap[a.heap_max] * 2 + 1] = 0, k = a.heap_max + 1; k < tg; k++)
    M = a.heap[k], O = l[l[M * 2 + 1] * 2 + 1] + 1, O > D && (O = D, le++), l[M * 2 + 1] = O, !(M > m) && (a.bl_count[O]++, z = 0, M >= s && (z = g[M - s]), pe = l[M * 2], a.opt_len += pe * (O + z), v && (a.static_len += pe * (w[M * 2 + 1] + z)));
  if (le !== 0) {
    do {
      for (O = D - 1; a.bl_count[O] === 0; )
        O--;
      a.bl_count[O]--, a.bl_count[O + 1] += 2, a.bl_count[D]--, le -= 2;
    } while (le > 0);
    for (O = D; O !== 0; O--)
      for (M = a.bl_count[O]; M !== 0; )
        q = a.heap[--k], !(q > m) && (l[q * 2 + 1] !== O && (a.opt_len += (O - l[q * 2 + 1]) * l[q * 2], l[q * 2 + 1] = O), M--);
  }
}, hg = (a, d, l) => {
  const m = new Array(Tu + 1);
  let w = 0, v, g;
  for (v = 1; v <= Tu; v++)
    w = w + l[v - 1] << 1, m[v] = w;
  for (g = 0; g <= d; g++) {
    let s = a[g * 2 + 1];
    s !== 0 && (a[g * 2] = cg(m[s]++, s));
  }
}, n_ = () => {
  let a, d, l, m, w;
  const v = new Array(Tu + 1);
  for (l = 0, m = 0; m < Yp - 1; m++)
    for (Qp[m] = l, a = 0; a < 1 << Ep[m]; a++)
      ch[l++] = m;
  for (ch[l - 1] = m, w = 0, m = 0; m < 16; m++)
    for (rd[m] = w, a = 0; a < 1 << Jh[m]; a++)
      uh[w++] = m;
  for (w >>= 7; m < cc; m++)
    for (rd[m] = w << 7, a = 0; a < 1 << Jh[m] - 7; a++)
      uh[256 + w++] = m;
  for (d = 0; d <= Tu; d++)
    v[d] = 0;
  for (a = 0; a <= 143; )
    wl[a * 2 + 1] = 8, a++, v[8]++;
  for (; a <= 255; )
    wl[a * 2 + 1] = 9, a++, v[9]++;
  for (; a <= 279; )
    wl[a * 2 + 1] = 7, a++, v[7]++;
  for (; a <= 287; )
    wl[a * 2 + 1] = 8, a++, v[8]++;
  for (hg(wl, lh + 1, v), a = 0; a < cc; a++)
    nh[a * 2 + 1] = 5, nh[a * 2] = cg(a, 5);
  sg = new rp(wl, Ep, yh + 1, lh, Tu), og = new rp(nh, Jh, 0, cc, Tu), lg = new rp(new Array(0), e_, 0, Jp, Q2);
}, dg = (a) => {
  let d;
  for (d = 0; d < lh; d++)
    a.dyn_ltree[d * 2] = 0;
  for (d = 0; d < cc; d++)
    a.dyn_dtree[d * 2] = 0;
  for (d = 0; d < Jp; d++)
    a.bl_tree[d * 2] = 0;
  a.dyn_ltree[Kp * 2] = 1, a.opt_len = a.static_len = 0, a.sym_next = a.matches = 0;
}, pg = (a) => {
  a.bi_valid > 8 ? hh(a, a.bi_buf) : a.bi_valid > 0 && (a.pending_buf[a.pending++] = a.bi_buf), a.bi_buf = 0, a.bi_valid = 0;
}, Rm = (a, d, l, m) => {
  const w = d * 2, v = l * 2;
  return a[w] < a[v] || a[w] === a[v] && m[d] <= m[l];
}, ap = (a, d, l) => {
  const m = a.heap[l];
  let w = l << 1;
  for (; w <= a.heap_len && (w < a.heap_len && Rm(d, a.heap[w + 1], a.heap[w], a.depth) && w++, !Rm(d, m, a.heap[w], a.depth)); )
    a.heap[l] = a.heap[w], l = w, w <<= 1;
  a.heap[l] = m;
}, Om = (a, d, l) => {
  let m, w, v = 0, g, s;
  if (a.sym_next !== 0)
    do
      m = a.pending_buf[a.sym_buf + v++] & 255, m += (a.pending_buf[a.sym_buf + v++] & 255) << 8, w = a.pending_buf[a.sym_buf + v++], m === 0 ? Oo(a, w, d) : (g = ch[w], Oo(a, g + yh + 1, d), s = Ep[g], s !== 0 && (w -= Qp[g], Fa(a, w, s)), m--, g = ug(m), Oo(a, g, l), s = Jh[g], s !== 0 && (m -= rd[g], Fa(a, m, s)));
    while (v < a.sym_next);
  Oo(a, Kp, d);
}, Tp = (a, d) => {
  const l = d.dyn_tree, m = d.stat_desc.static_tree, w = d.stat_desc.has_stree, v = d.stat_desc.elems;
  let g, s, D = -1, k;
  for (a.heap_len = 0, a.heap_max = tg, g = 0; g < v; g++)
    l[g * 2] !== 0 ? (a.heap[++a.heap_len] = D = g, a.depth[g] = 0) : l[g * 2 + 1] = 0;
  for (; a.heap_len < 2; )
    k = a.heap[++a.heap_len] = D < 2 ? ++D : 0, l[k * 2] = 1, a.depth[k] = 0, a.opt_len--, w && (a.static_len -= m[k * 2 + 1]);
  for (d.max_code = D, g = a.heap_len >> 1; g >= 1; g--)
    ap(a, l, g);
  k = v;
  do
    g = a.heap[
      1
      /*SMALLEST*/
    ], a.heap[
      1
      /*SMALLEST*/
    ] = a.heap[a.heap_len--], ap(
      a,
      l,
      1
      /*SMALLEST*/
    ), s = a.heap[
      1
      /*SMALLEST*/
    ], a.heap[--a.heap_max] = g, a.heap[--a.heap_max] = s, l[k * 2] = l[g * 2] + l[s * 2], a.depth[k] = (a.depth[g] >= a.depth[s] ? a.depth[g] : a.depth[s]) + 1, l[g * 2 + 1] = l[s * 2 + 1] = k, a.heap[
      1
      /*SMALLEST*/
    ] = k++, ap(
      a,
      l,
      1
      /*SMALLEST*/
    );
  while (a.heap_len >= 2);
  a.heap[--a.heap_max] = a.heap[
    1
    /*SMALLEST*/
  ], r_(a, d), hg(l, D, a.bl_count);
}, jm = (a, d, l) => {
  let m, w = -1, v, g = d[0 * 2 + 1], s = 0, D = 7, k = 4;
  for (g === 0 && (D = 138, k = 3), d[(l + 1) * 2 + 1] = 65535, m = 0; m <= l; m++)
    v = g, g = d[(m + 1) * 2 + 1], !(++s < D && v === g) && (s < k ? a.bl_tree[v * 2] += s : v !== 0 ? (v !== w && a.bl_tree[v * 2]++, a.bl_tree[ig * 2]++) : s <= 10 ? a.bl_tree[rg * 2]++ : a.bl_tree[ng * 2]++, s = 0, w = v, g === 0 ? (D = 138, k = 3) : v === g ? (D = 6, k = 3) : (D = 7, k = 4));
}, qm = (a, d, l) => {
  let m, w = -1, v, g = d[0 * 2 + 1], s = 0, D = 7, k = 4;
  for (g === 0 && (D = 138, k = 3), m = 0; m <= l; m++)
    if (v = g, g = d[(m + 1) * 2 + 1], !(++s < D && v === g)) {
      if (s < k)
        do
          Oo(a, v, a.bl_tree);
        while (--s !== 0);
      else v !== 0 ? (v !== w && (Oo(a, v, a.bl_tree), s--), Oo(a, ig, a.bl_tree), Fa(a, s - 3, 2)) : s <= 10 ? (Oo(a, rg, a.bl_tree), Fa(a, s - 3, 3)) : (Oo(a, ng, a.bl_tree), Fa(a, s - 11, 7));
      s = 0, w = v, g === 0 ? (D = 138, k = 3) : v === g ? (D = 6, k = 3) : (D = 7, k = 4);
    }
}, a_ = (a) => {
  let d;
  for (jm(a, a.dyn_ltree, a.l_desc.max_code), jm(a, a.dyn_dtree, a.d_desc.max_code), Tp(a, a.bl_desc), d = Jp - 1; d >= 3 && a.bl_tree[ag[d] * 2 + 1] === 0; d--)
    ;
  return a.opt_len += 3 * (d + 1) + 5 + 5 + 4, d;
}, s_ = (a, d, l, m) => {
  let w;
  for (Fa(a, d - 257, 5), Fa(a, l - 1, 5), Fa(a, m - 4, 4), w = 0; w < m; w++)
    Fa(a, a.bl_tree[ag[w] * 2 + 1], 3);
  qm(a, a.dyn_ltree, d - 1), qm(a, a.dyn_dtree, l - 1);
}, o_ = (a) => {
  let d = 4093624447, l;
  for (l = 0; l <= 31; l++, d >>>= 1)
    if (d & 1 && a.dyn_ltree[l * 2] !== 0)
      return Fm;
  if (a.dyn_ltree[9 * 2] !== 0 || a.dyn_ltree[10 * 2] !== 0 || a.dyn_ltree[13 * 2] !== 0)
    return Bm;
  for (l = 32; l < yh; l++)
    if (a.dyn_ltree[l * 2] !== 0)
      return Bm;
  return Fm;
};
let Um = !1;
const l_ = (a) => {
  Um || (n_(), Um = !0), a.l_desc = new np(a.dyn_ltree, sg), a.d_desc = new np(a.dyn_dtree, og), a.bl_desc = new np(a.bl_tree, lg), a.bi_buf = 0, a.bi_valid = 0, dg(a);
}, fg = (a, d, l, m) => {
  Fa(a, (X2 << 1) + (m ? 1 : 0), 3), pg(a), hh(a, l), hh(a, ~l), l && a.pending_buf.set(a.window.subarray(d, d + l), a.pending), a.pending += l;
}, u_ = (a) => {
  Fa(a, eg << 1, 3), Oo(a, Kp, wl), i_(a);
}, c_ = (a, d, l, m) => {
  let w, v, g = 0;
  a.level > 0 ? (a.strm.data_type === W2 && (a.strm.data_type = o_(a)), Tp(a, a.l_desc), Tp(a, a.d_desc), g = a_(a), w = a.opt_len + 3 + 7 >>> 3, v = a.static_len + 3 + 7 >>> 3, v <= w && (w = v)) : w = v = l + 5, l + 4 <= w && d !== -1 ? fg(a, d, l, m) : a.strategy === H2 || v === w ? (Fa(a, (eg << 1) + (m ? 1 : 0), 3), Om(a, wl, nh)) : (Fa(a, (Y2 << 1) + (m ? 1 : 0), 3), s_(a, a.l_desc.max_code + 1, a.d_desc.max_code + 1, g + 1), Om(a, a.dyn_ltree, a.dyn_dtree)), dg(a), m && pg(a);
}, h_ = (a, d, l) => (a.pending_buf[a.sym_buf + a.sym_next++] = d, a.pending_buf[a.sym_buf + a.sym_next++] = d >> 8, a.pending_buf[a.sym_buf + a.sym_next++] = l, d === 0 ? a.dyn_ltree[l * 2]++ : (a.matches++, d--, a.dyn_ltree[(ch[l] + yh + 1) * 2]++, a.dyn_dtree[ug(d) * 2]++), a.sym_next === a.sym_end);
var d_ = l_, p_ = fg, f_ = c_, m_ = h_, g_ = u_, __ = {
  _tr_init: d_,
  _tr_stored_block: p_,
  _tr_flush_block: f_,
  _tr_tally: m_,
  _tr_align: g_
};
const y_ = (a, d, l, m) => {
  let w = a & 65535 | 0, v = a >>> 16 & 65535 | 0, g = 0;
  for (; l !== 0; ) {
    g = l > 2e3 ? 2e3 : l, l -= g;
    do
      w = w + d[m++] | 0, v = v + w | 0;
    while (--g);
    w %= 65521, v %= 65521;
  }
  return w | v << 16 | 0;
};
var dh = y_;
const v_ = () => {
  let a, d = [];
  for (var l = 0; l < 256; l++) {
    a = l;
    for (var m = 0; m < 8; m++)
      a = a & 1 ? 3988292384 ^ a >>> 1 : a >>> 1;
    d[l] = a;
  }
  return d;
}, b_ = new Uint32Array(v_()), x_ = (a, d, l, m) => {
  const w = b_, v = m + l;
  a ^= -1;
  for (let g = m; g < v; g++)
    a = a >>> 8 ^ w[(a ^ d[g]) & 255];
  return a ^ -1;
};
var Sn = x_, mc = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, vh = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: w_, _tr_stored_block: Cp, _tr_flush_block: A_, _tr_tally: Yl, _tr_align: S_ } = __, {
  Z_NO_FLUSH: Jl,
  Z_PARTIAL_FLUSH: E_,
  Z_FULL_FLUSH: T_,
  Z_FINISH: Ds,
  Z_BLOCK: Vm,
  Z_OK: Bn,
  Z_STREAM_END: $m,
  Z_STREAM_ERROR: qo,
  Z_DATA_ERROR: C_,
  Z_BUF_ERROR: sp,
  Z_DEFAULT_COMPRESSION: D_,
  Z_FILTERED: I_,
  Z_HUFFMAN_ONLY: qh,
  Z_RLE: k_,
  Z_FIXED: P_,
  Z_DEFAULT_STRATEGY: L_,
  Z_UNKNOWN: M_,
  Z_DEFLATED: cd
} = vh, N_ = 9, z_ = 15, F_ = 8, B_ = 29, R_ = 256, Dp = R_ + 1 + B_, O_ = 30, j_ = 19, q_ = 2 * Dp + 1, U_ = 15, $i = 3, Wl = 258, Uo = Wl + $i + 1, V_ = 32, gc = 42, ef = 57, Ip = 69, kp = 73, Pp = 91, Lp = 103, Cu = 113, th = 666, va = 1, wc = 2, Pu = 3, Ac = 4, $_ = 3, Du = (a, d) => (a.msg = mc[d], d), Zm = (a) => a * 2 - (a > 4 ? 9 : 0), Gl = (a) => {
  let d = a.length;
  for (; --d >= 0; )
    a[d] = 0;
}, Z_ = (a) => {
  let d, l, m, w = a.w_size;
  d = a.hash_size, m = d;
  do
    l = a.head[--m], a.head[m] = l >= w ? l - w : 0;
  while (--d);
  d = w, m = d;
  do
    l = a.prev[--m], a.prev[m] = l >= w ? l - w : 0;
  while (--d);
};
let G_ = (a, d, l) => (d << a.hash_shift ^ l) & a.hash_mask, Kl = G_;
const ns = (a) => {
  const d = a.state;
  let l = d.pending;
  l > a.avail_out && (l = a.avail_out), l !== 0 && (a.output.set(d.pending_buf.subarray(d.pending_out, d.pending_out + l), a.next_out), a.next_out += l, d.pending_out += l, a.total_out += l, a.avail_out -= l, d.pending -= l, d.pending === 0 && (d.pending_out = 0));
}, as = (a, d) => {
  A_(a, a.block_start >= 0 ? a.block_start : -1, a.strstart - a.block_start, d), a.block_start = a.strstart, ns(a.strm);
}, er = (a, d) => {
  a.pending_buf[a.pending++] = d;
}, Yc = (a, d) => {
  a.pending_buf[a.pending++] = d >>> 8 & 255, a.pending_buf[a.pending++] = d & 255;
}, Mp = (a, d, l, m) => {
  let w = a.avail_in;
  return w > m && (w = m), w === 0 ? 0 : (a.avail_in -= w, d.set(a.input.subarray(a.next_in, a.next_in + w), l), a.state.wrap === 1 ? a.adler = dh(a.adler, d, w, l) : a.state.wrap === 2 && (a.adler = Sn(a.adler, d, w, l)), a.next_in += w, a.total_in += w, w);
}, mg = (a, d) => {
  let l = a.max_chain_length, m = a.strstart, w, v, g = a.prev_length, s = a.nice_match;
  const D = a.strstart > a.w_size - Uo ? a.strstart - (a.w_size - Uo) : 0, k = a.window, M = a.w_mask, q = a.prev, O = a.strstart + Wl;
  let z = k[m + g - 1], pe = k[m + g];
  a.prev_length >= a.good_match && (l >>= 2), s > a.lookahead && (s = a.lookahead);
  do
    if (w = d, !(k[w + g] !== pe || k[w + g - 1] !== z || k[w] !== k[m] || k[++w] !== k[m + 1])) {
      m += 2, w++;
      do
        ;
      while (k[++m] === k[++w] && k[++m] === k[++w] && k[++m] === k[++w] && k[++m] === k[++w] && k[++m] === k[++w] && k[++m] === k[++w] && k[++m] === k[++w] && k[++m] === k[++w] && m < O);
      if (v = Wl - (O - m), m = O - Wl, v > g) {
        if (a.match_start = d, g = v, v >= s)
          break;
        z = k[m + g - 1], pe = k[m + g];
      }
    }
  while ((d = q[d & M]) > D && --l !== 0);
  return g <= a.lookahead ? g : a.lookahead;
}, _c = (a) => {
  const d = a.w_size;
  let l, m, w;
  do {
    if (m = a.window_size - a.lookahead - a.strstart, a.strstart >= d + (d - Uo) && (a.window.set(a.window.subarray(d, d + d - m), 0), a.match_start -= d, a.strstart -= d, a.block_start -= d, a.insert > a.strstart && (a.insert = a.strstart), Z_(a), m += d), a.strm.avail_in === 0)
      break;
    if (l = Mp(a.strm, a.window, a.strstart + a.lookahead, m), a.lookahead += l, a.lookahead + a.insert >= $i)
      for (w = a.strstart - a.insert, a.ins_h = a.window[w], a.ins_h = Kl(a, a.ins_h, a.window[w + 1]); a.insert && (a.ins_h = Kl(a, a.ins_h, a.window[w + $i - 1]), a.prev[w & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = w, w++, a.insert--, !(a.lookahead + a.insert < $i)); )
        ;
  } while (a.lookahead < Uo && a.strm.avail_in !== 0);
}, gg = (a, d) => {
  let l = a.pending_buf_size - 5 > a.w_size ? a.w_size : a.pending_buf_size - 5, m, w, v, g = 0, s = a.strm.avail_in;
  do {
    if (m = 65535, v = a.bi_valid + 42 >> 3, a.strm.avail_out < v || (v = a.strm.avail_out - v, w = a.strstart - a.block_start, m > w + a.strm.avail_in && (m = w + a.strm.avail_in), m > v && (m = v), m < l && (m === 0 && d !== Ds || d === Jl || m !== w + a.strm.avail_in)))
      break;
    g = d === Ds && m === w + a.strm.avail_in ? 1 : 0, Cp(a, 0, 0, g), a.pending_buf[a.pending - 4] = m, a.pending_buf[a.pending - 3] = m >> 8, a.pending_buf[a.pending - 2] = ~m, a.pending_buf[a.pending - 1] = ~m >> 8, ns(a.strm), w && (w > m && (w = m), a.strm.output.set(a.window.subarray(a.block_start, a.block_start + w), a.strm.next_out), a.strm.next_out += w, a.strm.avail_out -= w, a.strm.total_out += w, a.block_start += w, m -= w), m && (Mp(a.strm, a.strm.output, a.strm.next_out, m), a.strm.next_out += m, a.strm.avail_out -= m, a.strm.total_out += m);
  } while (g === 0);
  return s -= a.strm.avail_in, s && (s >= a.w_size ? (a.matches = 2, a.window.set(a.strm.input.subarray(a.strm.next_in - a.w_size, a.strm.next_in), 0), a.strstart = a.w_size, a.insert = a.strstart) : (a.window_size - a.strstart <= s && (a.strstart -= a.w_size, a.window.set(a.window.subarray(a.w_size, a.w_size + a.strstart), 0), a.matches < 2 && a.matches++, a.insert > a.strstart && (a.insert = a.strstart)), a.window.set(a.strm.input.subarray(a.strm.next_in - s, a.strm.next_in), a.strstart), a.strstart += s, a.insert += s > a.w_size - a.insert ? a.w_size - a.insert : s), a.block_start = a.strstart), a.high_water < a.strstart && (a.high_water = a.strstart), g ? Ac : d !== Jl && d !== Ds && a.strm.avail_in === 0 && a.strstart === a.block_start ? wc : (v = a.window_size - a.strstart, a.strm.avail_in > v && a.block_start >= a.w_size && (a.block_start -= a.w_size, a.strstart -= a.w_size, a.window.set(a.window.subarray(a.w_size, a.w_size + a.strstart), 0), a.matches < 2 && a.matches++, v += a.w_size, a.insert > a.strstart && (a.insert = a.strstart)), v > a.strm.avail_in && (v = a.strm.avail_in), v && (Mp(a.strm, a.window, a.strstart, v), a.strstart += v, a.insert += v > a.w_size - a.insert ? a.w_size - a.insert : v), a.high_water < a.strstart && (a.high_water = a.strstart), v = a.bi_valid + 42 >> 3, v = a.pending_buf_size - v > 65535 ? 65535 : a.pending_buf_size - v, l = v > a.w_size ? a.w_size : v, w = a.strstart - a.block_start, (w >= l || (w || d === Ds) && d !== Jl && a.strm.avail_in === 0 && w <= v) && (m = w > v ? v : w, g = d === Ds && a.strm.avail_in === 0 && m === w ? 1 : 0, Cp(a, a.block_start, m, g), a.block_start += m, ns(a.strm)), g ? Pu : va);
}, op = (a, d) => {
  let l, m;
  for (; ; ) {
    if (a.lookahead < Uo) {
      if (_c(a), a.lookahead < Uo && d === Jl)
        return va;
      if (a.lookahead === 0)
        break;
    }
    if (l = 0, a.lookahead >= $i && (a.ins_h = Kl(a, a.ins_h, a.window[a.strstart + $i - 1]), l = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart), l !== 0 && a.strstart - l <= a.w_size - Uo && (a.match_length = mg(a, l)), a.match_length >= $i)
      if (m = Yl(a, a.strstart - a.match_start, a.match_length - $i), a.lookahead -= a.match_length, a.match_length <= a.max_lazy_match && a.lookahead >= $i) {
        a.match_length--;
        do
          a.strstart++, a.ins_h = Kl(a, a.ins_h, a.window[a.strstart + $i - 1]), l = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart;
        while (--a.match_length !== 0);
        a.strstart++;
      } else
        a.strstart += a.match_length, a.match_length = 0, a.ins_h = a.window[a.strstart], a.ins_h = Kl(a, a.ins_h, a.window[a.strstart + 1]);
    else
      m = Yl(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++;
    if (m && (as(a, !1), a.strm.avail_out === 0))
      return va;
  }
  return a.insert = a.strstart < $i - 1 ? a.strstart : $i - 1, d === Ds ? (as(a, !0), a.strm.avail_out === 0 ? Pu : Ac) : a.sym_next && (as(a, !1), a.strm.avail_out === 0) ? va : wc;
}, rc = (a, d) => {
  let l, m, w;
  for (; ; ) {
    if (a.lookahead < Uo) {
      if (_c(a), a.lookahead < Uo && d === Jl)
        return va;
      if (a.lookahead === 0)
        break;
    }
    if (l = 0, a.lookahead >= $i && (a.ins_h = Kl(a, a.ins_h, a.window[a.strstart + $i - 1]), l = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart), a.prev_length = a.match_length, a.prev_match = a.match_start, a.match_length = $i - 1, l !== 0 && a.prev_length < a.max_lazy_match && a.strstart - l <= a.w_size - Uo && (a.match_length = mg(a, l), a.match_length <= 5 && (a.strategy === I_ || a.match_length === $i && a.strstart - a.match_start > 4096) && (a.match_length = $i - 1)), a.prev_length >= $i && a.match_length <= a.prev_length) {
      w = a.strstart + a.lookahead - $i, m = Yl(a, a.strstart - 1 - a.prev_match, a.prev_length - $i), a.lookahead -= a.prev_length - 1, a.prev_length -= 2;
      do
        ++a.strstart <= w && (a.ins_h = Kl(a, a.ins_h, a.window[a.strstart + $i - 1]), l = a.prev[a.strstart & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = a.strstart);
      while (--a.prev_length !== 0);
      if (a.match_available = 0, a.match_length = $i - 1, a.strstart++, m && (as(a, !1), a.strm.avail_out === 0))
        return va;
    } else if (a.match_available) {
      if (m = Yl(a, 0, a.window[a.strstart - 1]), m && as(a, !1), a.strstart++, a.lookahead--, a.strm.avail_out === 0)
        return va;
    } else
      a.match_available = 1, a.strstart++, a.lookahead--;
  }
  return a.match_available && (m = Yl(a, 0, a.window[a.strstart - 1]), a.match_available = 0), a.insert = a.strstart < $i - 1 ? a.strstart : $i - 1, d === Ds ? (as(a, !0), a.strm.avail_out === 0 ? Pu : Ac) : a.sym_next && (as(a, !1), a.strm.avail_out === 0) ? va : wc;
}, H_ = (a, d) => {
  let l, m, w, v;
  const g = a.window;
  for (; ; ) {
    if (a.lookahead <= Wl) {
      if (_c(a), a.lookahead <= Wl && d === Jl)
        return va;
      if (a.lookahead === 0)
        break;
    }
    if (a.match_length = 0, a.lookahead >= $i && a.strstart > 0 && (w = a.strstart - 1, m = g[w], m === g[++w] && m === g[++w] && m === g[++w])) {
      v = a.strstart + Wl;
      do
        ;
      while (m === g[++w] && m === g[++w] && m === g[++w] && m === g[++w] && m === g[++w] && m === g[++w] && m === g[++w] && m === g[++w] && w < v);
      a.match_length = Wl - (v - w), a.match_length > a.lookahead && (a.match_length = a.lookahead);
    }
    if (a.match_length >= $i ? (l = Yl(a, 1, a.match_length - $i), a.lookahead -= a.match_length, a.strstart += a.match_length, a.match_length = 0) : (l = Yl(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++), l && (as(a, !1), a.strm.avail_out === 0))
      return va;
  }
  return a.insert = 0, d === Ds ? (as(a, !0), a.strm.avail_out === 0 ? Pu : Ac) : a.sym_next && (as(a, !1), a.strm.avail_out === 0) ? va : wc;
}, W_ = (a, d) => {
  let l;
  for (; ; ) {
    if (a.lookahead === 0 && (_c(a), a.lookahead === 0)) {
      if (d === Jl)
        return va;
      break;
    }
    if (a.match_length = 0, l = Yl(a, 0, a.window[a.strstart]), a.lookahead--, a.strstart++, l && (as(a, !1), a.strm.avail_out === 0))
      return va;
  }
  return a.insert = 0, d === Ds ? (as(a, !0), a.strm.avail_out === 0 ? Pu : Ac) : a.sym_next && (as(a, !1), a.strm.avail_out === 0) ? va : wc;
};
function Bo(a, d, l, m, w) {
  this.good_length = a, this.max_lazy = d, this.nice_length = l, this.max_chain = m, this.func = w;
}
const ih = [
  /*      good lazy nice chain */
  new Bo(0, 0, 0, 0, gg),
  /* 0 store only */
  new Bo(4, 4, 8, 4, op),
  /* 1 max speed, no lazy matches */
  new Bo(4, 5, 16, 8, op),
  /* 2 */
  new Bo(4, 6, 32, 32, op),
  /* 3 */
  new Bo(4, 4, 16, 16, rc),
  /* 4 lazy matches */
  new Bo(8, 16, 32, 32, rc),
  /* 5 */
  new Bo(8, 16, 128, 128, rc),
  /* 6 */
  new Bo(8, 32, 128, 256, rc),
  /* 7 */
  new Bo(32, 128, 258, 1024, rc),
  /* 8 */
  new Bo(32, 258, 258, 4096, rc)
  /* 9 max compression */
], X_ = (a) => {
  a.window_size = 2 * a.w_size, Gl(a.head), a.max_lazy_match = ih[a.level].max_lazy, a.good_match = ih[a.level].good_length, a.nice_match = ih[a.level].nice_length, a.max_chain_length = ih[a.level].max_chain, a.strstart = 0, a.block_start = 0, a.lookahead = 0, a.insert = 0, a.match_length = a.prev_length = $i - 1, a.match_available = 0, a.ins_h = 0;
};
function Y_() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = cd, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(q_ * 2), this.dyn_dtree = new Uint16Array((2 * O_ + 1) * 2), this.bl_tree = new Uint16Array((2 * j_ + 1) * 2), Gl(this.dyn_ltree), Gl(this.dyn_dtree), Gl(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(U_ + 1), this.heap = new Uint16Array(2 * Dp + 1), Gl(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * Dp + 1), Gl(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const bh = (a) => {
  if (!a)
    return 1;
  const d = a.state;
  return !d || d.strm !== a || d.status !== gc && //#ifdef GZIP
  d.status !== ef && //#endif
  d.status !== Ip && d.status !== kp && d.status !== Pp && d.status !== Lp && d.status !== Cu && d.status !== th ? 1 : 0;
}, _g = (a) => {
  if (bh(a))
    return Du(a, qo);
  a.total_in = a.total_out = 0, a.data_type = M_;
  const d = a.state;
  return d.pending = 0, d.pending_out = 0, d.wrap < 0 && (d.wrap = -d.wrap), d.status = //#ifdef GZIP
  d.wrap === 2 ? ef : (
    //#endif
    d.wrap ? gc : Cu
  ), a.adler = d.wrap === 2 ? 0 : 1, d.last_flush = -2, w_(d), Bn;
}, yg = (a) => {
  const d = _g(a);
  return d === Bn && X_(a.state), d;
}, J_ = (a, d) => bh(a) || a.state.wrap !== 2 ? qo : (a.state.gzhead = d, Bn), vg = (a, d, l, m, w, v) => {
  if (!a)
    return qo;
  let g = 1;
  if (d === D_ && (d = 6), m < 0 ? (g = 0, m = -m) : m > 15 && (g = 2, m -= 16), w < 1 || w > N_ || l !== cd || m < 8 || m > 15 || d < 0 || d > 9 || v < 0 || v > P_ || m === 8 && g !== 1)
    return Du(a, qo);
  m === 8 && (m = 9);
  const s = new Y_();
  return a.state = s, s.strm = a, s.status = gc, s.wrap = g, s.gzhead = null, s.w_bits = m, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = w + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + $i - 1) / $i), s.window = new Uint8Array(s.w_size * 2), s.head = new Uint16Array(s.hash_size), s.prev = new Uint16Array(s.w_size), s.lit_bufsize = 1 << w + 6, s.pending_buf_size = s.lit_bufsize * 4, s.pending_buf = new Uint8Array(s.pending_buf_size), s.sym_buf = s.lit_bufsize, s.sym_end = (s.lit_bufsize - 1) * 3, s.level = d, s.strategy = v, s.method = l, yg(a);
}, K_ = (a, d) => vg(a, d, cd, z_, F_, L_), Q_ = (a, d) => {
  if (bh(a) || d > Vm || d < 0)
    return a ? Du(a, qo) : qo;
  const l = a.state;
  if (!a.output || a.avail_in !== 0 && !a.input || l.status === th && d !== Ds)
    return Du(a, a.avail_out === 0 ? sp : qo);
  const m = l.last_flush;
  if (l.last_flush = d, l.pending !== 0) {
    if (ns(a), a.avail_out === 0)
      return l.last_flush = -1, Bn;
  } else if (a.avail_in === 0 && Zm(d) <= Zm(m) && d !== Ds)
    return Du(a, sp);
  if (l.status === th && a.avail_in !== 0)
    return Du(a, sp);
  if (l.status === gc && l.wrap === 0 && (l.status = Cu), l.status === gc) {
    let w = cd + (l.w_bits - 8 << 4) << 8, v = -1;
    if (l.strategy >= qh || l.level < 2 ? v = 0 : l.level < 6 ? v = 1 : l.level === 6 ? v = 2 : v = 3, w |= v << 6, l.strstart !== 0 && (w |= V_), w += 31 - w % 31, Yc(l, w), l.strstart !== 0 && (Yc(l, a.adler >>> 16), Yc(l, a.adler & 65535)), a.adler = 1, l.status = Cu, ns(a), l.pending !== 0)
      return l.last_flush = -1, Bn;
  }
  if (l.status === ef) {
    if (a.adler = 0, er(l, 31), er(l, 139), er(l, 8), l.gzhead)
      er(
        l,
        (l.gzhead.text ? 1 : 0) + (l.gzhead.hcrc ? 2 : 0) + (l.gzhead.extra ? 4 : 0) + (l.gzhead.name ? 8 : 0) + (l.gzhead.comment ? 16 : 0)
      ), er(l, l.gzhead.time & 255), er(l, l.gzhead.time >> 8 & 255), er(l, l.gzhead.time >> 16 & 255), er(l, l.gzhead.time >> 24 & 255), er(l, l.level === 9 ? 2 : l.strategy >= qh || l.level < 2 ? 4 : 0), er(l, l.gzhead.os & 255), l.gzhead.extra && l.gzhead.extra.length && (er(l, l.gzhead.extra.length & 255), er(l, l.gzhead.extra.length >> 8 & 255)), l.gzhead.hcrc && (a.adler = Sn(a.adler, l.pending_buf, l.pending, 0)), l.gzindex = 0, l.status = Ip;
    else if (er(l, 0), er(l, 0), er(l, 0), er(l, 0), er(l, 0), er(l, l.level === 9 ? 2 : l.strategy >= qh || l.level < 2 ? 4 : 0), er(l, $_), l.status = Cu, ns(a), l.pending !== 0)
      return l.last_flush = -1, Bn;
  }
  if (l.status === Ip) {
    if (l.gzhead.extra) {
      let w = l.pending, v = (l.gzhead.extra.length & 65535) - l.gzindex;
      for (; l.pending + v > l.pending_buf_size; ) {
        let s = l.pending_buf_size - l.pending;
        if (l.pending_buf.set(l.gzhead.extra.subarray(l.gzindex, l.gzindex + s), l.pending), l.pending = l.pending_buf_size, l.gzhead.hcrc && l.pending > w && (a.adler = Sn(a.adler, l.pending_buf, l.pending - w, w)), l.gzindex += s, ns(a), l.pending !== 0)
          return l.last_flush = -1, Bn;
        w = 0, v -= s;
      }
      let g = new Uint8Array(l.gzhead.extra);
      l.pending_buf.set(g.subarray(l.gzindex, l.gzindex + v), l.pending), l.pending += v, l.gzhead.hcrc && l.pending > w && (a.adler = Sn(a.adler, l.pending_buf, l.pending - w, w)), l.gzindex = 0;
    }
    l.status = kp;
  }
  if (l.status === kp) {
    if (l.gzhead.name) {
      let w = l.pending, v;
      do {
        if (l.pending === l.pending_buf_size) {
          if (l.gzhead.hcrc && l.pending > w && (a.adler = Sn(a.adler, l.pending_buf, l.pending - w, w)), ns(a), l.pending !== 0)
            return l.last_flush = -1, Bn;
          w = 0;
        }
        l.gzindex < l.gzhead.name.length ? v = l.gzhead.name.charCodeAt(l.gzindex++) & 255 : v = 0, er(l, v);
      } while (v !== 0);
      l.gzhead.hcrc && l.pending > w && (a.adler = Sn(a.adler, l.pending_buf, l.pending - w, w)), l.gzindex = 0;
    }
    l.status = Pp;
  }
  if (l.status === Pp) {
    if (l.gzhead.comment) {
      let w = l.pending, v;
      do {
        if (l.pending === l.pending_buf_size) {
          if (l.gzhead.hcrc && l.pending > w && (a.adler = Sn(a.adler, l.pending_buf, l.pending - w, w)), ns(a), l.pending !== 0)
            return l.last_flush = -1, Bn;
          w = 0;
        }
        l.gzindex < l.gzhead.comment.length ? v = l.gzhead.comment.charCodeAt(l.gzindex++) & 255 : v = 0, er(l, v);
      } while (v !== 0);
      l.gzhead.hcrc && l.pending > w && (a.adler = Sn(a.adler, l.pending_buf, l.pending - w, w));
    }
    l.status = Lp;
  }
  if (l.status === Lp) {
    if (l.gzhead.hcrc) {
      if (l.pending + 2 > l.pending_buf_size && (ns(a), l.pending !== 0))
        return l.last_flush = -1, Bn;
      er(l, a.adler & 255), er(l, a.adler >> 8 & 255), a.adler = 0;
    }
    if (l.status = Cu, ns(a), l.pending !== 0)
      return l.last_flush = -1, Bn;
  }
  if (a.avail_in !== 0 || l.lookahead !== 0 || d !== Jl && l.status !== th) {
    let w = l.level === 0 ? gg(l, d) : l.strategy === qh ? W_(l, d) : l.strategy === k_ ? H_(l, d) : ih[l.level].func(l, d);
    if ((w === Pu || w === Ac) && (l.status = th), w === va || w === Pu)
      return a.avail_out === 0 && (l.last_flush = -1), Bn;
    if (w === wc && (d === E_ ? S_(l) : d !== Vm && (Cp(l, 0, 0, !1), d === T_ && (Gl(l.head), l.lookahead === 0 && (l.strstart = 0, l.block_start = 0, l.insert = 0))), ns(a), a.avail_out === 0))
      return l.last_flush = -1, Bn;
  }
  return d !== Ds ? Bn : l.wrap <= 0 ? $m : (l.wrap === 2 ? (er(l, a.adler & 255), er(l, a.adler >> 8 & 255), er(l, a.adler >> 16 & 255), er(l, a.adler >> 24 & 255), er(l, a.total_in & 255), er(l, a.total_in >> 8 & 255), er(l, a.total_in >> 16 & 255), er(l, a.total_in >> 24 & 255)) : (Yc(l, a.adler >>> 16), Yc(l, a.adler & 65535)), ns(a), l.wrap > 0 && (l.wrap = -l.wrap), l.pending !== 0 ? Bn : $m);
}, ey = (a) => {
  if (bh(a))
    return qo;
  const d = a.state.status;
  return a.state = null, d === Cu ? Du(a, C_) : Bn;
}, ty = (a, d) => {
  let l = d.length;
  if (bh(a))
    return qo;
  const m = a.state, w = m.wrap;
  if (w === 2 || w === 1 && m.status !== gc || m.lookahead)
    return qo;
  if (w === 1 && (a.adler = dh(a.adler, d, l, 0)), m.wrap = 0, l >= m.w_size) {
    w === 0 && (Gl(m.head), m.strstart = 0, m.block_start = 0, m.insert = 0);
    let D = new Uint8Array(m.w_size);
    D.set(d.subarray(l - m.w_size, l), 0), d = D, l = m.w_size;
  }
  const v = a.avail_in, g = a.next_in, s = a.input;
  for (a.avail_in = l, a.next_in = 0, a.input = d, _c(m); m.lookahead >= $i; ) {
    let D = m.strstart, k = m.lookahead - ($i - 1);
    do
      m.ins_h = Kl(m, m.ins_h, m.window[D + $i - 1]), m.prev[D & m.w_mask] = m.head[m.ins_h], m.head[m.ins_h] = D, D++;
    while (--k);
    m.strstart = D, m.lookahead = $i - 1, _c(m);
  }
  return m.strstart += m.lookahead, m.block_start = m.strstart, m.insert = m.lookahead, m.lookahead = 0, m.match_length = m.prev_length = $i - 1, m.match_available = 0, a.next_in = g, a.input = s, a.avail_in = v, m.wrap = w, Bn;
};
var iy = K_, ry = vg, ny = yg, ay = _g, sy = J_, oy = Q_, ly = ey, uy = ty, cy = "pako deflate (from Nodeca project)", ah = {
  deflateInit: iy,
  deflateInit2: ry,
  deflateReset: ny,
  deflateResetKeep: ay,
  deflateSetHeader: sy,
  deflate: oy,
  deflateEnd: ly,
  deflateSetDictionary: uy,
  deflateInfo: cy
};
const hy = (a, d) => Object.prototype.hasOwnProperty.call(a, d);
var dy = function(a) {
  const d = Array.prototype.slice.call(arguments, 1);
  for (; d.length; ) {
    const l = d.shift();
    if (l) {
      if (typeof l != "object")
        throw new TypeError(l + "must be non-object");
      for (const m in l)
        hy(l, m) && (a[m] = l[m]);
    }
  }
  return a;
}, py = (a) => {
  let d = 0;
  for (let m = 0, w = a.length; m < w; m++)
    d += a[m].length;
  const l = new Uint8Array(d);
  for (let m = 0, w = 0, v = a.length; m < v; m++) {
    let g = a[m];
    l.set(g, w), w += g.length;
  }
  return l;
}, hd = {
  assign: dy,
  flattenChunks: py
};
let bg = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  bg = !1;
}
const ph = new Uint8Array(256);
for (let a = 0; a < 256; a++)
  ph[a] = a >= 252 ? 6 : a >= 248 ? 5 : a >= 240 ? 4 : a >= 224 ? 3 : a >= 192 ? 2 : 1;
ph[254] = ph[254] = 1;
var fy = (a) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(a);
  let d, l, m, w, v, g = a.length, s = 0;
  for (w = 0; w < g; w++)
    l = a.charCodeAt(w), (l & 64512) === 55296 && w + 1 < g && (m = a.charCodeAt(w + 1), (m & 64512) === 56320 && (l = 65536 + (l - 55296 << 10) + (m - 56320), w++)), s += l < 128 ? 1 : l < 2048 ? 2 : l < 65536 ? 3 : 4;
  for (d = new Uint8Array(s), v = 0, w = 0; v < s; w++)
    l = a.charCodeAt(w), (l & 64512) === 55296 && w + 1 < g && (m = a.charCodeAt(w + 1), (m & 64512) === 56320 && (l = 65536 + (l - 55296 << 10) + (m - 56320), w++)), l < 128 ? d[v++] = l : l < 2048 ? (d[v++] = 192 | l >>> 6, d[v++] = 128 | l & 63) : l < 65536 ? (d[v++] = 224 | l >>> 12, d[v++] = 128 | l >>> 6 & 63, d[v++] = 128 | l & 63) : (d[v++] = 240 | l >>> 18, d[v++] = 128 | l >>> 12 & 63, d[v++] = 128 | l >>> 6 & 63, d[v++] = 128 | l & 63);
  return d;
};
const my = (a, d) => {
  if (d < 65534 && a.subarray && bg)
    return String.fromCharCode.apply(null, a.length === d ? a : a.subarray(0, d));
  let l = "";
  for (let m = 0; m < d; m++)
    l += String.fromCharCode(a[m]);
  return l;
};
var gy = (a, d) => {
  const l = d || a.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(a.subarray(0, d));
  let m, w;
  const v = new Array(l * 2);
  for (w = 0, m = 0; m < l; ) {
    let g = a[m++];
    if (g < 128) {
      v[w++] = g;
      continue;
    }
    let s = ph[g];
    if (s > 4) {
      v[w++] = 65533, m += s - 1;
      continue;
    }
    for (g &= s === 2 ? 31 : s === 3 ? 15 : 7; s > 1 && m < l; )
      g = g << 6 | a[m++] & 63, s--;
    if (s > 1) {
      v[w++] = 65533;
      continue;
    }
    g < 65536 ? v[w++] = g : (g -= 65536, v[w++] = 55296 | g >> 10 & 1023, v[w++] = 56320 | g & 1023);
  }
  return my(v, w);
}, _y = (a, d) => {
  d = d || a.length, d > a.length && (d = a.length);
  let l = d - 1;
  for (; l >= 0 && (a[l] & 192) === 128; )
    l--;
  return l < 0 || l === 0 ? d : l + ph[a[l]] > d ? l : d;
}, fh = {
  string2buf: fy,
  buf2string: gy,
  utf8border: _y
};
function yy() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var xg = yy;
const wg = Object.prototype.toString, {
  Z_NO_FLUSH: vy,
  Z_SYNC_FLUSH: by,
  Z_FULL_FLUSH: xy,
  Z_FINISH: wy,
  Z_OK: nd,
  Z_STREAM_END: Ay,
  Z_DEFAULT_COMPRESSION: Sy,
  Z_DEFAULT_STRATEGY: Ey,
  Z_DEFLATED: Ty
} = vh;
function xh(a) {
  this.options = hd.assign({
    level: Sy,
    method: Ty,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Ey
  }, a || {});
  let d = this.options;
  d.raw && d.windowBits > 0 ? d.windowBits = -d.windowBits : d.gzip && d.windowBits > 0 && d.windowBits < 16 && (d.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new xg(), this.strm.avail_out = 0;
  let l = ah.deflateInit2(
    this.strm,
    d.level,
    d.method,
    d.windowBits,
    d.memLevel,
    d.strategy
  );
  if (l !== nd)
    throw new Error(mc[l]);
  if (d.header && ah.deflateSetHeader(this.strm, d.header), d.dictionary) {
    let m;
    if (typeof d.dictionary == "string" ? m = fh.string2buf(d.dictionary) : wg.call(d.dictionary) === "[object ArrayBuffer]" ? m = new Uint8Array(d.dictionary) : m = d.dictionary, l = ah.deflateSetDictionary(this.strm, m), l !== nd)
      throw new Error(mc[l]);
    this._dict_set = !0;
  }
}
xh.prototype.push = function(a, d) {
  const l = this.strm, m = this.options.chunkSize;
  let w, v;
  if (this.ended)
    return !1;
  for (d === ~~d ? v = d : v = d === !0 ? wy : vy, typeof a == "string" ? l.input = fh.string2buf(a) : wg.call(a) === "[object ArrayBuffer]" ? l.input = new Uint8Array(a) : l.input = a, l.next_in = 0, l.avail_in = l.input.length; ; ) {
    if (l.avail_out === 0 && (l.output = new Uint8Array(m), l.next_out = 0, l.avail_out = m), (v === by || v === xy) && l.avail_out <= 6) {
      this.onData(l.output.subarray(0, l.next_out)), l.avail_out = 0;
      continue;
    }
    if (w = ah.deflate(l, v), w === Ay)
      return l.next_out > 0 && this.onData(l.output.subarray(0, l.next_out)), w = ah.deflateEnd(this.strm), this.onEnd(w), this.ended = !0, w === nd;
    if (l.avail_out === 0) {
      this.onData(l.output);
      continue;
    }
    if (v > 0 && l.next_out > 0) {
      this.onData(l.output.subarray(0, l.next_out)), l.avail_out = 0;
      continue;
    }
    if (l.avail_in === 0) break;
  }
  return !0;
};
xh.prototype.onData = function(a) {
  this.chunks.push(a);
};
xh.prototype.onEnd = function(a) {
  a === nd && (this.result = hd.flattenChunks(this.chunks)), this.chunks = [], this.err = a, this.msg = this.strm.msg;
};
function tf(a, d) {
  const l = new xh(d);
  if (l.push(a, !0), l.err)
    throw l.msg || mc[l.err];
  return l.result;
}
function Cy(a, d) {
  return d = d || {}, d.raw = !0, tf(a, d);
}
function Dy(a, d) {
  return d = d || {}, d.gzip = !0, tf(a, d);
}
var Iy = xh, ky = tf, Py = Cy, Ly = Dy, My = vh, Ny = {
  Deflate: Iy,
  deflate: ky,
  deflateRaw: Py,
  gzip: Ly,
  constants: My
};
const Uh = 16209, zy = 16191;
var Fy = function(d, l) {
  let m, w, v, g, s, D, k, M, q, O, z, pe, le, se, ee, fe, Te, ze, qe, at, Ie, Ae, me, ve;
  const X = d.state;
  m = d.next_in, me = d.input, w = m + (d.avail_in - 5), v = d.next_out, ve = d.output, g = v - (l - d.avail_out), s = v + (d.avail_out - 257), D = X.dmax, k = X.wsize, M = X.whave, q = X.wnext, O = X.window, z = X.hold, pe = X.bits, le = X.lencode, se = X.distcode, ee = (1 << X.lenbits) - 1, fe = (1 << X.distbits) - 1;
  e:
    do {
      pe < 15 && (z += me[m++] << pe, pe += 8, z += me[m++] << pe, pe += 8), Te = le[z & ee];
      t:
        for (; ; ) {
          if (ze = Te >>> 24, z >>>= ze, pe -= ze, ze = Te >>> 16 & 255, ze === 0)
            ve[v++] = Te & 65535;
          else if (ze & 16) {
            qe = Te & 65535, ze &= 15, ze && (pe < ze && (z += me[m++] << pe, pe += 8), qe += z & (1 << ze) - 1, z >>>= ze, pe -= ze), pe < 15 && (z += me[m++] << pe, pe += 8, z += me[m++] << pe, pe += 8), Te = se[z & fe];
            i:
              for (; ; ) {
                if (ze = Te >>> 24, z >>>= ze, pe -= ze, ze = Te >>> 16 & 255, ze & 16) {
                  if (at = Te & 65535, ze &= 15, pe < ze && (z += me[m++] << pe, pe += 8, pe < ze && (z += me[m++] << pe, pe += 8)), at += z & (1 << ze) - 1, at > D) {
                    d.msg = "invalid distance too far back", X.mode = Uh;
                    break e;
                  }
                  if (z >>>= ze, pe -= ze, ze = v - g, at > ze) {
                    if (ze = at - ze, ze > M && X.sane) {
                      d.msg = "invalid distance too far back", X.mode = Uh;
                      break e;
                    }
                    if (Ie = 0, Ae = O, q === 0) {
                      if (Ie += k - ze, ze < qe) {
                        qe -= ze;
                        do
                          ve[v++] = O[Ie++];
                        while (--ze);
                        Ie = v - at, Ae = ve;
                      }
                    } else if (q < ze) {
                      if (Ie += k + q - ze, ze -= q, ze < qe) {
                        qe -= ze;
                        do
                          ve[v++] = O[Ie++];
                        while (--ze);
                        if (Ie = 0, q < qe) {
                          ze = q, qe -= ze;
                          do
                            ve[v++] = O[Ie++];
                          while (--ze);
                          Ie = v - at, Ae = ve;
                        }
                      }
                    } else if (Ie += q - ze, ze < qe) {
                      qe -= ze;
                      do
                        ve[v++] = O[Ie++];
                      while (--ze);
                      Ie = v - at, Ae = ve;
                    }
                    for (; qe > 2; )
                      ve[v++] = Ae[Ie++], ve[v++] = Ae[Ie++], ve[v++] = Ae[Ie++], qe -= 3;
                    qe && (ve[v++] = Ae[Ie++], qe > 1 && (ve[v++] = Ae[Ie++]));
                  } else {
                    Ie = v - at;
                    do
                      ve[v++] = ve[Ie++], ve[v++] = ve[Ie++], ve[v++] = ve[Ie++], qe -= 3;
                    while (qe > 2);
                    qe && (ve[v++] = ve[Ie++], qe > 1 && (ve[v++] = ve[Ie++]));
                  }
                } else if (ze & 64) {
                  d.msg = "invalid distance code", X.mode = Uh;
                  break e;
                } else {
                  Te = se[(Te & 65535) + (z & (1 << ze) - 1)];
                  continue i;
                }
                break;
              }
          } else if (ze & 64)
            if (ze & 32) {
              X.mode = zy;
              break e;
            } else {
              d.msg = "invalid literal/length code", X.mode = Uh;
              break e;
            }
          else {
            Te = le[(Te & 65535) + (z & (1 << ze) - 1)];
            continue t;
          }
          break;
        }
    } while (m < w && v < s);
  qe = pe >> 3, m -= qe, pe -= qe << 3, z &= (1 << pe) - 1, d.next_in = m, d.next_out = v, d.avail_in = m < w ? 5 + (w - m) : 5 - (m - w), d.avail_out = v < s ? 257 + (s - v) : 257 - (v - s), X.hold = z, X.bits = pe;
};
const nc = 15, Gm = 852, Hm = 592, Wm = 0, lp = 1, Xm = 2, By = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), Ry = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), Oy = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), jy = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), qy = (a, d, l, m, w, v, g, s) => {
  const D = s.bits;
  let k = 0, M = 0, q = 0, O = 0, z = 0, pe = 0, le = 0, se = 0, ee = 0, fe = 0, Te, ze, qe, at, Ie, Ae = null, me;
  const ve = new Uint16Array(nc + 1), X = new Uint16Array(nc + 1);
  let re = null, xe, ye, Ve;
  for (k = 0; k <= nc; k++)
    ve[k] = 0;
  for (M = 0; M < m; M++)
    ve[d[l + M]]++;
  for (z = D, O = nc; O >= 1 && ve[O] === 0; O--)
    ;
  if (z > O && (z = O), O === 0)
    return w[v++] = 1 << 24 | 64 << 16 | 0, w[v++] = 1 << 24 | 64 << 16 | 0, s.bits = 1, 0;
  for (q = 1; q < O && ve[q] === 0; q++)
    ;
  for (z < q && (z = q), se = 1, k = 1; k <= nc; k++)
    if (se <<= 1, se -= ve[k], se < 0)
      return -1;
  if (se > 0 && (a === Wm || O !== 1))
    return -1;
  for (X[1] = 0, k = 1; k < nc; k++)
    X[k + 1] = X[k] + ve[k];
  for (M = 0; M < m; M++)
    d[l + M] !== 0 && (g[X[d[l + M]]++] = M);
  if (a === Wm ? (Ae = re = g, me = 20) : a === lp ? (Ae = By, re = Ry, me = 257) : (Ae = Oy, re = jy, me = 0), fe = 0, M = 0, k = q, Ie = v, pe = z, le = 0, qe = -1, ee = 1 << z, at = ee - 1, a === lp && ee > Gm || a === Xm && ee > Hm)
    return 1;
  for (; ; ) {
    xe = k - le, g[M] + 1 < me ? (ye = 0, Ve = g[M]) : g[M] >= me ? (ye = re[g[M] - me], Ve = Ae[g[M] - me]) : (ye = 96, Ve = 0), Te = 1 << k - le, ze = 1 << pe, q = ze;
    do
      ze -= Te, w[Ie + (fe >> le) + ze] = xe << 24 | ye << 16 | Ve | 0;
    while (ze !== 0);
    for (Te = 1 << k - 1; fe & Te; )
      Te >>= 1;
    if (Te !== 0 ? (fe &= Te - 1, fe += Te) : fe = 0, M++, --ve[k] === 0) {
      if (k === O)
        break;
      k = d[l + g[M]];
    }
    if (k > z && (fe & at) !== qe) {
      for (le === 0 && (le = z), Ie += q, pe = k - le, se = 1 << pe; pe + le < O && (se -= ve[pe + le], !(se <= 0)); )
        pe++, se <<= 1;
      if (ee += 1 << pe, a === lp && ee > Gm || a === Xm && ee > Hm)
        return 1;
      qe = fe & at, w[qe] = z << 24 | pe << 16 | Ie - v | 0;
    }
  }
  return fe !== 0 && (w[Ie + fe] = k - le << 24 | 64 << 16 | 0), s.bits = z, 0;
};
var sh = qy;
const Uy = 0, Ag = 1, Sg = 2, {
  Z_FINISH: Ym,
  Z_BLOCK: Vy,
  Z_TREES: Vh,
  Z_OK: Lu,
  Z_STREAM_END: $y,
  Z_NEED_DICT: Zy,
  Z_STREAM_ERROR: Is,
  Z_DATA_ERROR: Eg,
  Z_MEM_ERROR: Tg,
  Z_BUF_ERROR: Gy,
  Z_DEFLATED: Jm
} = vh, dd = 16180, Km = 16181, Qm = 16182, e0 = 16183, t0 = 16184, i0 = 16185, r0 = 16186, n0 = 16187, a0 = 16188, s0 = 16189, ad = 16190, vl = 16191, up = 16192, o0 = 16193, cp = 16194, l0 = 16195, u0 = 16196, c0 = 16197, h0 = 16198, $h = 16199, Zh = 16200, d0 = 16201, p0 = 16202, f0 = 16203, m0 = 16204, g0 = 16205, hp = 16206, _0 = 16207, y0 = 16208, Mr = 16209, Cg = 16210, Dg = 16211, Hy = 852, Wy = 592, Xy = 15, Yy = Xy, v0 = (a) => (a >>> 24 & 255) + (a >>> 8 & 65280) + ((a & 65280) << 8) + ((a & 255) << 24);
function Jy() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const Mu = (a) => {
  if (!a)
    return 1;
  const d = a.state;
  return !d || d.strm !== a || d.mode < dd || d.mode > Dg ? 1 : 0;
}, Ig = (a) => {
  if (Mu(a))
    return Is;
  const d = a.state;
  return a.total_in = a.total_out = d.total = 0, a.msg = "", d.wrap && (a.adler = d.wrap & 1), d.mode = dd, d.last = 0, d.havedict = 0, d.flags = -1, d.dmax = 32768, d.head = null, d.hold = 0, d.bits = 0, d.lencode = d.lendyn = new Int32Array(Hy), d.distcode = d.distdyn = new Int32Array(Wy), d.sane = 1, d.back = -1, Lu;
}, kg = (a) => {
  if (Mu(a))
    return Is;
  const d = a.state;
  return d.wsize = 0, d.whave = 0, d.wnext = 0, Ig(a);
}, Pg = (a, d) => {
  let l;
  if (Mu(a))
    return Is;
  const m = a.state;
  return d < 0 ? (l = 0, d = -d) : (l = (d >> 4) + 5, d < 48 && (d &= 15)), d && (d < 8 || d > 15) ? Is : (m.window !== null && m.wbits !== d && (m.window = null), m.wrap = l, m.wbits = d, kg(a));
}, Lg = (a, d) => {
  if (!a)
    return Is;
  const l = new Jy();
  a.state = l, l.strm = a, l.window = null, l.mode = dd;
  const m = Pg(a, d);
  return m !== Lu && (a.state = null), m;
}, Ky = (a) => Lg(a, Yy);
let b0 = !0, dp, pp;
const Qy = (a) => {
  if (b0) {
    dp = new Int32Array(512), pp = new Int32Array(32);
    let d = 0;
    for (; d < 144; )
      a.lens[d++] = 8;
    for (; d < 256; )
      a.lens[d++] = 9;
    for (; d < 280; )
      a.lens[d++] = 7;
    for (; d < 288; )
      a.lens[d++] = 8;
    for (sh(Ag, a.lens, 0, 288, dp, 0, a.work, { bits: 9 }), d = 0; d < 32; )
      a.lens[d++] = 5;
    sh(Sg, a.lens, 0, 32, pp, 0, a.work, { bits: 5 }), b0 = !1;
  }
  a.lencode = dp, a.lenbits = 9, a.distcode = pp, a.distbits = 5;
}, Mg = (a, d, l, m) => {
  let w;
  const v = a.state;
  return v.window === null && (v.wsize = 1 << v.wbits, v.wnext = 0, v.whave = 0, v.window = new Uint8Array(v.wsize)), m >= v.wsize ? (v.window.set(d.subarray(l - v.wsize, l), 0), v.wnext = 0, v.whave = v.wsize) : (w = v.wsize - v.wnext, w > m && (w = m), v.window.set(d.subarray(l - m, l - m + w), v.wnext), m -= w, m ? (v.window.set(d.subarray(l - m, l), 0), v.wnext = m, v.whave = v.wsize) : (v.wnext += w, v.wnext === v.wsize && (v.wnext = 0), v.whave < v.wsize && (v.whave += w))), 0;
}, ev = (a, d) => {
  let l, m, w, v, g, s, D, k, M, q, O, z, pe, le, se = 0, ee, fe, Te, ze, qe, at, Ie, Ae;
  const me = new Uint8Array(4);
  let ve, X;
  const re = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (Mu(a) || !a.output || !a.input && a.avail_in !== 0)
    return Is;
  l = a.state, l.mode === vl && (l.mode = up), g = a.next_out, w = a.output, D = a.avail_out, v = a.next_in, m = a.input, s = a.avail_in, k = l.hold, M = l.bits, q = s, O = D, Ae = Lu;
  e:
    for (; ; )
      switch (l.mode) {
        case dd:
          if (l.wrap === 0) {
            l.mode = up;
            break;
          }
          for (; M < 16; ) {
            if (s === 0)
              break e;
            s--, k += m[v++] << M, M += 8;
          }
          if (l.wrap & 2 && k === 35615) {
            l.wbits === 0 && (l.wbits = 15), l.check = 0, me[0] = k & 255, me[1] = k >>> 8 & 255, l.check = Sn(l.check, me, 2, 0), k = 0, M = 0, l.mode = Km;
            break;
          }
          if (l.head && (l.head.done = !1), !(l.wrap & 1) || /* check if zlib header allowed */
          (((k & 255) << 8) + (k >> 8)) % 31) {
            a.msg = "incorrect header check", l.mode = Mr;
            break;
          }
          if ((k & 15) !== Jm) {
            a.msg = "unknown compression method", l.mode = Mr;
            break;
          }
          if (k >>>= 4, M -= 4, Ie = (k & 15) + 8, l.wbits === 0 && (l.wbits = Ie), Ie > 15 || Ie > l.wbits) {
            a.msg = "invalid window size", l.mode = Mr;
            break;
          }
          l.dmax = 1 << l.wbits, l.flags = 0, a.adler = l.check = 1, l.mode = k & 512 ? s0 : vl, k = 0, M = 0;
          break;
        case Km:
          for (; M < 16; ) {
            if (s === 0)
              break e;
            s--, k += m[v++] << M, M += 8;
          }
          if (l.flags = k, (l.flags & 255) !== Jm) {
            a.msg = "unknown compression method", l.mode = Mr;
            break;
          }
          if (l.flags & 57344) {
            a.msg = "unknown header flags set", l.mode = Mr;
            break;
          }
          l.head && (l.head.text = k >> 8 & 1), l.flags & 512 && l.wrap & 4 && (me[0] = k & 255, me[1] = k >>> 8 & 255, l.check = Sn(l.check, me, 2, 0)), k = 0, M = 0, l.mode = Qm;
        case Qm:
          for (; M < 32; ) {
            if (s === 0)
              break e;
            s--, k += m[v++] << M, M += 8;
          }
          l.head && (l.head.time = k), l.flags & 512 && l.wrap & 4 && (me[0] = k & 255, me[1] = k >>> 8 & 255, me[2] = k >>> 16 & 255, me[3] = k >>> 24 & 255, l.check = Sn(l.check, me, 4, 0)), k = 0, M = 0, l.mode = e0;
        case e0:
          for (; M < 16; ) {
            if (s === 0)
              break e;
            s--, k += m[v++] << M, M += 8;
          }
          l.head && (l.head.xflags = k & 255, l.head.os = k >> 8), l.flags & 512 && l.wrap & 4 && (me[0] = k & 255, me[1] = k >>> 8 & 255, l.check = Sn(l.check, me, 2, 0)), k = 0, M = 0, l.mode = t0;
        case t0:
          if (l.flags & 1024) {
            for (; M < 16; ) {
              if (s === 0)
                break e;
              s--, k += m[v++] << M, M += 8;
            }
            l.length = k, l.head && (l.head.extra_len = k), l.flags & 512 && l.wrap & 4 && (me[0] = k & 255, me[1] = k >>> 8 & 255, l.check = Sn(l.check, me, 2, 0)), k = 0, M = 0;
          } else l.head && (l.head.extra = null);
          l.mode = i0;
        case i0:
          if (l.flags & 1024 && (z = l.length, z > s && (z = s), z && (l.head && (Ie = l.head.extra_len - l.length, l.head.extra || (l.head.extra = new Uint8Array(l.head.extra_len)), l.head.extra.set(
            m.subarray(
              v,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              v + z
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            Ie
          )), l.flags & 512 && l.wrap & 4 && (l.check = Sn(l.check, m, z, v)), s -= z, v += z, l.length -= z), l.length))
            break e;
          l.length = 0, l.mode = r0;
        case r0:
          if (l.flags & 2048) {
            if (s === 0)
              break e;
            z = 0;
            do
              Ie = m[v + z++], l.head && Ie && l.length < 65536 && (l.head.name += String.fromCharCode(Ie));
            while (Ie && z < s);
            if (l.flags & 512 && l.wrap & 4 && (l.check = Sn(l.check, m, z, v)), s -= z, v += z, Ie)
              break e;
          } else l.head && (l.head.name = null);
          l.length = 0, l.mode = n0;
        case n0:
          if (l.flags & 4096) {
            if (s === 0)
              break e;
            z = 0;
            do
              Ie = m[v + z++], l.head && Ie && l.length < 65536 && (l.head.comment += String.fromCharCode(Ie));
            while (Ie && z < s);
            if (l.flags & 512 && l.wrap & 4 && (l.check = Sn(l.check, m, z, v)), s -= z, v += z, Ie)
              break e;
          } else l.head && (l.head.comment = null);
          l.mode = a0;
        case a0:
          if (l.flags & 512) {
            for (; M < 16; ) {
              if (s === 0)
                break e;
              s--, k += m[v++] << M, M += 8;
            }
            if (l.wrap & 4 && k !== (l.check & 65535)) {
              a.msg = "header crc mismatch", l.mode = Mr;
              break;
            }
            k = 0, M = 0;
          }
          l.head && (l.head.hcrc = l.flags >> 9 & 1, l.head.done = !0), a.adler = l.check = 0, l.mode = vl;
          break;
        case s0:
          for (; M < 32; ) {
            if (s === 0)
              break e;
            s--, k += m[v++] << M, M += 8;
          }
          a.adler = l.check = v0(k), k = 0, M = 0, l.mode = ad;
        case ad:
          if (l.havedict === 0)
            return a.next_out = g, a.avail_out = D, a.next_in = v, a.avail_in = s, l.hold = k, l.bits = M, Zy;
          a.adler = l.check = 1, l.mode = vl;
        case vl:
          if (d === Vy || d === Vh)
            break e;
        case up:
          if (l.last) {
            k >>>= M & 7, M -= M & 7, l.mode = hp;
            break;
          }
          for (; M < 3; ) {
            if (s === 0)
              break e;
            s--, k += m[v++] << M, M += 8;
          }
          switch (l.last = k & 1, k >>>= 1, M -= 1, k & 3) {
            case 0:
              l.mode = o0;
              break;
            case 1:
              if (Qy(l), l.mode = $h, d === Vh) {
                k >>>= 2, M -= 2;
                break e;
              }
              break;
            case 2:
              l.mode = u0;
              break;
            case 3:
              a.msg = "invalid block type", l.mode = Mr;
          }
          k >>>= 2, M -= 2;
          break;
        case o0:
          for (k >>>= M & 7, M -= M & 7; M < 32; ) {
            if (s === 0)
              break e;
            s--, k += m[v++] << M, M += 8;
          }
          if ((k & 65535) !== (k >>> 16 ^ 65535)) {
            a.msg = "invalid stored block lengths", l.mode = Mr;
            break;
          }
          if (l.length = k & 65535, k = 0, M = 0, l.mode = cp, d === Vh)
            break e;
        case cp:
          l.mode = l0;
        case l0:
          if (z = l.length, z) {
            if (z > s && (z = s), z > D && (z = D), z === 0)
              break e;
            w.set(m.subarray(v, v + z), g), s -= z, v += z, D -= z, g += z, l.length -= z;
            break;
          }
          l.mode = vl;
          break;
        case u0:
          for (; M < 14; ) {
            if (s === 0)
              break e;
            s--, k += m[v++] << M, M += 8;
          }
          if (l.nlen = (k & 31) + 257, k >>>= 5, M -= 5, l.ndist = (k & 31) + 1, k >>>= 5, M -= 5, l.ncode = (k & 15) + 4, k >>>= 4, M -= 4, l.nlen > 286 || l.ndist > 30) {
            a.msg = "too many length or distance symbols", l.mode = Mr;
            break;
          }
          l.have = 0, l.mode = c0;
        case c0:
          for (; l.have < l.ncode; ) {
            for (; M < 3; ) {
              if (s === 0)
                break e;
              s--, k += m[v++] << M, M += 8;
            }
            l.lens[re[l.have++]] = k & 7, k >>>= 3, M -= 3;
          }
          for (; l.have < 19; )
            l.lens[re[l.have++]] = 0;
          if (l.lencode = l.lendyn, l.lenbits = 7, ve = { bits: l.lenbits }, Ae = sh(Uy, l.lens, 0, 19, l.lencode, 0, l.work, ve), l.lenbits = ve.bits, Ae) {
            a.msg = "invalid code lengths set", l.mode = Mr;
            break;
          }
          l.have = 0, l.mode = h0;
        case h0:
          for (; l.have < l.nlen + l.ndist; ) {
            for (; se = l.lencode[k & (1 << l.lenbits) - 1], ee = se >>> 24, fe = se >>> 16 & 255, Te = se & 65535, !(ee <= M); ) {
              if (s === 0)
                break e;
              s--, k += m[v++] << M, M += 8;
            }
            if (Te < 16)
              k >>>= ee, M -= ee, l.lens[l.have++] = Te;
            else {
              if (Te === 16) {
                for (X = ee + 2; M < X; ) {
                  if (s === 0)
                    break e;
                  s--, k += m[v++] << M, M += 8;
                }
                if (k >>>= ee, M -= ee, l.have === 0) {
                  a.msg = "invalid bit length repeat", l.mode = Mr;
                  break;
                }
                Ie = l.lens[l.have - 1], z = 3 + (k & 3), k >>>= 2, M -= 2;
              } else if (Te === 17) {
                for (X = ee + 3; M < X; ) {
                  if (s === 0)
                    break e;
                  s--, k += m[v++] << M, M += 8;
                }
                k >>>= ee, M -= ee, Ie = 0, z = 3 + (k & 7), k >>>= 3, M -= 3;
              } else {
                for (X = ee + 7; M < X; ) {
                  if (s === 0)
                    break e;
                  s--, k += m[v++] << M, M += 8;
                }
                k >>>= ee, M -= ee, Ie = 0, z = 11 + (k & 127), k >>>= 7, M -= 7;
              }
              if (l.have + z > l.nlen + l.ndist) {
                a.msg = "invalid bit length repeat", l.mode = Mr;
                break;
              }
              for (; z--; )
                l.lens[l.have++] = Ie;
            }
          }
          if (l.mode === Mr)
            break;
          if (l.lens[256] === 0) {
            a.msg = "invalid code -- missing end-of-block", l.mode = Mr;
            break;
          }
          if (l.lenbits = 9, ve = { bits: l.lenbits }, Ae = sh(Ag, l.lens, 0, l.nlen, l.lencode, 0, l.work, ve), l.lenbits = ve.bits, Ae) {
            a.msg = "invalid literal/lengths set", l.mode = Mr;
            break;
          }
          if (l.distbits = 6, l.distcode = l.distdyn, ve = { bits: l.distbits }, Ae = sh(Sg, l.lens, l.nlen, l.ndist, l.distcode, 0, l.work, ve), l.distbits = ve.bits, Ae) {
            a.msg = "invalid distances set", l.mode = Mr;
            break;
          }
          if (l.mode = $h, d === Vh)
            break e;
        case $h:
          l.mode = Zh;
        case Zh:
          if (s >= 6 && D >= 258) {
            a.next_out = g, a.avail_out = D, a.next_in = v, a.avail_in = s, l.hold = k, l.bits = M, Fy(a, O), g = a.next_out, w = a.output, D = a.avail_out, v = a.next_in, m = a.input, s = a.avail_in, k = l.hold, M = l.bits, l.mode === vl && (l.back = -1);
            break;
          }
          for (l.back = 0; se = l.lencode[k & (1 << l.lenbits) - 1], ee = se >>> 24, fe = se >>> 16 & 255, Te = se & 65535, !(ee <= M); ) {
            if (s === 0)
              break e;
            s--, k += m[v++] << M, M += 8;
          }
          if (fe && !(fe & 240)) {
            for (ze = ee, qe = fe, at = Te; se = l.lencode[at + ((k & (1 << ze + qe) - 1) >> ze)], ee = se >>> 24, fe = se >>> 16 & 255, Te = se & 65535, !(ze + ee <= M); ) {
              if (s === 0)
                break e;
              s--, k += m[v++] << M, M += 8;
            }
            k >>>= ze, M -= ze, l.back += ze;
          }
          if (k >>>= ee, M -= ee, l.back += ee, l.length = Te, fe === 0) {
            l.mode = g0;
            break;
          }
          if (fe & 32) {
            l.back = -1, l.mode = vl;
            break;
          }
          if (fe & 64) {
            a.msg = "invalid literal/length code", l.mode = Mr;
            break;
          }
          l.extra = fe & 15, l.mode = d0;
        case d0:
          if (l.extra) {
            for (X = l.extra; M < X; ) {
              if (s === 0)
                break e;
              s--, k += m[v++] << M, M += 8;
            }
            l.length += k & (1 << l.extra) - 1, k >>>= l.extra, M -= l.extra, l.back += l.extra;
          }
          l.was = l.length, l.mode = p0;
        case p0:
          for (; se = l.distcode[k & (1 << l.distbits) - 1], ee = se >>> 24, fe = se >>> 16 & 255, Te = se & 65535, !(ee <= M); ) {
            if (s === 0)
              break e;
            s--, k += m[v++] << M, M += 8;
          }
          if (!(fe & 240)) {
            for (ze = ee, qe = fe, at = Te; se = l.distcode[at + ((k & (1 << ze + qe) - 1) >> ze)], ee = se >>> 24, fe = se >>> 16 & 255, Te = se & 65535, !(ze + ee <= M); ) {
              if (s === 0)
                break e;
              s--, k += m[v++] << M, M += 8;
            }
            k >>>= ze, M -= ze, l.back += ze;
          }
          if (k >>>= ee, M -= ee, l.back += ee, fe & 64) {
            a.msg = "invalid distance code", l.mode = Mr;
            break;
          }
          l.offset = Te, l.extra = fe & 15, l.mode = f0;
        case f0:
          if (l.extra) {
            for (X = l.extra; M < X; ) {
              if (s === 0)
                break e;
              s--, k += m[v++] << M, M += 8;
            }
            l.offset += k & (1 << l.extra) - 1, k >>>= l.extra, M -= l.extra, l.back += l.extra;
          }
          if (l.offset > l.dmax) {
            a.msg = "invalid distance too far back", l.mode = Mr;
            break;
          }
          l.mode = m0;
        case m0:
          if (D === 0)
            break e;
          if (z = O - D, l.offset > z) {
            if (z = l.offset - z, z > l.whave && l.sane) {
              a.msg = "invalid distance too far back", l.mode = Mr;
              break;
            }
            z > l.wnext ? (z -= l.wnext, pe = l.wsize - z) : pe = l.wnext - z, z > l.length && (z = l.length), le = l.window;
          } else
            le = w, pe = g - l.offset, z = l.length;
          z > D && (z = D), D -= z, l.length -= z;
          do
            w[g++] = le[pe++];
          while (--z);
          l.length === 0 && (l.mode = Zh);
          break;
        case g0:
          if (D === 0)
            break e;
          w[g++] = l.length, D--, l.mode = Zh;
          break;
        case hp:
          if (l.wrap) {
            for (; M < 32; ) {
              if (s === 0)
                break e;
              s--, k |= m[v++] << M, M += 8;
            }
            if (O -= D, a.total_out += O, l.total += O, l.wrap & 4 && O && (a.adler = l.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            l.flags ? Sn(l.check, w, O, g - O) : dh(l.check, w, O, g - O)), O = D, l.wrap & 4 && (l.flags ? k : v0(k)) !== l.check) {
              a.msg = "incorrect data check", l.mode = Mr;
              break;
            }
            k = 0, M = 0;
          }
          l.mode = _0;
        case _0:
          if (l.wrap && l.flags) {
            for (; M < 32; ) {
              if (s === 0)
                break e;
              s--, k += m[v++] << M, M += 8;
            }
            if (l.wrap & 4 && k !== (l.total & 4294967295)) {
              a.msg = "incorrect length check", l.mode = Mr;
              break;
            }
            k = 0, M = 0;
          }
          l.mode = y0;
        case y0:
          Ae = $y;
          break e;
        case Mr:
          Ae = Eg;
          break e;
        case Cg:
          return Tg;
        case Dg:
        default:
          return Is;
      }
  return a.next_out = g, a.avail_out = D, a.next_in = v, a.avail_in = s, l.hold = k, l.bits = M, (l.wsize || O !== a.avail_out && l.mode < Mr && (l.mode < hp || d !== Ym)) && Mg(a, a.output, a.next_out, O - a.avail_out), q -= a.avail_in, O -= a.avail_out, a.total_in += q, a.total_out += O, l.total += O, l.wrap & 4 && O && (a.adler = l.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  l.flags ? Sn(l.check, w, O, a.next_out - O) : dh(l.check, w, O, a.next_out - O)), a.data_type = l.bits + (l.last ? 64 : 0) + (l.mode === vl ? 128 : 0) + (l.mode === $h || l.mode === cp ? 256 : 0), (q === 0 && O === 0 || d === Ym) && Ae === Lu && (Ae = Gy), Ae;
}, tv = (a) => {
  if (Mu(a))
    return Is;
  let d = a.state;
  return d.window && (d.window = null), a.state = null, Lu;
}, iv = (a, d) => {
  if (Mu(a))
    return Is;
  const l = a.state;
  return l.wrap & 2 ? (l.head = d, d.done = !1, Lu) : Is;
}, rv = (a, d) => {
  const l = d.length;
  let m, w, v;
  return Mu(a) || (m = a.state, m.wrap !== 0 && m.mode !== ad) ? Is : m.mode === ad && (w = 1, w = dh(w, d, l, 0), w !== m.check) ? Eg : (v = Mg(a, d, l, l), v ? (m.mode = Cg, Tg) : (m.havedict = 1, Lu));
};
var nv = kg, av = Pg, sv = Ig, ov = Ky, lv = Lg, uv = ev, cv = tv, hv = iv, dv = rv, pv = "pako inflate (from Nodeca project)", Al = {
  inflateReset: nv,
  inflateReset2: av,
  inflateResetKeep: sv,
  inflateInit: ov,
  inflateInit2: lv,
  inflate: uv,
  inflateEnd: cv,
  inflateGetHeader: hv,
  inflateSetDictionary: dv,
  inflateInfo: pv
};
function fv() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var mv = fv;
const Ng = Object.prototype.toString, {
  Z_NO_FLUSH: gv,
  Z_FINISH: _v,
  Z_OK: mh,
  Z_STREAM_END: fp,
  Z_NEED_DICT: mp,
  Z_STREAM_ERROR: yv,
  Z_DATA_ERROR: x0,
  Z_MEM_ERROR: vv
} = vh;
function rf(a) {
  this.options = hd.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, a || {});
  const d = this.options;
  d.raw && d.windowBits >= 0 && d.windowBits < 16 && (d.windowBits = -d.windowBits, d.windowBits === 0 && (d.windowBits = -15)), d.windowBits >= 0 && d.windowBits < 16 && !(a && a.windowBits) && (d.windowBits += 32), d.windowBits > 15 && d.windowBits < 48 && (d.windowBits & 15 || (d.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new xg(), this.strm.avail_out = 0;
  let l = Al.inflateInit2(
    this.strm,
    d.windowBits
  );
  if (l !== mh)
    throw new Error(mc[l]);
  if (this.header = new mv(), Al.inflateGetHeader(this.strm, this.header), d.dictionary && (typeof d.dictionary == "string" ? d.dictionary = fh.string2buf(d.dictionary) : Ng.call(d.dictionary) === "[object ArrayBuffer]" && (d.dictionary = new Uint8Array(d.dictionary)), d.raw && (l = Al.inflateSetDictionary(this.strm, d.dictionary), l !== mh)))
    throw new Error(mc[l]);
}
rf.prototype.push = function(a, d) {
  const l = this.strm, m = this.options.chunkSize, w = this.options.dictionary;
  let v, g, s;
  if (this.ended) return !1;
  for (d === ~~d ? g = d : g = d === !0 ? _v : gv, Ng.call(a) === "[object ArrayBuffer]" ? l.input = new Uint8Array(a) : l.input = a, l.next_in = 0, l.avail_in = l.input.length; ; ) {
    for (l.avail_out === 0 && (l.output = new Uint8Array(m), l.next_out = 0, l.avail_out = m), v = Al.inflate(l, g), v === mp && w && (v = Al.inflateSetDictionary(l, w), v === mh ? v = Al.inflate(l, g) : v === x0 && (v = mp)); l.avail_in > 0 && v === fp && l.state.wrap > 0 && a[l.next_in] !== 0; )
      Al.inflateReset(l), v = Al.inflate(l, g);
    switch (v) {
      case yv:
      case x0:
      case mp:
      case vv:
        return this.onEnd(v), this.ended = !0, !1;
    }
    if (s = l.avail_out, l.next_out && (l.avail_out === 0 || v === fp))
      if (this.options.to === "string") {
        let D = fh.utf8border(l.output, l.next_out), k = l.next_out - D, M = fh.buf2string(l.output, D);
        l.next_out = k, l.avail_out = m - k, k && l.output.set(l.output.subarray(D, D + k), 0), this.onData(M);
      } else
        this.onData(l.output.length === l.next_out ? l.output : l.output.subarray(0, l.next_out));
    if (!(v === mh && s === 0)) {
      if (v === fp)
        return v = Al.inflateEnd(this.strm), this.onEnd(v), this.ended = !0, !0;
      if (l.avail_in === 0) break;
    }
  }
  return !0;
};
rf.prototype.onData = function(a) {
  this.chunks.push(a);
};
rf.prototype.onEnd = function(a) {
  a === mh && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = hd.flattenChunks(this.chunks)), this.chunks = [], this.err = a, this.msg = this.strm.msg;
};
const { Deflate: ox, deflate: bv, deflateRaw: lx, gzip: ux } = Ny;
var xv = bv;
const wv = [137, 80, 78, 71, 13, 10, 26, 10], zg = [];
for (let a = 0; a < 256; a++) {
  let d = a;
  for (let l = 0; l < 8; l++)
    d & 1 ? d = 3988292384 ^ d >>> 1 : d = d >>> 1;
  zg[a] = d;
}
const w0 = 4294967295;
function Av(a, d, l) {
  let m = a;
  for (let w = 0; w < l; w++)
    m = zg[(m ^ d[w]) & 255] ^ m >>> 8;
  return m;
}
function Sv(a, d) {
  return (Av(w0, a, d) ^ w0) >>> 0;
}
var Hl;
(function(a) {
  a[a.UNKNOWN = -1] = "UNKNOWN", a[a.GREYSCALE = 0] = "GREYSCALE", a[a.TRUECOLOUR = 2] = "TRUECOLOUR", a[a.INDEXED_COLOUR = 3] = "INDEXED_COLOUR", a[a.GREYSCALE_ALPHA = 4] = "GREYSCALE_ALPHA", a[a.TRUECOLOUR_ALPHA = 6] = "TRUECOLOUR_ALPHA";
})(Hl || (Hl = {}));
var Np;
(function(a) {
  a[a.UNKNOWN = -1] = "UNKNOWN", a[a.DEFLATE = 0] = "DEFLATE";
})(Np || (Np = {}));
var zp;
(function(a) {
  a[a.UNKNOWN = -1] = "UNKNOWN", a[a.ADAPTIVE = 0] = "ADAPTIVE";
})(zp || (zp = {}));
var Fp;
(function(a) {
  a[a.UNKNOWN = -1] = "UNKNOWN", a[a.NO_INTERLACE = 0] = "NO_INTERLACE", a[a.ADAM7 = 1] = "ADAM7";
})(Fp || (Fp = {}));
const Ev = new Uint16Array([255]), Tv = new Uint8Array(Ev.buffer);
Tv[0];
const Cv = {
  level: 3
};
class Dv extends id {
  constructor(d, l = {}) {
    super(), this._colorType = Hl.UNKNOWN, this._zlibOptions = { ...Cv, ...l.zlib }, this._png = this._checkData(d), this.setBigEndian();
  }
  encode() {
    return this.encodeSignature(), this.encodeIHDR(), this.encodeData(), this.encodeIEND(), this.toArray();
  }
  // https://www.w3.org/TR/PNG/#5PNG-file-signature
  encodeSignature() {
    this.writeBytes(wv);
  }
  // https://www.w3.org/TR/PNG/#11IHDR
  encodeIHDR() {
    this.writeUint32(13), this.writeChars("IHDR"), this.writeUint32(this._png.width), this.writeUint32(this._png.height), this.writeByte(this._png.depth), this.writeByte(this._colorType), this.writeByte(Np.DEFLATE), this.writeByte(zp.ADAPTIVE), this.writeByte(Fp.NO_INTERLACE), this.writeCrc(17);
  }
  // https://www.w3.org/TR/PNG/#11IEND
  encodeIEND() {
    this.writeUint32(0), this.writeChars("IEND"), this.writeCrc(4);
  }
  // https://www.w3.org/TR/PNG/#11IDAT
  encodeIDAT(d) {
    this.writeUint32(d.length), this.writeChars("IDAT"), this.writeBytes(d), this.writeCrc(d.length + 4);
  }
  encodeData() {
    const { width: d, height: l, channels: m, depth: w, data: v } = this._png, g = m * d, s = new id().setBigEndian();
    let D = 0;
    for (let q = 0; q < l; q++)
      if (s.writeByte(0), w === 8)
        D = kv(v, s, g, D);
      else if (w === 16)
        D = Pv(v, s, g, D);
      else
        throw new Error("unreachable");
    const k = s.toArray(), M = xv(k, this._zlibOptions);
    this.encodeIDAT(M);
  }
  _checkData(d) {
    const { colorType: l, channels: m, depth: w } = Iv(d), v = {
      width: A0(d.width, "width"),
      height: A0(d.height, "height"),
      channels: m,
      data: d.data,
      depth: w,
      text: {}
    };
    this._colorType = l;
    const g = v.width * v.height * m;
    if (v.data.length !== g)
      throw new RangeError(`wrong data size. Found ${v.data.length}, expected ${g}`);
    return v;
  }
  writeCrc(d) {
    this.writeUint32(Sv(new Uint8Array(this.buffer, this.byteOffset + this.offset - d, d), d));
  }
}
function A0(a, d) {
  if (Number.isInteger(a) && a > 0)
    return a;
  throw new TypeError(`${d} must be a positive integer`);
}
function Iv(a) {
  const { channels: d = 4, depth: l = 8 } = a;
  if (d !== 4 && d !== 3 && d !== 2 && d !== 1)
    throw new RangeError(`unsupported number of channels: ${d}`);
  if (l !== 8 && l !== 16)
    throw new RangeError(`unsupported bit depth: ${l}`);
  const m = { channels: d, depth: l, colorType: Hl.UNKNOWN };
  switch (d) {
    case 4:
      m.colorType = Hl.TRUECOLOUR_ALPHA;
      break;
    case 3:
      m.colorType = Hl.TRUECOLOUR;
      break;
    case 1:
      m.colorType = Hl.GREYSCALE;
      break;
    case 2:
      m.colorType = Hl.GREYSCALE_ALPHA;
      break;
    default:
      throw new Error("unsupported number of channels");
  }
  return m;
}
function kv(a, d, l, m) {
  for (let w = 0; w < l; w++)
    d.writeByte(a[m++]);
  return m;
}
function Pv(a, d, l, m) {
  for (let w = 0; w < l; w++)
    d.writeUint16(a[m++]);
  return m;
}
var S0;
(function(a) {
  a[a.UNKNOWN = 0] = "UNKNOWN", a[a.METRE = 1] = "METRE";
})(S0 || (S0 = {}));
function Lv(a, d) {
  return new Dv(a, d).encode();
}
function Mv(a, d, l) {
  let m = (a << 16) + (d << 8) + l, w = 0;
  m < 8388608 ? w = m * 0.01 : m > 8388608 && (w = (m - Math.pow(2, 24)) * 0.01), m = Math.floor((w + 1e4) / 0.1);
  const v = (m & 16711680) >> 16, g = (m & 65280) >> 8, s = m & 255;
  return [v, g, s];
}
function Nv(a) {
  return new Promise((d, l) => {
    const m = new Image();
    m.crossOrigin = "", m.onload = () => {
      const w = document.createElement("canvas");
      w.width = m.width, w.height = m.height;
      const v = w.getContext("2d", {
        willReadFrequently: !0
      });
      v.fillStyle = "rgb(128,0,0)", v.fillRect(0, 0, w.width, w.height), v.drawImage(m, 0, 0);
      const g = v.getImageData(0, 0, w.width, w.height);
      for (let D = 0; D < g.data.length / 4; D++) {
        const k = Mv(g.data[D * 4], g.data[D * 4 + 1], g.data[D * 4 + 2]);
        g.data[D * 4] = k[0], g.data[D * 4 + 1] = k[1], g.data[D * 4 + 2] = k[2];
      }
      const s = Lv(g);
      d(s);
    }, m.onerror = (w) => {
      l(w);
    }, m.src = a;
  });
}
const zv = (a, d = {}) => (a("gsidem", async (m, w) => {
  const v = m.url.replace("gsidem://", "");
  return { data: await Nv(v).catch((s) => {
    throw w.abort(), s.message;
  }) };
}), {
  type: "raster-dem",
  tiles: [`gsidem://${d.tileUrl ?? "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png"}`],
  tileSize: 256,
  minzoom: d.minzoom ?? 1,
  maxzoom: d.maxzoom ?? 14,
  attribution: d.attribution ?? '<a href="https://maps.gsi.go.jp/development/ichiran.html"></a>'
});
var Fv = Object.defineProperty, Bv = (a, d, l) => d in a ? Fv(a, d, { enumerable: !0, configurable: !0, writable: !0, value: l }) : a[d] = l, Xi = (a, d, l) => Bv(a, typeof d != "symbol" ? d + "" : d, l);
class Rv {
  constructor(d) {
    Xi(this, "map"), Xi(this, "width"), Xi(this, "height"), Xi(this, "svgCanvas"), Xi(this, "xLine"), Xi(this, "yLine"), Xi(this, "color", "#535353"), this.map = d, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    var d, l;
    this.width = (d = this.map) == null ? void 0 : d.getCanvas().clientWidth, this.height = (l = this.map) == null ? void 0 : l.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const d = this.width / 2, l = this.height / 2;
      this.yLine.setAttribute("x1", `${d}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${d}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${l}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${l}px`);
    } else
      console.error("element value is null");
  }
  createCanvas(d) {
    if (this.width !== void 0 && this.height !== void 0) {
      const l = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      l.style.position = "relative", l.setAttribute("width", `${this.width}px`), l.setAttribute("height", `${this.height}px`);
      const m = this.width / 2, w = this.height / 2;
      this.yLine = l.appendChild(
        this.createLine(m, 0, m, this.height, this.color, "2px")
      ), this.xLine = l.appendChild(
        this.createLine(0, w, this.width, w, this.color, "2px")
      ), d == null || d.appendChild(l), this.svgCanvas = l;
    }
  }
  createLine(d, l, m, w, v, g) {
    const s = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return s.setAttribute("x1", d), s.setAttribute("y1", l), s.setAttribute("x2", m), s.setAttribute("y2", w), s.setAttribute("stroke-dasharray", "5,5"), s.setAttribute("stroke", v), s.setAttribute("stroke-width", g), s;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const Bp = {
  72: 72,
  96: 96,
  200: 200,
  300: 300,
  400: 400
}, Sl = {
  JPEG: "jpg",
  PNG: "png",
  PDF: "pdf",
  SVG: "svg"
}, rh = {
  Landscape: "landscape",
  Portrait: "portrait"
}, Iu = {
  // A0, A1, B0, B1 are not working well.
  // A0: [1189, 841],
  // A1: [841, 594],
  LETTER: [279, 216],
  // 8.5x11 - works
  //TABLOID: [432,279] // 11x17 - not working currently prints to 11.68x8.27 in landscape
  A2: [594, 420],
  A3: [420, 297],
  A4: [297, 210],
  A5: [210, 148],
  A6: [148, 105],
  // B0: [1414, 1000],
  // B1: [1000, 707],
  B2: [707, 500],
  B3: [500, 353],
  B4: [353, 250],
  B5: [250, 176],
  B6: [176, 125]
}, yc = {
  // don't use inch unit. because page size setting is using mm unit.
  in: "in",
  mm: "mm"
};
class Ov {
  constructor(d) {
    Xi(this, "map"), Xi(this, "width"), Xi(this, "height"), Xi(this, "unit"), Xi(this, "svgCanvas"), Xi(this, "svgPath");
    var l, m, w;
    if (this.map = d, this.map === void 0)
      return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const v = (l = this.map) == null ? void 0 : l.getCanvas().clientWidth, g = (m = this.map) == null ? void 0 : m.getCanvas().clientHeight, s = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    s.style.position = "absolute", s.style.top = "0px", s.style.left = "0px", s.setAttribute("width", `${v}px`), s.setAttribute("height", `${g}px`);
    const D = document.createElementNS("http://www.w3.org/2000/svg", "path");
    D.setAttribute("style", "fill:#888888;stroke-width:0"), D.setAttribute("fill-opacity", "0.5"), s.append(D), (w = this.map) == null || w.getCanvasContainer().appendChild(s), this.svgCanvas = s, this.svgPath = D;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(d, l) {
    this.width = d, this.height = l, this.unit = yc.mm, this.generateCutOut();
  }
  generateCutOut() {
    var d, l;
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0)
      return;
    const m = this.toPixels(this.width), w = this.toPixels(this.height), v = (d = this.map) == null ? void 0 : d.getCanvas().clientWidth, g = (l = this.map) == null ? void 0 : l.getCanvas().clientHeight, s = v / 2 - m / 2, D = s + m, k = g / 2 - w / 2, M = k + w;
    this.svgCanvas.setAttribute("width", `${v}px`), this.svgCanvas.setAttribute("height", `${g}px`), this.svgPath.setAttribute(
      "d",
      `M 0 0 L ${v} 0 L ${v} ${g} L 0 ${g} M ${s} ${k} L ${s} ${M} L ${D} ${M} L ${D} ${k}`
    );
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(d, l = 96) {
    return this.unit === yc.mm && (l /= 25.4), l * d;
  }
}
const Fg = {
  PageSize: "Page Size",
  PageOrientation: "Page Orientation",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generate",
  LanguageName: "English",
  LanguageCode: "en"
}, jv = {
  PageSize: "Taille de page",
  PageOrientation: "Orientation de la page",
  Format: "Format",
  DPI: "DPI",
  Generate: "Gnrer",
  LanguageName: "Franais",
  LanguageCode: "fr"
}, qv = {
  PageSize: "Sivukoko",
  PageOrientation: "Sivun suunta",
  Format: "Muoto",
  DPI: "DPI",
  Generate: "Generoi",
  LanguageName: "Suomalainen",
  LanguageCode: "fi"
}, Uv = {
  PageSize: "Papierformat",
  PageOrientation: "Papierausrichtung",
  Format: "Dateiformat",
  DPI: "Druckauflsung",
  Generate: "Erstellen",
  LanguageName: "Deutsch",
  LanguageCode: "de"
}, Vv = {
  PageSize: "Sidstorlek",
  PageOrientation: "Sidorientering",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generera",
  LanguageName: "Svenska",
  LanguageCode: "sv"
}, $v = {
  PageSize: "Tamao de pgina",
  PageOrientation: "Orientacin de pgina",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Generar",
  LanguageName: "Espaola",
  LanguageCode: "es"
}, Zv = {
  PageSize: "Mida",
  PageOrientation: "Orientaci",
  Format: "Format",
  DPI: "DPI",
  Generate: "Genera",
  LanguageName: "Catalan",
  LanguageCode: "ca"
}, Gv = {
  PageSize: "Kch thc trang",
  PageOrientation: "Loi trang",
  Format: "nh dng",
  DPI: "Mt  im nh (DPI)",
  Generate: "To",
  LanguageName: "Ting Vit",
  LanguageCode: "vi"
}, Hv = {
  PageSize: " ",
  PageOrientation: " ",
  Format: "",
  DPI: "DPI",
  Generate: "",
  LanguageName: "",
  LanguageCode: "uk"
}, Wv = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "",
  Generate: "",
  LanguageName: "",
  LanguageCode: "zhHans"
}, Xv = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "",
  Generate: "",
  LanguageName: "",
  LanguageCode: "zhHant"
}, Yv = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "DPI",
  Generate: "",
  LanguageName: "",
  LanguageCode: "ja"
}, Jv = {
  PageSize: "Tamanho da pgina",
  PageOrientation: "Orientao da pgina",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Gerar",
  LanguageName: "Portugus",
  LanguageCode: "pt"
}, Kv = [
  Fg,
  jv,
  qv,
  Uv,
  Vv,
  $v,
  Zv,
  Gv,
  Hv,
  Wv,
  Xv,
  Yv,
  Jv
], Qv = (a) => Kv.find((d) => d.LanguageCode === a) ?? Fg;
(function(a) {
  var d = {};
  function l(m) {
    if (d[m]) return d[m].exports;
    var w = d[m] = { i: m, l: !1, exports: {} };
    return a[m].call(w.exports, w, w.exports, l), w.l = !0, w.exports;
  }
  l.m = a, l.c = d, l.d = function(m, w, v) {
    l.o(m, w) || Object.defineProperty(m, w, { enumerable: !0, get: v });
  }, l.r = function(m) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(m, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(m, "__esModule", { value: !0 });
  }, l.t = function(m, w) {
    if (1 & w && (m = l(m)), 8 & w || 4 & w && typeof m == "object" && m && m.__esModule) return m;
    var v = /* @__PURE__ */ Object.create(null);
    if (l.r(v), Object.defineProperty(v, "default", { enumerable: !0, value: m }), 2 & w && typeof m != "string") for (var g in m) l.d(v, g, (function(s) {
      return m[s];
    }).bind(null, g));
    return v;
  }, l.n = function(m) {
    var w = m && m.__esModule ? function() {
      return m.default;
    } : function() {
      return m;
    };
    return l.d(w, "a", w), w;
  }, l.o = function(m, w) {
    return Object.prototype.hasOwnProperty.call(m, w);
  }, l.p = "", l(l.s = 0);
})([function(a, d, l) {
  a.exports = l(1);
}, function(a, d) {
  function l(w, v) {
    for (var g = 0; g < v.length; g++) {
      var s = v[g];
      s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(w, s.key, s);
    }
  }
  var m = function() {
    function w() {
      (function(s, D) {
        if (!(s instanceof D)) throw new TypeError("Cannot call a class as a function");
      })(this, w), this.options = { overlayBackgroundColor: "#666666", overlayOpacity: 0.6, spinnerIcon: "ball-circus", spinnerColor: "#000", spinnerSize: "3x", overlayIDName: "overlay", spinnerIDName: "spinner", offsetY: 0, offsetX: 0, lockScroll: !1, containerID: null, spinnerZIndex: 99999, overlayZIndex: 99998 }, this.stylesheetBaseURL = "https://cdn.jsdelivr.net/npm/load-awesome@1.1.0/css/", this.spinner = null, this.spinnerStylesheetURL = null, this.numberOfEmptyDivForSpinner = { "ball-8bits": 16, "ball-atom": 4, "ball-beat": 3, "ball-circus": 5, "ball-climbing-dot": 1, "ball-clip-rotate": 1, "ball-clip-rotate-multiple": 2, "ball-clip-rotate-pulse": 2, "ball-elastic-dots": 5, "ball-fall": 3, "ball-fussion": 4, "ball-grid-beat": 9, "ball-grid-pulse": 9, "ball-newton-cradle": 4, "ball-pulse": 3, "ball-pulse-rise": 5, "ball-pulse-sync": 3, "ball-rotate": 1, "ball-running-dots": 5, "ball-scale": 1, "ball-scale-multiple": 3, "ball-scale-pulse": 2, "ball-scale-ripple": 1, "ball-scale-ripple-multiple": 3, "ball-spin": 8, "ball-spin-clockwise": 8, "ball-spin-clockwise-fade": 8, "ball-spin-clockwise-fade-rotating": 8, "ball-spin-fade": 8, "ball-spin-fade-rotating": 8, "ball-spin-rotate": 2, "ball-square-clockwise-spin": 8, "ball-square-spin": 8, "ball-triangle-path": 3, "ball-zig-zag": 2, "ball-zig-zag-deflect": 2, cog: 1, "cube-transition": 2, fire: 3, "line-scale": 5, "line-scale-party": 5, "line-scale-pulse-out": 5, "line-scale-pulse-out-rapid": 5, "line-spin-clockwise-fade": 8, "line-spin-clockwise-fade-rotating": 8, "line-spin-fade": 8, "line-spin-fade-rotating": 8, pacman: 6, "square-jelly-box": 2, "square-loader": 1, "square-spin": 1, timer: 1, "triangle-skew-spin": 1 };
    }
    var v, g;
    return v = w, (g = [{ key: "show", value: function(s) {
      this.setOptions(s), this.addSpinnerStylesheet(), this.generateSpinnerElement(), this.options.lockScroll && (document.body.style.overflow = "hidden", document.documentElement.style.overflow = "hidden"), this.generateAndAddOverlayElement();
    } }, { key: "hide", value: function() {
      this.options.lockScroll && (document.body.style.overflow = "", document.documentElement.style.overflow = "");
      var s = document.getElementById("loading-overlay-stylesheet");
      s && (s.disabled = !0, s.parentNode.removeChild(s), document.getElementById(this.options.overlayIDName).remove(), document.getElementById(this.options.spinnerIDName).remove());
    } }, { key: "setOptions", value: function(s) {
      if (s !== void 0) for (var D in s) this.options[D] = s[D];
    } }, { key: "generateAndAddOverlayElement", value: function() {
      var s = "50%";
      this.options.offsetX !== 0 && (s = "calc(50% + " + this.options.offsetX + ")");
      var D = "50%";
      if (this.options.offsetY !== 0 && (D = "calc(50% + " + this.options.offsetY + ")"), this.options.containerID && document.body.contains(document.getElementById(this.options.containerID))) {
        var k = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: absolute; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, '; z-index: 50; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: absolute; top: ').concat(D, "; left: ").concat(s, '; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: 9999;">').concat(this.spinner, "</div>"), M = document.getElementById(this.options.containerID);
        return M.style.position = "relative", void M.insertAdjacentHTML("beforeend", k);
      }
      var q = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: fixed; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, "; z-index: ").concat(this.options.overlayZIndex, '; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: fixed; top: ').concat(D, "; left: ").concat(s, "; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: ").concat(this.options.spinnerZIndex, ';">').concat(this.spinner, "</div>");
      document.body.insertAdjacentHTML("beforeend", q);
    } }, { key: "generateSpinnerElement", value: function() {
      var s = this, D = Object.keys(this.numberOfEmptyDivForSpinner).find(function(M) {
        return M === s.options.spinnerIcon;
      }), k = this.generateEmptyDivElement(this.numberOfEmptyDivForSpinner[D]);
      this.spinner = '<div style="color: '.concat(this.options.spinnerColor, '" class="la-').concat(this.options.spinnerIcon, " la-").concat(this.options.spinnerSize, '">').concat(k, "</div>");
    } }, { key: "addSpinnerStylesheet", value: function() {
      this.setSpinnerStylesheetURL();
      var s = document.createElement("link");
      s.setAttribute("id", "loading-overlay-stylesheet"), s.setAttribute("rel", "stylesheet"), s.setAttribute("type", "text/css"), s.setAttribute("href", this.spinnerStylesheetURL), document.getElementsByTagName("head")[0].appendChild(s);
    } }, { key: "setSpinnerStylesheetURL", value: function() {
      this.spinnerStylesheetURL = this.stylesheetBaseURL + this.options.spinnerIcon + ".min.css";
    } }, { key: "generateEmptyDivElement", value: function(s) {
      for (var D = "", k = 1; k <= s; k++) D += "<div></div>";
      return D;
    } }]) && l(v.prototype, g), w;
  }();
  window.JsLoadingOverlay = new m(), a.exports = JsLoadingOverlay;
}]);
function ur(a) {
  "@babel/helpers - typeof";
  return ur = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
    return typeof d;
  } : function(d) {
    return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
  }, ur(a);
}
var Ba = Uint8Array, ba = Uint16Array, gh = Uint32Array, pd = new Ba([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), fd = new Ba([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Rp = new Ba([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Bg = function(a, d) {
  for (var l = new ba(31), m = 0; m < 31; ++m)
    l[m] = d += 1 << a[m - 1];
  for (var w = new gh(l[30]), m = 1; m < 30; ++m)
    for (var v = l[m]; v < l[m + 1]; ++v)
      w[v] = v - l[m] << 5 | m;
  return [l, w];
}, Rg = Bg(pd, 2), Og = Rg[0], Op = Rg[1];
Og[28] = 258, Op[258] = 28;
var jg = Bg(fd, 0), eb = jg[0], E0 = jg[1], jp = new ba(32768);
for (var Ir = 0; Ir < 32768; ++Ir) {
  var $l = (Ir & 43690) >>> 1 | (Ir & 21845) << 1;
  $l = ($l & 52428) >>> 2 | ($l & 13107) << 2, $l = ($l & 61680) >>> 4 | ($l & 3855) << 4, jp[Ir] = (($l & 65280) >>> 8 | ($l & 255) << 8) >>> 1;
}
var Vo = function(a, d, l) {
  for (var m = a.length, w = 0, v = new ba(d); w < m; ++w)
    ++v[a[w] - 1];
  var g = new ba(d);
  for (w = 0; w < d; ++w)
    g[w] = g[w - 1] + v[w - 1] << 1;
  var s;
  if (l) {
    s = new ba(1 << d);
    var D = 15 - d;
    for (w = 0; w < m; ++w)
      if (a[w])
        for (var k = w << 4 | a[w], M = d - a[w], q = g[a[w] - 1]++ << M, O = q | (1 << M) - 1; q <= O; ++q)
          s[jp[q] >>> D] = k;
  } else
    for (s = new ba(m), w = 0; w < m; ++w)
      s[w] = jp[g[a[w] - 1]++] >>> 15 - a[w];
  return s;
}, Ql = new Ba(288);
for (var Ir = 0; Ir < 144; ++Ir)
  Ql[Ir] = 8;
for (var Ir = 144; Ir < 256; ++Ir)
  Ql[Ir] = 9;
for (var Ir = 256; Ir < 280; ++Ir)
  Ql[Ir] = 7;
for (var Ir = 280; Ir < 288; ++Ir)
  Ql[Ir] = 8;
var _h = new Ba(32);
for (var Ir = 0; Ir < 32; ++Ir)
  _h[Ir] = 5;
var tb = /* @__PURE__ */ Vo(Ql, 9, 0), ib = /* @__PURE__ */ Vo(Ql, 9, 1), rb = /* @__PURE__ */ Vo(_h, 5, 0), nb = /* @__PURE__ */ Vo(_h, 5, 1), gp = function(a) {
  for (var d = a[0], l = 1; l < a.length; ++l)
    a[l] > d && (d = a[l]);
  return d;
}, Xs = function(a, d, l) {
  var m = d / 8 >> 0;
  return (a[m] | a[m + 1] << 8) >>> (d & 7) & l;
}, _p = function(a, d) {
  var l = d / 8 >> 0;
  return (a[l] | a[l + 1] << 8 | a[l + 2] << 16) >>> (d & 7);
}, nf = function(a) {
  return (a / 8 >> 0) + (a & 7 && 1);
}, qg = function(a, d, l) {
  (l == null || l > a.length) && (l = a.length);
  var m = new (a instanceof ba ? ba : a instanceof gh ? gh : Ba)(l - d);
  return m.set(a.subarray(d, l)), m;
}, ab = function(a, d, l) {
  var m = a.length, w = !d || l, v = !l || l.i;
  l || (l = {}), d || (d = new Ba(m * 3));
  var g = function(Oe) {
    var $e = d.length;
    if (Oe > $e) {
      var Ue = new Ba(Math.max($e * 2, Oe));
      Ue.set(d), d = Ue;
    }
  }, s = l.f || 0, D = l.p || 0, k = l.b || 0, M = l.l, q = l.d, O = l.m, z = l.n, pe = m * 8;
  do {
    if (!M) {
      l.f = s = Xs(a, D, 1);
      var le = Xs(a, D + 1, 3);
      if (D += 3, le)
        if (le == 1)
          M = ib, q = nb, O = 9, z = 5;
        else if (le == 2) {
          var se = Xs(a, D, 31) + 257, ee = Xs(a, D + 10, 15) + 4, fe = se + Xs(a, D + 5, 31) + 1;
          D += 14;
          for (var Te = new Ba(fe), ze = new Ba(19), qe = 0; qe < ee; ++qe)
            ze[Rp[qe]] = Xs(a, D + qe * 3, 7);
          D += ee * 3;
          var at = gp(ze), Ie = (1 << at) - 1;
          if (!v && D + fe * (at + 7) > pe)
            break;
          for (var Ae = Vo(ze, at, 1), qe = 0; qe < fe; ) {
            var me = Ae[Xs(a, D, Ie)];
            D += me & 15;
            var ve = me >>> 4;
            if (ve < 16)
              Te[qe++] = ve;
            else {
              var X = 0, re = 0;
              for (ve == 16 ? (re = 3 + Xs(a, D, 3), D += 2, X = Te[qe - 1]) : ve == 17 ? (re = 3 + Xs(a, D, 7), D += 3) : ve == 18 && (re = 11 + Xs(a, D, 127), D += 7); re--; )
                Te[qe++] = X;
            }
          }
          var xe = Te.subarray(0, se), ye = Te.subarray(se);
          O = gp(xe), z = gp(ye), M = Vo(xe, O, 1), q = Vo(ye, z, 1);
        } else
          throw "invalid block type";
      else {
        var ve = nf(D) + 4, Ve = a[ve - 4] | a[ve - 3] << 8, He = ve + Ve;
        if (He > m) {
          if (v)
            throw "unexpected EOF";
          break;
        }
        w && g(k + Ve), d.set(a.subarray(ve, He), k), l.b = k += Ve, l.p = D = He * 8;
        continue;
      }
      if (D > pe)
        throw "unexpected EOF";
    }
    w && g(k + 131072);
    for (var Ze = (1 << O) - 1, je = (1 << z) - 1, Je = O + z + 18; v || D + Je < pe; ) {
      var X = M[_p(a, D) & Ze], Qe = X >>> 4;
      if (D += X & 15, D > pe)
        throw "unexpected EOF";
      if (!X)
        throw "invalid length/literal";
      if (Qe < 256)
        d[k++] = Qe;
      else if (Qe == 256) {
        M = null;
        break;
      } else {
        var nt = Qe - 254;
        if (Qe > 264) {
          var qe = Qe - 257, Q = pd[qe];
          nt = Xs(a, D, (1 << Q) - 1) + Og[qe], D += Q;
        }
        var _e = q[_p(a, D) & je], be = _e >>> 4;
        if (!_e)
          throw "invalid distance";
        D += _e & 15;
        var ye = eb[be];
        if (be > 3) {
          var Q = fd[be];
          ye += _p(a, D) & (1 << Q) - 1, D += Q;
        }
        if (D > pe)
          throw "unexpected EOF";
        w && g(k + 131072);
        for (var Ce = k + nt; k < Ce; k += 4)
          d[k] = d[k - ye], d[k + 1] = d[k + 1 - ye], d[k + 2] = d[k + 2 - ye], d[k + 3] = d[k + 3 - ye];
        k = Ce;
      }
    }
    l.l = M, l.p = D, l.b = k, M && (s = 1, l.m = O, l.d = q, l.n = z);
  } while (!s);
  return k == d.length ? d : qg(d, 0, k);
}, bl = function(a, d, l) {
  l <<= d & 7;
  var m = d / 8 >> 0;
  a[m] |= l, a[m + 1] |= l >>> 8;
}, Jc = function(a, d, l) {
  l <<= d & 7;
  var m = d / 8 >> 0;
  a[m] |= l, a[m + 1] |= l >>> 8, a[m + 2] |= l >>> 16;
}, yp = function(a, d) {
  for (var l = [], m = 0; m < a.length; ++m)
    a[m] && l.push({ s: m, f: a[m] });
  var w = l.length, v = l.slice();
  if (!w)
    return [new Ba(0), 0];
  if (w == 1) {
    var g = new Ba(l[0].s + 1);
    return g[l[0].s] = 1, [g, 1];
  }
  l.sort(function(qe, at) {
    return qe.f - at.f;
  }), l.push({ s: -1, f: 25001 });
  var s = l[0], D = l[1], k = 0, M = 1, q = 2;
  for (l[0] = { s: -1, f: s.f + D.f, l: s, r: D }; M != w - 1; )
    s = l[l[k].f < l[q].f ? k++ : q++], D = l[k != M && l[k].f < l[q].f ? k++ : q++], l[M++] = { s: -1, f: s.f + D.f, l: s, r: D };
  for (var O = v[0].s, m = 1; m < w; ++m)
    v[m].s > O && (O = v[m].s);
  var z = new ba(O + 1), pe = qp(l[M - 1], z, 0);
  if (pe > d) {
    var m = 0, le = 0, se = pe - d, ee = 1 << se;
    for (v.sort(function(at, Ie) {
      return z[Ie.s] - z[at.s] || at.f - Ie.f;
    }); m < w; ++m) {
      var fe = v[m].s;
      if (z[fe] > d)
        le += ee - (1 << pe - z[fe]), z[fe] = d;
      else
        break;
    }
    for (le >>>= se; le > 0; ) {
      var Te = v[m].s;
      z[Te] < d ? le -= 1 << d - z[Te]++ - 1 : ++m;
    }
    for (; m >= 0 && le; --m) {
      var ze = v[m].s;
      z[ze] == d && (--z[ze], ++le);
    }
    pe = d;
  }
  return [new Ba(z), pe];
}, qp = function(a, d, l) {
  return a.s == -1 ? Math.max(qp(a.l, d, l + 1), qp(a.r, d, l + 1)) : d[a.s] = l;
}, T0 = function(a) {
  for (var d = a.length; d && !a[--d]; )
    ;
  for (var l = new ba(++d), m = 0, w = a[0], v = 1, g = function(D) {
    l[m++] = D;
  }, s = 1; s <= d; ++s)
    if (a[s] == w && s != d)
      ++v;
    else {
      if (!w && v > 2) {
        for (; v > 138; v -= 138)
          g(32754);
        v > 2 && (g(v > 10 ? v - 11 << 5 | 28690 : v - 3 << 5 | 12305), v = 0);
      } else if (v > 3) {
        for (g(w), --v; v > 6; v -= 6)
          g(8304);
        v > 2 && (g(v - 3 << 5 | 8208), v = 0);
      }
      for (; v--; )
        g(w);
      v = 1, w = a[s];
    }
  return [l.subarray(0, m), d];
}, Kc = function(a, d) {
  for (var l = 0, m = 0; m < d.length; ++m)
    l += a[m] * d[m];
  return l;
}, Up = function(a, d, l) {
  var m = l.length, w = nf(d + 2);
  a[w] = m & 255, a[w + 1] = m >>> 8, a[w + 2] = a[w] ^ 255, a[w + 3] = a[w + 1] ^ 255;
  for (var v = 0; v < m; ++v)
    a[w + v + 4] = l[v];
  return (w + 4 + m) * 8;
}, C0 = function(a, d, l, m, w, v, g, s, D, k, M) {
  bl(d, M++, l), ++w[256];
  for (var q = yp(w, 15), O = q[0], z = q[1], pe = yp(v, 15), le = pe[0], se = pe[1], ee = T0(O), fe = ee[0], Te = ee[1], ze = T0(le), qe = ze[0], at = ze[1], Ie = new ba(19), Ae = 0; Ae < fe.length; ++Ae)
    Ie[fe[Ae] & 31]++;
  for (var Ae = 0; Ae < qe.length; ++Ae)
    Ie[qe[Ae] & 31]++;
  for (var me = yp(Ie, 7), ve = me[0], X = me[1], re = 19; re > 4 && !ve[Rp[re - 1]]; --re)
    ;
  var xe = k + 5 << 3, ye = Kc(w, Ql) + Kc(v, _h) + g, Ve = Kc(w, O) + Kc(v, le) + g + 14 + 3 * re + Kc(Ie, ve) + (2 * Ie[16] + 3 * Ie[17] + 7 * Ie[18]);
  if (xe <= ye && xe <= Ve)
    return Up(d, M, a.subarray(D, D + k));
  var He, Ze, je, Je;
  if (bl(d, M, 1 + (Ve < ye)), M += 2, Ve < ye) {
    He = Vo(O, z, 0), Ze = O, je = Vo(le, se, 0), Je = le;
    var Qe = Vo(ve, X, 0);
    bl(d, M, Te - 257), bl(d, M + 5, at - 1), bl(d, M + 10, re - 4), M += 14;
    for (var Ae = 0; Ae < re; ++Ae)
      bl(d, M + 3 * Ae, ve[Rp[Ae]]);
    M += 3 * re;
    for (var nt = [fe, qe], Q = 0; Q < 2; ++Q)
      for (var _e = nt[Q], Ae = 0; Ae < _e.length; ++Ae) {
        var be = _e[Ae] & 31;
        bl(d, M, Qe[be]), M += ve[be], be > 15 && (bl(d, M, _e[Ae] >>> 5 & 127), M += _e[Ae] >>> 12);
      }
  } else
    He = tb, Ze = Ql, je = rb, Je = _h;
  for (var Ae = 0; Ae < s; ++Ae)
    if (m[Ae] > 255) {
      var be = m[Ae] >>> 18 & 31;
      Jc(d, M, He[be + 257]), M += Ze[be + 257], be > 7 && (bl(d, M, m[Ae] >>> 23 & 31), M += pd[be]);
      var Ce = m[Ae] & 31;
      Jc(d, M, je[Ce]), M += Je[Ce], Ce > 3 && (Jc(d, M, m[Ae] >>> 5 & 8191), M += fd[Ce]);
    } else
      Jc(d, M, He[m[Ae]]), M += Ze[m[Ae]];
  return Jc(d, M, He[256]), M + Ze[256];
}, sb = /* @__PURE__ */ new gh([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), ob = function(a, d, l, m, w, v) {
  var g = a.length, s = new Ba(m + g + 5 * (1 + Math.floor(g / 7e3)) + w), D = s.subarray(m, s.length - w), k = 0;
  if (!d || g < 8)
    for (var M = 0; M <= g; M += 65535) {
      var q = M + 65535;
      q < g ? k = Up(D, k, a.subarray(M, q)) : (D[M] = v, k = Up(D, k, a.subarray(M, g)));
    }
  else {
    for (var O = sb[d - 1], z = O >>> 13, pe = O & 8191, le = (1 << l) - 1, se = new ba(32768), ee = new ba(le + 1), fe = Math.ceil(l / 3), Te = 2 * fe, ze = function(Pt) {
      return (a[Pt] ^ a[Pt + 1] << fe ^ a[Pt + 2] << Te) & le;
    }, qe = new gh(25e3), at = new ba(288), Ie = new ba(32), Ae = 0, me = 0, M = 0, ve = 0, X = 0, re = 0; M < g; ++M) {
      var xe = ze(M), ye = M & 32767, Ve = ee[xe];
      if (se[ye] = Ve, ee[xe] = ye, X <= M) {
        var He = g - M;
        if ((Ae > 7e3 || ve > 24576) && He > 423) {
          k = C0(a, D, 0, qe, at, Ie, me, ve, re, M - re, k), ve = Ae = me = 0, re = M;
          for (var Ze = 0; Ze < 286; ++Ze)
            at[Ze] = 0;
          for (var Ze = 0; Ze < 30; ++Ze)
            Ie[Ze] = 0;
        }
        var je = 2, Je = 0, Qe = pe, nt = ye - Ve & 32767;
        if (He > 2 && xe == ze(M - nt))
          for (var Q = Math.min(z, He) - 1, _e = Math.min(32767, M), be = Math.min(258, He); nt <= _e && --Qe && ye != Ve; ) {
            if (a[M + je] == a[M + je - nt]) {
              for (var Ce = 0; Ce < be && a[M + Ce] == a[M + Ce - nt]; ++Ce)
                ;
              if (Ce > je) {
                if (je = Ce, Je = nt, Ce > Q)
                  break;
                for (var Oe = Math.min(nt, Ce - 2), $e = 0, Ze = 0; Ze < Oe; ++Ze) {
                  var Ue = M - nt + Ze + 32768 & 32767, Ke = se[Ue], rt = Ue - Ke + 32768 & 32767;
                  rt > $e && ($e = rt, Ve = Ue);
                }
              }
            }
            ye = Ve, Ve = se[ye], nt += ye - Ve + 32768 & 32767;
          }
        if (Je) {
          qe[ve++] = 268435456 | Op[je] << 18 | E0[Je];
          var ot = Op[je] & 31, vt = E0[Je] & 31;
          me += pd[ot] + fd[vt], ++at[257 + ot], ++Ie[vt], X = M + je, ++Ae;
        } else
          qe[ve++] = a[M], ++at[a[M]];
      }
    }
    k = C0(a, D, v, qe, at, Ie, me, ve, re, M - re, k);
  }
  return qg(s, 0, m + nf(k) + w);
}, lb = function() {
  var a = 1, d = 0;
  return {
    p: function(l) {
      for (var m = a, w = d, v = l.length, g = 0; g != v; ) {
        for (var s = Math.min(g + 5552, v); g < s; ++g)
          m += l[g], w += m;
        m %= 65521, w %= 65521;
      }
      a = m, d = w;
    },
    d: function() {
      return (a >>> 8 << 16 | (d & 255) << 8 | d >>> 8) + ((a & 255) << 23) * 2;
    }
  };
}, ub = function(a, d, l, m, w) {
  return ob(a, d.level == null ? 6 : d.level, d.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(a.length))) * 1.5) : 12 + d.mem, l, m, !w);
}, cb = function(a, d, l) {
  for (; l; ++d)
    a[d] = l, l >>>= 8;
}, hb = function(a, d) {
  var l = d.level, m = l == 0 ? 0 : l < 6 ? 1 : l == 9 ? 3 : 2;
  a[0] = 120, a[1] = m << 6 | (m ? 32 - 2 * m : 1);
}, db = function(a) {
  if ((a[0] & 15) != 8 || a[0] >>> 4 > 7 || (a[0] << 8 | a[1]) % 31)
    throw "invalid zlib data";
  if (a[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Vp(a, d) {
  d === void 0 && (d = {});
  var l = lb();
  l.p(a);
  var m = ub(a, d, 2, 4);
  return hb(m, d), cb(m, m.length - 4, l.d()), m;
}
function pb(a, d) {
  return ab((db(a), a.subarray(2, -4)), d);
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var Ai = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function vp() {
  Ai.console && typeof Ai.console.log == "function" && Ai.console.log.apply(Ai.console, arguments);
}
var yr = { log: vp, warn: function(a) {
  Ai.console && (typeof Ai.console.warn == "function" ? Ai.console.warn.apply(Ai.console, arguments) : vp.call(null, arguments));
}, error: function(a) {
  Ai.console && (typeof Ai.console.error == "function" ? Ai.console.error.apply(Ai.console, arguments) : vp(a));
} };
function bp(a, d, l) {
  var m = new XMLHttpRequest();
  m.open("GET", a), m.responseType = "blob", m.onload = function() {
    Su(m.response, d, l);
  }, m.onerror = function() {
    yr.error("could not download file");
  }, m.send();
}
function D0(a) {
  var d = new XMLHttpRequest();
  d.open("HEAD", a, !1);
  try {
    d.send();
  } catch {
  }
  return d.status >= 200 && d.status <= 299;
}
function Gh(a) {
  try {
    a.dispatchEvent(new MouseEvent("click"));
  } catch {
    var d = document.createEvent("MouseEvents");
    d.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(d);
  }
}
var oh, $p, Su = Ai.saveAs || ((typeof window > "u" ? "undefined" : ur(window)) !== "object" || window !== Ai ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(a, d, l) {
  var m = Ai.URL || Ai.webkitURL, w = document.createElement("a");
  d = d || a.name || "download", w.download = d, w.rel = "noopener", typeof a == "string" ? (w.href = a, w.origin !== location.origin ? D0(w.href) ? bp(a, d, l) : Gh(w, w.target = "_blank") : Gh(w)) : (w.href = m.createObjectURL(a), setTimeout(function() {
    m.revokeObjectURL(w.href);
  }, 4e4), setTimeout(function() {
    Gh(w);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(a, d, l) {
  if (d = d || a.name || "download", typeof a == "string") if (D0(a)) bp(a, d, l);
  else {
    var m = document.createElement("a");
    m.href = a, m.target = "_blank", setTimeout(function() {
      Gh(m);
    });
  }
  else navigator.msSaveOrOpenBlob(function(w, v) {
    return v === void 0 ? v = { autoBom: !1 } : ur(v) !== "object" && (yr.warn("Deprecated: Expected third argument to be a object"), v = { autoBom: !v }), v.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(w.type) ? new Blob(["\uFEFF", w], { type: w.type }) : w;
  }(a, l), d);
} : function(a, d, l, m) {
  if ((m = m || open("", "_blank")) && (m.document.title = m.document.body.innerText = "downloading..."), typeof a == "string") return bp(a, d, l);
  var w = a.type === "application/octet-stream", v = /constructor/i.test(Ai.HTMLElement) || Ai.safari, g = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((g || w && v) && (typeof FileReader > "u" ? "undefined" : ur(FileReader)) === "object") {
    var s = new FileReader();
    s.onloadend = function() {
      var M = s.result;
      M = g ? M : M.replace(/^data:[^;]*;/, "data:attachment/file;"), m ? m.location.href = M : location = M, m = null;
    }, s.readAsDataURL(a);
  } else {
    var D = Ai.URL || Ai.webkitURL, k = D.createObjectURL(a);
    m ? m.location = k : location.href = k, m = null, setTimeout(function() {
      D.revokeObjectURL(k);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function Ug(a) {
  var d;
  a = a || "", this.ok = !1, a.charAt(0) == "#" && (a = a.substr(1, 6)), a = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[a = (a = a.replace(/ /g, "")).toLowerCase()] || a;
  for (var l = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(s) {
    return [parseInt(s[1]), parseInt(s[2]), parseInt(s[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(s) {
    return [parseInt(s[1], 16), parseInt(s[2], 16), parseInt(s[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(s) {
    return [parseInt(s[1] + s[1], 16), parseInt(s[2] + s[2], 16), parseInt(s[3] + s[3], 16)];
  } }], m = 0; m < l.length; m++) {
    var w = l[m].re, v = l[m].process, g = w.exec(a);
    g && (d = v(g), this.r = d[0], this.g = d[1], this.b = d[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var s = this.r.toString(16), D = this.g.toString(16), k = this.b.toString(16);
    return s.length == 1 && (s = "0" + s), D.length == 1 && (D = "0" + D), k.length == 1 && (k = "0" + k), "#" + s + D + k;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function xp(a, d) {
  var l = a[0], m = a[1], w = a[2], v = a[3];
  l = ea(l, m, w, v, d[0], 7, -680876936), v = ea(v, l, m, w, d[1], 12, -389564586), w = ea(w, v, l, m, d[2], 17, 606105819), m = ea(m, w, v, l, d[3], 22, -1044525330), l = ea(l, m, w, v, d[4], 7, -176418897), v = ea(v, l, m, w, d[5], 12, 1200080426), w = ea(w, v, l, m, d[6], 17, -1473231341), m = ea(m, w, v, l, d[7], 22, -45705983), l = ea(l, m, w, v, d[8], 7, 1770035416), v = ea(v, l, m, w, d[9], 12, -1958414417), w = ea(w, v, l, m, d[10], 17, -42063), m = ea(m, w, v, l, d[11], 22, -1990404162), l = ea(l, m, w, v, d[12], 7, 1804603682), v = ea(v, l, m, w, d[13], 12, -40341101), w = ea(w, v, l, m, d[14], 17, -1502002290), l = ta(l, m = ea(m, w, v, l, d[15], 22, 1236535329), w, v, d[1], 5, -165796510), v = ta(v, l, m, w, d[6], 9, -1069501632), w = ta(w, v, l, m, d[11], 14, 643717713), m = ta(m, w, v, l, d[0], 20, -373897302), l = ta(l, m, w, v, d[5], 5, -701558691), v = ta(v, l, m, w, d[10], 9, 38016083), w = ta(w, v, l, m, d[15], 14, -660478335), m = ta(m, w, v, l, d[4], 20, -405537848), l = ta(l, m, w, v, d[9], 5, 568446438), v = ta(v, l, m, w, d[14], 9, -1019803690), w = ta(w, v, l, m, d[3], 14, -187363961), m = ta(m, w, v, l, d[8], 20, 1163531501), l = ta(l, m, w, v, d[13], 5, -1444681467), v = ta(v, l, m, w, d[2], 9, -51403784), w = ta(w, v, l, m, d[7], 14, 1735328473), l = ia(l, m = ta(m, w, v, l, d[12], 20, -1926607734), w, v, d[5], 4, -378558), v = ia(v, l, m, w, d[8], 11, -2022574463), w = ia(w, v, l, m, d[11], 16, 1839030562), m = ia(m, w, v, l, d[14], 23, -35309556), l = ia(l, m, w, v, d[1], 4, -1530992060), v = ia(v, l, m, w, d[4], 11, 1272893353), w = ia(w, v, l, m, d[7], 16, -155497632), m = ia(m, w, v, l, d[10], 23, -1094730640), l = ia(l, m, w, v, d[13], 4, 681279174), v = ia(v, l, m, w, d[0], 11, -358537222), w = ia(w, v, l, m, d[3], 16, -722521979), m = ia(m, w, v, l, d[6], 23, 76029189), l = ia(l, m, w, v, d[9], 4, -640364487), v = ia(v, l, m, w, d[12], 11, -421815835), w = ia(w, v, l, m, d[15], 16, 530742520), l = ra(l, m = ia(m, w, v, l, d[2], 23, -995338651), w, v, d[0], 6, -198630844), v = ra(v, l, m, w, d[7], 10, 1126891415), w = ra(w, v, l, m, d[14], 15, -1416354905), m = ra(m, w, v, l, d[5], 21, -57434055), l = ra(l, m, w, v, d[12], 6, 1700485571), v = ra(v, l, m, w, d[3], 10, -1894986606), w = ra(w, v, l, m, d[10], 15, -1051523), m = ra(m, w, v, l, d[1], 21, -2054922799), l = ra(l, m, w, v, d[8], 6, 1873313359), v = ra(v, l, m, w, d[15], 10, -30611744), w = ra(w, v, l, m, d[6], 15, -1560198380), m = ra(m, w, v, l, d[13], 21, 1309151649), l = ra(l, m, w, v, d[4], 6, -145523070), v = ra(v, l, m, w, d[11], 10, -1120210379), w = ra(w, v, l, m, d[2], 15, 718787259), m = ra(m, w, v, l, d[9], 21, -343485551), a[0] = Xl(l, a[0]), a[1] = Xl(m, a[1]), a[2] = Xl(w, a[2]), a[3] = Xl(v, a[3]);
}
function md(a, d, l, m, w, v) {
  return d = Xl(Xl(d, a), Xl(m, v)), Xl(d << w | d >>> 32 - w, l);
}
function ea(a, d, l, m, w, v, g) {
  return md(d & l | ~d & m, a, d, w, v, g);
}
function ta(a, d, l, m, w, v, g) {
  return md(d & m | l & ~m, a, d, w, v, g);
}
function ia(a, d, l, m, w, v, g) {
  return md(d ^ l ^ m, a, d, w, v, g);
}
function ra(a, d, l, m, w, v, g) {
  return md(l ^ (d | ~m), a, d, w, v, g);
}
function Vg(a) {
  var d, l = a.length, m = [1732584193, -271733879, -1732584194, 271733878];
  for (d = 64; d <= a.length; d += 64) xp(m, fb(a.substring(d - 64, d)));
  a = a.substring(d - 64);
  var w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (d = 0; d < a.length; d++) w[d >> 2] |= a.charCodeAt(d) << (d % 4 << 3);
  if (w[d >> 2] |= 128 << (d % 4 << 3), d > 55) for (xp(m, w), d = 0; d < 16; d++) w[d] = 0;
  return w[14] = 8 * l, xp(m, w), m;
}
function fb(a) {
  var d, l = [];
  for (d = 0; d < 64; d += 4) l[d >> 2] = a.charCodeAt(d) + (a.charCodeAt(d + 1) << 8) + (a.charCodeAt(d + 2) << 16) + (a.charCodeAt(d + 3) << 24);
  return l;
}
oh = Ai.atob.bind(Ai), $p = Ai.btoa.bind(Ai);
var I0 = "0123456789abcdef".split("");
function mb(a) {
  for (var d = "", l = 0; l < 4; l++) d += I0[a >> 8 * l + 4 & 15] + I0[a >> 8 * l & 15];
  return d;
}
function gb(a) {
  return String.fromCharCode((255 & a) >> 0, (65280 & a) >> 8, (16711680 & a) >> 16, (4278190080 & a) >> 24);
}
function Zp(a) {
  return Vg(a).map(gb).join("");
}
var _b = function(a) {
  for (var d = 0; d < a.length; d++) a[d] = mb(a[d]);
  return a.join("");
}(Vg("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Xl(a, d) {
  if (_b) {
    var l = (65535 & a) + (65535 & d);
    return (a >> 16) + (d >> 16) + (l >> 16) << 16 | 65535 & l;
  }
  return a + d & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function Gp(a, d) {
  var l, m, w, v;
  if (a !== l) {
    for (var g = (w = a, v = 1 + (256 / a.length >> 0), new Array(v + 1).join(w)), s = [], D = 0; D < 256; D++) s[D] = D;
    var k = 0;
    for (D = 0; D < 256; D++) {
      var M = s[D];
      k = (k + M + g.charCodeAt(D)) % 256, s[D] = s[k], s[k] = M;
    }
    l = a, m = s;
  } else s = m;
  var q = d.length, O = 0, z = 0, pe = "";
  for (D = 0; D < q; D++) z = (z + (M = s[O = (O + 1) % 256])) % 256, s[O] = s[z], s[z] = M, g = s[(s[O] + s[z]) % 256], pe += String.fromCharCode(d.charCodeAt(D) ^ g);
  return pe;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var k0 = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function oc(a, d, l, m) {
  this.v = 1, this.r = 2;
  var w = 192;
  a.forEach(function(s) {
    if (k0.perm !== void 0) throw new Error("Invalid permission: " + s);
    w += k0[s];
  }), this.padding = "(N^NuAd\0NV\b..\0h>/\fdSiz";
  var v = (d + this.padding).substr(0, 32), g = (l + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(v, g), this.P = -(1 + (255 ^ w)), this.encryptionKey = Zp(v + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(m)).substr(0, 5), this.U = Gp(this.encryptionKey, this.padding);
}
function lc(a) {
  if (/[^\u0000-\u00ff]/.test(a)) throw new Error("Invalid PDF Name Object: " + a + ", Only accept ASCII characters.");
  for (var d = "", l = a.length, m = 0; m < l; m++) {
    var w = a.charCodeAt(m);
    w < 33 || w === 35 || w === 37 || w === 40 || w === 41 || w === 47 || w === 60 || w === 62 || w === 91 || w === 93 || w === 123 || w === 125 || w > 126 ? d += "#" + ("0" + w.toString(16)).slice(-2) : d += a[m];
  }
  return d;
}
function P0(a) {
  if (ur(a) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var d = {};
  this.subscribe = function(l, m, w) {
    if (w = w || !1, typeof l != "string" || typeof m != "function" || typeof w != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    d.hasOwnProperty(l) || (d[l] = {});
    var v = Math.random().toString(35);
    return d[l][v] = [m, !!w], v;
  }, this.unsubscribe = function(l) {
    for (var m in d) if (d[m][l]) return delete d[m][l], Object.keys(d[m]).length === 0 && delete d[m], !0;
    return !1;
  }, this.publish = function(l) {
    if (d.hasOwnProperty(l)) {
      var m = Array.prototype.slice.call(arguments, 1), w = [];
      for (var v in d[l]) {
        var g = d[l][v];
        try {
          g[0].apply(a, m);
        } catch (s) {
          Ai.console && yr.error("jsPDF PubSub Error", s.message, s);
        }
        g[1] && w.push(v);
      }
      w.length && w.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return d;
  };
}
function sd(a) {
  if (!(this instanceof sd)) return new sd(a);
  var d = "opacity,stroke-opacity".split(",");
  for (var l in a) a.hasOwnProperty(l) && d.indexOf(l) >= 0 && (this[l] = a[l]);
  this.id = "", this.objectNumber = -1;
}
function $g(a, d) {
  this.gState = a, this.matrix = d, this.id = "", this.objectNumber = -1;
}
function Eu(a, d, l, m, w) {
  if (!(this instanceof Eu)) return new Eu(a, d, l, m, w);
  this.type = a === "axial" ? 2 : 3, this.coords = d, this.colors = l, $g.call(this, m, w);
}
function uc(a, d, l, m, w) {
  if (!(this instanceof uc)) return new uc(a, d, l, m, w);
  this.boundingBox = a, this.xStep = d, this.yStep = l, this.stream = "", this.cloneIndex = 0, $g.call(this, m, w);
}
function wi(a) {
  var d, l = typeof arguments[0] == "string" ? arguments[0] : "p", m = arguments[1], w = arguments[2], v = arguments[3], g = [], s = 1, D = 16, k = "S", M = null;
  ur(a = a || {}) === "object" && (l = a.orientation, m = a.unit || m, w = a.format || w, v = a.compress || a.compressPdf || v, (M = a.encryption || null) !== null && (M.userPassword = M.userPassword || "", M.ownerPassword = M.ownerPassword || "", M.userPermissions = M.userPermissions || []), s = typeof a.userUnit == "number" ? Math.abs(a.userUnit) : 1, a.precision !== void 0 && (d = a.precision), a.floatPrecision !== void 0 && (D = a.floatPrecision), k = a.defaultPathOperation || "S"), g = a.filters || (v === !0 ? ["FlateEncode"] : g), m = m || "mm", l = ("" + (l || "P")).toLowerCase();
  var q = a.putOnlyUsedFonts || !1, O = {}, z = { internal: {}, __private__: {} };
  z.__private__.PubSub = P0;
  var pe = "1.3", le = z.__private__.getPdfVersion = function() {
    return pe;
  };
  z.__private__.setPdfVersion = function(I) {
    pe = I;
  };
  var se = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  z.__private__.getPageFormats = function() {
    return se;
  };
  var ee = z.__private__.getPageFormat = function(I) {
    return se[I];
  };
  w = w || "a4";
  var fe = { COMPAT: "compat", ADVANCED: "advanced" }, Te = fe.COMPAT;
  function ze() {
    this.saveGraphicsState(), Y(new Ne(kt, 0, 0, -kt, 0, hs() * kt).toString() + " cm"), this.setFontSize(this.getFontSize() / kt), k = "n", Te = fe.ADVANCED;
  }
  function qe() {
    this.restoreGraphicsState(), k = "S", Te = fe.COMPAT;
  }
  var at = z.__private__.combineFontStyleAndFontWeight = function(I, K) {
    if (I == "bold" && K == "normal" || I == "bold" && K == 400 || I == "normal" && K == "italic" || I == "bold" && K == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return K && (I = K == 400 || K === "normal" ? I === "italic" ? "italic" : "normal" : K != 700 && K !== "bold" || I !== "normal" ? (K == 700 ? "bold" : K) + "" + I : "bold"), I;
  };
  z.advancedAPI = function(I) {
    var K = Te === fe.COMPAT;
    return K && ze.call(this), typeof I != "function" || (I(this), K && qe.call(this)), this;
  }, z.compatAPI = function(I) {
    var K = Te === fe.ADVANCED;
    return K && qe.call(this), typeof I != "function" || (I(this), K && ze.call(this)), this;
  }, z.isAdvancedAPI = function() {
    return Te === fe.ADVANCED;
  };
  var Ie, Ae = function(I) {
    if (Te !== fe.ADVANCED) throw new Error(I + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, me = z.roundToPrecision = z.__private__.roundToPrecision = function(I, K) {
    var Ee = d || K;
    if (isNaN(I) || isNaN(Ee)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return I.toFixed(Ee).replace(/0+$/, "");
  };
  Ie = z.hpf = z.__private__.hpf = typeof D == "number" ? function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return me(I, D);
  } : D === "smart" ? function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return me(I, I > -1 && I < 1 ? 16 : 5);
  } : function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return me(I, 16);
  };
  var ve = z.f2 = z.__private__.f2 = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.f2");
    return me(I, 2);
  }, X = z.__private__.f3 = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.f3");
    return me(I, 3);
  }, re = z.scale = z.__private__.scale = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.scale");
    return Te === fe.COMPAT ? I * kt : Te === fe.ADVANCED ? I : void 0;
  }, xe = function(I) {
    return Te === fe.COMPAT ? hs() - I : Te === fe.ADVANCED ? I : void 0;
  }, ye = function(I) {
    return re(xe(I));
  };
  z.__private__.setPrecision = z.setPrecision = function(I) {
    typeof parseInt(I, 10) == "number" && (d = parseInt(I, 10));
  };
  var Ve, He = "00000000000000000000000000000000", Ze = z.__private__.getFileId = function() {
    return He;
  }, je = z.__private__.setFileId = function(I) {
    return He = I !== void 0 && /^[a-fA-F0-9]{32}$/.test(I) ? I.toUpperCase() : He.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), M !== null && (xr = new oc(M.userPermissions, M.userPassword, M.ownerPassword, He)), He;
  };
  z.setFileId = function(I) {
    return je(I), this;
  }, z.getFileId = function() {
    return Ze();
  };
  var Je = z.__private__.convertDateToPDFDate = function(I) {
    var K = I.getTimezoneOffset(), Ee = K < 0 ? "+" : "-", Re = Math.floor(Math.abs(K / 60)), Ye = Math.abs(K % 60), ct = [Ee, be(Re), "'", be(Ye), "'"].join("");
    return ["D:", I.getFullYear(), be(I.getMonth() + 1), be(I.getDate()), be(I.getHours()), be(I.getMinutes()), be(I.getSeconds()), ct].join("");
  }, Qe = z.__private__.convertPDFDateToDate = function(I) {
    var K = parseInt(I.substr(2, 4), 10), Ee = parseInt(I.substr(6, 2), 10) - 1, Re = parseInt(I.substr(8, 2), 10), Ye = parseInt(I.substr(10, 2), 10), ct = parseInt(I.substr(12, 2), 10), It = parseInt(I.substr(14, 2), 10);
    return new Date(K, Ee, Re, Ye, ct, It, 0);
  }, nt = z.__private__.setCreationDate = function(I) {
    var K;
    if (I === void 0 && (I = /* @__PURE__ */ new Date()), I instanceof Date) K = Je(I);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(I)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      K = I;
    }
    return Ve = K;
  }, Q = z.__private__.getCreationDate = function(I) {
    var K = Ve;
    return I === "jsDate" && (K = Qe(Ve)), K;
  };
  z.setCreationDate = function(I) {
    return nt(I), this;
  }, z.getCreationDate = function(I) {
    return Q(I);
  };
  var _e, be = z.__private__.padd2 = function(I) {
    return ("0" + parseInt(I)).slice(-2);
  }, Ce = z.__private__.padd2Hex = function(I) {
    return ("00" + (I = I.toString())).substr(I.length);
  }, Oe = 0, $e = [], Ue = [], Ke = 0, rt = [], ot = [], vt = !1, mt = Ue, Pt = function() {
    Oe = 0, Ke = 0, Ue = [], $e = [], rt = [], Qt = gt(), ei = gt();
  };
  z.__private__.setCustomOutputDestination = function(I) {
    vt = !0, mt = I;
  };
  var it = function(I) {
    vt || (mt = I);
  };
  z.__private__.resetCustomOutputDestination = function() {
    vt = !1, mt = Ue;
  };
  var Y = z.__private__.out = function(I) {
    return I = I.toString(), Ke += I.length + 1, mt.push(I), mt;
  }, Kt = z.__private__.write = function(I) {
    return Y(arguments.length === 1 ? I.toString() : Array.prototype.join.call(arguments, " "));
  }, Rt = z.__private__.getArrayBuffer = function(I) {
    for (var K = I.length, Ee = new ArrayBuffer(K), Re = new Uint8Array(Ee); K--; ) Re[K] = I.charCodeAt(K);
    return Ee;
  }, lt = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  z.__private__.getStandardFonts = function() {
    return lt;
  };
  var xt = a.fontSize || 16;
  z.__private__.setFontSize = z.setFontSize = function(I) {
    return xt = Te === fe.ADVANCED ? I / kt : I, this;
  };
  var At, Et = z.__private__.getFontSize = z.getFontSize = function() {
    return Te === fe.COMPAT ? xt : xt * kt;
  }, jt = a.R2L || !1;
  z.__private__.setR2L = z.setR2L = function(I) {
    return jt = I, this;
  }, z.__private__.getR2L = z.getR2L = function() {
    return jt;
  };
  var ni, ii = z.__private__.setZoomMode = function(I) {
    var K = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(I)) At = I;
    else if (isNaN(I)) {
      if (K.indexOf(I) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + I + '" is not recognized.');
      At = I;
    } else At = parseInt(I, 10);
  };
  z.__private__.getZoomMode = function() {
    return At;
  };
  var yi, xi = z.__private__.setPageMode = function(I) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(I) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + I + '" is not recognized.');
    ni = I;
  };
  z.__private__.getPageMode = function() {
    return ni;
  };
  var pt = z.__private__.setLayoutMode = function(I) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(I) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + I + '" is not recognized.');
    yi = I;
  };
  z.__private__.getLayoutMode = function() {
    return yi;
  }, z.__private__.setDisplayMode = z.setDisplayMode = function(I, K, Ee) {
    return ii(I), pt(K), xi(Ee), this;
  };
  var Jt = { title: "", subject: "", author: "", keywords: "", creator: "" };
  z.__private__.getDocumentProperty = function(I) {
    if (Object.keys(Jt).indexOf(I) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return Jt[I];
  }, z.__private__.getDocumentProperties = function() {
    return Jt;
  }, z.__private__.setDocumentProperties = z.setProperties = z.setDocumentProperties = function(I) {
    for (var K in Jt) Jt.hasOwnProperty(K) && I[K] && (Jt[K] = I[K]);
    return this;
  }, z.__private__.setDocumentProperty = function(I, K) {
    if (Object.keys(Jt).indexOf(I) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return Jt[I] = K;
  };
  var ai, kt, Zi, ft, ri, Lt = {}, Si = {}, Gi = [], zt = {}, cr = {}, Ni = {}, ie = {}, ue = null, $ = 0, B = [], j = new P0(z), te = a.hotfixes || [], ge = {}, Me = {}, Fe = [], Ne = function I(K, Ee, Re, Ye, ct, It) {
    if (!(this instanceof I)) return new I(K, Ee, Re, Ye, ct, It);
    isNaN(K) && (K = 1), isNaN(Ee) && (Ee = 0), isNaN(Re) && (Re = 0), isNaN(Ye) && (Ye = 1), isNaN(ct) && (ct = 0), isNaN(It) && (It = 0), this._matrix = [K, Ee, Re, Ye, ct, It];
  };
  Object.defineProperty(Ne.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(I) {
    this._matrix[0] = I;
  } }), Object.defineProperty(Ne.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(I) {
    this._matrix[1] = I;
  } }), Object.defineProperty(Ne.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(I) {
    this._matrix[2] = I;
  } }), Object.defineProperty(Ne.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(I) {
    this._matrix[3] = I;
  } }), Object.defineProperty(Ne.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(I) {
    this._matrix[4] = I;
  } }), Object.defineProperty(Ne.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(I) {
    this._matrix[5] = I;
  } }), Object.defineProperty(Ne.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(I) {
    this._matrix[0] = I;
  } }), Object.defineProperty(Ne.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(I) {
    this._matrix[1] = I;
  } }), Object.defineProperty(Ne.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(I) {
    this._matrix[2] = I;
  } }), Object.defineProperty(Ne.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(I) {
    this._matrix[3] = I;
  } }), Object.defineProperty(Ne.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(I) {
    this._matrix[4] = I;
  } }), Object.defineProperty(Ne.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(I) {
    this._matrix[5] = I;
  } }), Object.defineProperty(Ne.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Ne.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Ne.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Ne.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), Ne.prototype.join = function(I) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(Ie).join(I);
  }, Ne.prototype.multiply = function(I) {
    var K = I.sx * this.sx + I.shy * this.shx, Ee = I.sx * this.shy + I.shy * this.sy, Re = I.shx * this.sx + I.sy * this.shx, Ye = I.shx * this.shy + I.sy * this.sy, ct = I.tx * this.sx + I.ty * this.shx + this.tx, It = I.tx * this.shy + I.ty * this.sy + this.ty;
    return new Ne(K, Ee, Re, Ye, ct, It);
  }, Ne.prototype.decompose = function() {
    var I = this.sx, K = this.shy, Ee = this.shx, Re = this.sy, Ye = this.tx, ct = this.ty, It = Math.sqrt(I * I + K * K), Ut = (I /= It) * Ee + (K /= It) * Re;
    Ee -= I * Ut, Re -= K * Ut;
    var ui = Math.sqrt(Ee * Ee + Re * Re);
    return Ut /= ui, I * (Re /= ui) < K * (Ee /= ui) && (I = -I, K = -K, Ut = -Ut, It = -It), { scale: new Ne(It, 0, 0, ui, 0, 0), translate: new Ne(1, 0, 0, 1, Ye, ct), rotate: new Ne(I, K, -K, I, 0, 0), skew: new Ne(1, 0, Ut, 1, 0, 0) };
  }, Ne.prototype.toString = function(I) {
    return this.join(" ");
  }, Ne.prototype.inversed = function() {
    var I = this.sx, K = this.shy, Ee = this.shx, Re = this.sy, Ye = this.tx, ct = this.ty, It = 1 / (I * Re - K * Ee), Ut = Re * It, ui = -K * It, bi = -Ee * It, Ti = I * It;
    return new Ne(Ut, ui, bi, Ti, -Ut * Ye - bi * ct, -ui * Ye - Ti * ct);
  }, Ne.prototype.applyToPoint = function(I) {
    var K = I.x * this.sx + I.y * this.shx + this.tx, Ee = I.x * this.shy + I.y * this.sy + this.ty;
    return new On(K, Ee);
  }, Ne.prototype.applyToRectangle = function(I) {
    var K = this.applyToPoint(I), Ee = this.applyToPoint(new On(I.x + I.w, I.y + I.h));
    return new fo(K.x, K.y, Ee.x - K.x, Ee.y - K.y);
  }, Ne.prototype.clone = function() {
    var I = this.sx, K = this.shy, Ee = this.shx, Re = this.sy, Ye = this.tx, ct = this.ty;
    return new Ne(I, K, Ee, Re, Ye, ct);
  }, z.Matrix = Ne;
  var De = z.matrixMult = function(I, K) {
    return K.multiply(I);
  }, et = new Ne(1, 0, 0, 1, 0, 0);
  z.unitMatrix = z.identityMatrix = et;
  var ut = function(I, K) {
    if (!cr[I]) {
      var Ee = (K instanceof Eu ? "Sh" : "P") + (Object.keys(zt).length + 1).toString(10);
      K.id = Ee, cr[I] = Ee, zt[Ee] = K, j.publish("addPattern", K);
    }
  };
  z.ShadingPattern = Eu, z.TilingPattern = uc, z.addShadingPattern = function(I, K) {
    return Ae("addShadingPattern()"), ut(I, K), this;
  }, z.beginTilingPattern = function(I) {
    Ae("beginTilingPattern()"), Qo(I.boundingBox[0], I.boundingBox[1], I.boundingBox[2] - I.boundingBox[0], I.boundingBox[3] - I.boundingBox[1], I.matrix);
  }, z.endTilingPattern = function(I, K) {
    Ae("endTilingPattern()"), K.stream = ot[_e].join(`
`), ut(I, K), j.publish("endTilingPattern", K), Fe.pop().restore();
  };
  var We = z.__private__.newObject = function() {
    var I = gt();
    return Mt(I, !0), I;
  }, gt = z.__private__.newObjectDeferred = function() {
    return Oe++, $e[Oe] = function() {
      return Ke;
    }, Oe;
  }, Mt = function(I, K) {
    return K = typeof K == "boolean" && K, $e[I] = Ke, K && Y(I + " 0 obj"), I;
  }, $t = z.__private__.newAdditionalObject = function() {
    var I = { objId: gt(), content: "" };
    return rt.push(I), I;
  }, Qt = gt(), ei = gt(), pi = z.__private__.decodeColorString = function(I) {
    var K = I.split(" ");
    if (K.length !== 2 || K[1] !== "g" && K[1] !== "G")
      K.length === 5 && (K[4] === "k" || K[4] === "K") && (K = [(1 - K[0]) * (1 - K[3]), (1 - K[1]) * (1 - K[3]), (1 - K[2]) * (1 - K[3]), "r"]);
    else {
      var Ee = parseFloat(K[0]);
      K = [Ee, Ee, Ee, "r"];
    }
    for (var Re = "#", Ye = 0; Ye < 3; Ye++) Re += ("0" + Math.floor(255 * parseFloat(K[Ye])).toString(16)).slice(-2);
    return Re;
  }, fi = z.__private__.encodeColorString = function(I) {
    var K;
    typeof I == "string" && (I = { ch1: I });
    var Ee = I.ch1, Re = I.ch2, Ye = I.ch3, ct = I.ch4, It = I.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof Ee == "string" && Ee.charAt(0) !== "#") {
      var Ut = new Ug(Ee);
      if (Ut.ok) Ee = Ut.toHex();
      else if (!/^\d*\.?\d*$/.test(Ee)) throw new Error('Invalid color "' + Ee + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof Ee == "string" && /^#[0-9A-Fa-f]{3}$/.test(Ee) && (Ee = "#" + Ee[1] + Ee[1] + Ee[2] + Ee[2] + Ee[3] + Ee[3]), typeof Ee == "string" && /^#[0-9A-Fa-f]{6}$/.test(Ee)) {
      var ui = parseInt(Ee.substr(1), 16);
      Ee = ui >> 16 & 255, Re = ui >> 8 & 255, Ye = 255 & ui;
    }
    if (Re === void 0 || ct === void 0 && Ee === Re && Re === Ye) if (typeof Ee == "string") K = Ee + " " + It[0];
    else switch (I.precision) {
      case 2:
        K = ve(Ee / 255) + " " + It[0];
        break;
      case 3:
      default:
        K = X(Ee / 255) + " " + It[0];
    }
    else if (ct === void 0 || ur(ct) === "object") {
      if (ct && !isNaN(ct.a) && ct.a === 0) return K = ["1.", "1.", "1.", It[1]].join(" ");
      if (typeof Ee == "string") K = [Ee, Re, Ye, It[1]].join(" ");
      else switch (I.precision) {
        case 2:
          K = [ve(Ee / 255), ve(Re / 255), ve(Ye / 255), It[1]].join(" ");
          break;
        default:
        case 3:
          K = [X(Ee / 255), X(Re / 255), X(Ye / 255), It[1]].join(" ");
      }
    } else if (typeof Ee == "string") K = [Ee, Re, Ye, ct, It[2]].join(" ");
    else switch (I.precision) {
      case 2:
        K = [ve(Ee), ve(Re), ve(Ye), ve(ct), It[2]].join(" ");
        break;
      case 3:
      default:
        K = [X(Ee), X(Re), X(Ye), X(ct), It[2]].join(" ");
    }
    return K;
  }, Wi = z.__private__.getFilters = function() {
    return g;
  }, Oi = z.__private__.putStream = function(I) {
    var K = (I = I || {}).data || "", Ee = I.filters || Wi(), Re = I.alreadyAppliedFilters || [], Ye = I.addLength1 || !1, ct = K.length, It = I.objectId, Ut = function(Xr) {
      return Xr;
    };
    if (M !== null && It === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    M !== null && (Ut = xr.encryptor(It, 0));
    var ui = {};
    Ee === !0 && (Ee = ["FlateEncode"]);
    var bi = I.additionalKeyValues || [], Ti = (ui = wi.API.processDataByFilters !== void 0 ? wi.API.processDataByFilters(K, Ee) : { data: K, reverseChain: [] }).reverseChain + (Array.isArray(Re) ? Re.join(" ") : Re.toString());
    if (ui.data.length !== 0 && (bi.push({ key: "Length", value: ui.data.length }), Ye === !0 && bi.push({ key: "Length1", value: ct })), Ti.length != 0) if (Ti.split("/").length - 1 == 1) bi.push({ key: "Filter", value: Ti });
    else {
      bi.push({ key: "Filter", value: "[" + Ti + "]" });
      for (var ki = 0; ki < bi.length; ki += 1) if (bi[ki].key === "DecodeParms") {
        for (var nr = [], Sr = 0; Sr < ui.reverseChain.split("/").length - 1; Sr += 1) nr.push("null");
        nr.push(bi[ki].value), bi[ki].value = "[" + nr.join(" ") + "]";
      }
    }
    Y("<<");
    for (var Ci = 0; Ci < bi.length; Ci++) Y("/" + bi[Ci].key + " " + bi[Ci].value);
    Y(">>"), ui.data.length !== 0 && (Y("stream"), Y(Ut(ui.data)), Y("endstream"));
  }, mi = z.__private__.putPage = function(I) {
    var K = I.number, Ee = I.data, Re = I.objId, Ye = I.contentsObjId;
    Mt(Re, !0), Y("<</Type /Page"), Y("/Parent " + I.rootDictionaryObjId + " 0 R"), Y("/Resources " + I.resourceDictionaryObjId + " 0 R"), Y("/MediaBox [" + parseFloat(Ie(I.mediaBox.bottomLeftX)) + " " + parseFloat(Ie(I.mediaBox.bottomLeftY)) + " " + Ie(I.mediaBox.topRightX) + " " + Ie(I.mediaBox.topRightY) + "]"), I.cropBox !== null && Y("/CropBox [" + Ie(I.cropBox.bottomLeftX) + " " + Ie(I.cropBox.bottomLeftY) + " " + Ie(I.cropBox.topRightX) + " " + Ie(I.cropBox.topRightY) + "]"), I.bleedBox !== null && Y("/BleedBox [" + Ie(I.bleedBox.bottomLeftX) + " " + Ie(I.bleedBox.bottomLeftY) + " " + Ie(I.bleedBox.topRightX) + " " + Ie(I.bleedBox.topRightY) + "]"), I.trimBox !== null && Y("/TrimBox [" + Ie(I.trimBox.bottomLeftX) + " " + Ie(I.trimBox.bottomLeftY) + " " + Ie(I.trimBox.topRightX) + " " + Ie(I.trimBox.topRightY) + "]"), I.artBox !== null && Y("/ArtBox [" + Ie(I.artBox.bottomLeftX) + " " + Ie(I.artBox.bottomLeftY) + " " + Ie(I.artBox.topRightX) + " " + Ie(I.artBox.topRightY) + "]"), typeof I.userUnit == "number" && I.userUnit !== 1 && Y("/UserUnit " + I.userUnit), j.publish("putPage", { objId: Re, pageContext: B[K], pageNumber: K, page: Ee }), Y("/Contents " + Ye + " 0 R"), Y(">>"), Y("endobj");
    var ct = Ee.join(`
`);
    return Te === fe.ADVANCED && (ct += `
Q`), Mt(Ye, !0), Oi({ data: ct, filters: Wi(), objectId: Ye }), Y("endobj"), Re;
  }, Bi = z.__private__.putPages = function() {
    var I, K, Ee = [];
    for (I = 1; I <= $; I++) B[I].objId = gt(), B[I].contentsObjId = gt();
    for (I = 1; I <= $; I++) Ee.push(mi({ number: I, data: ot[I], objId: B[I].objId, contentsObjId: B[I].contentsObjId, mediaBox: B[I].mediaBox, cropBox: B[I].cropBox, bleedBox: B[I].bleedBox, trimBox: B[I].trimBox, artBox: B[I].artBox, userUnit: B[I].userUnit, rootDictionaryObjId: Qt, resourceDictionaryObjId: ei }));
    Mt(Qt, !0), Y("<</Type /Pages");
    var Re = "/Kids [";
    for (K = 0; K < $; K++) Re += Ee[K] + " 0 R ";
    Y(Re + "]"), Y("/Count " + $), Y(">>"), Y("endobj"), j.publish("postPutPages");
  }, Hi = function(I) {
    j.publish("putFont", { font: I, out: Y, newObject: We, putStream: Oi }), I.isAlreadyPutted !== !0 && (I.objectNumber = We(), Y("<<"), Y("/Type /Font"), Y("/BaseFont /" + lc(I.postScriptName)), Y("/Subtype /Type1"), typeof I.encoding == "string" && Y("/Encoding /" + I.encoding), Y("/FirstChar 32"), Y("/LastChar 255"), Y(">>"), Y("endobj"));
  }, mr = function() {
    for (var I in Lt) Lt.hasOwnProperty(I) && (q === !1 || q === !0 && O.hasOwnProperty(I)) && Hi(Lt[I]);
  }, vr = function(I) {
    I.objectNumber = We();
    var K = [];
    K.push({ key: "Type", value: "/XObject" }), K.push({ key: "Subtype", value: "/Form" }), K.push({ key: "BBox", value: "[" + [Ie(I.x), Ie(I.y), Ie(I.x + I.width), Ie(I.y + I.height)].join(" ") + "]" }), K.push({ key: "Matrix", value: "[" + I.matrix.toString() + "]" });
    var Ee = I.pages[1].join(`
`);
    Oi({ data: Ee, additionalKeyValues: K, objectId: I.objectNumber }), Y("endobj");
  }, kr = function() {
    for (var I in ge) ge.hasOwnProperty(I) && vr(ge[I]);
  }, Oa = function(I, K) {
    var Ee, Re = [], Ye = 1 / (K - 1);
    for (Ee = 0; Ee < 1; Ee += Ye) Re.push(Ee);
    if (Re.push(1), I[0].offset != 0) {
      var ct = { offset: 0, color: I[0].color };
      I.unshift(ct);
    }
    if (I[I.length - 1].offset != 1) {
      var It = { offset: 1, color: I[I.length - 1].color };
      I.push(It);
    }
    for (var Ut = "", ui = 0, bi = 0; bi < Re.length; bi++) {
      for (Ee = Re[bi]; Ee > I[ui + 1].offset; ) ui++;
      var Ti = I[ui].offset, ki = (Ee - Ti) / (I[ui + 1].offset - Ti), nr = I[ui].color, Sr = I[ui + 1].color;
      Ut += Ce(Math.round((1 - ki) * nr[0] + ki * Sr[0]).toString(16)) + Ce(Math.round((1 - ki) * nr[1] + ki * Sr[1]).toString(16)) + Ce(Math.round((1 - ki) * nr[2] + ki * Sr[2]).toString(16));
    }
    return Ut.trim();
  }, ji = function(I, K) {
    K || (K = 21);
    var Ee = We(), Re = Oa(I.colors, K), Ye = [];
    Ye.push({ key: "FunctionType", value: "0" }), Ye.push({ key: "Domain", value: "[0.0 1.0]" }), Ye.push({ key: "Size", value: "[" + K + "]" }), Ye.push({ key: "BitsPerSample", value: "8" }), Ye.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Ye.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Oi({ data: Re, additionalKeyValues: Ye, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: Ee }), Y("endobj"), I.objectNumber = We(), Y("<< /ShadingType " + I.type), Y("/ColorSpace /DeviceRGB");
    var ct = "/Coords [" + Ie(parseFloat(I.coords[0])) + " " + Ie(parseFloat(I.coords[1])) + " ";
    I.type === 2 ? ct += Ie(parseFloat(I.coords[2])) + " " + Ie(parseFloat(I.coords[3])) : ct += Ie(parseFloat(I.coords[2])) + " " + Ie(parseFloat(I.coords[3])) + " " + Ie(parseFloat(I.coords[4])) + " " + Ie(parseFloat(I.coords[5])), Y(ct += "]"), I.matrix && Y("/Matrix [" + I.matrix.toString() + "]"), Y("/Function " + Ee + " 0 R"), Y("/Extend [true true]"), Y(">>"), Y("endobj");
  }, Zo = function(I, K) {
    var Ee = gt(), Re = We();
    K.push({ resourcesOid: Ee, objectOid: Re }), I.objectNumber = Re;
    var Ye = [];
    Ye.push({ key: "Type", value: "/Pattern" }), Ye.push({ key: "PatternType", value: "1" }), Ye.push({ key: "PaintType", value: "1" }), Ye.push({ key: "TilingType", value: "1" }), Ye.push({ key: "BBox", value: "[" + I.boundingBox.map(Ie).join(" ") + "]" }), Ye.push({ key: "XStep", value: Ie(I.xStep) }), Ye.push({ key: "YStep", value: Ie(I.yStep) }), Ye.push({ key: "Resources", value: Ee + " 0 R" }), I.matrix && Ye.push({ key: "Matrix", value: "[" + I.matrix.toString() + "]" }), Oi({ data: I.stream, additionalKeyValues: Ye, objectId: I.objectNumber }), Y("endobj");
  }, ss = function(I) {
    var K;
    for (K in zt) zt.hasOwnProperty(K) && (zt[K] instanceof Eu ? ji(zt[K]) : zt[K] instanceof uc && Zo(zt[K], I));
  }, Hr = function(I) {
    for (var K in I.objectNumber = We(), Y("<<"), I) switch (K) {
      case "opacity":
        Y("/ca " + ve(I[K]));
        break;
      case "stroke-opacity":
        Y("/CA " + ve(I[K]));
    }
    Y(">>"), Y("endobj");
  }, sn = function() {
    var I;
    for (I in Ni) Ni.hasOwnProperty(I) && Hr(Ni[I]);
  }, Go = function() {
    for (var I in Y("/XObject <<"), ge) ge.hasOwnProperty(I) && ge[I].objectNumber >= 0 && Y("/" + I + " " + ge[I].objectNumber + " 0 R");
    j.publish("putXobjectDict"), Y(">>");
  }, mn = function() {
    xr.oid = We(), Y("<<"), Y("/Filter /Standard"), Y("/V " + xr.v), Y("/R " + xr.r), Y("/U <" + xr.toHexString(xr.U) + ">"), Y("/O <" + xr.toHexString(xr.O) + ">"), Y("/P " + xr.P), Y(">>"), Y("endobj");
  }, Wr = function() {
    for (var I in Y("/Font <<"), Lt) Lt.hasOwnProperty(I) && (q === !1 || q === !0 && O.hasOwnProperty(I)) && Y("/" + I + " " + Lt[I].objectNumber + " 0 R");
    Y(">>");
  }, os = function() {
    if (Object.keys(zt).length > 0) {
      for (var I in Y("/Shading <<"), zt) zt.hasOwnProperty(I) && zt[I] instanceof Eu && zt[I].objectNumber >= 0 && Y("/" + I + " " + zt[I].objectNumber + " 0 R");
      j.publish("putShadingPatternDict"), Y(">>");
    }
  }, Rn = function(I) {
    if (Object.keys(zt).length > 0) {
      for (var K in Y("/Pattern <<"), zt) zt.hasOwnProperty(K) && zt[K] instanceof z.TilingPattern && zt[K].objectNumber >= 0 && zt[K].objectNumber < I && Y("/" + K + " " + zt[K].objectNumber + " 0 R");
      j.publish("putTilingPatternDict"), Y(">>");
    }
  }, br = function() {
    if (Object.keys(Ni).length > 0) {
      var I;
      for (I in Y("/ExtGState <<"), Ni) Ni.hasOwnProperty(I) && Ni[I].objectNumber >= 0 && Y("/" + I + " " + Ni[I].objectNumber + " 0 R");
      j.publish("putGStateDict"), Y(">>");
    }
  }, rr = function(I) {
    Mt(I.resourcesOid, !0), Y("<<"), Y("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), Wr(), os(), Rn(I.objectOid), br(), Go(), Y(">>"), Y("endobj");
  }, gn = function() {
    var I = [];
    mr(), sn(), kr(), ss(I), j.publish("putResources"), I.forEach(rr), rr({ resourcesOid: ei, objectOid: Number.MAX_SAFE_INTEGER }), j.publish("postPutResources");
  }, hr = function() {
    j.publish("putAdditionalObjects");
    for (var I = 0; I < rt.length; I++) {
      var K = rt[I];
      Mt(K.objId, !0), Y(K.content), Y("endobj");
    }
    j.publish("postPutAdditionalObjects");
  }, ks = function(I) {
    Si[I.fontName] = Si[I.fontName] || {}, Si[I.fontName][I.fontStyle] = I.id;
  }, on = function(I, K, Ee, Re, Ye) {
    var ct = { id: "F" + (Object.keys(Lt).length + 1).toString(10), postScriptName: I, fontName: K, fontStyle: Ee, encoding: Re, isStandardFont: Ye || !1, metadata: {} };
    return j.publish("addFont", { font: ct, instance: this }), Lt[ct.id] = ct, ks(ct), ct.id;
  }, Ho = function(I) {
    for (var K = 0, Ee = lt.length; K < Ee; K++) {
      var Re = on.call(this, I[K][0], I[K][1], I[K][2], lt[K][3], !0);
      q === !1 && (O[Re] = !0);
      var Ye = I[K][0].split("-");
      ks({ id: Re, fontName: Ye[0], fontStyle: Ye[1] || "" });
    }
    j.publish("addFonts", { fonts: Lt, dictionary: Si });
  }, Ar = function(I) {
    return I.foo = function() {
      try {
        return I.apply(this, arguments);
      } catch (Re) {
        var K = Re.stack || "";
        ~K.indexOf(" at ") && (K = K.split(" at ")[1]);
        var Ee = "Error in function " + K.split(`
`)[0].split("<")[0] + ": " + Re.message;
        if (!Ai.console) throw new Error(Ee);
        Ai.console.error(Ee, Re), Ai.alert && alert(Ee);
      }
    }, I.foo.bar = I, I.foo;
  }, Qs = function(I, K) {
    var Ee, Re, Ye, ct, It, Ut, ui, bi, Ti;
    if (Ye = (K = K || {}).sourceEncoding || "Unicode", It = K.outputEncoding, (K.autoencode || It) && Lt[ai].metadata && Lt[ai].metadata[Ye] && Lt[ai].metadata[Ye].encoding && (ct = Lt[ai].metadata[Ye].encoding, !It && Lt[ai].encoding && (It = Lt[ai].encoding), !It && ct.codePages && (It = ct.codePages[0]), typeof It == "string" && (It = ct[It]), It)) {
      for (ui = !1, Ut = [], Ee = 0, Re = I.length; Ee < Re; Ee++) (bi = It[I.charCodeAt(Ee)]) ? Ut.push(String.fromCharCode(bi)) : Ut.push(I[Ee]), Ut[Ee].charCodeAt(0) >> 8 && (ui = !0);
      I = Ut.join("");
    }
    for (Ee = I.length; ui === void 0 && Ee !== 0; ) I.charCodeAt(Ee - 1) >> 8 && (ui = !0), Ee--;
    if (!ui) return I;
    for (Ut = K.noBOM ? [] : [254, 255], Ee = 0, Re = I.length; Ee < Re; Ee++) {
      if ((Ti = (bi = I.charCodeAt(Ee)) >> 8) >> 8) throw new Error("Character at position " + Ee + " of string '" + I + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      Ut.push(Ti), Ut.push(bi - (Ti << 8));
    }
    return String.fromCharCode.apply(void 0, Ut);
  }, Or = z.__private__.pdfEscape = z.pdfEscape = function(I, K) {
    return Qs(I, K).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, na = z.__private__.beginPage = function(I) {
    ot[++$] = [], B[$] = { objId: 0, contentsObjId: 0, userUnit: Number(s), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(I[0]), topRightY: Number(I[1]) } }, eo($), it(ot[_e]);
  }, aa = function(I, K) {
    var Ee, Re, Ye;
    switch (l = K || l, typeof I == "string" && (Ee = ee(I.toLowerCase()), Array.isArray(Ee) && (Re = Ee[0], Ye = Ee[1])), Array.isArray(I) && (Re = I[0] * kt, Ye = I[1] * kt), isNaN(Re) && (Re = w[0], Ye = w[1]), (Re > 14400 || Ye > 14400) && (yr.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), Re = Math.min(14400, Re), Ye = Math.min(14400, Ye)), w = [Re, Ye], l.substr(0, 1)) {
      case "l":
        Ye > Re && (w = [Ye, Re]);
        break;
      case "p":
        Re > Ye && (w = [Ye, Re]);
    }
    na(w), Cl(Ns), Y(ua), ho !== 0 && Y(ho + " J"), po !== 0 && Y(po + " j"), j.publish("addPage", { pageNumber: $ });
  }, Ri = function(I) {
    I > 0 && I <= $ && (ot.splice(I, 1), B.splice(I, 1), $--, _e > $ && (_e = $), this.setPage(_e));
  }, eo = function(I) {
    I > 0 && I <= $ && (_e = I);
  }, Wo = z.__private__.getNumberOfPages = z.getNumberOfPages = function() {
    return ot.length - 1;
  }, ja = function(I, K, Ee) {
    var Re, Ye = void 0;
    return Ee = Ee || {}, I = I !== void 0 ? I : Lt[ai].fontName, K = K !== void 0 ? K : Lt[ai].fontStyle, Re = I.toLowerCase(), Si[Re] !== void 0 && Si[Re][K] !== void 0 ? Ye = Si[Re][K] : Si[I] !== void 0 && Si[I][K] !== void 0 ? Ye = Si[I][K] : Ee.disableWarning === !1 && yr.warn("Unable to look up font label for font '" + I + "', '" + K + "'. Refer to getFontList() for available fonts."), Ye || Ee.noFallback || (Ye = Si.times[K]) == null && (Ye = Si.times.normal), Ye;
  }, Xo = z.__private__.putInfo = function() {
    var I = We(), K = function(Re) {
      return Re;
    };
    for (var Ee in M !== null && (K = xr.encryptor(I, 0)), Y("<<"), Y("/Producer (" + Or(K("jsPDF " + wi.version)) + ")"), Jt) Jt.hasOwnProperty(Ee) && Jt[Ee] && Y("/" + Ee.substr(0, 1).toUpperCase() + Ee.substr(1) + " (" + Or(K(Jt[Ee])) + ")");
    Y("/CreationDate (" + Or(K(Ve)) + ")"), Y(">>"), Y("endobj");
  }, ls = z.__private__.putCatalog = function(I) {
    var K = (I = I || {}).rootDictionaryObjId || Qt;
    switch (We(), Y("<<"), Y("/Type /Catalog"), Y("/Pages " + K + " 0 R"), At || (At = "fullwidth"), At) {
      case "fullwidth":
        Y("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        Y("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        Y("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        Y("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var Ee = "" + At;
        Ee.substr(Ee.length - 1) === "%" && (At = parseInt(At) / 100), typeof At == "number" && Y("/OpenAction [3 0 R /XYZ null null " + ve(At) + "]");
    }
    switch (yi || (yi = "continuous"), yi) {
      case "continuous":
        Y("/PageLayout /OneColumn");
        break;
      case "single":
        Y("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        Y("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        Y("/PageLayout /TwoColumnRight");
    }
    ni && Y("/PageMode /" + ni), j.publish("putCatalog"), Y(">>"), Y("endobj");
  }, Ps = z.__private__.putTrailer = function() {
    Y("trailer"), Y("<<"), Y("/Size " + (Oe + 1)), Y("/Root " + Oe + " 0 R"), Y("/Info " + (Oe - 1) + " 0 R"), M !== null && Y("/Encrypt " + xr.oid + " 0 R"), Y("/ID [ <" + He + "> <" + He + "> ]"), Y(">>");
  }, to = z.__private__.putHeader = function() {
    Y("%PDF-" + pe), Y("%");
  }, us = z.__private__.putXRef = function() {
    var I = "0000000000";
    Y("xref"), Y("0 " + (Oe + 1)), Y("0000000000 65535 f ");
    for (var K = 1; K <= Oe; K++)
      typeof $e[K] == "function" ? Y((I + $e[K]()).slice(-10) + " 00000 n ") : $e[K] !== void 0 ? Y((I + $e[K]).slice(-10) + " 00000 n ") : Y("0000000000 00000 n ");
  }, xa = z.__private__.buildDocument = function() {
    Pt(), it(Ue), j.publish("buildDocument"), to(), Bi(), hr(), gn(), M !== null && mn(), Xo(), ls();
    var I = Ke;
    return us(), Ps(), Y("startxref"), Y("" + I), Y("%%EOF"), it(ot[_e]), Ue.join(`
`);
  }, io = z.__private__.getBlob = function(I) {
    return new Blob([Rt(I)], { type: "application/pdf" });
  }, Ls = z.output = z.__private__.output = Ar(function(I, K) {
    switch (typeof (K = K || {}) == "string" ? K = { filename: K } : K.filename = K.filename || "generated.pdf", I) {
      case void 0:
        return xa();
      case "save":
        z.save(K.filename);
        break;
      case "arraybuffer":
        return Rt(xa());
      case "blob":
        return io(xa());
      case "bloburi":
      case "bloburl":
        if (Ai.URL !== void 0 && typeof Ai.URL.createObjectURL == "function") return Ai.URL && Ai.URL.createObjectURL(io(xa())) || void 0;
        yr.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var Ee = "", Re = xa();
        try {
          Ee = $p(Re);
        } catch {
          Ee = $p(unescape(encodeURIComponent(Re)));
        }
        return "data:application/pdf;filename=" + K.filename + ";base64," + Ee;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(Ai) === "[object Window]") {
          var Ye = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", ct = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          K.pdfObjectUrl && (Ye = K.pdfObjectUrl, ct = "");
          var It = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Ye + '"' + ct + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(K) + ");<\/script></body></html>", Ut = Ai.open();
          return Ut !== null && Ut.document.write(It), Ut;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(Ai) === "[object Window]") {
          var ui = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (K.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + K.filename + '" width="500px" height="400px" /></body></html>', bi = Ai.open();
          if (bi !== null) {
            bi.document.write(ui);
            var Ti = this;
            bi.document.documentElement.querySelector("#pdfViewer").onload = function() {
              bi.document.title = K.filename, bi.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Ti.output("bloburl"));
            };
          }
          return bi;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(Ai) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var ki = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", K) + '"></iframe></body></html>', nr = Ai.open();
        if (nr !== null && (nr.document.write(ki), nr.document.title = K.filename), nr || typeof safari > "u") return nr;
        break;
      case "datauri":
      case "dataurl":
        return Ai.document.location.href = this.output("datauristring", K);
      default:
        return null;
    }
  }), El = function(I) {
    return Array.isArray(te) === !0 && te.indexOf(I) > -1;
  };
  switch (m) {
    case "pt":
      kt = 1;
      break;
    case "mm":
      kt = 72 / 25.4;
      break;
    case "cm":
      kt = 72 / 2.54;
      break;
    case "in":
      kt = 72;
      break;
    case "px":
      kt = El("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      kt = 12;
      break;
    case "ex":
      kt = 6;
      break;
    default:
      if (typeof m != "number") throw new Error("Invalid unit: " + m);
      kt = m;
  }
  var xr = null;
  nt(), je();
  var Ms = function(I) {
    return M !== null ? xr.encryptor(I, 0) : function(K) {
      return K;
    };
  }, jr = z.__private__.getPageInfo = z.getPageInfo = function(I) {
    if (isNaN(I) || I % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: B[I].objId, pageNumber: I, pageContext: B[I] };
  }, si = z.__private__.getPageInfoByObjId = function(I) {
    if (isNaN(I) || I % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var K in B) if (B[K].objId === I) break;
    return jr(K);
  }, ro = z.__private__.getCurrentPageInfo = z.getCurrentPageInfo = function() {
    return { objId: B[_e].objId, pageNumber: _e, pageContext: B[_e] };
  };
  z.addPage = function() {
    return aa.apply(this, arguments), this;
  }, z.setPage = function() {
    return eo.apply(this, arguments), it.call(this, ot[_e]), this;
  }, z.insertPage = function(I) {
    return this.addPage(), this.movePage(_e, I), this;
  }, z.movePage = function(I, K) {
    var Ee, Re;
    if (I > K) {
      Ee = ot[I], Re = B[I];
      for (var Ye = I; Ye > K; Ye--) ot[Ye] = ot[Ye - 1], B[Ye] = B[Ye - 1];
      ot[K] = Ee, B[K] = Re, this.setPage(K);
    } else if (I < K) {
      Ee = ot[I], Re = B[I];
      for (var ct = I; ct < K; ct++) ot[ct] = ot[ct + 1], B[ct] = B[ct + 1];
      ot[K] = Ee, B[K] = Re, this.setPage(K);
    }
    return this;
  }, z.deletePage = function() {
    return Ri.apply(this, arguments), this;
  }, z.__private__.text = z.text = function(I, K, Ee, Re, Ye) {
    var ct, It, Ut, ui, bi, Ti, ki, nr, Sr, Ci = (Re = Re || {}).scope || this;
    if (typeof I == "number" && typeof K == "number" && (typeof Ee == "string" || Array.isArray(Ee))) {
      var Xr = Ee;
      Ee = K, K = I, I = Xr;
    }
    if (arguments[3] instanceof Ne ? (Ae("The transform parameter of text() with a Matrix value"), Sr = Ye) : (Ut = arguments[4], ui = arguments[5], ur(ki = arguments[3]) === "object" && ki !== null || (typeof Ut == "string" && (ui = Ut, Ut = null), typeof ki == "string" && (ui = ki, ki = null), typeof ki == "number" && (Ut = ki, ki = null), Re = { flags: ki, angle: Ut, align: ui })), isNaN(K) || isNaN(Ee) || I == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (I.length === 0) return Ci;
    var oi = "", _n = !1, Mi = typeof Re.lineHeightFactor == "number" ? Re.lineHeightFactor : Ua, zi = Ci.internal.scaleFactor;
    function Ea(tr) {
      return tr = tr.split("	").join(Array(Re.TabLen || 9).join(" ")), Or(tr, ki);
    }
    function Va(tr) {
      for (var Yi, dr = tr.concat(), Er = [], Dn = dr.length; Dn--; ) typeof (Yi = dr.shift()) == "string" ? Er.push(Yi) : Array.isArray(tr) && (Yi.length === 1 || Yi[1] === void 0 && Yi[2] === void 0) ? Er.push(Yi[0]) : Er.push([Yi[0], Yi[1], Yi[2]]);
      return Er;
    }
    function $a(tr, Yi) {
      var dr;
      if (typeof tr == "string") dr = Yi(tr)[0];
      else if (Array.isArray(tr)) {
        for (var Er, Dn, Zn = tr.concat(), Tr = [], Ia = Zn.length; Ia--; ) typeof (Er = Zn.shift()) == "string" ? Tr.push(Yi(Er)[0]) : Array.isArray(Er) && typeof Er[0] == "string" && (Dn = Yi(Er[0], Er[1], Er[2]), Tr.push([Dn[0], Dn[1], Dn[2]]));
        dr = Tr;
      }
      return dr;
    }
    var ds = !1, ca = !0;
    if (typeof I == "string") ds = !0;
    else if (Array.isArray(I)) {
      var Ta = I.concat();
      It = [];
      for (var qr, Yr = Ta.length; Yr--; ) (typeof (qr = Ta.shift()) != "string" || Array.isArray(qr) && typeof qr[0] != "string") && (ca = !1);
      ds = ca;
    }
    if (ds === !1) throw new Error('Type of text must be string or Array. "' + I + '" is not recognized.');
    typeof I == "string" && (I = I.match(/[\r?\n]/) ? I.split(/\r\n|\r|\n/g) : [I]);
    var ps = xt / Ci.internal.scaleFactor, fs = ps * (Mi - 1);
    switch (Re.baseline) {
      case "bottom":
        Ee -= fs;
        break;
      case "top":
        Ee += ps - fs;
        break;
      case "hanging":
        Ee += ps - 2 * fs;
        break;
      case "middle":
        Ee += ps / 2 - fs;
    }
    if ((Ti = Re.maxWidth || 0) > 0 && (typeof I == "string" ? I = Ci.splitTextToSize(I, Ti) : Object.prototype.toString.call(I) === "[object Array]" && (I = I.reduce(function(tr, Yi) {
      return tr.concat(Ci.splitTextToSize(Yi, Ti));
    }, []))), ct = { text: I, x: K, y: Ee, options: Re, mutex: { pdfEscape: Or, activeFontKey: ai, fonts: Lt, activeFontSize: xt } }, j.publish("preProcessText", ct), I = ct.text, Ut = (Re = ct.options).angle, !(Sr instanceof Ne) && Ut && typeof Ut == "number") {
      Ut *= Math.PI / 180, Re.rotationDirection === 0 && (Ut = -Ut), Te === fe.ADVANCED && (Ut = -Ut);
      var jn = Math.cos(Ut), Za = Math.sin(Ut);
      Sr = new Ne(jn, Za, -Za, jn, 0, 0);
    } else Ut && Ut instanceof Ne && (Sr = Ut);
    Te !== fe.ADVANCED || Sr || (Sr = et), (bi = Re.charSpace || cs) !== void 0 && (oi += Ie(re(bi)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (nr = Re.horizontalScale) !== void 0 && (oi += Ie(100 * nr) + ` Tz
`), Re.lang;
    var zr = -1, ms = Re.renderingMode !== void 0 ? Re.renderingMode : Re.stroke, Ga = Ci.internal.getCurrentPageInfo().pageContext;
    switch (ms) {
      case 0:
      case !1:
      case "fill":
        zr = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        zr = 1;
        break;
      case 2:
      case "fillThenStroke":
        zr = 2;
        break;
      case 3:
      case "invisible":
        zr = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        zr = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        zr = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        zr = 6;
        break;
      case 7:
      case "addToPathForClipping":
        zr = 7;
    }
    var Bs = Ga.usedRenderingMode !== void 0 ? Ga.usedRenderingMode : -1;
    zr !== -1 ? oi += zr + ` Tr
` : Bs !== -1 && (oi += `0 Tr
`), zr !== -1 && (Ga.usedRenderingMode = zr), ui = Re.align || "left";
    var Jr, Ca = xt * Mi, kl = Ci.internal.pageSize.getWidth(), tl = Lt[ai];
    bi = Re.charSpace || cs, Ti = Re.maxWidth || 0, ki = Object.assign({ autoencode: !0, noBOM: !0 }, Re.flags);
    var Di = [];
    if (Object.prototype.toString.call(I) === "[object Array]") {
      var un;
      It = Va(I), ui !== "left" && (Jr = It.map(function(tr) {
        return Ci.getStringUnitWidth(tr, { font: tl, charSpace: bi, fontSize: xt, doKerning: !1 }) * xt / zi;
      }));
      var ha, Ha = 0;
      if (ui === "right") {
        K -= Jr[0], I = [], Yr = It.length;
        for (var cn = 0; cn < Yr; cn++) cn === 0 ? (ha = Ii(K), un = la(Ee)) : (ha = re(Ha - Jr[cn]), un = -Ca), I.push([It[cn], ha, un]), Ha = Jr[cn];
      } else if (ui === "center") {
        K -= Jr[0] / 2, I = [], Yr = It.length;
        for (var Da = 0; Da < Yr; Da++) Da === 0 ? (ha = Ii(K), un = la(Ee)) : (ha = re((Ha - Jr[Da]) / 2), un = -Ca), I.push([It[Da], ha, un]), Ha = Jr[Da];
      } else if (ui === "left") {
        I = [], Yr = It.length;
        for (var Wa = 0; Wa < Yr; Wa++) I.push(It[Wa]);
      } else {
        if (ui !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        I = [], Yr = It.length, Ti = Ti !== 0 ? Ti : kl;
        for (var qn = 0; qn < Yr; qn++) un = qn === 0 ? la(Ee) : -Ca, ha = qn === 0 ? Ii(K) : 0, qn < Yr - 1 ? Di.push(Ie(re((Ti - Jr[qn]) / (It[qn].split(" ").length - 1)))) : Di.push(0), I.push([It[qn], ha, un]);
      }
    }
    var Rs = typeof Re.R2L == "boolean" ? Re.R2L : jt;
    Rs === !0 && (I = $a(I, function(tr, Yi, dr) {
      return [tr.split("").reverse().join(""), Yi, dr];
    })), ct = { text: I, x: K, y: Ee, options: Re, mutex: { pdfEscape: Or, activeFontKey: ai, fonts: Lt, activeFontSize: xt } }, j.publish("postProcessText", ct), I = ct.text, _n = ct.mutex.isHex || !1;
    var gs = Lt[ai].encoding;
    gs !== "WinAnsiEncoding" && gs !== "StandardEncoding" || (I = $a(I, function(tr, Yi, dr) {
      return [Ea(tr), Yi, dr];
    })), It = Va(I), I = [];
    for (var da, Kr, yn, Un = 0, _s = 1, Vn = Array.isArray(It[0]) ? _s : Un, $n = "", ys = function(tr, Yi, dr) {
      var Er = "";
      return dr instanceof Ne ? (dr = typeof Re.angle == "number" ? De(dr, new Ne(1, 0, 0, 1, tr, Yi)) : De(new Ne(1, 0, 0, 1, tr, Yi), dr), Te === fe.ADVANCED && (dr = De(new Ne(1, 0, 0, -1, 0, 0), dr)), Er = dr.join(" ") + ` Tm
`) : Er = Ie(tr) + " " + Ie(Yi) + ` Td
`, Er;
    }, hn = 0; hn < It.length; hn++) {
      switch ($n = "", Vn) {
        case _s:
          yn = (_n ? "<" : "(") + It[hn][0] + (_n ? ">" : ")"), da = parseFloat(It[hn][1]), Kr = parseFloat(It[hn][2]);
          break;
        case Un:
          yn = (_n ? "<" : "(") + It[hn] + (_n ? ">" : ")"), da = Ii(K), Kr = la(Ee);
      }
      Di !== void 0 && Di[hn] !== void 0 && ($n = Di[hn] + ` Tw
`), hn === 0 ? I.push($n + ys(da, Kr, Sr) + yn) : Vn === Un ? I.push($n + yn) : Vn === _s && I.push($n + ys(da, Kr, Sr) + yn);
    }
    I = Vn === Un ? I.join(` Tj
T* `) : I.join(` Tj
`), I += ` Tj
`;
    var pa = `BT
/`;
    return pa += ai + " " + xt + ` Tf
`, pa += Ie(xt * Mi) + ` TL
`, pa += zs + `
`, pa += oi, pa += I, Y(pa += "ET"), O[ai] = !0, Ci;
  };
  var no = z.__private__.clip = z.clip = function(I) {
    return Y(I === "evenodd" ? "W*" : "W"), this;
  };
  z.clipEvenOdd = function() {
    return no("evenodd");
  }, z.__private__.discardPath = z.discardPath = function() {
    return Y("n"), this;
  };
  var Tn = z.__private__.isValidStyle = function(I) {
    var K = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(I) !== -1 && (K = !0), K;
  };
  z.__private__.setDefaultPathOperation = z.setDefaultPathOperation = function(I) {
    return Tn(I) && (k = I), this;
  };
  var Yo = z.__private__.getStyle = z.getStyle = function(I) {
    var K = k;
    switch (I) {
      case "D":
      case "S":
        K = "S";
        break;
      case "F":
        K = "f";
        break;
      case "FD":
      case "DF":
        K = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        K = I;
    }
    return K;
  }, qa = z.close = function() {
    return Y("h"), this;
  };
  z.stroke = function() {
    return Y("S"), this;
  }, z.fill = function(I) {
    return ao("f", I), this;
  }, z.fillEvenOdd = function(I) {
    return ao("f*", I), this;
  }, z.fillStroke = function(I) {
    return ao("B", I), this;
  }, z.fillStrokeEvenOdd = function(I) {
    return ao("B*", I), this;
  };
  var ao = function(I, K) {
    ur(K) === "object" ? tu(K, I) : Y(I);
  }, so = function(I) {
    I === null || Te === fe.ADVANCED && I === void 0 || (I = Yo(I), Y(I));
  };
  function Tl(I, K, Ee, Re, Ye) {
    var ct = new uc(K || this.boundingBox, Ee || this.xStep, Re || this.yStep, this.gState, Ye || this.matrix);
    ct.stream = this.stream;
    var It = I + "$$" + this.cloneIndex++ + "$$";
    return ut(It, ct), ct;
  }
  var tu = function(I, K) {
    var Ee = cr[I.key], Re = zt[Ee];
    if (Re instanceof Eu) Y("q"), Y(iu(K)), Re.gState && z.setGState(Re.gState), Y(I.matrix.toString() + " cm"), Y("/" + Ee + " sh"), Y("Q");
    else if (Re instanceof uc) {
      var Ye = new Ne(1, 0, 0, -1, 0, hs());
      I.matrix && (Ye = Ye.multiply(I.matrix || et), Ee = Tl.call(Re, I.key, I.boundingBox, I.xStep, I.yStep, Ye).id), Y("q"), Y("/Pattern cs"), Y("/" + Ee + " scn"), Re.gState && z.setGState(Re.gState), Y(K), Y("Q");
    }
  }, iu = function(I) {
    switch (I) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, oo = z.moveTo = function(I, K) {
    return Y(Ie(re(I)) + " " + Ie(ye(K)) + " m"), this;
  }, sa = z.lineTo = function(I, K) {
    return Y(Ie(re(I)) + " " + Ie(ye(K)) + " l"), this;
  }, wa = z.curveTo = function(I, K, Ee, Re, Ye, ct) {
    return Y([Ie(re(I)), Ie(ye(K)), Ie(re(Ee)), Ie(ye(Re)), Ie(re(Ye)), Ie(ye(ct)), "c"].join(" ")), this;
  };
  z.__private__.line = z.line = function(I, K, Ee, Re, Ye) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || isNaN(Re) || !Tn(Ye)) throw new Error("Invalid arguments passed to jsPDF.line");
    return Te === fe.COMPAT ? this.lines([[Ee - I, Re - K]], I, K, [1, 1], Ye || "S") : this.lines([[Ee - I, Re - K]], I, K, [1, 1]).stroke();
  }, z.__private__.lines = z.lines = function(I, K, Ee, Re, Ye, ct) {
    var It, Ut, ui, bi, Ti, ki, nr, Sr, Ci, Xr, oi, _n;
    if (typeof I == "number" && (_n = Ee, Ee = K, K = I, I = _n), Re = Re || [1, 1], ct = ct || !1, isNaN(K) || isNaN(Ee) || !Array.isArray(I) || !Array.isArray(Re) || !Tn(Ye) || typeof ct != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (oo(K, Ee), It = Re[0], Ut = Re[1], bi = I.length, Xr = K, oi = Ee, ui = 0; ui < bi; ui++) (Ti = I[ui]).length === 2 ? (Xr = Ti[0] * It + Xr, oi = Ti[1] * Ut + oi, sa(Xr, oi)) : (ki = Ti[0] * It + Xr, nr = Ti[1] * Ut + oi, Sr = Ti[2] * It + Xr, Ci = Ti[3] * Ut + oi, Xr = Ti[4] * It + Xr, oi = Ti[5] * Ut + oi, wa(ki, nr, Sr, Ci, Xr, oi));
    return ct && qa(), so(Ye), this;
  }, z.path = function(I) {
    for (var K = 0; K < I.length; K++) {
      var Ee = I[K], Re = Ee.c;
      switch (Ee.op) {
        case "m":
          oo(Re[0], Re[1]);
          break;
        case "l":
          sa(Re[0], Re[1]);
          break;
        case "c":
          wa.apply(this, Re);
          break;
        case "h":
          qa();
      }
    }
    return this;
  }, z.__private__.rect = z.rect = function(I, K, Ee, Re, Ye) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || isNaN(Re) || !Tn(Ye)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return Te === fe.COMPAT && (Re = -Re), Y([Ie(re(I)), Ie(ye(K)), Ie(re(Ee)), Ie(re(Re)), "re"].join(" ")), so(Ye), this;
  }, z.__private__.triangle = z.triangle = function(I, K, Ee, Re, Ye, ct, It) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || isNaN(Re) || isNaN(Ye) || isNaN(ct) || !Tn(It)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[Ee - I, Re - K], [Ye - Ee, ct - Re], [I - Ye, K - ct]], I, K, [1, 1], It, !0), this;
  }, z.__private__.roundedRect = z.roundedRect = function(I, K, Ee, Re, Ye, ct, It) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || isNaN(Re) || isNaN(Ye) || isNaN(ct) || !Tn(It)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var Ut = 4 / 3 * (Math.SQRT2 - 1);
    return Ye = Math.min(Ye, 0.5 * Ee), ct = Math.min(ct, 0.5 * Re), this.lines([[Ee - 2 * Ye, 0], [Ye * Ut, 0, Ye, ct - ct * Ut, Ye, ct], [0, Re - 2 * ct], [0, ct * Ut, -Ye * Ut, ct, -Ye, ct], [2 * Ye - Ee, 0], [-Ye * Ut, 0, -Ye, -ct * Ut, -Ye, -ct], [0, 2 * ct - Re], [0, -ct * Ut, Ye * Ut, -ct, Ye, -ct]], I + Ye, K, [1, 1], It, !0), this;
  }, z.__private__.ellipse = z.ellipse = function(I, K, Ee, Re, Ye) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || isNaN(Re) || !Tn(Ye)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var ct = 4 / 3 * (Math.SQRT2 - 1) * Ee, It = 4 / 3 * (Math.SQRT2 - 1) * Re;
    return oo(I + Ee, K), wa(I + Ee, K - It, I + ct, K - Re, I, K - Re), wa(I - ct, K - Re, I - Ee, K - It, I - Ee, K), wa(I - Ee, K + It, I - ct, K + Re, I, K + Re), wa(I + ct, K + Re, I + Ee, K + It, I + Ee, K), so(Ye), this;
  }, z.__private__.circle = z.circle = function(I, K, Ee, Re) {
    if (isNaN(I) || isNaN(K) || isNaN(Ee) || !Tn(Re)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(I, K, Ee, Ee, Re);
  }, z.setFont = function(I, K, Ee) {
    return Ee && (K = at(K, Ee)), ai = ja(I, K, { disableWarning: !1 }), this;
  };
  var lo = z.__private__.getFont = z.getFont = function() {
    return Lt[ja.apply(z, arguments)];
  };
  z.__private__.getFontList = z.getFontList = function() {
    var I, K, Ee = {};
    for (I in Si) if (Si.hasOwnProperty(I)) for (K in Ee[I] = [], Si[I]) Si[I].hasOwnProperty(K) && Ee[I].push(K);
    return Ee;
  }, z.addFont = function(I, K, Ee, Re, Ye) {
    var ct = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && ct.indexOf(arguments[3]) !== -1 ? Ye = arguments[3] : arguments[3] && ct.indexOf(arguments[3]) == -1 && (Ee = at(Ee, Re)), Ye = Ye || "Identity-H", on.call(this, I, K, Ee, Ye);
  };
  var Ua, Ns = a.lineWidth || 0.200025, ln = z.__private__.getLineWidth = z.getLineWidth = function() {
    return Ns;
  }, Cl = z.__private__.setLineWidth = z.setLineWidth = function(I) {
    return Ns = I, Y(Ie(re(I)) + " w"), this;
  };
  z.__private__.setLineDash = wi.API.setLineDash = wi.API.setLineDashPattern = function(I, K) {
    if (I = I || [], K = K || 0, isNaN(K) || !Array.isArray(I)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return I = I.map(function(Ee) {
      return Ie(re(Ee));
    }).join(" "), K = Ie(re(K)), Y("[" + I + "] " + K + " d"), this;
  };
  var uo = z.__private__.getLineHeight = z.getLineHeight = function() {
    return xt * Ua;
  };
  z.__private__.getLineHeight = z.getLineHeight = function() {
    return xt * Ua;
  };
  var Aa = z.__private__.setLineHeightFactor = z.setLineHeightFactor = function(I) {
    return typeof (I = I || 1.15) == "number" && (Ua = I), this;
  }, oa = z.__private__.getLineHeightFactor = z.getLineHeightFactor = function() {
    return Ua;
  };
  Aa(a.lineHeight);
  var Ii = z.__private__.getHorizontalCoordinate = function(I) {
    return re(I);
  }, la = z.__private__.getVerticalCoordinate = function(I) {
    return Te === fe.ADVANCED ? I : B[_e].mediaBox.topRightY - B[_e].mediaBox.bottomLeftY - re(I);
  }, ru = z.__private__.getHorizontalCoordinateString = z.getHorizontalCoordinateString = function(I) {
    return Ie(Ii(I));
  }, Cn = z.__private__.getVerticalCoordinateString = z.getVerticalCoordinateString = function(I) {
    return Ie(la(I));
  }, ua = a.strokeColor || "0 G";
  z.__private__.getStrokeColor = z.getDrawColor = function() {
    return pi(ua);
  }, z.__private__.setStrokeColor = z.setDrawColor = function(I, K, Ee, Re) {
    return ua = fi({ ch1: I, ch2: K, ch3: Ee, ch4: Re, pdfColorType: "draw", precision: 2 }), Y(ua), this;
  };
  var co = a.fillColor || "0 g";
  z.__private__.getFillColor = z.getFillColor = function() {
    return pi(co);
  }, z.__private__.setFillColor = z.setFillColor = function(I, K, Ee, Re) {
    return co = fi({ ch1: I, ch2: K, ch3: Ee, ch4: Re, pdfColorType: "fill", precision: 2 }), Y(co), this;
  };
  var zs = a.textColor || "0 g", Dl = z.__private__.getTextColor = z.getTextColor = function() {
    return pi(zs);
  };
  z.__private__.setTextColor = z.setTextColor = function(I, K, Ee, Re) {
    return zs = fi({ ch1: I, ch2: K, ch3: Ee, ch4: Re, pdfColorType: "text", precision: 3 }), this;
  };
  var cs = a.charSpace, Il = z.__private__.getCharSpace = z.getCharSpace = function() {
    return parseFloat(cs || 0);
  };
  z.__private__.setCharSpace = z.setCharSpace = function(I) {
    if (isNaN(I)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return cs = I, this;
  };
  var ho = 0;
  z.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, z.__private__.setLineCap = z.setLineCap = function(I) {
    var K = z.CapJoinStyles[I];
    if (K === void 0) throw new Error("Line cap style of '" + I + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return ho = K, Y(K + " J"), this;
  };
  var po = 0;
  z.__private__.setLineJoin = z.setLineJoin = function(I) {
    var K = z.CapJoinStyles[I];
    if (K === void 0) throw new Error("Line join style of '" + I + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return po = K, Y(K + " j"), this;
  }, z.__private__.setLineMiterLimit = z.__private__.setMiterLimit = z.setLineMiterLimit = z.setMiterLimit = function(I) {
    if (I = I || 0, isNaN(I)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return Y(Ie(re(I)) + " M"), this;
  }, z.GState = sd, z.setGState = function(I) {
    (I = typeof I == "string" ? Ni[ie[I]] : Jo(null, I)).equals(ue) || (Y("/" + I.id + " gs"), ue = I);
  };
  var Jo = function(I, K) {
    if (!I || !ie[I]) {
      var Ee = !1;
      for (var Re in Ni) if (Ni.hasOwnProperty(Re) && Ni[Re].equals(K)) {
        Ee = !0;
        break;
      }
      if (Ee) K = Ni[Re];
      else {
        var Ye = "GS" + (Object.keys(Ni).length + 1).toString(10);
        Ni[Ye] = K, K.id = Ye;
      }
      return I && (ie[I] = K.id), j.publish("addGState", K), K;
    }
  };
  z.addGState = function(I, K) {
    return Jo(I, K), this;
  }, z.saveGraphicsState = function() {
    return Y("q"), Gi.push({ key: ai, size: xt, color: zs }), this;
  }, z.restoreGraphicsState = function() {
    Y("Q");
    var I = Gi.pop();
    return ai = I.key, xt = I.size, zs = I.color, ue = null, this;
  }, z.setCurrentTransformationMatrix = function(I) {
    return Y(I.toString() + " cm"), this;
  }, z.comment = function(I) {
    return Y("#" + I), this;
  };
  var On = function(I, K) {
    var Ee = I || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return Ee;
    }, set: function(ct) {
      isNaN(ct) || (Ee = parseFloat(ct));
    } });
    var Re = K || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return Re;
    }, set: function(ct) {
      isNaN(ct) || (Re = parseFloat(ct));
    } });
    var Ye = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Ye;
    }, set: function(ct) {
      Ye = ct.toString();
    } }), this;
  }, fo = function(I, K, Ee, Re) {
    On.call(this, I, K), this.type = "rect";
    var Ye = Ee || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Ye;
    }, set: function(It) {
      isNaN(It) || (Ye = parseFloat(It));
    } });
    var ct = Re || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return ct;
    }, set: function(It) {
      isNaN(It) || (ct = parseFloat(It));
    } }), this;
  }, Ko = function() {
    this.page = $, this.currentPage = _e, this.pages = ot.slice(0), this.pagesContext = B.slice(0), this.x = Zi, this.y = ft, this.matrix = ri, this.width = Sa(_e), this.height = hs(_e), this.outputDestination = mt, this.id = "", this.objectNumber = -1;
  };
  Ko.prototype.restore = function() {
    $ = this.page, _e = this.currentPage, B = this.pagesContext, ot = this.pages, Zi = this.x, ft = this.y, ri = this.matrix, el(_e, this.width), go(_e, this.height), mt = this.outputDestination;
  };
  var Qo = function(I, K, Ee, Re, Ye) {
    Fe.push(new Ko()), $ = _e = 0, ot = [], Zi = I, ft = K, ri = Ye, na([Ee, Re]);
  }, Fs = function(I) {
    if (Me[I]) Fe.pop().restore();
    else {
      var K = new Ko(), Ee = "Xo" + (Object.keys(ge).length + 1).toString(10);
      K.id = Ee, Me[I] = Ee, ge[Ee] = K, j.publish("addFormObject", K), Fe.pop().restore();
    }
  };
  for (var mo in z.beginFormObject = function(I, K, Ee, Re, Ye) {
    return Qo(I, K, Ee, Re, Ye), this;
  }, z.endFormObject = function(I) {
    return Fs(I), this;
  }, z.doFormObject = function(I, K) {
    var Ee = ge[Me[I]];
    return Y("q"), Y(K.toString() + " cm"), Y("/" + Ee.id + " Do"), Y("Q"), this;
  }, z.getFormObject = function(I) {
    var K = ge[Me[I]];
    return { x: K.x, y: K.y, width: K.width, height: K.height, matrix: K.matrix };
  }, z.save = function(I, K) {
    return I = I || "generated.pdf", (K = K || {}).returnPromise = K.returnPromise || !1, K.returnPromise === !1 ? (Su(io(xa()), I), typeof Su.unload == "function" && Ai.setTimeout && setTimeout(Su.unload, 911), this) : new Promise(function(Ee, Re) {
      try {
        var Ye = Su(io(xa()), I);
        typeof Su.unload == "function" && Ai.setTimeout && setTimeout(Su.unload, 911), Ee(Ye);
      } catch (ct) {
        Re(ct.message);
      }
    });
  }, wi.API) wi.API.hasOwnProperty(mo) && (mo === "events" && wi.API.events.length ? function(I, K) {
    var Ee, Re, Ye;
    for (Ye = K.length - 1; Ye !== -1; Ye--) Ee = K[Ye][0], Re = K[Ye][1], I.subscribe.apply(I, [Ee].concat(typeof Re == "function" ? [Re] : Re));
  }(j, wi.API.events) : z[mo] = wi.API[mo]);
  var Sa = z.getPageWidth = function(I) {
    return (B[I = I || _e].mediaBox.topRightX - B[I].mediaBox.bottomLeftX) / kt;
  }, el = z.setPageWidth = function(I, K) {
    B[I].mediaBox.topRightX = K * kt + B[I].mediaBox.bottomLeftX;
  }, hs = z.getPageHeight = function(I) {
    return (B[I = I || _e].mediaBox.topRightY - B[I].mediaBox.bottomLeftY) / kt;
  }, go = z.setPageHeight = function(I, K) {
    B[I].mediaBox.topRightY = K * kt + B[I].mediaBox.bottomLeftY;
  };
  return z.internal = { pdfEscape: Or, getStyle: Yo, getFont: lo, getFontSize: Et, getCharSpace: Il, getTextColor: Dl, getLineHeight: uo, getLineHeightFactor: oa, getLineWidth: ln, write: Kt, getHorizontalCoordinate: Ii, getVerticalCoordinate: la, getCoordinateString: ru, getVerticalCoordinateString: Cn, collections: {}, newObject: We, newAdditionalObject: $t, newObjectDeferred: gt, newObjectDeferredBegin: Mt, getFilters: Wi, putStream: Oi, events: j, scaleFactor: kt, pageSize: { getWidth: function() {
    return Sa(_e);
  }, setWidth: function(I) {
    el(_e, I);
  }, getHeight: function() {
    return hs(_e);
  }, setHeight: function(I) {
    go(_e, I);
  } }, encryptionOptions: M, encryption: xr, getEncryptor: Ms, output: Ls, getNumberOfPages: Wo, pages: ot, out: Y, f2: ve, f3: X, getPageInfo: jr, getPageInfoByObjId: si, getCurrentPageInfo: ro, getPDFVersion: le, Point: On, Rectangle: fo, Matrix: Ne, hasHotfix: El }, Object.defineProperty(z.internal.pageSize, "width", { get: function() {
    return Sa(_e);
  }, set: function(I) {
    el(_e, I);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(z.internal.pageSize, "height", { get: function() {
    return hs(_e);
  }, set: function(I) {
    go(_e, I);
  }, enumerable: !0, configurable: !0 }), Ho.call(z, lt), ai = "F1", aa(w, l), j.publish("initialized"), z;
}
oc.prototype.lsbFirstWord = function(a) {
  return String.fromCharCode(a >> 0 & 255, a >> 8 & 255, a >> 16 & 255, a >> 24 & 255);
}, oc.prototype.toHexString = function(a) {
  return a.split("").map(function(d) {
    return ("0" + (255 & d.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, oc.prototype.hexToBytes = function(a) {
  for (var d = [], l = 0; l < a.length; l += 2) d.push(String.fromCharCode(parseInt(a.substr(l, 2), 16)));
  return d.join("");
}, oc.prototype.processOwnerPassword = function(a, d) {
  return Gp(Zp(d).substr(0, 5), a);
}, oc.prototype.encryptor = function(a, d) {
  var l = Zp(this.encryptionKey + String.fromCharCode(255 & a, a >> 8 & 255, a >> 16 & 255, 255 & d, d >> 8 & 255)).substr(0, 10);
  return function(m) {
    return Gp(l, m);
  };
}, sd.prototype.equals = function(a) {
  var d, l = "id,objectNumber,equals";
  if (!a || ur(a) !== ur(this)) return !1;
  var m = 0;
  for (d in this) if (!(l.indexOf(d) >= 0)) {
    if (this.hasOwnProperty(d) && !a.hasOwnProperty(d) || this[d] !== a[d]) return !1;
    m++;
  }
  for (d in a) a.hasOwnProperty(d) && l.indexOf(d) < 0 && m--;
  return m === 0;
}, wi.API = { events: [] }, wi.version = "2.5.1";
var Rr = wi.API, af = 1, Nu = function(a) {
  return a.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, ac = function(a) {
  return a.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Pi = function(a) {
  return a.toFixed(2);
}, Zl = function(a) {
  return a.toFixed(5);
};
Rr.__acroform__ = {};
var Ra = function(a, d) {
  a.prototype = Object.create(d.prototype), a.prototype.constructor = a;
}, L0 = function(a) {
  return a * af;
}, Ro = function(a) {
  var d = new Gg(), l = ti.internal.getHeight(a) || 0, m = ti.internal.getWidth(a) || 0;
  return d.BBox = [0, 0, Number(Pi(m)), Number(Pi(l))], d;
}, yb = Rr.__acroform__.setBit = function(a, d) {
  if (a = a || 0, d = d || 0, isNaN(a) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return a |= 1 << d;
}, vb = Rr.__acroform__.clearBit = function(a, d) {
  if (a = a || 0, d = d || 0, isNaN(a) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return a &= ~(1 << d);
}, bb = Rr.__acroform__.getBit = function(a, d) {
  if (isNaN(a) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return a & 1 << d ? 1 : 0;
}, $r = Rr.__acroform__.getBitForPdf = function(a, d) {
  if (isNaN(a) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return bb(a, d - 1);
}, Zr = Rr.__acroform__.setBitForPdf = function(a, d) {
  if (isNaN(a) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return yb(a, d - 1);
}, Gr = Rr.__acroform__.clearBitForPdf = function(a, d) {
  if (isNaN(a) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return vb(a, d - 1);
}, xb = Rr.__acroform__.calculateCoordinates = function(a, d) {
  var l = d.internal.getHorizontalCoordinate, m = d.internal.getVerticalCoordinate, w = a[0], v = a[1], g = a[2], s = a[3], D = {};
  return D.lowerLeft_X = l(w) || 0, D.lowerLeft_Y = m(v + s) || 0, D.upperRight_X = l(w + g) || 0, D.upperRight_Y = m(v) || 0, [Number(Pi(D.lowerLeft_X)), Number(Pi(D.lowerLeft_Y)), Number(Pi(D.upperRight_X)), Number(Pi(D.upperRight_Y))];
}, wb = function(a) {
  if (a.appearanceStreamContent) return a.appearanceStreamContent;
  if (a.V || a.DV) {
    var d = [], l = a._V || a.DV, m = Hp(a, l), w = a.scope.internal.getFont(a.fontName, a.fontStyle).id;
    d.push("/Tx BMC"), d.push("q"), d.push("BT"), d.push(a.scope.__private__.encodeColorString(a.color)), d.push("/" + w + " " + Pi(m.fontSize) + " Tf"), d.push("1 0 0 1 0 0 Tm"), d.push(m.text), d.push("ET"), d.push("Q"), d.push("EMC");
    var v = Ro(a);
    return v.scope = a.scope, v.stream = d.join(`
`), v;
  }
}, Hp = function(a, d) {
  var l = a.fontSize === 0 ? a.maxFontSize : a.fontSize, m = { text: "", fontSize: "" }, w = (d = (d = d.substr(0, 1) == "(" ? d.substr(1) : d).substr(d.length - 1) == ")" ? d.substr(0, d.length - 1) : d).split(" ");
  w = a.multiline ? w.map(function(X) {
    return X.split(`
`);
  }) : w.map(function(X) {
    return [X];
  });
  var v = l, g = ti.internal.getHeight(a) || 0;
  g = g < 0 ? -g : g;
  var s = ti.internal.getWidth(a) || 0;
  s = s < 0 ? -s : s;
  var D = function(X, re, xe) {
    if (X + 1 < w.length) {
      var ye = re + " " + w[X + 1][0];
      return Hh(ye, a, xe).width <= s - 4;
    }
    return !1;
  };
  v++;
  e: for (; v > 0; ) {
    d = "", v--;
    var k, M, q = Hh("3", a, v).height, O = a.multiline ? g - v : (g - q) / 2, z = O += 2, pe = 0, le = 0, se = 0;
    if (v <= 0) {
      d = `(...) Tj
`, d += "% Width of Text: " + Hh(d, a, v = 12).width + ", FieldWidth:" + s + `
`;
      break;
    }
    for (var ee = "", fe = 0, Te = 0; Te < w.length; Te++) if (w.hasOwnProperty(Te)) {
      var ze = !1;
      if (w[Te].length !== 1 && se !== w[Te].length - 1) {
        if ((q + 2) * (fe + 2) + 2 > g) continue e;
        ee += w[Te][se], ze = !0, le = Te, Te--;
      } else {
        ee = (ee += w[Te][se] + " ").substr(ee.length - 1) == " " ? ee.substr(0, ee.length - 1) : ee;
        var qe = parseInt(Te), at = D(qe, ee, v), Ie = Te >= w.length - 1;
        if (at && !Ie) {
          ee += " ", se = 0;
          continue;
        }
        if (at || Ie) {
          if (Ie) le = qe;
          else if (a.multiline && (q + 2) * (fe + 2) + 2 > g) continue e;
        } else {
          if (!a.multiline || (q + 2) * (fe + 2) + 2 > g) continue e;
          le = qe;
        }
      }
      for (var Ae = "", me = pe; me <= le; me++) {
        var ve = w[me];
        if (a.multiline) {
          if (me === le) {
            Ae += ve[se] + " ", se = (se + 1) % ve.length;
            continue;
          }
          if (me === pe) {
            Ae += ve[ve.length - 1] + " ";
            continue;
          }
        }
        Ae += ve[0] + " ";
      }
      switch (Ae = Ae.substr(Ae.length - 1) == " " ? Ae.substr(0, Ae.length - 1) : Ae, M = Hh(Ae, a, v).width, a.textAlign) {
        case "right":
          k = s - M - 2;
          break;
        case "center":
          k = (s - M) / 2;
          break;
        case "left":
        default:
          k = 2;
      }
      d += Pi(k) + " " + Pi(z) + ` Td
`, d += "(" + Nu(Ae) + `) Tj
`, d += -Pi(k) + ` 0 Td
`, z = -(v + 2), M = 0, pe = ze ? le : le + 1, fe++, ee = "";
    }
    break;
  }
  return m.text = d, m.fontSize = v, m;
}, Hh = function(a, d, l) {
  var m = d.scope.internal.getFont(d.fontName, d.fontStyle), w = d.scope.getStringUnitWidth(a, { font: m, fontSize: parseFloat(l), charSpace: 0 }) * parseFloat(l);
  return { height: d.scope.getStringUnitWidth("3", { font: m, fontSize: parseFloat(l), charSpace: 0 }) * parseFloat(l) * 1.5, width: w };
}, Ab = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, Sb = function(a, d) {
  var l = { type: "reference", object: a };
  d.internal.getPageInfo(a.page).pageContext.annotations.find(function(m) {
    return m.type === l.type && m.object === l.object;
  }) === void 0 && d.internal.getPageInfo(a.page).pageContext.annotations.push(l);
}, Eb = function(a, d) {
  for (var l in a) if (a.hasOwnProperty(l)) {
    var m = l, w = a[l];
    d.internal.newObjectDeferredBegin(w.objId, !0), ur(w) === "object" && typeof w.putStream == "function" && w.putStream(), delete a[m];
  }
}, Tb = function(a, d) {
  if (d.scope = a, a.internal !== void 0 && (a.internal.acroformPlugin === void 0 || a.internal.acroformPlugin.isInitialized === !1)) {
    if (Js.FieldNum = 0, a.internal.acroformPlugin = JSON.parse(JSON.stringify(Ab)), a.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    af = a.internal.scaleFactor, a.internal.acroformPlugin.acroFormDictionaryRoot = new Hg(), a.internal.acroformPlugin.acroFormDictionaryRoot.scope = a, a.internal.acroformPlugin.acroFormDictionaryRoot._eventID = a.internal.events.subscribe("postPutResources", function() {
      (function(l) {
        l.internal.events.unsubscribe(l.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete l.internal.acroformPlugin.acroFormDictionaryRoot._eventID, l.internal.acroformPlugin.printedOut = !0;
      })(a);
    }), a.internal.events.subscribe("buildDocument", function() {
      (function(l) {
        l.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var m = l.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var w in m) if (m.hasOwnProperty(w)) {
          var v = m[w];
          v.objId = void 0, v.hasAnnotation && Sb(v, l);
        }
      })(a);
    }), a.internal.events.subscribe("putCatalog", function() {
      (function(l) {
        if (l.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        l.internal.write("/AcroForm " + l.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(a);
    }), a.internal.events.subscribe("postPutPages", function(l) {
      (function(m, w) {
        var v = !m;
        for (var g in m || (w.internal.newObjectDeferredBegin(w.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), w.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), m = m || w.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (m.hasOwnProperty(g)) {
          var s = m[g], D = [], k = s.Rect;
          if (s.Rect && (s.Rect = xb(s.Rect, w)), w.internal.newObjectDeferredBegin(s.objId, !0), s.DA = ti.createDefaultAppearanceStream(s), ur(s) === "object" && typeof s.getKeyValueListForStream == "function" && (D = s.getKeyValueListForStream()), s.Rect = k, s.hasAppearanceStream && !s.appearanceStreamContent) {
            var M = wb(s);
            D.push({ key: "AP", value: "<</N " + M + ">>" }), w.internal.acroformPlugin.xForms.push(M);
          }
          if (s.appearanceStreamContent) {
            var q = "";
            for (var O in s.appearanceStreamContent) if (s.appearanceStreamContent.hasOwnProperty(O)) {
              var z = s.appearanceStreamContent[O];
              if (q += "/" + O + " ", q += "<<", Object.keys(z).length >= 1 || Array.isArray(z)) {
                for (var g in z) if (z.hasOwnProperty(g)) {
                  var pe = z[g];
                  typeof pe == "function" && (pe = pe.call(w, s)), q += "/" + g + " " + pe + " ", w.internal.acroformPlugin.xForms.indexOf(pe) >= 0 || w.internal.acroformPlugin.xForms.push(pe);
                }
              } else typeof (pe = z) == "function" && (pe = pe.call(w, s)), q += "/" + g + " " + pe, w.internal.acroformPlugin.xForms.indexOf(pe) >= 0 || w.internal.acroformPlugin.xForms.push(pe);
              q += ">>";
            }
            D.push({ key: "AP", value: `<<
` + q + ">>" });
          }
          w.internal.putStream({ additionalKeyValues: D, objectId: s.objId }), w.internal.out("endobj");
        }
        v && Eb(w.internal.acroformPlugin.xForms, w);
      })(l, a);
    }), a.internal.acroformPlugin.isInitialized = !0;
  }
}, Zg = Rr.__acroform__.arrayToPdfArray = function(a, d, l) {
  var m = function(g) {
    return g;
  };
  if (Array.isArray(a)) {
    for (var w = "[", v = 0; v < a.length; v++) switch (v !== 0 && (w += " "), ur(a[v])) {
      case "boolean":
      case "number":
      case "object":
        w += a[v].toString();
        break;
      case "string":
        a[v].substr(0, 1) !== "/" ? (d !== void 0 && l && (m = l.internal.getEncryptor(d)), w += "(" + Nu(m(a[v].toString())) + ")") : w += a[v].toString();
    }
    return w += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, wp = function(a, d, l) {
  var m = function(w) {
    return w;
  };
  return d !== void 0 && l && (m = l.internal.getEncryptor(d)), (a = a || "").toString(), a = "(" + Nu(m(a)) + ")";
}, jo = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(a) {
    this._objId = a;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
jo.prototype.toString = function() {
  return this.objId + " 0 R";
}, jo.prototype.putStream = function() {
  var a = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: a, objectId: this.objId }), this.scope.internal.out("endobj");
}, jo.prototype.getKeyValueListForStream = function() {
  var a = [], d = Object.getOwnPropertyNames(this).filter(function(v) {
    return v != "content" && v != "appearanceStreamContent" && v != "scope" && v != "objId" && v.substring(0, 1) != "_";
  });
  for (var l in d) if (Object.getOwnPropertyDescriptor(this, d[l]).configurable === !1) {
    var m = d[l], w = this[m];
    w && (Array.isArray(w) ? a.push({ key: m, value: Zg(w, this.objId, this.scope) }) : w instanceof jo ? (w.scope = this.scope, a.push({ key: m, value: w.objId + " 0 R" })) : typeof w != "function" && a.push({ key: m, value: w }));
  }
  return a;
};
var Gg = function() {
  jo.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var a, d = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return d;
  }, set: function(l) {
    d = l;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(l) {
    a = l.trim();
  }, get: function() {
    return a || null;
  } });
};
Ra(Gg, jo);
var Hg = function() {
  jo.call(this);
  var a, d = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return d.length > 0 ? d : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return d;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (a) {
      var l = function(m) {
        return m;
      };
      return this.scope && (l = this.scope.internal.getEncryptor(this.objId)), "(" + Nu(l(a)) + ")";
    }
  }, set: function(l) {
    a = l;
  } });
};
Ra(Hg, jo);
var Js = function a() {
  jo.call(this);
  var d = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return d;
  }, set: function(ee) {
    if (isNaN(ee)) throw new Error('Invalid value "' + ee + '" for attribute F supplied.');
    d = ee;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(d, 3);
  }, set: function(ee) {
    ee ? this.F = Zr(d, 3) : this.F = Gr(d, 3);
  } });
  var l = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return l;
  }, set: function(ee) {
    if (isNaN(ee)) throw new Error('Invalid value "' + ee + '" for attribute Ff supplied.');
    l = ee;
  } });
  var m = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (m.length !== 0) return m;
  }, set: function(ee) {
    m = ee !== void 0 ? ee : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !m || isNaN(m[0]) ? 0 : m[0];
  }, set: function(ee) {
    m[0] = ee;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !m || isNaN(m[1]) ? 0 : m[1];
  }, set: function(ee) {
    m[1] = ee;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !m || isNaN(m[2]) ? 0 : m[2];
  }, set: function(ee) {
    m[2] = ee;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !m || isNaN(m[3]) ? 0 : m[3];
  }, set: function(ee) {
    m[3] = ee;
  } });
  var w = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return w;
  }, set: function(ee) {
    switch (ee) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        w = ee;
        break;
      default:
        throw new Error('Invalid value "' + ee + '" for attribute FT supplied.');
    }
  } });
  var v = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!v || v.length < 1) {
      if (this instanceof od) return;
      v = "FieldObject" + a.FieldNum++;
    }
    var ee = function(fe) {
      return fe;
    };
    return this.scope && (ee = this.scope.internal.getEncryptor(this.objId)), "(" + Nu(ee(v)) + ")";
  }, set: function(ee) {
    v = ee.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return v;
  }, set: function(ee) {
    v = ee;
  } });
  var g = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return g;
  }, set: function(ee) {
    g = ee;
  } });
  var s = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return s;
  }, set: function(ee) {
    s = ee;
  } });
  var D = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return D;
  }, set: function(ee) {
    D = ee;
  } });
  var k = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return k === void 0 ? 50 / af : k;
  }, set: function(ee) {
    k = ee;
  } });
  var M = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return M;
  }, set: function(ee) {
    M = ee;
  } });
  var q = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!q || this instanceof od || this instanceof ku)) return wp(q, this.objId, this.scope);
  }, set: function(ee) {
    ee = ee.toString(), q = ee;
  } });
  var O = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (O) return this instanceof En ? O : wp(O, this.objId, this.scope);
  }, set: function(ee) {
    ee = ee.toString(), O = this instanceof En ? ee : ee.substr(0, 1) === "(" ? ac(ee.substr(1, ee.length - 2)) : ac(ee);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof En ? ac(O.substr(1, O.length - 1)) : O;
  }, set: function(ee) {
    ee = ee.toString(), O = this instanceof En ? "/" + ee : ee;
  } });
  var z = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (z) return z;
  }, set: function(ee) {
    this.V = ee;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (z) return this instanceof En ? z : wp(z, this.objId, this.scope);
  }, set: function(ee) {
    ee = ee.toString(), z = this instanceof En ? ee : ee.substr(0, 1) === "(" ? ac(ee.substr(1, ee.length - 2)) : ac(ee);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof En ? ac(z.substr(1, z.length - 1)) : z;
  }, set: function(ee) {
    ee = ee.toString(), z = this instanceof En ? "/" + ee : ee;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var pe, le = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return le;
  }, set: function(ee) {
    ee = !!ee, le = ee;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (pe) return pe;
  }, set: function(ee) {
    pe = ee;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 1);
  }, set: function(ee) {
    ee ? this.Ff = Zr(this.Ff, 1) : this.Ff = Gr(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 2);
  }, set: function(ee) {
    ee ? this.Ff = Zr(this.Ff, 2) : this.Ff = Gr(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 3);
  }, set: function(ee) {
    ee ? this.Ff = Zr(this.Ff, 3) : this.Ff = Gr(this.Ff, 3);
  } });
  var se = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (se !== null) return se;
  }, set: function(ee) {
    if ([0, 1, 2].indexOf(ee) === -1) throw new Error('Invalid value "' + ee + '" for attribute Q supplied.');
    se = ee;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var ee;
    switch (se) {
      case 0:
      default:
        ee = "left";
        break;
      case 1:
        ee = "center";
        break;
      case 2:
        ee = "right";
    }
    return ee;
  }, configurable: !0, enumerable: !0, set: function(ee) {
    switch (ee) {
      case "right":
      case 2:
        se = 2;
        break;
      case "center":
      case 1:
        se = 1;
        break;
      case "left":
      case 0:
      default:
        se = 0;
    }
  } });
};
Ra(Js, jo);
var hc = function() {
  Js.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var a = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return a;
  }, set: function(l) {
    a = l;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return a;
  }, set: function(l) {
    a = l;
  } });
  var d = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return Zg(d, this.objId, this.scope);
  }, set: function(l) {
    var m, w;
    w = [], typeof (m = l) == "string" && (w = function(v, g, s) {
      s || (s = 1);
      for (var D, k = []; D = g.exec(v); ) k.push(D[s]);
      return k;
    }(m, /\((.*?)\)/g)), d = w;
  } }), this.getOptions = function() {
    return d;
  }, this.setOptions = function(l) {
    d = l, this.sort && d.sort();
  }, this.addOption = function(l) {
    l = (l = l || "").toString(), d.push(l), this.sort && d.sort();
  }, this.removeOption = function(l, m) {
    for (m = m || !1, l = (l = l || "").toString(); d.indexOf(l) !== -1 && (d.splice(d.indexOf(l), 1), m !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 18);
  }, set: function(l) {
    l ? this.Ff = Zr(this.Ff, 18) : this.Ff = Gr(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 19);
  }, set: function(l) {
    this.combo === !0 && (l ? this.Ff = Zr(this.Ff, 19) : this.Ff = Gr(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 20);
  }, set: function(l) {
    l ? (this.Ff = Zr(this.Ff, 20), d.sort()) : this.Ff = Gr(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 22);
  }, set: function(l) {
    l ? this.Ff = Zr(this.Ff, 22) : this.Ff = Gr(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 23);
  }, set: function(l) {
    l ? this.Ff = Zr(this.Ff, 23) : this.Ff = Gr(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 27);
  }, set: function(l) {
    l ? this.Ff = Zr(this.Ff, 27) : this.Ff = Gr(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
Ra(hc, Js);
var dc = function() {
  hc.call(this), this.fontName = "helvetica", this.combo = !1;
};
Ra(dc, hc);
var pc = function() {
  dc.call(this), this.combo = !0;
};
Ra(pc, dc);
var Kh = function() {
  pc.call(this), this.edit = !0;
};
Ra(Kh, pc);
var En = function() {
  Js.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 15);
  }, set: function(l) {
    l ? this.Ff = Zr(this.Ff, 15) : this.Ff = Gr(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 16);
  }, set: function(l) {
    l ? this.Ff = Zr(this.Ff, 16) : this.Ff = Gr(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 17);
  }, set: function(l) {
    l ? this.Ff = Zr(this.Ff, 17) : this.Ff = Gr(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 26);
  }, set: function(l) {
    l ? this.Ff = Zr(this.Ff, 26) : this.Ff = Gr(this.Ff, 26);
  } });
  var a, d = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var l = function(v) {
      return v;
    };
    if (this.scope && (l = this.scope.internal.getEncryptor(this.objId)), Object.keys(d).length !== 0) {
      var m, w = [];
      for (m in w.push("<<"), d) w.push("/" + m + " (" + Nu(l(d[m])) + ")");
      return w.push(">>"), w.join(`
`);
    }
  }, set: function(l) {
    ur(l) === "object" && (d = l);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return d.CA || "";
  }, set: function(l) {
    typeof l == "string" && (d.CA = l);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return a;
  }, set: function(l) {
    a = l;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return a.substr(1, a.length - 1);
  }, set: function(l) {
    a = "/" + l;
  } });
};
Ra(En, Js);
var Qh = function() {
  En.call(this), this.pushButton = !0;
};
Ra(Qh, En);
var fc = function() {
  En.call(this), this.radio = !0, this.pushButton = !1;
  var a = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return a;
  }, set: function(d) {
    a = d !== void 0 ? d : [];
  } });
};
Ra(fc, En);
var od = function() {
  var a, d;
  Js.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return a;
  }, set: function(w) {
    a = w;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return d;
  }, set: function(w) {
    d = w;
  } });
  var l, m = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var w = function(s) {
      return s;
    };
    this.scope && (w = this.scope.internal.getEncryptor(this.objId));
    var v, g = [];
    for (v in g.push("<<"), m) g.push("/" + v + " (" + Nu(w(m[v])) + ")");
    return g.push(">>"), g.join(`
`);
  }, set: function(w) {
    ur(w) === "object" && (m = w);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return m.CA || "";
  }, set: function(w) {
    typeof w == "string" && (m.CA = w);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return l;
  }, set: function(w) {
    l = w;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return l.substr(1, l.length - 1);
  }, set: function(w) {
    l = "/" + w;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = ti.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
Ra(od, Js), fc.prototype.setAppearance = function(a) {
  if (!("createAppearanceStream" in a) || !("getCA" in a)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var d in this.Kids) if (this.Kids.hasOwnProperty(d)) {
    var l = this.Kids[d];
    l.appearanceStreamContent = a.createAppearanceStream(l.optionName), l.caption = a.getCA();
  }
}, fc.prototype.createOption = function(a) {
  var d = new od();
  return d.Parent = this, d.optionName = a, this.Kids.push(d), Cb.call(this.scope, d), d;
};
var ed = function() {
  En.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = ti.CheckBox.createAppearanceStream();
};
Ra(ed, En);
var ku = function() {
  Js.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 13);
  }, set: function(d) {
    d ? this.Ff = Zr(this.Ff, 13) : this.Ff = Gr(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 21);
  }, set: function(d) {
    d ? this.Ff = Zr(this.Ff, 21) : this.Ff = Gr(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 23);
  }, set: function(d) {
    d ? this.Ff = Zr(this.Ff, 23) : this.Ff = Gr(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 24);
  }, set: function(d) {
    d ? this.Ff = Zr(this.Ff, 24) : this.Ff = Gr(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 25);
  }, set: function(d) {
    d ? this.Ff = Zr(this.Ff, 25) : this.Ff = Gr(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 26);
  }, set: function(d) {
    d ? this.Ff = Zr(this.Ff, 26) : this.Ff = Gr(this.Ff, 26);
  } });
  var a = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return a;
  }, set: function(d) {
    a = d;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return a;
  }, set: function(d) {
    Number.isInteger(d) && (a = d);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
Ra(ku, Js);
var td = function() {
  ku.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 14);
  }, set: function(a) {
    a ? this.Ff = Zr(this.Ff, 14) : this.Ff = Gr(this.Ff, 14);
  } }), this.password = !0;
};
Ra(td, ku);
var ti = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: ti.CheckBox.YesNormal }, D: { On: ti.CheckBox.YesPushDown, Off: ti.CheckBox.OffPushDown } };
}, YesPushDown: function(a) {
  var d = Ro(a);
  d.scope = a.scope;
  var l = [], m = a.scope.internal.getFont(a.fontName, a.fontStyle).id, w = a.scope.__private__.encodeColorString(a.color), v = Hp(a, a.caption);
  return l.push("0.749023 g"), l.push("0 0 " + Pi(ti.internal.getWidth(a)) + " " + Pi(ti.internal.getHeight(a)) + " re"), l.push("f"), l.push("BMC"), l.push("q"), l.push("0 0 1 rg"), l.push("/" + m + " " + Pi(v.fontSize) + " Tf " + w), l.push("BT"), l.push(v.text), l.push("ET"), l.push("Q"), l.push("EMC"), d.stream = l.join(`
`), d;
}, YesNormal: function(a) {
  var d = Ro(a);
  d.scope = a.scope;
  var l = a.scope.internal.getFont(a.fontName, a.fontStyle).id, m = a.scope.__private__.encodeColorString(a.color), w = [], v = ti.internal.getHeight(a), g = ti.internal.getWidth(a), s = Hp(a, a.caption);
  return w.push("1 g"), w.push("0 0 " + Pi(g) + " " + Pi(v) + " re"), w.push("f"), w.push("q"), w.push("0 0 1 rg"), w.push("0 0 " + Pi(g - 1) + " " + Pi(v - 1) + " re"), w.push("W"), w.push("n"), w.push("0 g"), w.push("BT"), w.push("/" + l + " " + Pi(s.fontSize) + " Tf " + m), w.push(s.text), w.push("ET"), w.push("Q"), d.stream = w.join(`
`), d;
}, OffPushDown: function(a) {
  var d = Ro(a);
  d.scope = a.scope;
  var l = [];
  return l.push("0.749023 g"), l.push("0 0 " + Pi(ti.internal.getWidth(a)) + " " + Pi(ti.internal.getHeight(a)) + " re"), l.push("f"), d.stream = l.join(`
`), d;
} }, RadioButton: { Circle: { createAppearanceStream: function(a) {
  var d = { D: { Off: ti.RadioButton.Circle.OffPushDown }, N: {} };
  return d.N[a] = ti.RadioButton.Circle.YesNormal, d.D[a] = ti.RadioButton.Circle.YesPushDown, d;
}, getCA: function() {
  return "l";
}, YesNormal: function(a) {
  var d = Ro(a);
  d.scope = a.scope;
  var l = [], m = ti.internal.getWidth(a) <= ti.internal.getHeight(a) ? ti.internal.getWidth(a) / 4 : ti.internal.getHeight(a) / 4;
  m = Number((0.9 * m).toFixed(5));
  var w = ti.internal.Bezier_C, v = Number((m * w).toFixed(5));
  return l.push("q"), l.push("1 0 0 1 " + Zl(ti.internal.getWidth(a) / 2) + " " + Zl(ti.internal.getHeight(a) / 2) + " cm"), l.push(m + " 0 m"), l.push(m + " " + v + " " + v + " " + m + " 0 " + m + " c"), l.push("-" + v + " " + m + " -" + m + " " + v + " -" + m + " 0 c"), l.push("-" + m + " -" + v + " -" + v + " -" + m + " 0 -" + m + " c"), l.push(v + " -" + m + " " + m + " -" + v + " " + m + " 0 c"), l.push("f"), l.push("Q"), d.stream = l.join(`
`), d;
}, YesPushDown: function(a) {
  var d = Ro(a);
  d.scope = a.scope;
  var l = [], m = ti.internal.getWidth(a) <= ti.internal.getHeight(a) ? ti.internal.getWidth(a) / 4 : ti.internal.getHeight(a) / 4;
  m = Number((0.9 * m).toFixed(5));
  var w = Number((2 * m).toFixed(5)), v = Number((w * ti.internal.Bezier_C).toFixed(5)), g = Number((m * ti.internal.Bezier_C).toFixed(5));
  return l.push("0.749023 g"), l.push("q"), l.push("1 0 0 1 " + Zl(ti.internal.getWidth(a) / 2) + " " + Zl(ti.internal.getHeight(a) / 2) + " cm"), l.push(w + " 0 m"), l.push(w + " " + v + " " + v + " " + w + " 0 " + w + " c"), l.push("-" + v + " " + w + " -" + w + " " + v + " -" + w + " 0 c"), l.push("-" + w + " -" + v + " -" + v + " -" + w + " 0 -" + w + " c"), l.push(v + " -" + w + " " + w + " -" + v + " " + w + " 0 c"), l.push("f"), l.push("Q"), l.push("0 g"), l.push("q"), l.push("1 0 0 1 " + Zl(ti.internal.getWidth(a) / 2) + " " + Zl(ti.internal.getHeight(a) / 2) + " cm"), l.push(m + " 0 m"), l.push(m + " " + g + " " + g + " " + m + " 0 " + m + " c"), l.push("-" + g + " " + m + " -" + m + " " + g + " -" + m + " 0 c"), l.push("-" + m + " -" + g + " -" + g + " -" + m + " 0 -" + m + " c"), l.push(g + " -" + m + " " + m + " -" + g + " " + m + " 0 c"), l.push("f"), l.push("Q"), d.stream = l.join(`
`), d;
}, OffPushDown: function(a) {
  var d = Ro(a);
  d.scope = a.scope;
  var l = [], m = ti.internal.getWidth(a) <= ti.internal.getHeight(a) ? ti.internal.getWidth(a) / 4 : ti.internal.getHeight(a) / 4;
  m = Number((0.9 * m).toFixed(5));
  var w = Number((2 * m).toFixed(5)), v = Number((w * ti.internal.Bezier_C).toFixed(5));
  return l.push("0.749023 g"), l.push("q"), l.push("1 0 0 1 " + Zl(ti.internal.getWidth(a) / 2) + " " + Zl(ti.internal.getHeight(a) / 2) + " cm"), l.push(w + " 0 m"), l.push(w + " " + v + " " + v + " " + w + " 0 " + w + " c"), l.push("-" + v + " " + w + " -" + w + " " + v + " -" + w + " 0 c"), l.push("-" + w + " -" + v + " -" + v + " -" + w + " 0 -" + w + " c"), l.push(v + " -" + w + " " + w + " -" + v + " " + w + " 0 c"), l.push("f"), l.push("Q"), d.stream = l.join(`
`), d;
} }, Cross: { createAppearanceStream: function(a) {
  var d = { D: { Off: ti.RadioButton.Cross.OffPushDown }, N: {} };
  return d.N[a] = ti.RadioButton.Cross.YesNormal, d.D[a] = ti.RadioButton.Cross.YesPushDown, d;
}, getCA: function() {
  return "8";
}, YesNormal: function(a) {
  var d = Ro(a);
  d.scope = a.scope;
  var l = [], m = ti.internal.calculateCross(a);
  return l.push("q"), l.push("1 1 " + Pi(ti.internal.getWidth(a) - 2) + " " + Pi(ti.internal.getHeight(a) - 2) + " re"), l.push("W"), l.push("n"), l.push(Pi(m.x1.x) + " " + Pi(m.x1.y) + " m"), l.push(Pi(m.x2.x) + " " + Pi(m.x2.y) + " l"), l.push(Pi(m.x4.x) + " " + Pi(m.x4.y) + " m"), l.push(Pi(m.x3.x) + " " + Pi(m.x3.y) + " l"), l.push("s"), l.push("Q"), d.stream = l.join(`
`), d;
}, YesPushDown: function(a) {
  var d = Ro(a);
  d.scope = a.scope;
  var l = ti.internal.calculateCross(a), m = [];
  return m.push("0.749023 g"), m.push("0 0 " + Pi(ti.internal.getWidth(a)) + " " + Pi(ti.internal.getHeight(a)) + " re"), m.push("f"), m.push("q"), m.push("1 1 " + Pi(ti.internal.getWidth(a) - 2) + " " + Pi(ti.internal.getHeight(a) - 2) + " re"), m.push("W"), m.push("n"), m.push(Pi(l.x1.x) + " " + Pi(l.x1.y) + " m"), m.push(Pi(l.x2.x) + " " + Pi(l.x2.y) + " l"), m.push(Pi(l.x4.x) + " " + Pi(l.x4.y) + " m"), m.push(Pi(l.x3.x) + " " + Pi(l.x3.y) + " l"), m.push("s"), m.push("Q"), d.stream = m.join(`
`), d;
}, OffPushDown: function(a) {
  var d = Ro(a);
  d.scope = a.scope;
  var l = [];
  return l.push("0.749023 g"), l.push("0 0 " + Pi(ti.internal.getWidth(a)) + " " + Pi(ti.internal.getHeight(a)) + " re"), l.push("f"), d.stream = l.join(`
`), d;
} } }, createDefaultAppearanceStream: function(a) {
  var d = a.scope.internal.getFont(a.fontName, a.fontStyle).id, l = a.scope.__private__.encodeColorString(a.color);
  return "/" + d + " " + a.fontSize + " Tf " + l;
} };
ti.internal = { Bezier_C: 0.551915024494, calculateCross: function(a) {
  var d = ti.internal.getWidth(a), l = ti.internal.getHeight(a), m = Math.min(d, l);
  return { x1: { x: (d - m) / 2, y: (l - m) / 2 + m }, x2: { x: (d - m) / 2 + m, y: (l - m) / 2 }, x3: { x: (d - m) / 2, y: (l - m) / 2 }, x4: { x: (d - m) / 2 + m, y: (l - m) / 2 + m } };
} }, ti.internal.getWidth = function(a) {
  var d = 0;
  return ur(a) === "object" && (d = L0(a.Rect[2])), d;
}, ti.internal.getHeight = function(a) {
  var d = 0;
  return ur(a) === "object" && (d = L0(a.Rect[3])), d;
};
var Cb = Rr.addField = function(a) {
  if (Tb(this, a), !(a instanceof Js)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var d;
  return (d = a).scope.internal.acroformPlugin.printedOut && (d.scope.internal.acroformPlugin.printedOut = !1, d.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), d.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(d), a.page = a.scope.internal.getCurrentPageInfo().pageNumber, this;
};
Rr.AcroFormChoiceField = hc, Rr.AcroFormListBox = dc, Rr.AcroFormComboBox = pc, Rr.AcroFormEditBox = Kh, Rr.AcroFormButton = En, Rr.AcroFormPushButton = Qh, Rr.AcroFormRadioButton = fc, Rr.AcroFormCheckBox = ed, Rr.AcroFormTextField = ku, Rr.AcroFormPasswordField = td, Rr.AcroFormAppearance = ti, Rr.AcroForm = { ChoiceField: hc, ListBox: dc, ComboBox: pc, EditBox: Kh, Button: En, PushButton: Qh, RadioButton: fc, CheckBox: ed, TextField: ku, PasswordField: td, Appearance: ti }, wi.AcroForm = { ChoiceField: hc, ListBox: dc, ComboBox: pc, EditBox: Kh, Button: En, PushButton: Qh, RadioButton: fc, CheckBox: ed, TextField: ku, PasswordField: td, Appearance: ti };
function Wg(a) {
  return a.reduce(function(d, l, m) {
    return d[l] = m, d;
  }, {});
}
(function(a) {
  a.__addimage__ = {};
  var d = "UNKNOWN", l = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, m = a.__addimage__.getImageFileTypeByImageData = function(X, re) {
    var xe, ye, Ve, He, Ze, je = d;
    if ((re = re || d) === "RGBA" || X.data !== void 0 && X.data instanceof Uint8ClampedArray && "height" in X && "width" in X) return "RGBA";
    if (at(X)) for (Ze in l) for (Ve = l[Ze], xe = 0; xe < Ve.length; xe += 1) {
      for (He = !0, ye = 0; ye < Ve[xe].length; ye += 1) if (Ve[xe][ye] !== void 0 && Ve[xe][ye] !== X[ye]) {
        He = !1;
        break;
      }
      if (He === !0) {
        je = Ze;
        break;
      }
    }
    else for (Ze in l) for (Ve = l[Ze], xe = 0; xe < Ve.length; xe += 1) {
      for (He = !0, ye = 0; ye < Ve[xe].length; ye += 1) if (Ve[xe][ye] !== void 0 && Ve[xe][ye] !== X.charCodeAt(ye)) {
        He = !1;
        break;
      }
      if (He === !0) {
        je = Ze;
        break;
      }
    }
    return je === d && re !== d && (je = re), je;
  }, w = function X(re) {
    for (var xe = this.internal.write, ye = this.internal.putStream, Ve = (0, this.internal.getFilters)(); Ve.indexOf("FlateEncode") !== -1; ) Ve.splice(Ve.indexOf("FlateEncode"), 1);
    re.objectId = this.internal.newObject();
    var He = [];
    if (He.push({ key: "Type", value: "/XObject" }), He.push({ key: "Subtype", value: "/Image" }), He.push({ key: "Width", value: re.width }), He.push({ key: "Height", value: re.height }), re.colorSpace === se.INDEXED ? He.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (re.palette.length / 3 - 1) + " " + ("sMask" in re && re.sMask !== void 0 ? re.objectId + 2 : re.objectId + 1) + " 0 R]" }) : (He.push({ key: "ColorSpace", value: "/" + re.colorSpace }), re.colorSpace === se.DEVICE_CMYK && He.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), He.push({ key: "BitsPerComponent", value: re.bitsPerComponent }), "decodeParameters" in re && re.decodeParameters !== void 0 && He.push({ key: "DecodeParms", value: "<<" + re.decodeParameters + ">>" }), "transparency" in re && Array.isArray(re.transparency)) {
      for (var Ze = "", je = 0, Je = re.transparency.length; je < Je; je++) Ze += re.transparency[je] + " " + re.transparency[je] + " ";
      He.push({ key: "Mask", value: "[" + Ze + "]" });
    }
    re.sMask !== void 0 && He.push({ key: "SMask", value: re.objectId + 1 + " 0 R" });
    var Qe = re.filter !== void 0 ? ["/" + re.filter] : void 0;
    if (ye({ data: re.data, additionalKeyValues: He, alreadyAppliedFilters: Qe, objectId: re.objectId }), xe("endobj"), "sMask" in re && re.sMask !== void 0) {
      var nt = "/Predictor " + re.predictor + " /Colors 1 /BitsPerComponent " + re.bitsPerComponent + " /Columns " + re.width, Q = { width: re.width, height: re.height, colorSpace: "DeviceGray", bitsPerComponent: re.bitsPerComponent, decodeParameters: nt, data: re.sMask };
      "filter" in re && (Q.filter = re.filter), X.call(this, Q);
    }
    if (re.colorSpace === se.INDEXED) {
      var _e = this.internal.newObject();
      ye({ data: Ae(new Uint8Array(re.palette)), objectId: _e }), xe("endobj");
    }
  }, v = function() {
    var X = this.internal.collections.addImage_images;
    for (var re in X) w.call(this, X[re]);
  }, g = function() {
    var X, re = this.internal.collections.addImage_images, xe = this.internal.write;
    for (var ye in re) xe("/I" + (X = re[ye]).index, X.objectId, "0", "R");
  }, s = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", v), this.internal.events.subscribe("putXobjectDict", g));
  }, D = function() {
    var X = this.internal.collections.addImage_images;
    return s.call(this), X;
  }, k = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, M = function(X) {
    return typeof a["process" + X.toUpperCase()] == "function";
  }, q = function(X) {
    return ur(X) === "object" && X.nodeType === 1;
  }, O = function(X, re) {
    if (X.nodeName === "IMG" && X.hasAttribute("src")) {
      var xe = "" + X.getAttribute("src");
      if (xe.indexOf("data:image/") === 0) return oh(unescape(xe).split("base64,").pop());
      var ye = a.loadFile(xe, !0);
      if (ye !== void 0) return ye;
    }
    if (X.nodeName === "CANVAS") {
      if (X.width === 0 || X.height === 0) throw new Error("Given canvas must have data. Canvas width: " + X.width + ", height: " + X.height);
      var Ve;
      switch (re) {
        case "PNG":
          Ve = "image/png";
          break;
        case "WEBP":
          Ve = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          Ve = "image/jpeg";
      }
      return oh(X.toDataURL(Ve, 1).split("base64,").pop());
    }
  }, z = function(X) {
    var re = this.internal.collections.addImage_images;
    if (re) {
      for (var xe in re) if (X === re[xe].alias) return re[xe];
    }
  }, pe = function(X, re, xe) {
    return X || re || (X = -96, re = -96), X < 0 && (X = -1 * xe.width * 72 / X / this.internal.scaleFactor), re < 0 && (re = -1 * xe.height * 72 / re / this.internal.scaleFactor), X === 0 && (X = re * xe.width / xe.height), re === 0 && (re = X * xe.height / xe.width), [X, re];
  }, le = function(X, re, xe, ye, Ve, He) {
    var Ze = pe.call(this, xe, ye, Ve), je = this.internal.getCoordinateString, Je = this.internal.getVerticalCoordinateString, Qe = D.call(this);
    if (xe = Ze[0], ye = Ze[1], Qe[Ve.index] = Ve, He) {
      He *= Math.PI / 180;
      var nt = Math.cos(He), Q = Math.sin(He), _e = function(Ce) {
        return Ce.toFixed(4);
      }, be = [_e(nt), _e(Q), _e(-1 * Q), _e(nt), 0, 0, "cm"];
    }
    this.internal.write("q"), He ? (this.internal.write([1, "0", "0", 1, je(X), Je(re + ye), "cm"].join(" ")), this.internal.write(be.join(" ")), this.internal.write([je(xe), "0", "0", je(ye), "0", "0", "cm"].join(" "))) : this.internal.write([je(xe), "0", "0", je(ye), je(X), Je(re + ye), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + Ve.index + " Do"), this.internal.write("Q");
  }, se = a.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  a.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var ee = a.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, fe = a.__addimage__.sHashCode = function(X) {
    var re, xe, ye = 0;
    if (typeof X == "string") for (xe = X.length, re = 0; re < xe; re++) ye = (ye << 5) - ye + X.charCodeAt(re), ye |= 0;
    else if (at(X)) for (xe = X.byteLength / 2, re = 0; re < xe; re++) ye = (ye << 5) - ye + X[re], ye |= 0;
    return ye;
  }, Te = a.__addimage__.validateStringAsBase64 = function(X) {
    (X = X || "").toString().trim();
    var re = !0;
    return X.length === 0 && (re = !1), X.length % 4 != 0 && (re = !1), /^[A-Za-z0-9+/]+$/.test(X.substr(0, X.length - 2)) === !1 && (re = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(X.substr(-2)) === !1 && (re = !1), re;
  }, ze = a.__addimage__.extractImageFromDataUrl = function(X) {
    var re = (X = X || "").split("base64,"), xe = null;
    if (re.length === 2) {
      var ye = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(re[0]);
      Array.isArray(ye) && (xe = { mimeType: ye[1], charset: ye[2], data: re[1] });
    }
    return xe;
  }, qe = a.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  a.__addimage__.isArrayBuffer = function(X) {
    return qe() && X instanceof ArrayBuffer;
  };
  var at = a.__addimage__.isArrayBufferView = function(X) {
    return qe() && typeof Uint32Array < "u" && (X instanceof Int8Array || X instanceof Uint8Array || typeof Uint8ClampedArray < "u" && X instanceof Uint8ClampedArray || X instanceof Int16Array || X instanceof Uint16Array || X instanceof Int32Array || X instanceof Uint32Array || X instanceof Float32Array || X instanceof Float64Array);
  }, Ie = a.__addimage__.binaryStringToUint8Array = function(X) {
    for (var re = X.length, xe = new Uint8Array(re), ye = 0; ye < re; ye++) xe[ye] = X.charCodeAt(ye);
    return xe;
  }, Ae = a.__addimage__.arrayBufferToBinaryString = function(X) {
    for (var re = "", xe = at(X) ? X : new Uint8Array(X), ye = 0; ye < xe.length; ye += 8192) re += String.fromCharCode.apply(null, xe.subarray(ye, ye + 8192));
    return re;
  };
  a.addImage = function() {
    var X, re, xe, ye, Ve, He, Ze, je, Je;
    if (typeof arguments[1] == "number" ? (re = d, xe = arguments[1], ye = arguments[2], Ve = arguments[3], He = arguments[4], Ze = arguments[5], je = arguments[6], Je = arguments[7]) : (re = arguments[1], xe = arguments[2], ye = arguments[3], Ve = arguments[4], He = arguments[5], Ze = arguments[6], je = arguments[7], Je = arguments[8]), ur(X = arguments[0]) === "object" && !q(X) && "imageData" in X) {
      var Qe = X;
      X = Qe.imageData, re = Qe.format || re || d, xe = Qe.x || xe || 0, ye = Qe.y || ye || 0, Ve = Qe.w || Qe.width || Ve, He = Qe.h || Qe.height || He, Ze = Qe.alias || Ze, je = Qe.compression || je, Je = Qe.rotation || Qe.angle || Je;
    }
    var nt = this.internal.getFilters();
    if (je === void 0 && nt.indexOf("FlateEncode") !== -1 && (je = "SLOW"), isNaN(xe) || isNaN(ye)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    s.call(this);
    var Q = me.call(this, X, re, Ze, je);
    return le.call(this, xe, ye, Ve, He, Q, Je), this;
  };
  var me = function(X, re, xe, ye) {
    var Ve, He, Ze;
    if (typeof X == "string" && m(X) === d) {
      X = unescape(X);
      var je = ve(X, !1);
      (je !== "" || (je = a.loadFile(X, !0)) !== void 0) && (X = je);
    }
    if (q(X) && (X = O(X, re)), re = m(X, re), !M(re)) throw new Error("addImage does not support files of type '" + re + "', please ensure that a plugin for '" + re + "' support is added.");
    if (((Ze = xe) == null || Ze.length === 0) && (xe = function(Je) {
      return typeof Je == "string" || at(Je) ? fe(Je) : at(Je.data) ? fe(Je.data) : null;
    }(X)), (Ve = z.call(this, xe)) || (qe() && (X instanceof Uint8Array || re === "RGBA" || (He = X, X = Ie(X))), Ve = this["process" + re.toUpperCase()](X, k.call(this), xe, function(Je) {
      return Je && typeof Je == "string" && (Je = Je.toUpperCase()), Je in a.image_compression ? Je : ee.NONE;
    }(ye), He)), !Ve) throw new Error("An unknown error occurred whilst processing the image.");
    return Ve;
  }, ve = a.__addimage__.convertBase64ToBinaryString = function(X, re) {
    var xe;
    re = typeof re != "boolean" || re;
    var ye, Ve = "";
    if (typeof X == "string") {
      ye = (xe = ze(X)) !== null ? xe.data : X;
      try {
        Ve = oh(ye);
      } catch (He) {
        if (re) throw Te(ye) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + He.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return Ve;
  };
  a.getImageProperties = function(X) {
    var re, xe, ye = "";
    if (q(X) && (X = O(X)), typeof X == "string" && m(X) === d && ((ye = ve(X, !1)) === "" && (ye = a.loadFile(X) || ""), X = ye), xe = m(X), !M(xe)) throw new Error("addImage does not support files of type '" + xe + "', please ensure that a plugin for '" + xe + "' support is added.");
    if (!qe() || X instanceof Uint8Array || (X = Ie(X)), !(re = this["process" + xe.toUpperCase()](X))) throw new Error("An unknown error occurred whilst processing the image");
    return re.fileType = xe, re;
  };
})(wi.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(a) {
  var d = function(l) {
    if (l !== void 0 && l != "") return !0;
  };
  wi.API.events.push(["addPage", function(l) {
    this.internal.getPageInfo(l.pageNumber).pageContext.annotations = [];
  }]), a.events.push(["putPage", function(l) {
    for (var m, w, v, g = this.internal.getCoordinateString, s = this.internal.getVerticalCoordinateString, D = this.internal.getPageInfoByObjId(l.objId), k = l.pageContext.annotations, M = !1, q = 0; q < k.length && !M; q++) switch ((m = k[q]).type) {
      case "link":
        (d(m.options.url) || d(m.options.pageNumber)) && (M = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        M = !0;
    }
    if (M != 0) {
      this.internal.write("/Annots [");
      for (var O = 0; O < k.length; O++) {
        m = k[O];
        var z = this.internal.pdfEscape, pe = this.internal.getEncryptor(l.objId);
        switch (m.type) {
          case "reference":
            this.internal.write(" " + m.object.objId + " 0 R ");
            break;
          case "text":
            var le = this.internal.newAdditionalObject(), se = this.internal.newAdditionalObject(), ee = this.internal.getEncryptor(le.objId), fe = m.title || "Note";
            v = "<</Type /Annot /Subtype /Text " + (w = "/Rect [" + g(m.bounds.x) + " " + s(m.bounds.y + m.bounds.h) + " " + g(m.bounds.x + m.bounds.w) + " " + s(m.bounds.y) + "] ") + "/Contents (" + z(ee(m.contents)) + ")", v += " /Popup " + se.objId + " 0 R", v += " /P " + D.objId + " 0 R", v += " /T (" + z(ee(fe)) + ") >>", le.content = v;
            var Te = le.objId + " 0 R";
            v = "<</Type /Annot /Subtype /Popup " + (w = "/Rect [" + g(m.bounds.x + 30) + " " + s(m.bounds.y + m.bounds.h) + " " + g(m.bounds.x + m.bounds.w + 30) + " " + s(m.bounds.y) + "] ") + " /Parent " + Te, m.open && (v += " /Open true"), v += " >>", se.content = v, this.internal.write(le.objId, "0 R", se.objId, "0 R");
            break;
          case "freetext":
            w = "/Rect [" + g(m.bounds.x) + " " + s(m.bounds.y) + " " + g(m.bounds.x + m.bounds.w) + " " + s(m.bounds.y + m.bounds.h) + "] ";
            var ze = m.color || "#000000";
            v = "<</Type /Annot /Subtype /FreeText " + w + "/Contents (" + z(pe(m.contents)) + ")", v += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + ze + ")", v += " /Border [0 0 0]", v += " >>", this.internal.write(v);
            break;
          case "link":
            if (m.options.name) {
              var qe = this.annotations._nameMap[m.options.name];
              m.options.pageNumber = qe.page, m.options.top = qe.y;
            } else m.options.top || (m.options.top = 0);
            if (w = "/Rect [" + m.finalBounds.x + " " + m.finalBounds.y + " " + m.finalBounds.w + " " + m.finalBounds.h + "] ", v = "", m.options.url) v = "<</Type /Annot /Subtype /Link " + w + "/Border [0 0 0] /A <</S /URI /URI (" + z(pe(m.options.url)) + ") >>";
            else if (m.options.pageNumber)
              switch (v = "<</Type /Annot /Subtype /Link " + w + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(m.options.pageNumber).objId + " 0 R", m.options.magFactor = m.options.magFactor || "XYZ", m.options.magFactor) {
                case "Fit":
                  v += " /Fit]";
                  break;
                case "FitH":
                  v += " /FitH " + m.options.top + "]";
                  break;
                case "FitV":
                  m.options.left = m.options.left || 0, v += " /FitV " + m.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var at = s(m.options.top);
                  m.options.left = m.options.left || 0, m.options.zoom === void 0 && (m.options.zoom = 0), v += " /XYZ " + m.options.left + " " + at + " " + m.options.zoom + "]";
              }
            v != "" && (v += " >>", this.internal.write(v));
        }
      }
      this.internal.write("]");
    }
  }]), a.createAnnotation = function(l) {
    var m = this.internal.getCurrentPageInfo();
    switch (l.type) {
      case "link":
        this.link(l.bounds.x, l.bounds.y, l.bounds.w, l.bounds.h, l);
        break;
      case "text":
      case "freetext":
        m.pageContext.annotations.push(l);
    }
  }, a.link = function(l, m, w, v, g) {
    var s = this.internal.getCurrentPageInfo(), D = this.internal.getCoordinateString, k = this.internal.getVerticalCoordinateString;
    s.pageContext.annotations.push({ finalBounds: { x: D(l), y: k(m), w: D(l + w), h: k(m + v) }, options: g, type: "link" });
  }, a.textWithLink = function(l, m, w, v) {
    var g, s, D = this.getTextWidth(l), k = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (v.maxWidth !== void 0) {
      s = v.maxWidth;
      var M = this.splitTextToSize(l, s).length;
      g = Math.ceil(k * M);
    } else s = D, g = k;
    return this.text(l, m, w, v), w += 0.2 * k, v.align === "center" && (m -= D / 2), v.align === "right" && (m -= D), this.link(m, w - k, s, g, v), D;
  }, a.getTextWidth = function(l) {
    var m = this.internal.getFontSize();
    return this.getStringUnitWidth(l) * m / this.internal.scaleFactor;
  };
}(wi.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(a) {
  var d = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, l = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, m = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, w = [1570, 1571, 1573, 1575];
  a.__arabicParser__ = {};
  var v = a.__arabicParser__.isInArabicSubstitutionA = function(le) {
    return d[le.charCodeAt(0)] !== void 0;
  }, g = a.__arabicParser__.isArabicLetter = function(le) {
    return typeof le == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(le);
  }, s = a.__arabicParser__.isArabicEndLetter = function(le) {
    return g(le) && v(le) && d[le.charCodeAt(0)].length <= 2;
  }, D = a.__arabicParser__.isArabicAlfLetter = function(le) {
    return g(le) && w.indexOf(le.charCodeAt(0)) >= 0;
  };
  a.__arabicParser__.arabicLetterHasIsolatedForm = function(le) {
    return g(le) && v(le) && d[le.charCodeAt(0)].length >= 1;
  };
  var k = a.__arabicParser__.arabicLetterHasFinalForm = function(le) {
    return g(le) && v(le) && d[le.charCodeAt(0)].length >= 2;
  };
  a.__arabicParser__.arabicLetterHasInitialForm = function(le) {
    return g(le) && v(le) && d[le.charCodeAt(0)].length >= 3;
  };
  var M = a.__arabicParser__.arabicLetterHasMedialForm = function(le) {
    return g(le) && v(le) && d[le.charCodeAt(0)].length == 4;
  }, q = a.__arabicParser__.resolveLigatures = function(le) {
    var se = 0, ee = l, fe = "", Te = 0;
    for (se = 0; se < le.length; se += 1) ee[le.charCodeAt(se)] !== void 0 ? (Te++, typeof (ee = ee[le.charCodeAt(se)]) == "number" && (fe += String.fromCharCode(ee), ee = l, Te = 0), se === le.length - 1 && (ee = l, fe += le.charAt(se - (Te - 1)), se -= Te - 1, Te = 0)) : (ee = l, fe += le.charAt(se - Te), se -= Te, Te = 0);
    return fe;
  };
  a.__arabicParser__.isArabicDiacritic = function(le) {
    return le !== void 0 && m[le.charCodeAt(0)] !== void 0;
  };
  var O = a.__arabicParser__.getCorrectForm = function(le, se, ee) {
    return g(le) ? v(le) === !1 ? -1 : !k(le) || !g(se) && !g(ee) || !g(ee) && s(se) || s(le) && !g(se) || s(le) && D(se) || s(le) && s(se) ? 0 : M(le) && g(se) && !s(se) && g(ee) && k(ee) ? 3 : s(le) || !g(ee) ? 1 : 2 : -1;
  }, z = function(le) {
    var se = 0, ee = 0, fe = 0, Te = "", ze = "", qe = "", at = (le = le || "").split("\\s+"), Ie = [];
    for (se = 0; se < at.length; se += 1) {
      for (Ie.push(""), ee = 0; ee < at[se].length; ee += 1) Te = at[se][ee], ze = at[se][ee - 1], qe = at[se][ee + 1], g(Te) ? (fe = O(Te, ze, qe), Ie[se] += fe !== -1 ? String.fromCharCode(d[Te.charCodeAt(0)][fe]) : Te) : Ie[se] += Te;
      Ie[se] = q(Ie[se]);
    }
    return Ie.join(" ");
  }, pe = a.__arabicParser__.processArabic = a.processArabic = function() {
    var le, se = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, ee = [];
    if (Array.isArray(se)) {
      var fe = 0;
      for (ee = [], fe = 0; fe < se.length; fe += 1) Array.isArray(se[fe]) ? ee.push([z(se[fe][0]), se[fe][1], se[fe][2]]) : ee.push([z(se[fe])]);
      le = ee;
    } else le = z(se);
    return typeof arguments[0] == "string" ? le : (arguments[0].text = le, arguments[0]);
  };
  a.events.push(["preProcessText", pe]);
}(wi.API), wi.API.autoPrint = function(a) {
  var d;
  switch ((a = a || {}).variant = a.variant || "non-conform", a.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        d = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + d + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(a) {
  var d = function() {
    var l = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return l;
    }, set: function(s) {
      l = s;
    } });
    var m = 150;
    Object.defineProperty(this, "width", { get: function() {
      return m;
    }, set: function(s) {
      m = isNaN(s) || Number.isInteger(s) === !1 || s < 0 ? 150 : s, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = m + 1);
    } });
    var w = 300;
    Object.defineProperty(this, "height", { get: function() {
      return w;
    }, set: function(s) {
      w = isNaN(s) || Number.isInteger(s) === !1 || s < 0 ? 300 : s, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = w + 1);
    } });
    var v = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return v;
    }, set: function(s) {
      v = s;
    } });
    var g = {};
    Object.defineProperty(this, "style", { get: function() {
      return g;
    }, set: function(s) {
      g = s;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  d.prototype.getContext = function(l, m) {
    var w;
    if ((l = l || "2d") !== "2d") return null;
    for (w in m) this.pdf.context2d.hasOwnProperty(w) && (this.pdf.context2d[w] = m[w]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, d.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, a.events.push(["initialized", function() {
    this.canvas = new d(), this.canvas.pdf = this;
  }]);
}(wi.API), function(a) {
  var d = { left: 0, top: 0, bottom: 0, right: 0 }, l = !1, m = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, d), this.internal.__cell__.margins.width = this.getPageWidth(), w.call(this));
  }, w = function() {
    this.internal.__cell__.lastCell = new v(), this.internal.__cell__.pages = 1;
  }, v = function() {
    var D = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return D;
    }, set: function(le) {
      D = le;
    } });
    var k = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return k;
    }, set: function(le) {
      k = le;
    } });
    var M = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return M;
    }, set: function(le) {
      M = le;
    } });
    var q = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return q;
    }, set: function(le) {
      q = le;
    } });
    var O = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return O;
    }, set: function(le) {
      O = le;
    } });
    var z = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return z;
    }, set: function(le) {
      z = le;
    } });
    var pe = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return pe;
    }, set: function(le) {
      pe = le;
    } }), this;
  };
  v.prototype.clone = function() {
    return new v(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, v.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, a.setHeaderFunction = function(D) {
    return m.call(this), this.internal.__cell__.headerFunction = typeof D == "function" ? D : void 0, this;
  }, a.getTextDimensions = function(D, k) {
    m.call(this);
    var M = (k = k || {}).fontSize || this.getFontSize(), q = k.font || this.getFont(), O = k.scaleFactor || this.internal.scaleFactor, z = 0, pe = 0, le = 0, se = this;
    if (!Array.isArray(D) && typeof D != "string") {
      if (typeof D != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      D = String(D);
    }
    var ee = k.maxWidth;
    ee > 0 ? typeof D == "string" ? D = this.splitTextToSize(D, ee) : Object.prototype.toString.call(D) === "[object Array]" && (D = D.reduce(function(Te, ze) {
      return Te.concat(se.splitTextToSize(ze, ee));
    }, [])) : D = Array.isArray(D) ? D : [D];
    for (var fe = 0; fe < D.length; fe++) z < (le = this.getStringUnitWidth(D[fe], { font: q }) * M) && (z = le);
    return z !== 0 && (pe = D.length), { w: z /= O, h: Math.max((pe * M * this.getLineHeightFactor() - M * (this.getLineHeightFactor() - 1)) / O, 0) };
  }, a.cellAddPage = function() {
    m.call(this), this.addPage();
    var D = this.internal.__cell__.margins || d;
    return this.internal.__cell__.lastCell = new v(D.left, D.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var g = a.cell = function() {
    var D;
    D = arguments[0] instanceof v ? arguments[0] : new v(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), m.call(this);
    var k = this.internal.__cell__.lastCell, M = this.internal.__cell__.padding, q = this.internal.__cell__.margins || d, O = this.internal.__cell__.tableHeaderRow, z = this.internal.__cell__.printHeaders;
    return k.lineNumber !== void 0 && (k.lineNumber === D.lineNumber ? (D.x = (k.x || 0) + (k.width || 0), D.y = k.y || 0) : k.y + k.height + D.height + q.bottom > this.getPageHeight() ? (this.cellAddPage(), D.y = q.top, z && O && (this.printHeaderRow(D.lineNumber, !0), D.y += O[0].height)) : D.y = k.y + k.height || D.y), D.text[0] !== void 0 && (this.rect(D.x, D.y, D.width, D.height, l === !0 ? "FD" : void 0), D.align === "right" ? this.text(D.text, D.x + D.width - M, D.y + M, { align: "right", baseline: "top" }) : D.align === "center" ? this.text(D.text, D.x + D.width / 2, D.y + M, { align: "center", baseline: "top", maxWidth: D.width - M - M }) : this.text(D.text, D.x + M, D.y + M, { align: "left", baseline: "top", maxWidth: D.width - M - M })), this.internal.__cell__.lastCell = D, this;
  };
  a.table = function(D, k, M, q, O) {
    if (m.call(this), !M) throw new Error("No data for PDF table.");
    var z, pe, le, se, ee = [], fe = [], Te = [], ze = {}, qe = {}, at = [], Ie = [], Ae = (O = O || {}).autoSize || !1, me = O.printHeaders !== !1, ve = O.css && O.css["font-size"] !== void 0 ? 16 * O.css["font-size"] : O.fontSize || 12, X = O.margins || Object.assign({ width: this.getPageWidth() }, d), re = typeof O.padding == "number" ? O.padding : 3, xe = O.headerBackgroundColor || "#c8c8c8", ye = O.headerTextColor || "#000";
    if (w.call(this), this.internal.__cell__.printHeaders = me, this.internal.__cell__.margins = X, this.internal.__cell__.table_font_size = ve, this.internal.__cell__.padding = re, this.internal.__cell__.headerBackgroundColor = xe, this.internal.__cell__.headerTextColor = ye, this.setFontSize(ve), q == null) fe = ee = Object.keys(M[0]), Te = ee.map(function() {
      return "left";
    });
    else if (Array.isArray(q) && ur(q[0]) === "object") for (ee = q.map(function(Qe) {
      return Qe.name;
    }), fe = q.map(function(Qe) {
      return Qe.prompt || Qe.name || "";
    }), Te = q.map(function(Qe) {
      return Qe.align || "left";
    }), z = 0; z < q.length; z += 1) qe[q[z].name] = q[z].width * (19.049976 / 25.4);
    else Array.isArray(q) && typeof q[0] == "string" && (fe = ee = q, Te = ee.map(function() {
      return "left";
    }));
    if (Ae || Array.isArray(q) && typeof q[0] == "string") for (z = 0; z < ee.length; z += 1) {
      for (ze[se = ee[z]] = M.map(function(Qe) {
        return Qe[se];
      }), this.setFont(void 0, "bold"), at.push(this.getTextDimensions(fe[z], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), pe = ze[se], this.setFont(void 0, "normal"), le = 0; le < pe.length; le += 1) at.push(this.getTextDimensions(pe[le], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      qe[se] = Math.max.apply(null, at) + re + re, at = [];
    }
    if (me) {
      var Ve = {};
      for (z = 0; z < ee.length; z += 1) Ve[ee[z]] = {}, Ve[ee[z]].text = fe[z], Ve[ee[z]].align = Te[z];
      var He = s.call(this, Ve, qe);
      Ie = ee.map(function(Qe) {
        return new v(D, k, qe[Qe], He, Ve[Qe].text, void 0, Ve[Qe].align);
      }), this.setTableHeaderRow(Ie), this.printHeaderRow(1, !1);
    }
    var Ze = q.reduce(function(Qe, nt) {
      return Qe[nt.name] = nt.align, Qe;
    }, {});
    for (z = 0; z < M.length; z += 1) {
      "rowStart" in O && O.rowStart instanceof Function && O.rowStart({ row: z, data: M[z] }, this);
      var je = s.call(this, M[z], qe);
      for (le = 0; le < ee.length; le += 1) {
        var Je = M[z][ee[le]];
        "cellStart" in O && O.cellStart instanceof Function && O.cellStart({ row: z, col: le, data: Je }, this), g.call(this, new v(D, k, qe[ee[le]], je, Je, z + 2, Ze[ee[le]]));
      }
    }
    return this.internal.__cell__.table_x = D, this.internal.__cell__.table_y = k, this;
  };
  var s = function(D, k) {
    var M = this.internal.__cell__.padding, q = this.internal.__cell__.table_font_size, O = this.internal.scaleFactor;
    return Object.keys(D).map(function(z) {
      var pe = D[z];
      return this.splitTextToSize(pe.hasOwnProperty("text") ? pe.text : pe, k[z] - M - M);
    }, this).map(function(z) {
      return this.getLineHeightFactor() * z.length * q / O + M + M;
    }, this).reduce(function(z, pe) {
      return Math.max(z, pe);
    }, 0);
  };
  a.setTableHeaderRow = function(D) {
    m.call(this), this.internal.__cell__.tableHeaderRow = D;
  }, a.printHeaderRow = function(D, k) {
    if (m.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var M;
    if (l = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var q = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new v(q[0], q[1], q[2], q[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var O = [], z = 0; z < this.internal.__cell__.tableHeaderRow.length; z += 1) {
      M = this.internal.__cell__.tableHeaderRow[z].clone(), k && (M.y = this.internal.__cell__.margins.top || 0, O.push(M)), M.lineNumber = D;
      var pe = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), g.call(this, M), this.setTextColor(pe);
    }
    O.length > 0 && this.setTableHeaderRow(O), this.setFont(void 0, "normal"), l = !1;
  };
}(wi.API);
var Xg = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, Yg = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], Wp = Wg(Yg), Jg = [100, 200, 300, 400, 500, 600, 700, 800, 900], Db = Wg(Jg);
function Xp(a) {
  var d = a.family.replace(/"|'/g, "").toLowerCase(), l = function(v) {
    return Xg[v = v || "normal"] ? v : "normal";
  }(a.style), m = function(v) {
    if (!v) return 400;
    if (typeof v == "number") return v >= 100 && v <= 900 && v % 100 == 0 ? v : 400;
    if (/^\d00$/.test(v)) return parseInt(v);
    switch (v) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(a.weight), w = function(v) {
    return typeof Wp[v = v || "normal"] == "number" ? v : "normal";
  }(a.stretch);
  return { family: d, style: l, weight: m, stretch: w, src: a.src || [], ref: a.ref || { name: d, style: [w, l, m].join(" ") } };
}
function M0(a, d, l, m) {
  var w;
  for (w = l; w >= 0 && w < d.length; w += m) if (a[d[w]]) return a[d[w]];
  for (w = l; w >= 0 && w < d.length; w -= m) if (a[d[w]]) return a[d[w]];
}
var Ib = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, N0 = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function z0(a) {
  return [a.stretch, a.style, a.weight, a.family].join(" ");
}
function kb(a, d, l) {
  for (var m = (l = l || {}).defaultFontFamily || "times", w = Object.assign({}, Ib, l.genericFontFamilies || {}), v = null, g = null, s = 0; s < d.length; ++s) if (w[(v = Xp(d[s])).family] && (v.family = w[v.family]), a.hasOwnProperty(v.family)) {
    g = a[v.family];
    break;
  }
  if (!(g = g || a[m])) throw new Error("Could not find a font-family for the rule '" + z0(v) + "' and default family '" + m + "'.");
  if (g = function(D, k) {
    if (k[D]) return k[D];
    var M = Wp[D], q = M <= Wp.normal ? -1 : 1, O = M0(k, Yg, M, q);
    if (!O) throw new Error("Could not find a matching font-stretch value for " + D);
    return O;
  }(v.stretch, g), g = function(D, k) {
    if (k[D]) return k[D];
    for (var M = Xg[D], q = 0; q < M.length; ++q) if (k[M[q]]) return k[M[q]];
    throw new Error("Could not find a matching font-style for " + D);
  }(v.style, g), !(g = function(D, k) {
    if (k[D]) return k[D];
    if (D === 400 && k[500]) return k[500];
    if (D === 500 && k[400]) return k[400];
    var M = Db[D], q = M0(k, Jg, M, D < 400 ? -1 : 1);
    if (!q) throw new Error("Could not find a matching font-weight for value " + D);
    return q;
  }(v.weight, g))) throw new Error("Failed to resolve a font for the rule '" + z0(v) + "'.");
  return g;
}
function F0(a) {
  return a.trimLeft();
}
function Pb(a, d) {
  for (var l = 0; l < a.length; ) {
    if (a.charAt(l) === d) return [a.substring(0, l), a.substring(l + 1)];
    l += 1;
  }
  return null;
}
function Lb(a) {
  var d = a.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return d === null ? null : [d[0], a.substring(d[0].length)];
}
var Wh, B0, R0, O0 = ["times"];
(function(a) {
  var d, l, m, w, v, g, s, D, k, M = function(Q) {
    return Q = Q || {}, this.isStrokeTransparent = Q.isStrokeTransparent || !1, this.strokeOpacity = Q.strokeOpacity || 1, this.strokeStyle = Q.strokeStyle || "#000000", this.fillStyle = Q.fillStyle || "#000000", this.isFillTransparent = Q.isFillTransparent || !1, this.fillOpacity = Q.fillOpacity || 1, this.font = Q.font || "10px sans-serif", this.textBaseline = Q.textBaseline || "alphabetic", this.textAlign = Q.textAlign || "left", this.lineWidth = Q.lineWidth || 1, this.lineJoin = Q.lineJoin || "miter", this.lineCap = Q.lineCap || "butt", this.path = Q.path || [], this.transform = Q.transform !== void 0 ? Q.transform.clone() : new D(), this.globalCompositeOperation = Q.globalCompositeOperation || "normal", this.globalAlpha = Q.globalAlpha || 1, this.clip_path = Q.clip_path || [], this.currentPoint = Q.currentPoint || new g(), this.miterLimit = Q.miterLimit || 10, this.lastPoint = Q.lastPoint || new g(), this.lineDashOffset = Q.lineDashOffset || 0, this.lineDash = Q.lineDash || [], this.margin = Q.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = Q.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof Q.ignoreClearRect != "boolean" || Q.ignoreClearRect, this;
  };
  a.events.push(["initialized", function() {
    this.context2d = new q(this), d = this.internal.f2, l = this.internal.getCoordinateString, m = this.internal.getVerticalCoordinateString, w = this.internal.getHorizontalCoordinate, v = this.internal.getVerticalCoordinate, g = this.internal.Point, s = this.internal.Rectangle, D = this.internal.Matrix, k = new M();
  }]);
  var q = function(Q) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var _e = Q;
    Object.defineProperty(this, "pdf", { get: function() {
      return _e;
    } });
    var be = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return be;
    }, set: function(it) {
      be = !!it;
    } });
    var Ce = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Ce;
    }, set: function(it) {
      Ce = !!it;
    } });
    var Oe = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return Oe;
    }, set: function(it) {
      isNaN(it) || (Oe = it);
    } });
    var $e = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return $e;
    }, set: function(it) {
      isNaN(it) || ($e = it);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return k.margin;
    }, set: function(it) {
      var Y;
      typeof it == "number" ? Y = [it, it, it, it] : ((Y = new Array(4))[0] = it[0], Y[1] = it.length >= 2 ? it[1] : Y[0], Y[2] = it.length >= 3 ? it[2] : Y[0], Y[3] = it.length >= 4 ? it[3] : Y[1]), k.margin = Y;
    } });
    var Ue = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return Ue;
    }, set: function(it) {
      Ue = it;
    } });
    var Ke = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return Ke;
    }, set: function(it) {
      Ke = it;
    } });
    var rt = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return rt;
    }, set: function(it) {
      rt = it;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return k;
    }, set: function(it) {
      it instanceof M && (k = it);
    } }), Object.defineProperty(this, "path", { get: function() {
      return k.path;
    }, set: function(it) {
      k.path = it;
    } });
    var ot = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return ot;
    }, set: function(it) {
      ot = it;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(it) {
      var Y;
      Y = O(it), this.ctx.fillStyle = Y.style, this.ctx.isFillTransparent = Y.a === 0, this.ctx.fillOpacity = Y.a, this.pdf.setFillColor(Y.r, Y.g, Y.b, { a: Y.a }), this.pdf.setTextColor(Y.r, Y.g, Y.b, { a: Y.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(it) {
      var Y = O(it);
      this.ctx.strokeStyle = Y.style, this.ctx.isStrokeTransparent = Y.a === 0, this.ctx.strokeOpacity = Y.a, Y.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (Y.a, this.pdf.setDrawColor(Y.r, Y.g, Y.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(it) {
      ["butt", "round", "square"].indexOf(it) !== -1 && (this.ctx.lineCap = it, this.pdf.setLineCap(it));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(it) {
      isNaN(it) || (this.ctx.lineWidth = it, this.pdf.setLineWidth(it));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(it) {
      ["bevel", "round", "miter"].indexOf(it) !== -1 && (this.ctx.lineJoin = it, this.pdf.setLineJoin(it));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(it) {
      isNaN(it) || (this.ctx.miterLimit = it, this.pdf.setMiterLimit(it));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(it) {
      this.ctx.textBaseline = it;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(it) {
      ["right", "end", "center", "left", "start"].indexOf(it) !== -1 && (this.ctx.textAlign = it);
    } });
    var vt = null;
    function mt(it, Y) {
      if (vt === null) {
        var Kt = function(Rt) {
          var lt = [];
          return Object.keys(Rt).forEach(function(xt) {
            Rt[xt].forEach(function(At) {
              var Et = null;
              switch (At) {
                case "bold":
                  Et = { family: xt, weight: "bold" };
                  break;
                case "italic":
                  Et = { family: xt, style: "italic" };
                  break;
                case "bolditalic":
                  Et = { family: xt, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  Et = { family: xt };
              }
              Et !== null && (Et.ref = { name: xt, style: At }, lt.push(Et));
            });
          }), lt;
        }(it.getFontList());
        vt = function(Rt) {
          for (var lt = {}, xt = 0; xt < Rt.length; ++xt) {
            var At = Xp(Rt[xt]), Et = At.family, jt = At.stretch, ni = At.style, ii = At.weight;
            lt[Et] = lt[Et] || {}, lt[Et][jt] = lt[Et][jt] || {}, lt[Et][jt][ni] = lt[Et][jt][ni] || {}, lt[Et][jt][ni][ii] = At;
          }
          return lt;
        }(Kt.concat(Y));
      }
      return vt;
    }
    var Pt = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return Pt;
    }, set: function(it) {
      vt = null, Pt = it;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(it) {
      var Y;
      if (this.ctx.font = it, (Y = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(it)) !== null) {
        var Kt = Y[1], Rt = (Y[2], Y[3]), lt = Y[4], xt = (Y[5], Y[6]), At = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(lt)[2];
        lt = Math.floor(At === "px" ? parseFloat(lt) * this.pdf.internal.scaleFactor : At === "em" ? parseFloat(lt) * this.pdf.getFontSize() : parseFloat(lt) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(lt);
        var Et = function(Jt) {
          var ai, kt, Zi = [], ft = Jt.trim();
          if (ft === "") return O0;
          if (ft in N0) return [N0[ft]];
          for (; ft !== ""; ) {
            switch (kt = null, ai = (ft = F0(ft)).charAt(0)) {
              case '"':
              case "'":
                kt = Pb(ft.substring(1), ai);
                break;
              default:
                kt = Lb(ft);
            }
            if (kt === null || (Zi.push(kt[0]), (ft = F0(kt[1])) !== "" && ft.charAt(0) !== ",")) return O0;
            ft = ft.replace(/^,/, "");
          }
          return Zi;
        }(xt);
        if (this.fontFaces) {
          var jt = kb(mt(this.pdf, this.fontFaces), Et.map(function(Jt) {
            return { family: Jt, stretch: "normal", weight: Rt, style: Kt };
          }));
          this.pdf.setFont(jt.ref.name, jt.ref.style);
        } else {
          var ni = "";
          (Rt === "bold" || parseInt(Rt, 10) >= 700 || Kt === "bold") && (ni = "bold"), Kt === "italic" && (ni += "italic"), ni.length === 0 && (ni = "normal");
          for (var ii = "", yi = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, xi = 0; xi < Et.length; xi++) {
            if (this.pdf.internal.getFont(Et[xi], ni, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              ii = Et[xi];
              break;
            }
            if (ni === "bolditalic" && this.pdf.internal.getFont(Et[xi], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) ii = Et[xi], ni = "bold";
            else if (this.pdf.internal.getFont(Et[xi], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              ii = Et[xi], ni = "normal";
              break;
            }
          }
          if (ii === "") {
            for (var pt = 0; pt < Et.length; pt++) if (yi[Et[pt]]) {
              ii = yi[Et[pt]];
              break;
            }
          }
          ii = ii === "" ? "Times" : ii, this.pdf.setFont(ii, ni);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(it) {
      this.ctx.globalCompositeOperation = it;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(it) {
      this.ctx.globalAlpha = it;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(it) {
      this.ctx.lineDashOffset = it, nt.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(it) {
      this.ctx.lineDash = it, nt.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(it) {
      this.ctx.ignoreClearRect = !!it;
    } });
  };
  q.prototype.setLineDash = function(Q) {
    this.lineDash = Q;
  }, q.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, q.prototype.fill = function() {
    ze.call(this, "fill", !1);
  }, q.prototype.stroke = function() {
    ze.call(this, "stroke", !1);
  }, q.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, q.prototype.moveTo = function(Q, _e) {
    if (isNaN(Q) || isNaN(_e)) throw yr.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var be = this.ctx.transform.applyToPoint(new g(Q, _e));
    this.path.push({ type: "mt", x: be.x, y: be.y }), this.ctx.lastPoint = new g(Q, _e);
  }, q.prototype.closePath = function() {
    var Q = new g(0, 0), _e = 0;
    for (_e = this.path.length - 1; _e !== -1; _e--) if (this.path[_e].type === "begin" && ur(this.path[_e + 1]) === "object" && typeof this.path[_e + 1].x == "number") {
      Q = new g(this.path[_e + 1].x, this.path[_e + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new g(Q.x, Q.y);
  }, q.prototype.lineTo = function(Q, _e) {
    if (isNaN(Q) || isNaN(_e)) throw yr.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var be = this.ctx.transform.applyToPoint(new g(Q, _e));
    this.path.push({ type: "lt", x: be.x, y: be.y }), this.ctx.lastPoint = new g(be.x, be.y);
  }, q.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), ze.call(this, null, !0);
  }, q.prototype.quadraticCurveTo = function(Q, _e, be, Ce) {
    if (isNaN(be) || isNaN(Ce) || isNaN(Q) || isNaN(_e)) throw yr.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var Oe = this.ctx.transform.applyToPoint(new g(be, Ce)), $e = this.ctx.transform.applyToPoint(new g(Q, _e));
    this.path.push({ type: "qct", x1: $e.x, y1: $e.y, x: Oe.x, y: Oe.y }), this.ctx.lastPoint = new g(Oe.x, Oe.y);
  }, q.prototype.bezierCurveTo = function(Q, _e, be, Ce, Oe, $e) {
    if (isNaN(Oe) || isNaN($e) || isNaN(Q) || isNaN(_e) || isNaN(be) || isNaN(Ce)) throw yr.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var Ue = this.ctx.transform.applyToPoint(new g(Oe, $e)), Ke = this.ctx.transform.applyToPoint(new g(Q, _e)), rt = this.ctx.transform.applyToPoint(new g(be, Ce));
    this.path.push({ type: "bct", x1: Ke.x, y1: Ke.y, x2: rt.x, y2: rt.y, x: Ue.x, y: Ue.y }), this.ctx.lastPoint = new g(Ue.x, Ue.y);
  }, q.prototype.arc = function(Q, _e, be, Ce, Oe, $e) {
    if (isNaN(Q) || isNaN(_e) || isNaN(be) || isNaN(Ce) || isNaN(Oe)) throw yr.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if ($e = !!$e, !this.ctx.transform.isIdentity) {
      var Ue = this.ctx.transform.applyToPoint(new g(Q, _e));
      Q = Ue.x, _e = Ue.y;
      var Ke = this.ctx.transform.applyToPoint(new g(0, be)), rt = this.ctx.transform.applyToPoint(new g(0, 0));
      be = Math.sqrt(Math.pow(Ke.x - rt.x, 2) + Math.pow(Ke.y - rt.y, 2));
    }
    Math.abs(Oe - Ce) >= 2 * Math.PI && (Ce = 0, Oe = 2 * Math.PI), this.path.push({ type: "arc", x: Q, y: _e, radius: be, startAngle: Ce, endAngle: Oe, counterclockwise: $e });
  }, q.prototype.arcTo = function(Q, _e, be, Ce, Oe) {
    throw new Error("arcTo not implemented.");
  }, q.prototype.rect = function(Q, _e, be, Ce) {
    if (isNaN(Q) || isNaN(_e) || isNaN(be) || isNaN(Ce)) throw yr.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(Q, _e), this.lineTo(Q + be, _e), this.lineTo(Q + be, _e + Ce), this.lineTo(Q, _e + Ce), this.lineTo(Q, _e), this.lineTo(Q + be, _e), this.lineTo(Q, _e);
  }, q.prototype.fillRect = function(Q, _e, be, Ce) {
    if (isNaN(Q) || isNaN(_e) || isNaN(be) || isNaN(Ce)) throw yr.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!z.call(this)) {
      var Oe = {};
      this.lineCap !== "butt" && (Oe.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (Oe.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(Q, _e, be, Ce), this.fill(), Oe.hasOwnProperty("lineCap") && (this.lineCap = Oe.lineCap), Oe.hasOwnProperty("lineJoin") && (this.lineJoin = Oe.lineJoin);
    }
  }, q.prototype.strokeRect = function(Q, _e, be, Ce) {
    if (isNaN(Q) || isNaN(_e) || isNaN(be) || isNaN(Ce)) throw yr.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    pe.call(this) || (this.beginPath(), this.rect(Q, _e, be, Ce), this.stroke());
  }, q.prototype.clearRect = function(Q, _e, be, Ce) {
    if (isNaN(Q) || isNaN(_e) || isNaN(be) || isNaN(Ce)) throw yr.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(Q, _e, be, Ce));
  }, q.prototype.save = function(Q) {
    Q = typeof Q != "boolean" || Q;
    for (var _e = this.pdf.internal.getCurrentPageInfo().pageNumber, be = 0; be < this.pdf.internal.getNumberOfPages(); be++) this.pdf.setPage(be + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(_e), Q) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Ce = new M(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Ce;
    }
  }, q.prototype.restore = function(Q) {
    Q = typeof Q != "boolean" || Q;
    for (var _e = this.pdf.internal.getCurrentPageInfo().pageNumber, be = 0; be < this.pdf.internal.getNumberOfPages(); be++) this.pdf.setPage(be + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(_e), Q && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, q.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var O = function(Q) {
    var _e, be, Ce, Oe;
    if (Q.isCanvasGradient === !0 && (Q = Q.getColor()), !Q) return { r: 0, g: 0, b: 0, a: 0, style: Q };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(Q)) _e = 0, be = 0, Ce = 0, Oe = 0;
    else {
      var $e = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(Q);
      if ($e !== null) _e = parseInt($e[1]), be = parseInt($e[2]), Ce = parseInt($e[3]), Oe = 1;
      else if (($e = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(Q)) !== null) _e = parseInt($e[1]), be = parseInt($e[2]), Ce = parseInt($e[3]), Oe = parseFloat($e[4]);
      else {
        if (Oe = 1, typeof Q == "string" && Q.charAt(0) !== "#") {
          var Ue = new Ug(Q);
          Q = Ue.ok ? Ue.toHex() : "#000000";
        }
        Q.length === 4 ? (_e = Q.substring(1, 2), _e += _e, be = Q.substring(2, 3), be += be, Ce = Q.substring(3, 4), Ce += Ce) : (_e = Q.substring(1, 3), be = Q.substring(3, 5), Ce = Q.substring(5, 7)), _e = parseInt(_e, 16), be = parseInt(be, 16), Ce = parseInt(Ce, 16);
      }
    }
    return { r: _e, g: be, b: Ce, a: Oe, style: Q };
  }, z = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, pe = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  q.prototype.fillText = function(Q, _e, be, Ce) {
    if (isNaN(_e) || isNaN(be) || typeof Q != "string") throw yr.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Ce = isNaN(Ce) ? void 0 : Ce, !z.call(this)) {
      var Oe = je(this.ctx.transform.rotation), $e = this.ctx.transform.scaleX;
      re.call(this, { text: Q, x: _e, y: be, scale: $e, angle: Oe, align: this.textAlign, maxWidth: Ce });
    }
  }, q.prototype.strokeText = function(Q, _e, be, Ce) {
    if (isNaN(_e) || isNaN(be) || typeof Q != "string") throw yr.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!pe.call(this)) {
      Ce = isNaN(Ce) ? void 0 : Ce;
      var Oe = je(this.ctx.transform.rotation), $e = this.ctx.transform.scaleX;
      re.call(this, { text: Q, x: _e, y: be, scale: $e, renderingMode: "stroke", angle: Oe, align: this.textAlign, maxWidth: Ce });
    }
  }, q.prototype.measureText = function(Q) {
    if (typeof Q != "string") throw yr.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var _e = this.pdf, be = this.pdf.internal.scaleFactor, Ce = _e.internal.getFontSize(), Oe = _e.getStringUnitWidth(Q) * Ce / _e.internal.scaleFactor, $e = function(Ue) {
      var Ke = (Ue = Ue || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return Ke;
      } }), this;
    };
    return new $e({ width: Oe *= Math.round(96 * be / 72 * 1e4) / 1e4 });
  }, q.prototype.scale = function(Q, _e) {
    if (isNaN(Q) || isNaN(_e)) throw yr.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var be = new D(Q, 0, 0, _e, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(be);
  }, q.prototype.rotate = function(Q) {
    if (isNaN(Q)) throw yr.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var _e = new D(Math.cos(Q), Math.sin(Q), -Math.sin(Q), Math.cos(Q), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(_e);
  }, q.prototype.translate = function(Q, _e) {
    if (isNaN(Q) || isNaN(_e)) throw yr.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var be = new D(1, 0, 0, 1, Q, _e);
    this.ctx.transform = this.ctx.transform.multiply(be);
  }, q.prototype.transform = function(Q, _e, be, Ce, Oe, $e) {
    if (isNaN(Q) || isNaN(_e) || isNaN(be) || isNaN(Ce) || isNaN(Oe) || isNaN($e)) throw yr.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var Ue = new D(Q, _e, be, Ce, Oe, $e);
    this.ctx.transform = this.ctx.transform.multiply(Ue);
  }, q.prototype.setTransform = function(Q, _e, be, Ce, Oe, $e) {
    Q = isNaN(Q) ? 1 : Q, _e = isNaN(_e) ? 0 : _e, be = isNaN(be) ? 0 : be, Ce = isNaN(Ce) ? 1 : Ce, Oe = isNaN(Oe) ? 0 : Oe, $e = isNaN($e) ? 0 : $e, this.ctx.transform = new D(Q, _e, be, Ce, Oe, $e);
  };
  var le = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  q.prototype.drawImage = function(Q, _e, be, Ce, Oe, $e, Ue, Ke, rt) {
    var ot = this.pdf.getImageProperties(Q), vt = 1, mt = 1, Pt = 1, it = 1;
    Ce !== void 0 && Ke !== void 0 && (Pt = Ke / Ce, it = rt / Oe, vt = ot.width / Ce * Ke / Ce, mt = ot.height / Oe * rt / Oe), $e === void 0 && ($e = _e, Ue = be, _e = 0, be = 0), Ce !== void 0 && Ke === void 0 && (Ke = Ce, rt = Oe), Ce === void 0 && Ke === void 0 && (Ke = ot.width, rt = ot.height);
    for (var Y, Kt = this.ctx.transform.decompose(), Rt = je(Kt.rotate.shx), lt = new D(), xt = (lt = (lt = (lt = lt.multiply(Kt.translate)).multiply(Kt.skew)).multiply(Kt.scale)).applyToRectangle(new s($e - _e * Pt, Ue - be * it, Ce * vt, Oe * mt)), At = se.call(this, xt), Et = [], jt = 0; jt < At.length; jt += 1) Et.indexOf(At[jt]) === -1 && Et.push(At[jt]);
    if (Te(Et), this.autoPaging) for (var ni = Et[0], ii = Et[Et.length - 1], yi = ni; yi < ii + 1; yi++) {
      this.pdf.setPage(yi);
      var xi = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], pt = yi === 1 ? this.posY + this.margin[0] : this.margin[0], Jt = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], ai = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], kt = yi === 1 ? 0 : Jt + (yi - 2) * ai;
      if (this.ctx.clip_path.length !== 0) {
        var Zi = this.path;
        Y = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = fe(Y, this.posX + this.margin[3], -kt + pt + this.ctx.prevPageLastElemOffset), qe.call(this, "fill", !0), this.path = Zi;
      }
      var ft = JSON.parse(JSON.stringify(xt));
      ft = fe([ft], this.posX + this.margin[3], -kt + pt + this.ctx.prevPageLastElemOffset)[0];
      var ri = (yi > ni || yi < ii) && le.call(this);
      ri && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], xi, ai, null).clip().discardPath()), this.pdf.addImage(Q, "JPEG", ft.x, ft.y, ft.w, ft.h, null, null, Rt), ri && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(Q, "JPEG", xt.x, xt.y, xt.w, xt.h, null, null, Rt);
  };
  var se = function(Q, _e, be) {
    var Ce = [];
    _e = _e || this.pdf.internal.pageSize.width, be = be || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var Oe = this.posY + this.ctx.prevPageLastElemOffset;
    switch (Q.type) {
      default:
      case "mt":
      case "lt":
        Ce.push(Math.floor((Q.y + Oe) / be) + 1);
        break;
      case "arc":
        Ce.push(Math.floor((Q.y + Oe - Q.radius) / be) + 1), Ce.push(Math.floor((Q.y + Oe + Q.radius) / be) + 1);
        break;
      case "qct":
        var $e = Je(this.ctx.lastPoint.x, this.ctx.lastPoint.y, Q.x1, Q.y1, Q.x, Q.y);
        Ce.push(Math.floor(($e.y + Oe) / be) + 1), Ce.push(Math.floor(($e.y + $e.h + Oe) / be) + 1);
        break;
      case "bct":
        var Ue = Qe(this.ctx.lastPoint.x, this.ctx.lastPoint.y, Q.x1, Q.y1, Q.x2, Q.y2, Q.x, Q.y);
        Ce.push(Math.floor((Ue.y + Oe) / be) + 1), Ce.push(Math.floor((Ue.y + Ue.h + Oe) / be) + 1);
        break;
      case "rect":
        Ce.push(Math.floor((Q.y + Oe) / be) + 1), Ce.push(Math.floor((Q.y + Q.h + Oe) / be) + 1);
    }
    for (var Ke = 0; Ke < Ce.length; Ke += 1) for (; this.pdf.internal.getNumberOfPages() < Ce[Ke]; ) ee.call(this);
    return Ce;
  }, ee = function() {
    var Q = this.fillStyle, _e = this.strokeStyle, be = this.font, Ce = this.lineCap, Oe = this.lineWidth, $e = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = Q, this.strokeStyle = _e, this.font = be, this.lineCap = Ce, this.lineWidth = Oe, this.lineJoin = $e;
  }, fe = function(Q, _e, be) {
    for (var Ce = 0; Ce < Q.length; Ce++) switch (Q[Ce].type) {
      case "bct":
        Q[Ce].x2 += _e, Q[Ce].y2 += be;
      case "qct":
        Q[Ce].x1 += _e, Q[Ce].y1 += be;
      case "mt":
      case "lt":
      case "arc":
      default:
        Q[Ce].x += _e, Q[Ce].y += be;
    }
    return Q;
  }, Te = function(Q) {
    return Q.sort(function(_e, be) {
      return _e - be;
    });
  }, ze = function(Q, _e) {
    for (var be, Ce, Oe = this.fillStyle, $e = this.strokeStyle, Ue = this.lineCap, Ke = this.lineWidth, rt = Math.abs(Ke * this.ctx.transform.scaleX), ot = this.lineJoin, vt = JSON.parse(JSON.stringify(this.path)), mt = JSON.parse(JSON.stringify(this.path)), Pt = [], it = 0; it < mt.length; it++) if (mt[it].x !== void 0) for (var Y = se.call(this, mt[it]), Kt = 0; Kt < Y.length; Kt += 1) Pt.indexOf(Y[Kt]) === -1 && Pt.push(Y[Kt]);
    for (var Rt = 0; Rt < Pt.length; Rt++) for (; this.pdf.internal.getNumberOfPages() < Pt[Rt]; ) ee.call(this);
    if (Te(Pt), this.autoPaging) for (var lt = Pt[0], xt = Pt[Pt.length - 1], At = lt; At < xt + 1; At++) {
      this.pdf.setPage(At), this.fillStyle = Oe, this.strokeStyle = $e, this.lineCap = Ue, this.lineWidth = rt, this.lineJoin = ot;
      var Et = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], jt = At === 1 ? this.posY + this.margin[0] : this.margin[0], ni = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], ii = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], yi = At === 1 ? 0 : ni + (At - 2) * ii;
      if (this.ctx.clip_path.length !== 0) {
        var xi = this.path;
        be = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = fe(be, this.posX + this.margin[3], -yi + jt + this.ctx.prevPageLastElemOffset), qe.call(this, Q, !0), this.path = xi;
      }
      if (Ce = JSON.parse(JSON.stringify(vt)), this.path = fe(Ce, this.posX + this.margin[3], -yi + jt + this.ctx.prevPageLastElemOffset), _e === !1 || At === 0) {
        var pt = (At > lt || At < xt) && le.call(this);
        pt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Et, ii, null).clip().discardPath()), qe.call(this, Q, _e), pt && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = Ke;
    }
    else this.lineWidth = rt, qe.call(this, Q, _e), this.lineWidth = Ke;
    this.path = vt;
  }, qe = function(Q, _e) {
    if ((Q !== "stroke" || _e || !pe.call(this)) && (Q === "stroke" || _e || !z.call(this))) {
      for (var be, Ce, Oe = [], $e = this.path, Ue = 0; Ue < $e.length; Ue++) {
        var Ke = $e[Ue];
        switch (Ke.type) {
          case "begin":
            Oe.push({ begin: !0 });
            break;
          case "close":
            Oe.push({ close: !0 });
            break;
          case "mt":
            Oe.push({ start: Ke, deltas: [], abs: [] });
            break;
          case "lt":
            var rt = Oe.length;
            if ($e[Ue - 1] && !isNaN($e[Ue - 1].x) && (be = [Ke.x - $e[Ue - 1].x, Ke.y - $e[Ue - 1].y], rt > 0)) {
              for (; rt >= 0; rt--) if (Oe[rt - 1].close !== !0 && Oe[rt - 1].begin !== !0) {
                Oe[rt - 1].deltas.push(be), Oe[rt - 1].abs.push(Ke);
                break;
              }
            }
            break;
          case "bct":
            be = [Ke.x1 - $e[Ue - 1].x, Ke.y1 - $e[Ue - 1].y, Ke.x2 - $e[Ue - 1].x, Ke.y2 - $e[Ue - 1].y, Ke.x - $e[Ue - 1].x, Ke.y - $e[Ue - 1].y], Oe[Oe.length - 1].deltas.push(be);
            break;
          case "qct":
            var ot = $e[Ue - 1].x + 2 / 3 * (Ke.x1 - $e[Ue - 1].x), vt = $e[Ue - 1].y + 2 / 3 * (Ke.y1 - $e[Ue - 1].y), mt = Ke.x + 2 / 3 * (Ke.x1 - Ke.x), Pt = Ke.y + 2 / 3 * (Ke.y1 - Ke.y), it = Ke.x, Y = Ke.y;
            be = [ot - $e[Ue - 1].x, vt - $e[Ue - 1].y, mt - $e[Ue - 1].x, Pt - $e[Ue - 1].y, it - $e[Ue - 1].x, Y - $e[Ue - 1].y], Oe[Oe.length - 1].deltas.push(be);
            break;
          case "arc":
            Oe.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(Oe[Oe.length - 1].abs) && Oe[Oe.length - 1].abs.push(Ke);
        }
      }
      Ce = _e ? null : Q === "stroke" ? "stroke" : "fill";
      for (var Kt = !1, Rt = 0; Rt < Oe.length; Rt++) if (Oe[Rt].arc) for (var lt = Oe[Rt].abs, xt = 0; xt < lt.length; xt++) {
        var At = lt[xt];
        At.type === "arc" ? Ae.call(this, At.x, At.y, At.radius, At.startAngle, At.endAngle, At.counterclockwise, void 0, _e, !Kt) : xe.call(this, At.x, At.y), Kt = !0;
      }
      else if (Oe[Rt].close === !0) this.pdf.internal.out("h"), Kt = !1;
      else if (Oe[Rt].begin !== !0) {
        var Et = Oe[Rt].start.x, jt = Oe[Rt].start.y;
        ye.call(this, Oe[Rt].deltas, Et, jt), Kt = !0;
      }
      Ce && me.call(this, Ce), _e && ve.call(this);
    }
  }, at = function(Q) {
    var _e = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, be = _e * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return Q - be;
      case "top":
        return Q + _e - be;
      case "hanging":
        return Q + _e - 2 * be;
      case "middle":
        return Q + _e / 2 - be;
      case "ideographic":
        return Q;
      case "alphabetic":
      default:
        return Q;
    }
  }, Ie = function(Q) {
    return Q + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  q.prototype.createLinearGradient = function() {
    var Q = function() {
    };
    return Q.colorStops = [], Q.addColorStop = function(_e, be) {
      this.colorStops.push([_e, be]);
    }, Q.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, Q.isCanvasGradient = !0, Q;
  }, q.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, q.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var Ae = function(Q, _e, be, Ce, Oe, $e, Ue, Ke, rt) {
    for (var ot = He.call(this, be, Ce, Oe, $e), vt = 0; vt < ot.length; vt++) {
      var mt = ot[vt];
      vt === 0 && (rt ? X.call(this, mt.x1 + Q, mt.y1 + _e) : xe.call(this, mt.x1 + Q, mt.y1 + _e)), Ve.call(this, Q, _e, mt.x2, mt.y2, mt.x3, mt.y3, mt.x4, mt.y4);
    }
    Ke ? ve.call(this) : me.call(this, Ue);
  }, me = function(Q) {
    switch (Q) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, ve = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, X = function(Q, _e) {
    this.pdf.internal.out(l(Q) + " " + m(_e) + " m");
  }, re = function(Q) {
    var _e;
    switch (Q.align) {
      case "right":
      case "end":
        _e = "right";
        break;
      case "center":
        _e = "center";
        break;
      case "left":
      case "start":
      default:
        _e = "left";
    }
    var be = this.pdf.getTextDimensions(Q.text), Ce = at.call(this, Q.y), Oe = Ie.call(this, Ce) - be.h, $e = this.ctx.transform.applyToPoint(new g(Q.x, Ce)), Ue = this.ctx.transform.decompose(), Ke = new D();
    Ke = (Ke = (Ke = Ke.multiply(Ue.translate)).multiply(Ue.skew)).multiply(Ue.scale);
    for (var rt, ot, vt, mt = this.ctx.transform.applyToRectangle(new s(Q.x, Ce, be.w, be.h)), Pt = Ke.applyToRectangle(new s(Q.x, Oe, be.w, be.h)), it = se.call(this, Pt), Y = [], Kt = 0; Kt < it.length; Kt += 1) Y.indexOf(it[Kt]) === -1 && Y.push(it[Kt]);
    if (Te(Y), this.autoPaging) for (var Rt = Y[0], lt = Y[Y.length - 1], xt = Rt; xt < lt + 1; xt++) {
      this.pdf.setPage(xt);
      var At = xt === 1 ? this.posY + this.margin[0] : this.margin[0], Et = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], jt = this.pdf.internal.pageSize.height - this.margin[2], ni = jt - this.margin[0], ii = this.pdf.internal.pageSize.width - this.margin[1], yi = ii - this.margin[3], xi = xt === 1 ? 0 : Et + (xt - 2) * ni;
      if (this.ctx.clip_path.length !== 0) {
        var pt = this.path;
        rt = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = fe(rt, this.posX + this.margin[3], -1 * xi + At), qe.call(this, "fill", !0), this.path = pt;
      }
      var Jt = fe([JSON.parse(JSON.stringify(Pt))], this.posX + this.margin[3], -xi + At + this.ctx.prevPageLastElemOffset)[0];
      Q.scale >= 0.01 && (ot = this.pdf.internal.getFontSize(), this.pdf.setFontSize(ot * Q.scale), vt = this.lineWidth, this.lineWidth = vt * Q.scale);
      var ai = this.autoPaging !== "text";
      if (ai || Jt.y + Jt.h <= jt) {
        if (ai || Jt.y >= At && Jt.x <= ii) {
          var kt = ai ? Q.text : this.pdf.splitTextToSize(Q.text, Q.maxWidth || ii - Jt.x)[0], Zi = fe([JSON.parse(JSON.stringify(mt))], this.posX + this.margin[3], -xi + At + this.ctx.prevPageLastElemOffset)[0], ft = ai && (xt > Rt || xt < lt) && le.call(this);
          ft && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], yi, ni, null).clip().discardPath()), this.pdf.text(kt, Zi.x, Zi.y, { angle: Q.angle, align: _e, renderingMode: Q.renderingMode }), ft && this.pdf.restoreGraphicsState();
        }
      } else Jt.y < jt && (this.ctx.prevPageLastElemOffset += jt - Jt.y);
      Q.scale >= 0.01 && (this.pdf.setFontSize(ot), this.lineWidth = vt);
    }
    else Q.scale >= 0.01 && (ot = this.pdf.internal.getFontSize(), this.pdf.setFontSize(ot * Q.scale), vt = this.lineWidth, this.lineWidth = vt * Q.scale), this.pdf.text(Q.text, $e.x + this.posX, $e.y + this.posY, { angle: Q.angle, align: _e, renderingMode: Q.renderingMode, maxWidth: Q.maxWidth }), Q.scale >= 0.01 && (this.pdf.setFontSize(ot), this.lineWidth = vt);
  }, xe = function(Q, _e, be, Ce) {
    be = be || 0, Ce = Ce || 0, this.pdf.internal.out(l(Q + be) + " " + m(_e + Ce) + " l");
  }, ye = function(Q, _e, be) {
    return this.pdf.lines(Q, _e, be, null, null);
  }, Ve = function(Q, _e, be, Ce, Oe, $e, Ue, Ke) {
    this.pdf.internal.out([d(w(be + Q)), d(v(Ce + _e)), d(w(Oe + Q)), d(v($e + _e)), d(w(Ue + Q)), d(v(Ke + _e)), "c"].join(" "));
  }, He = function(Q, _e, be, Ce) {
    for (var Oe = 2 * Math.PI, $e = Math.PI / 2; _e > be; ) _e -= Oe;
    var Ue = Math.abs(be - _e);
    Ue < Oe && Ce && (Ue = Oe - Ue);
    for (var Ke = [], rt = Ce ? -1 : 1, ot = _e; Ue > 1e-5; ) {
      var vt = ot + rt * Math.min(Ue, $e);
      Ke.push(Ze.call(this, Q, ot, vt)), Ue -= Math.abs(vt - ot), ot = vt;
    }
    return Ke;
  }, Ze = function(Q, _e, be) {
    var Ce = (be - _e) / 2, Oe = Q * Math.cos(Ce), $e = Q * Math.sin(Ce), Ue = Oe, Ke = -$e, rt = Ue * Ue + Ke * Ke, ot = rt + Ue * Oe + Ke * $e, vt = 4 / 3 * (Math.sqrt(2 * rt * ot) - ot) / (Ue * $e - Ke * Oe), mt = Ue - vt * Ke, Pt = Ke + vt * Ue, it = mt, Y = -Pt, Kt = Ce + _e, Rt = Math.cos(Kt), lt = Math.sin(Kt);
    return { x1: Q * Math.cos(_e), y1: Q * Math.sin(_e), x2: mt * Rt - Pt * lt, y2: mt * lt + Pt * Rt, x3: it * Rt - Y * lt, y3: it * lt + Y * Rt, x4: Q * Math.cos(be), y4: Q * Math.sin(be) };
  }, je = function(Q) {
    return 180 * Q / Math.PI;
  }, Je = function(Q, _e, be, Ce, Oe, $e) {
    var Ue = Q + 0.5 * (be - Q), Ke = _e + 0.5 * (Ce - _e), rt = Oe + 0.5 * (be - Oe), ot = $e + 0.5 * (Ce - $e), vt = Math.min(Q, Oe, Ue, rt), mt = Math.max(Q, Oe, Ue, rt), Pt = Math.min(_e, $e, Ke, ot), it = Math.max(_e, $e, Ke, ot);
    return new s(vt, Pt, mt - vt, it - Pt);
  }, Qe = function(Q, _e, be, Ce, Oe, $e, Ue, Ke) {
    var rt, ot, vt, mt, Pt, it, Y, Kt, Rt, lt, xt, At, Et, jt, ni = be - Q, ii = Ce - _e, yi = Oe - be, xi = $e - Ce, pt = Ue - Oe, Jt = Ke - $e;
    for (ot = 0; ot < 41; ot++) Rt = (Y = (vt = Q + (rt = ot / 40) * ni) + rt * ((Pt = be + rt * yi) - vt)) + rt * (Pt + rt * (Oe + rt * pt - Pt) - Y), lt = (Kt = (mt = _e + rt * ii) + rt * ((it = Ce + rt * xi) - mt)) + rt * (it + rt * ($e + rt * Jt - it) - Kt), ot == 0 ? (xt = Rt, At = lt, Et = Rt, jt = lt) : (xt = Math.min(xt, Rt), At = Math.min(At, lt), Et = Math.max(Et, Rt), jt = Math.max(jt, lt));
    return new s(Math.round(xt), Math.round(At), Math.round(Et - xt), Math.round(jt - At));
  }, nt = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var Q, _e, be = (Q = this.ctx.lineDash, _e = this.ctx.lineDashOffset, JSON.stringify({ lineDash: Q, lineDashOffset: _e }));
      this.prevLineDash !== be && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = be);
    }
  };
})(wi.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(a) {
  var d = function(v) {
    var g, s, D, k, M, q, O, z, pe, le;
    for (s = [], D = 0, k = (v += g = "\0\0\0\0".slice(v.length % 4 || 4)).length; k > D; D += 4) (M = (v.charCodeAt(D) << 24) + (v.charCodeAt(D + 1) << 16) + (v.charCodeAt(D + 2) << 8) + v.charCodeAt(D + 3)) !== 0 ? (q = (M = ((M = ((M = ((M = (M - (le = M % 85)) / 85) - (pe = M % 85)) / 85) - (z = M % 85)) / 85) - (O = M % 85)) / 85) % 85, s.push(q + 33, O + 33, z + 33, pe + 33, le + 33)) : s.push(122);
    return function(se, ee) {
      for (var fe = ee; fe > 0; fe--) se.pop();
    }(s, g.length), String.fromCharCode.apply(String, s) + "~>";
  }, l = function(v) {
    var g, s, D, k, M, q = String, O = "length", z = 255, pe = "charCodeAt", le = "slice", se = "replace";
    for (v[le](-2), v = v[le](0, -2)[se](/\s/g, "")[se]("z", "!!!!!"), D = [], k = 0, M = (v += g = "uuuuu"[le](v[O] % 5 || 5))[O]; M > k; k += 5) s = 52200625 * (v[pe](k) - 33) + 614125 * (v[pe](k + 1) - 33) + 7225 * (v[pe](k + 2) - 33) + 85 * (v[pe](k + 3) - 33) + (v[pe](k + 4) - 33), D.push(z & s >> 24, z & s >> 16, z & s >> 8, z & s);
    return function(ee, fe) {
      for (var Te = fe; Te > 0; Te--) ee.pop();
    }(D, g[O]), q.fromCharCode.apply(q, D);
  }, m = function(v) {
    var g = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((v = v.replace(/\s/g, "")).indexOf(">") !== -1 && (v = v.substr(0, v.indexOf(">"))), v.length % 2 && (v += "0"), g.test(v) === !1) return "";
    for (var s = "", D = 0; D < v.length; D += 2) s += String.fromCharCode("0x" + (v[D] + v[D + 1]));
    return s;
  }, w = function(v) {
    for (var g = new Uint8Array(v.length), s = v.length; s--; ) g[s] = v.charCodeAt(s);
    return v = (g = Vp(g)).reduce(function(D, k) {
      return D + String.fromCharCode(k);
    }, "");
  };
  a.processDataByFilters = function(v, g) {
    var s = 0, D = v || "", k = [];
    for (typeof (g = g || []) == "string" && (g = [g]), s = 0; s < g.length; s += 1) switch (g[s]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        D = l(D), k.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        D = d(D), k.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        D = m(D), k.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        D = D.split("").map(function(M) {
          return ("0" + M.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", k.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        D = w(D), k.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + g[s] + '" is not implemented');
    }
    return { data: D, reverseChain: k.reverse().join(" ") };
  };
}(wi.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(a) {
  a.loadFile = function(d, l, m) {
    return function(w, v, g) {
      v = v !== !1, g = typeof g == "function" ? g : function() {
      };
      var s = void 0;
      try {
        s = function(D, k, M) {
          var q = new XMLHttpRequest(), O = 0, z = function(pe) {
            var le = pe.length, se = [], ee = String.fromCharCode;
            for (O = 0; O < le; O += 1) se.push(ee(255 & pe.charCodeAt(O)));
            return se.join("");
          };
          if (q.open("GET", D, !k), q.overrideMimeType("text/plain; charset=x-user-defined"), k === !1 && (q.onload = function() {
            q.status === 200 ? M(z(this.responseText)) : M(void 0);
          }), q.send(null), k && q.status === 200) return z(q.responseText);
        }(w, v, g);
      } catch {
      }
      return s;
    }(d, l, m);
  }, a.loadImageFile = a.loadFile;
}(wi.API), function(a) {
  function d() {
    return (Ai.html2canvas ? Promise.resolve(Ai.html2canvas) : import("./html2canvas.esm-d2sM-0Wm-BdPOovWT.js")).catch(function(g) {
      return Promise.reject(new Error("Could not load html2canvas: " + g));
    }).then(function(g) {
      return g.default ? g.default : g;
    });
  }
  function l() {
    return (Ai.DOMPurify ? Promise.resolve(Ai.DOMPurify) : import("./purify.es-BwOkayRK--f1u9f-k.js")).catch(function(g) {
      return Promise.reject(new Error("Could not load dompurify: " + g));
    }).then(function(g) {
      return g.default ? g.default : g;
    });
  }
  var m = function(g) {
    var s = ur(g);
    return s === "undefined" ? "undefined" : s === "string" || g instanceof String ? "string" : s === "number" || g instanceof Number ? "number" : s === "function" || g instanceof Function ? "function" : g && g.constructor === Array ? "array" : g && g.nodeType === 1 ? "element" : s === "object" ? "object" : "unknown";
  }, w = function(g, s) {
    var D = document.createElement(g);
    for (var k in s.className && (D.className = s.className), s.innerHTML && s.dompurify && (D.innerHTML = s.dompurify.sanitize(s.innerHTML)), s.style) D.style[k] = s.style[k];
    return D;
  }, v = function g(s) {
    var D = Object.assign(g.convert(Promise.resolve()), JSON.parse(JSON.stringify(g.template))), k = g.convert(Promise.resolve(), D);
    return k = (k = k.setProgress(1, g, 1, [g])).set(s);
  };
  (v.prototype = Object.create(Promise.prototype)).constructor = v, v.convert = function(g, s) {
    return g.__proto__ = s || v.prototype, g;
  }, v.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, v.prototype.from = function(g, s) {
    return this.then(function() {
      switch (s = s || function(D) {
        switch (m(D)) {
          case "string":
            return "string";
          case "element":
            return D.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(g)) {
        case "string":
          return this.then(l).then(function(D) {
            return this.set({ src: w("div", { innerHTML: g, dompurify: D }) });
          });
        case "element":
          return this.set({ src: g });
        case "canvas":
          return this.set({ canvas: g });
        case "img":
          return this.set({ img: g });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, v.prototype.to = function(g) {
    switch (g) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, v.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var g = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, s = function D(k, M) {
        for (var q = k.nodeType === 3 ? document.createTextNode(k.nodeValue) : k.cloneNode(!1), O = k.firstChild; O; O = O.nextSibling) M !== !0 && O.nodeType === 1 && O.nodeName === "SCRIPT" || q.appendChild(D(O, M));
        return k.nodeType === 1 && (k.nodeName === "CANVAS" ? (q.width = k.width, q.height = k.height, q.getContext("2d").drawImage(k, 0, 0)) : k.nodeName !== "TEXTAREA" && k.nodeName !== "SELECT" || (q.value = k.value), q.addEventListener("load", function() {
          q.scrollTop = k.scrollTop, q.scrollLeft = k.scrollLeft;
        }, !0)), q;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      s.tagName === "BODY" && (g.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = w("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = w("div", { className: "html2pdf__container", style: g }), this.prop.container.appendChild(s), this.prop.container.firstChild.appendChild(w("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, v.prototype.toCanvas = function() {
    var g = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(g).then(d).then(function(s) {
      var D = Object.assign({}, this.opt.html2canvas);
      return delete D.onrendered, s(this.prop.container, D);
    }).then(function(s) {
      (this.opt.html2canvas.onrendered || function() {
      })(s), this.prop.canvas = s, document.body.removeChild(this.prop.overlay);
    });
  }, v.prototype.toContext2d = function() {
    var g = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(g).then(d).then(function(s) {
      var D = this.opt.jsPDF, k = this.opt.fontFaces, M = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, q = Object.assign({ async: !0, allowTaint: !0, scale: M, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete q.onrendered, D.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, D.context2d.posX = this.opt.x, D.context2d.posY = this.opt.y, D.context2d.margin = this.opt.margin, D.context2d.fontFaces = k, k) for (var O = 0; O < k.length; ++O) {
        var z = k[O], pe = z.src.find(function(le) {
          return le.format === "truetype";
        });
        pe && D.addFont(pe.url, z.ref.name, z.ref.style);
      }
      return q.windowHeight = q.windowHeight || 0, q.windowHeight = q.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : q.windowHeight, D.context2d.save(!0), s(this.prop.container, q);
    }).then(function(s) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(s), this.prop.canvas = s, document.body.removeChild(this.prop.overlay);
    });
  }, v.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var g = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = g;
    });
  }, v.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, v.prototype.output = function(g, s, D) {
    return (D = D || "pdf").toLowerCase() === "img" || D.toLowerCase() === "image" ? this.outputImg(g, s) : this.outputPdf(g, s);
  }, v.prototype.outputPdf = function(g, s) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(g, s);
    });
  }, v.prototype.outputImg = function(g) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (g) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + g + '" is not supported.';
      }
    });
  }, v.prototype.save = function(g) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(g ? { filename: g } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, v.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, v.prototype.set = function(g) {
    if (m(g) !== "object") return this;
    var s = Object.keys(g || {}).map(function(D) {
      if (D in v.template.prop) return function() {
        this.prop[D] = g[D];
      };
      switch (D) {
        case "margin":
          return this.setMargin.bind(this, g.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = g.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, g.pageSize);
        default:
          return function() {
            this.opt[D] = g[D];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(s);
    });
  }, v.prototype.get = function(g, s) {
    return this.then(function() {
      var D = g in v.template.prop ? this.prop[g] : this.opt[g];
      return s ? s(D) : D;
    });
  }, v.prototype.setMargin = function(g) {
    return this.then(function() {
      switch (m(g)) {
        case "number":
          g = [g, g, g, g];
        case "array":
          if (g.length === 2 && (g = [g[0], g[1], g[0], g[1]]), g.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = g;
    }).then(this.setPageSize);
  }, v.prototype.setPageSize = function(g) {
    function s(D, k) {
      return Math.floor(D * k / 72 * 96);
    }
    return this.then(function() {
      (g = g || wi.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (g.inner = { width: g.width - this.opt.margin[1] - this.opt.margin[3], height: g.height - this.opt.margin[0] - this.opt.margin[2] }, g.inner.px = { width: s(g.inner.width, g.k), height: s(g.inner.height, g.k) }, g.inner.ratio = g.inner.height / g.inner.width), this.prop.pageSize = g;
    });
  }, v.prototype.setProgress = function(g, s, D, k) {
    return g != null && (this.progress.val = g), s != null && (this.progress.state = s), D != null && (this.progress.n = D), k != null && (this.progress.stack = k), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, v.prototype.updateProgress = function(g, s, D, k) {
    return this.setProgress(g ? this.progress.val + g : null, s || null, D ? this.progress.n + D : null, k ? this.progress.stack.concat(k) : null);
  }, v.prototype.then = function(g, s) {
    var D = this;
    return this.thenCore(g, s, function(k, M) {
      return D.updateProgress(null, null, 1, [k]), Promise.prototype.then.call(this, function(q) {
        return D.updateProgress(null, k), q;
      }).then(k, M).then(function(q) {
        return D.updateProgress(1), q;
      });
    });
  }, v.prototype.thenCore = function(g, s, D) {
    D = D || Promise.prototype.then, g && (g = g.bind(this)), s && (s = s.bind(this));
    var k = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : v.convert(Object.assign({}, this), Promise.prototype), M = D.call(k, g, s);
    return v.convert(M, this.__proto__);
  }, v.prototype.thenExternal = function(g, s) {
    return Promise.prototype.then.call(this, g, s);
  }, v.prototype.thenList = function(g) {
    var s = this;
    return g.forEach(function(D) {
      s = s.thenCore(D);
    }), s;
  }, v.prototype.catch = function(g) {
    g && (g = g.bind(this));
    var s = Promise.prototype.catch.call(this, g);
    return v.convert(s, this);
  }, v.prototype.catchExternal = function(g) {
    return Promise.prototype.catch.call(this, g);
  }, v.prototype.error = function(g) {
    return this.then(function() {
      throw new Error(g);
    });
  }, v.prototype.using = v.prototype.set, v.prototype.saveAs = v.prototype.save, v.prototype.export = v.prototype.output, v.prototype.run = v.prototype.then, wi.getPageSize = function(g, s, D) {
    if (ur(g) === "object") {
      var k = g;
      g = k.orientation, s = k.unit || s, D = k.format || D;
    }
    s = s || "mm", D = D || "a4", g = ("" + (g || "P")).toLowerCase();
    var M, q = ("" + D).toLowerCase(), O = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (s) {
      case "pt":
        M = 1;
        break;
      case "mm":
        M = 72 / 25.4;
        break;
      case "cm":
        M = 72 / 2.54;
        break;
      case "in":
        M = 72;
        break;
      case "px":
        M = 0.75;
        break;
      case "pc":
      case "em":
        M = 12;
        break;
      case "ex":
        M = 6;
        break;
      default:
        throw "Invalid unit: " + s;
    }
    var z, pe = 0, le = 0;
    if (O.hasOwnProperty(q)) pe = O[q][1] / M, le = O[q][0] / M;
    else try {
      pe = D[1], le = D[0];
    } catch {
      throw new Error("Invalid format: " + D);
    }
    if (g === "p" || g === "portrait") g = "p", le > pe && (z = le, le = pe, pe = z);
    else {
      if (g !== "l" && g !== "landscape") throw "Invalid orientation: " + g;
      g = "l", pe > le && (z = le, le = pe, pe = z);
    }
    return { width: le, height: pe, unit: s, k: M, orientation: g };
  }, a.html = function(g, s) {
    (s = s || {}).callback = s.callback || function() {
    }, s.html2canvas = s.html2canvas || {}, s.html2canvas.canvas = s.html2canvas.canvas || this.canvas, s.jsPDF = s.jsPDF || this, s.fontFaces = s.fontFaces ? s.fontFaces.map(Xp) : null;
    var D = new v(s);
    return s.worker ? D : D.from(g).doCallback();
  };
}(wi.API), wi.API.addJS = function(a) {
  return R0 = a, this.internal.events.subscribe("postPutResources", function() {
    Wh = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Wh + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), B0 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + R0 + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Wh !== void 0 && B0 !== void 0 && this.internal.out("/Names <</JavaScript " + Wh + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(a) {
  var d;
  a.events.push(["postPutResources", function() {
    var l = this, m = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var w = l.outline.render().split(/\r\n/), v = 0; v < w.length; v++) {
      var g = w[v], s = m.exec(g);
      if (s != null) {
        var D = s[1];
        l.internal.newObjectDeferredBegin(D, !1);
      }
      l.internal.write(g);
    }
    if (this.outline.createNamedDestinations) {
      var k = this.internal.pages.length, M = [];
      for (v = 0; v < k; v++) {
        var q = l.internal.newObject();
        M.push(q);
        var O = l.internal.getPageInfo(v + 1);
        l.internal.write("<< /D[" + O.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var z = l.internal.newObject();
      for (l.internal.write("<< /Names [ "), v = 0; v < M.length; v++) l.internal.write("(page_" + (v + 1) + ")" + M[v] + " 0 R");
      l.internal.write(" ] >>", "endobj"), d = l.internal.newObject(), l.internal.write("<< /Dests " + z + " 0 R"), l.internal.write(">>", "endobj");
    }
  }]), a.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + d + " 0 R"));
  }]), a.events.push(["initialized", function() {
    var l = this;
    l.outline = { createNamedDestinations: !1, root: { children: [] } }, l.outline.add = function(m, w, v) {
      var g = { title: w, options: v, children: [] };
      return m == null && (m = this.root), m.children.push(g), g;
    }, l.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = l, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, l.outline.genIds_r = function(m) {
      m.id = l.internal.newObjectDeferred();
      for (var w = 0; w < m.children.length; w++) this.genIds_r(m.children[w]);
    }, l.outline.renderRoot = function(m) {
      this.objStart(m), this.line("/Type /Outlines"), m.children.length > 0 && (this.line("/First " + this.makeRef(m.children[0])), this.line("/Last " + this.makeRef(m.children[m.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, m)), this.objEnd();
    }, l.outline.renderItems = function(m) {
      for (var w = this.ctx.pdf.internal.getVerticalCoordinateString, v = 0; v < m.children.length; v++) {
        var g = m.children[v];
        this.objStart(g), this.line("/Title " + this.makeString(g.title)), this.line("/Parent " + this.makeRef(m)), v > 0 && this.line("/Prev " + this.makeRef(m.children[v - 1])), v < m.children.length - 1 && this.line("/Next " + this.makeRef(m.children[v + 1])), g.children.length > 0 && (this.line("/First " + this.makeRef(g.children[0])), this.line("/Last " + this.makeRef(g.children[g.children.length - 1])));
        var s = this.count = this.count_r({ count: 0 }, g);
        if (s > 0 && this.line("/Count " + s), g.options && g.options.pageNumber) {
          var D = l.internal.getPageInfo(g.options.pageNumber);
          this.line("/Dest [" + D.objId + " 0 R /XYZ 0 " + w(0) + " 0]");
        }
        this.objEnd();
      }
      for (var k = 0; k < m.children.length; k++) this.renderItems(m.children[k]);
    }, l.outline.line = function(m) {
      this.ctx.val += m + `\r
`;
    }, l.outline.makeRef = function(m) {
      return m.id + " 0 R";
    }, l.outline.makeString = function(m) {
      return "(" + l.internal.pdfEscape(m) + ")";
    }, l.outline.objStart = function(m) {
      this.ctx.val += `\r
` + m.id + ` 0 obj\r
<<\r
`;
    }, l.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, l.outline.count_r = function(m, w) {
      for (var v = 0; v < w.children.length; v++) m.count++, this.count_r(m, w.children[v]);
      return m.count;
    };
  }]);
}(wi.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(a) {
  var d = [192, 193, 194, 195, 196, 197, 198, 199];
  a.processJPEG = function(l, m, w, v, g, s) {
    var D, k = this.decode.DCT_DECODE, M = null;
    if (typeof l == "string" || this.__addimage__.isArrayBuffer(l) || this.__addimage__.isArrayBufferView(l)) {
      switch (l = g || l, l = this.__addimage__.isArrayBuffer(l) ? new Uint8Array(l) : l, (D = function(q) {
        for (var O, z = 256 * q.charCodeAt(4) + q.charCodeAt(5), pe = q.length, le = { width: 0, height: 0, numcomponents: 1 }, se = 4; se < pe; se += 2) {
          if (se += z, d.indexOf(q.charCodeAt(se + 1)) !== -1) {
            O = 256 * q.charCodeAt(se + 5) + q.charCodeAt(se + 6), le = { width: 256 * q.charCodeAt(se + 7) + q.charCodeAt(se + 8), height: O, numcomponents: q.charCodeAt(se + 9) };
            break;
          }
          z = 256 * q.charCodeAt(se + 2) + q.charCodeAt(se + 3);
        }
        return le;
      }(l = this.__addimage__.isArrayBufferView(l) ? this.__addimage__.arrayBufferToBinaryString(l) : l)).numcomponents) {
        case 1:
          s = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          s = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          s = this.color_spaces.DEVICE_RGB;
      }
      M = { data: l, width: D.width, height: D.height, colorSpace: s, bitsPerComponent: 8, filter: k, index: m, alias: w };
    }
    return M;
  };
}(wi.API);
var sc, Xh, j0, q0, U0, Mb = function() {
  var a, d, l;
  function m(v) {
    var g, s, D, k, M, q, O, z, pe, le, se, ee, fe, Te;
    for (this.data = v, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, q = null; ; ) {
      switch (g = this.readUInt32(), pe = (function() {
        var ze, qe;
        for (qe = [], ze = 0; ze < 4; ++ze) qe.push(String.fromCharCode(this.data[this.pos++]));
        return qe;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(g);
          break;
        case "fcTL":
          q && this.animation.frames.push(q), this.pos += 4, q = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, M = this.readUInt16(), k = this.readUInt16() || 100, q.delay = 1e3 * M / k, q.disposeOp = this.data[this.pos++], q.blendOp = this.data[this.pos++], q.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (pe === "fdAT" && (this.pos += 4, g -= 4), v = (q != null ? q.data : void 0) || this.imgData, ee = 0; 0 <= g ? ee < g : ee > g; 0 <= g ? ++ee : --ee) v.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (D = this.palette.length / 3, this.transparency.indexed = this.read(g), this.transparency.indexed.length > D) throw new Error("More transparent colors than palette size");
              if ((le = D - this.transparency.indexed.length) > 0) for (fe = 0; 0 <= le ? fe < le : fe > le; 0 <= le ? ++fe : --fe) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(g)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(g);
          }
          break;
        case "tEXt":
          O = (se = this.read(g)).indexOf(0), z = String.fromCharCode.apply(String, se.slice(0, O)), this.text[z] = String.fromCharCode.apply(String, se.slice(O + 1));
          break;
        case "IEND":
          return q && this.animation.frames.push(q), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (Te = this.colorType) === 4 || Te === 6, s = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * s, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += g;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  m.prototype.read = function(v) {
    var g, s;
    for (s = [], g = 0; 0 <= v ? g < v : g > v; 0 <= v ? ++g : --g) s.push(this.data[this.pos++]);
    return s;
  }, m.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, m.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, m.prototype.decodePixels = function(v) {
    var g = this.pixelBitlength / 8, s = new Uint8Array(this.width * this.height * g), D = 0, k = this;
    if (v == null && (v = this.imgData), v.length === 0) return new Uint8Array(0);
    function M(q, O, z, pe) {
      var le, se, ee, fe, Te, ze, qe, at, Ie, Ae, me, ve, X, re, xe, ye, Ve, He, Ze, je, Je, Qe = Math.ceil((k.width - q) / z), nt = Math.ceil((k.height - O) / pe), Q = k.width == Qe && k.height == nt;
      for (re = g * Qe, ve = Q ? s : new Uint8Array(re * nt), ze = v.length, X = 0, se = 0; X < nt && D < ze; ) {
        switch (v[D++]) {
          case 0:
            for (fe = Ve = 0; Ve < re; fe = Ve += 1) ve[se++] = v[D++];
            break;
          case 1:
            for (fe = He = 0; He < re; fe = He += 1) le = v[D++], Te = fe < g ? 0 : ve[se - g], ve[se++] = (le + Te) % 256;
            break;
          case 2:
            for (fe = Ze = 0; Ze < re; fe = Ze += 1) le = v[D++], ee = (fe - fe % g) / g, xe = X && ve[(X - 1) * re + ee * g + fe % g], ve[se++] = (xe + le) % 256;
            break;
          case 3:
            for (fe = je = 0; je < re; fe = je += 1) le = v[D++], ee = (fe - fe % g) / g, Te = fe < g ? 0 : ve[se - g], xe = X && ve[(X - 1) * re + ee * g + fe % g], ve[se++] = (le + Math.floor((Te + xe) / 2)) % 256;
            break;
          case 4:
            for (fe = Je = 0; Je < re; fe = Je += 1) le = v[D++], ee = (fe - fe % g) / g, Te = fe < g ? 0 : ve[se - g], X === 0 ? xe = ye = 0 : (xe = ve[(X - 1) * re + ee * g + fe % g], ye = ee && ve[(X - 1) * re + (ee - 1) * g + fe % g]), qe = Te + xe - ye, at = Math.abs(qe - Te), Ae = Math.abs(qe - xe), me = Math.abs(qe - ye), Ie = at <= Ae && at <= me ? Te : Ae <= me ? xe : ye, ve[se++] = (le + Ie) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + v[D - 1]);
        }
        if (!Q) {
          var _e = ((O + X * pe) * k.width + q) * g, be = X * re;
          for (fe = 0; fe < Qe; fe += 1) {
            for (var Ce = 0; Ce < g; Ce += 1) s[_e++] = ve[be++];
            _e += (z - 1) * g;
          }
        }
        X++;
      }
    }
    return v = pb(v), k.interlaceMethod == 1 ? (M(0, 0, 8, 8), M(4, 0, 8, 8), M(0, 4, 4, 8), M(2, 0, 4, 4), M(0, 2, 2, 4), M(1, 0, 2, 2), M(0, 1, 1, 2)) : M(0, 0, 1, 1), s;
  }, m.prototype.decodePalette = function() {
    var v, g, s, D, k, M, q, O, z;
    for (s = this.palette, M = this.transparency.indexed || [], k = new Uint8Array((M.length || 0) + s.length), D = 0, v = 0, g = q = 0, O = s.length; q < O; g = q += 3) k[D++] = s[g], k[D++] = s[g + 1], k[D++] = s[g + 2], k[D++] = (z = M[v++]) != null ? z : 255;
    return k;
  }, m.prototype.copyToImageData = function(v, g) {
    var s, D, k, M, q, O, z, pe, le, se, ee;
    if (D = this.colors, le = null, s = this.hasAlphaChannel, this.palette.length && (le = (ee = this._decodedPalette) != null ? ee : this._decodedPalette = this.decodePalette(), D = 4, s = !0), pe = (k = v.data || v).length, q = le || g, M = O = 0, D === 1) for (; M < pe; ) z = le ? 4 * g[M / 4] : O, se = q[z++], k[M++] = se, k[M++] = se, k[M++] = se, k[M++] = s ? q[z++] : 255, O = z;
    else for (; M < pe; ) z = le ? 4 * g[M / 4] : O, k[M++] = q[z++], k[M++] = q[z++], k[M++] = q[z++], k[M++] = s ? q[z++] : 255, O = z;
  }, m.prototype.decode = function() {
    var v;
    return v = new Uint8Array(this.width * this.height * 4), this.copyToImageData(v, this.decodePixels()), v;
  };
  var w = function() {
    if (Object.prototype.toString.call(Ai) === "[object Window]") {
      try {
        d = Ai.document.createElement("canvas"), l = d.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return w(), a = function(v) {
    var g;
    if (w() === !0) return l.width = v.width, l.height = v.height, l.clearRect(0, 0, v.width, v.height), l.putImageData(v, 0, 0), (g = new Image()).src = d.toDataURL(), g;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, m.prototype.decodeFrames = function(v) {
    var g, s, D, k, M, q, O, z;
    if (this.animation) {
      for (z = [], s = M = 0, q = (O = this.animation.frames).length; M < q; s = ++M) g = O[s], D = v.createImageData(g.width, g.height), k = this.decodePixels(new Uint8Array(g.data)), this.copyToImageData(D, k), g.imageData = D, z.push(g.image = a(D));
      return z;
    }
  }, m.prototype.renderFrame = function(v, g) {
    var s, D, k;
    return s = (D = this.animation.frames)[g], k = D[g - 1], g === 0 && v.clearRect(0, 0, this.width, this.height), (k != null ? k.disposeOp : void 0) === 1 ? v.clearRect(k.xOffset, k.yOffset, k.width, k.height) : (k != null ? k.disposeOp : void 0) === 2 && v.putImageData(k.imageData, k.xOffset, k.yOffset), s.blendOp === 0 && v.clearRect(s.xOffset, s.yOffset, s.width, s.height), v.drawImage(s.image, s.xOffset, s.yOffset);
  }, m.prototype.animate = function(v) {
    var g, s, D, k, M, q, O = this;
    return s = 0, q = this.animation, k = q.numFrames, D = q.frames, M = q.numPlays, (g = function() {
      var z, pe;
      if (z = s++ % k, pe = D[z], O.renderFrame(v, z), k > 1 && s / k < M) return O.animation._timeout = setTimeout(g, pe.delay);
    })();
  }, m.prototype.stopAnimation = function() {
    var v;
    return clearTimeout((v = this.animation) != null ? v._timeout : void 0);
  }, m.prototype.render = function(v) {
    var g, s;
    return v._png && v._png.stopAnimation(), v._png = this, v.width = this.width, v.height = this.height, g = v.getContext("2d"), this.animation ? (this.decodeFrames(g), this.animate(g)) : (s = g.createImageData(this.width, this.height), this.copyToImageData(s, this.decodePixels()), g.putImageData(s, 0, 0));
  }, m;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function Nb(a) {
  var d = 0;
  if (a[d++] !== 71 || a[d++] !== 73 || a[d++] !== 70 || a[d++] !== 56 || (a[d++] + 1 & 253) != 56 || a[d++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var l = a[d++] | a[d++] << 8, m = a[d++] | a[d++] << 8, w = a[d++], v = w >> 7, g = 1 << (7 & w) + 1;
  a[d++], a[d++];
  var s = null, D = null;
  v && (s = d, D = g, d += 3 * g);
  var k = !0, M = [], q = 0, O = null, z = 0, pe = null;
  for (this.width = l, this.height = m; k && d < a.length; ) switch (a[d++]) {
    case 33:
      switch (a[d++]) {
        case 255:
          if (a[d] !== 11 || a[d + 1] == 78 && a[d + 2] == 69 && a[d + 3] == 84 && a[d + 4] == 83 && a[d + 5] == 67 && a[d + 6] == 65 && a[d + 7] == 80 && a[d + 8] == 69 && a[d + 9] == 50 && a[d + 10] == 46 && a[d + 11] == 48 && a[d + 12] == 3 && a[d + 13] == 1 && a[d + 16] == 0) d += 14, pe = a[d++] | a[d++] << 8, d++;
          else for (d += 12; ; ) {
            if (!((X = a[d++]) >= 0)) throw Error("Invalid block size");
            if (X === 0) break;
            d += X;
          }
          break;
        case 249:
          if (a[d++] !== 4 || a[d + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var le = a[d++];
          q = a[d++] | a[d++] << 8, O = a[d++], !(1 & le) && (O = null), z = le >> 2 & 7, d++;
          break;
        case 254:
          for (; ; ) {
            if (!((X = a[d++]) >= 0)) throw Error("Invalid block size");
            if (X === 0) break;
            d += X;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + a[d - 1].toString(16));
      }
      break;
    case 44:
      var se = a[d++] | a[d++] << 8, ee = a[d++] | a[d++] << 8, fe = a[d++] | a[d++] << 8, Te = a[d++] | a[d++] << 8, ze = a[d++], qe = ze >> 6 & 1, at = 1 << (7 & ze) + 1, Ie = s, Ae = D, me = !1;
      ze >> 7 && (me = !0, Ie = d, Ae = at, d += 3 * at);
      var ve = d;
      for (d++; ; ) {
        var X;
        if (!((X = a[d++]) >= 0)) throw Error("Invalid block size");
        if (X === 0) break;
        d += X;
      }
      M.push({ x: se, y: ee, width: fe, height: Te, has_local_palette: me, palette_offset: Ie, palette_size: Ae, data_offset: ve, data_length: d - ve, transparent_index: O, interlaced: !!qe, delay: q, disposal: z });
      break;
    case 59:
      k = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + a[d - 1].toString(16));
  }
  this.numFrames = function() {
    return M.length;
  }, this.loopCount = function() {
    return pe;
  }, this.frameInfo = function(re) {
    if (re < 0 || re >= M.length) throw new Error("Frame index out of range.");
    return M[re];
  }, this.decodeAndBlitFrameBGRA = function(re, xe) {
    var ye = this.frameInfo(re), Ve = ye.width * ye.height, He = new Uint8Array(Ve);
    V0(a, ye.data_offset, He, Ve);
    var Ze = ye.palette_offset, je = ye.transparent_index;
    je === null && (je = 256);
    var Je = ye.width, Qe = l - Je, nt = Je, Q = 4 * (ye.y * l + ye.x), _e = 4 * ((ye.y + ye.height) * l + ye.x), be = Q, Ce = 4 * Qe;
    ye.interlaced === !0 && (Ce += 4 * l * 7);
    for (var Oe = 8, $e = 0, Ue = He.length; $e < Ue; ++$e) {
      var Ke = He[$e];
      if (nt === 0 && (nt = Je, (be += Ce) >= _e && (Ce = 4 * Qe + 4 * l * (Oe - 1), be = Q + (Je + Qe) * (Oe << 1), Oe >>= 1)), Ke === je) be += 4;
      else {
        var rt = a[Ze + 3 * Ke], ot = a[Ze + 3 * Ke + 1], vt = a[Ze + 3 * Ke + 2];
        xe[be++] = vt, xe[be++] = ot, xe[be++] = rt, xe[be++] = 255;
      }
      --nt;
    }
  }, this.decodeAndBlitFrameRGBA = function(re, xe) {
    var ye = this.frameInfo(re), Ve = ye.width * ye.height, He = new Uint8Array(Ve);
    V0(a, ye.data_offset, He, Ve);
    var Ze = ye.palette_offset, je = ye.transparent_index;
    je === null && (je = 256);
    var Je = ye.width, Qe = l - Je, nt = Je, Q = 4 * (ye.y * l + ye.x), _e = 4 * ((ye.y + ye.height) * l + ye.x), be = Q, Ce = 4 * Qe;
    ye.interlaced === !0 && (Ce += 4 * l * 7);
    for (var Oe = 8, $e = 0, Ue = He.length; $e < Ue; ++$e) {
      var Ke = He[$e];
      if (nt === 0 && (nt = Je, (be += Ce) >= _e && (Ce = 4 * Qe + 4 * l * (Oe - 1), be = Q + (Je + Qe) * (Oe << 1), Oe >>= 1)), Ke === je) be += 4;
      else {
        var rt = a[Ze + 3 * Ke], ot = a[Ze + 3 * Ke + 1], vt = a[Ze + 3 * Ke + 2];
        xe[be++] = rt, xe[be++] = ot, xe[be++] = vt, xe[be++] = 255;
      }
      --nt;
    }
  };
}
function V0(a, d, l, m) {
  for (var w = a[d++], v = 1 << w, g = v + 1, s = g + 1, D = w + 1, k = (1 << D) - 1, M = 0, q = 0, O = 0, z = a[d++], pe = new Int32Array(4096), le = null; ; ) {
    for (; M < 16 && z !== 0; ) q |= a[d++] << M, M += 8, z === 1 ? z = a[d++] : --z;
    if (M < D) break;
    var se = q & k;
    if (q >>= D, M -= D, se !== v) {
      if (se === g) break;
      for (var ee = se < s ? se : le, fe = 0, Te = ee; Te > v; ) Te = pe[Te] >> 8, ++fe;
      var ze = Te;
      if (O + fe + (ee !== se ? 1 : 0) > m) return void yr.log("Warning, gif stream longer than expected.");
      l[O++] = ze;
      var qe = O += fe;
      for (ee !== se && (l[O++] = ze), Te = ee; fe--; ) Te = pe[Te], l[--qe] = 255 & Te, Te >>= 8;
      le !== null && s < 4096 && (pe[s++] = le << 8 | ze, s >= k + 1 && D < 12 && (++D, k = k << 1 | 1)), le = se;
    } else s = g + 1, k = (1 << (D = w + 1)) - 1, le = null;
  }
  return O !== m && yr.log("Warning, gif stream shorter than expected."), l;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Ap(a) {
  var d, l, m, w, v, g = Math.floor, s = new Array(64), D = new Array(64), k = new Array(64), M = new Array(64), q = new Array(65535), O = new Array(65535), z = new Array(64), pe = new Array(64), le = [], se = 0, ee = 7, fe = new Array(64), Te = new Array(64), ze = new Array(64), qe = new Array(256), at = new Array(2048), Ie = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], Ae = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], me = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], ve = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], X = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], re = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], xe = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], ye = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], Ve = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function He(Q, _e) {
    for (var be = 0, Ce = 0, Oe = new Array(), $e = 1; $e <= 16; $e++) {
      for (var Ue = 1; Ue <= Q[$e]; Ue++) Oe[_e[Ce]] = [], Oe[_e[Ce]][0] = be, Oe[_e[Ce]][1] = $e, Ce++, be++;
      be *= 2;
    }
    return Oe;
  }
  function Ze(Q) {
    for (var _e = Q[0], be = Q[1] - 1; be >= 0; ) _e & 1 << be && (se |= 1 << ee), be--, --ee < 0 && (se == 255 ? (je(255), je(0)) : je(se), ee = 7, se = 0);
  }
  function je(Q) {
    le.push(Q);
  }
  function Je(Q) {
    je(Q >> 8 & 255), je(255 & Q);
  }
  function Qe(Q, _e, be, Ce, Oe) {
    for (var $e, Ue = Oe[0], Ke = Oe[240], rt = function(lt, xt) {
      var At, Et, jt, ni, ii, yi, xi, pt, Jt, ai, kt = 0;
      for (Jt = 0; Jt < 8; ++Jt) {
        At = lt[kt], Et = lt[kt + 1], jt = lt[kt + 2], ni = lt[kt + 3], ii = lt[kt + 4], yi = lt[kt + 5], xi = lt[kt + 6];
        var Zi = At + (pt = lt[kt + 7]), ft = At - pt, ri = Et + xi, Lt = Et - xi, Si = jt + yi, Gi = jt - yi, zt = ni + ii, cr = ni - ii, Ni = Zi + zt, ie = Zi - zt, ue = ri + Si, $ = ri - Si;
        lt[kt] = Ni + ue, lt[kt + 4] = Ni - ue;
        var B = 0.707106781 * ($ + ie);
        lt[kt + 2] = ie + B, lt[kt + 6] = ie - B;
        var j = 0.382683433 * ((Ni = cr + Gi) - ($ = Lt + ft)), te = 0.5411961 * Ni + j, ge = 1.306562965 * $ + j, Me = 0.707106781 * (ue = Gi + Lt), Fe = ft + Me, Ne = ft - Me;
        lt[kt + 5] = Ne + te, lt[kt + 3] = Ne - te, lt[kt + 1] = Fe + ge, lt[kt + 7] = Fe - ge, kt += 8;
      }
      for (kt = 0, Jt = 0; Jt < 8; ++Jt) {
        At = lt[kt], Et = lt[kt + 8], jt = lt[kt + 16], ni = lt[kt + 24], ii = lt[kt + 32], yi = lt[kt + 40], xi = lt[kt + 48];
        var De = At + (pt = lt[kt + 56]), et = At - pt, ut = Et + xi, We = Et - xi, gt = jt + yi, Mt = jt - yi, $t = ni + ii, Qt = ni - ii, ei = De + $t, pi = De - $t, fi = ut + gt, Wi = ut - gt;
        lt[kt] = ei + fi, lt[kt + 32] = ei - fi;
        var Oi = 0.707106781 * (Wi + pi);
        lt[kt + 16] = pi + Oi, lt[kt + 48] = pi - Oi;
        var mi = 0.382683433 * ((ei = Qt + Mt) - (Wi = We + et)), Bi = 0.5411961 * ei + mi, Hi = 1.306562965 * Wi + mi, mr = 0.707106781 * (fi = Mt + We), vr = et + mr, kr = et - mr;
        lt[kt + 40] = kr + Bi, lt[kt + 24] = kr - Bi, lt[kt + 8] = vr + Hi, lt[kt + 56] = vr - Hi, kt++;
      }
      for (Jt = 0; Jt < 64; ++Jt) ai = lt[Jt] * xt[Jt], z[Jt] = ai > 0 ? ai + 0.5 | 0 : ai - 0.5 | 0;
      return z;
    }(Q, _e), ot = 0; ot < 64; ++ot) pe[Ie[ot]] = rt[ot];
    var vt = pe[0] - be;
    be = pe[0], vt == 0 ? Ze(Ce[0]) : (Ze(Ce[O[$e = 32767 + vt]]), Ze(q[$e]));
    for (var mt = 63; mt > 0 && pe[mt] == 0; ) mt--;
    if (mt == 0) return Ze(Ue), be;
    for (var Pt, it = 1; it <= mt; ) {
      for (var Y = it; pe[it] == 0 && it <= mt; ) ++it;
      var Kt = it - Y;
      if (Kt >= 16) {
        Pt = Kt >> 4;
        for (var Rt = 1; Rt <= Pt; ++Rt) Ze(Ke);
        Kt &= 15;
      }
      $e = 32767 + pe[it], Ze(Oe[(Kt << 4) + O[$e]]), Ze(q[$e]), it++;
    }
    return mt != 63 && Ze(Ue), be;
  }
  function nt(Q) {
    Q = Math.min(Math.max(Q, 1), 100), v != Q && (function(_e) {
      for (var be = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Ce = 0; Ce < 64; Ce++) {
        var Oe = g((be[Ce] * _e + 50) / 100);
        Oe = Math.min(Math.max(Oe, 1), 255), s[Ie[Ce]] = Oe;
      }
      for (var $e = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], Ue = 0; Ue < 64; Ue++) {
        var Ke = g(($e[Ue] * _e + 50) / 100);
        Ke = Math.min(Math.max(Ke, 1), 255), D[Ie[Ue]] = Ke;
      }
      for (var rt = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], ot = 0, vt = 0; vt < 8; vt++) for (var mt = 0; mt < 8; mt++) k[ot] = 1 / (s[Ie[ot]] * rt[vt] * rt[mt] * 8), M[ot] = 1 / (D[Ie[ot]] * rt[vt] * rt[mt] * 8), ot++;
    }(Q < 50 ? Math.floor(5e3 / Q) : Math.floor(200 - 2 * Q)), v = Q);
  }
  this.encode = function(Q, _e) {
    _e && nt(_e), le = new Array(), se = 0, ee = 7, Je(65496), Je(65504), Je(16), je(74), je(70), je(73), je(70), je(0), je(1), je(1), je(0), Je(1), Je(1), je(0), je(0), function() {
      Je(65499), Je(132), je(0);
      for (var Et = 0; Et < 64; Et++) je(s[Et]);
      je(1);
      for (var jt = 0; jt < 64; jt++) je(D[jt]);
    }(), function(Et, jt) {
      Je(65472), Je(17), je(8), Je(jt), Je(Et), je(3), je(1), je(17), je(0), je(2), je(17), je(1), je(3), je(17), je(1);
    }(Q.width, Q.height), function() {
      Je(65476), Je(418), je(0);
      for (var Et = 0; Et < 16; Et++) je(Ae[Et + 1]);
      for (var jt = 0; jt <= 11; jt++) je(me[jt]);
      je(16);
      for (var ni = 0; ni < 16; ni++) je(ve[ni + 1]);
      for (var ii = 0; ii <= 161; ii++) je(X[ii]);
      je(1);
      for (var yi = 0; yi < 16; yi++) je(re[yi + 1]);
      for (var xi = 0; xi <= 11; xi++) je(xe[xi]);
      je(17);
      for (var pt = 0; pt < 16; pt++) je(ye[pt + 1]);
      for (var Jt = 0; Jt <= 161; Jt++) je(Ve[Jt]);
    }(), Je(65498), Je(12), je(3), je(1), je(0), je(2), je(17), je(3), je(17), je(0), je(63), je(0);
    var be = 0, Ce = 0, Oe = 0;
    se = 0, ee = 7, this.encode.displayName = "_encode_";
    for (var $e, Ue, Ke, rt, ot, vt, mt, Pt, it, Y = Q.data, Kt = Q.width, Rt = Q.height, lt = 4 * Kt, xt = 0; xt < Rt; ) {
      for ($e = 0; $e < lt; ) {
        for (ot = lt * xt + $e, mt = -1, Pt = 0, it = 0; it < 64; it++) vt = ot + (Pt = it >> 3) * lt + (mt = 4 * (7 & it)), xt + Pt >= Rt && (vt -= lt * (xt + 1 + Pt - Rt)), $e + mt >= lt && (vt -= $e + mt - lt + 4), Ue = Y[vt++], Ke = Y[vt++], rt = Y[vt++], fe[it] = (at[Ue] + at[Ke + 256 >> 0] + at[rt + 512 >> 0] >> 16) - 128, Te[it] = (at[Ue + 768 >> 0] + at[Ke + 1024 >> 0] + at[rt + 1280 >> 0] >> 16) - 128, ze[it] = (at[Ue + 1280 >> 0] + at[Ke + 1536 >> 0] + at[rt + 1792 >> 0] >> 16) - 128;
        be = Qe(fe, k, be, d, m), Ce = Qe(Te, M, Ce, l, w), Oe = Qe(ze, M, Oe, l, w), $e += 32;
      }
      xt += 8;
    }
    if (ee >= 0) {
      var At = [];
      At[1] = ee + 1, At[0] = (1 << ee + 1) - 1, Ze(At);
    }
    return Je(65497), new Uint8Array(le);
  }, a = a || 50, function() {
    for (var Q = String.fromCharCode, _e = 0; _e < 256; _e++) qe[_e] = Q(_e);
  }(), d = He(Ae, me), l = He(re, xe), m = He(ve, X), w = He(ye, Ve), function() {
    for (var Q = 1, _e = 2, be = 1; be <= 15; be++) {
      for (var Ce = Q; Ce < _e; Ce++) O[32767 + Ce] = be, q[32767 + Ce] = [], q[32767 + Ce][1] = be, q[32767 + Ce][0] = Ce;
      for (var Oe = -(_e - 1); Oe <= -Q; Oe++) O[32767 + Oe] = be, q[32767 + Oe] = [], q[32767 + Oe][1] = be, q[32767 + Oe][0] = _e - 1 + Oe;
      Q <<= 1, _e <<= 1;
    }
  }(), function() {
    for (var Q = 0; Q < 256; Q++) at[Q] = 19595 * Q, at[Q + 256 >> 0] = 38470 * Q, at[Q + 512 >> 0] = 7471 * Q + 32768, at[Q + 768 >> 0] = -11059 * Q, at[Q + 1024 >> 0] = -21709 * Q, at[Q + 1280 >> 0] = 32768 * Q + 8421375, at[Q + 1536 >> 0] = -27439 * Q, at[Q + 1792 >> 0] = -5329 * Q;
  }(), nt(a);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function Ys(a, d) {
  if (this.pos = 0, this.buffer = a, this.datav = new DataView(a.buffer), this.is_with_alpha = !!d, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function $0(a) {
  function d(Ae) {
    if (!Ae) throw Error("assert :P");
  }
  function l(Ae, me, ve) {
    for (var X = 0; 4 > X; X++) if (Ae[me + X] != ve.charCodeAt(X)) return !0;
    return !1;
  }
  function m(Ae, me, ve, X, re) {
    for (var xe = 0; xe < re; xe++) Ae[me + xe] = ve[X + xe];
  }
  function w(Ae, me, ve, X) {
    for (var re = 0; re < X; re++) Ae[me + re] = ve;
  }
  function v(Ae) {
    return new Int32Array(Ae);
  }
  function g(Ae, me) {
    for (var ve = [], X = 0; X < Ae; X++) ve.push(new me());
    return ve;
  }
  function s(Ae, me) {
    var ve = [];
    return function X(re, xe, ye) {
      for (var Ve = ye[xe], He = 0; He < Ve && (re.push(ye.length > xe + 1 ? [] : new me()), !(ye.length < xe + 1)); He++) X(re[He], xe + 1, ye);
    }(ve, 0, Ae), ve;
  }
  var D = function() {
    var Ae = this;
    function me(y, S) {
      for (var c = 1 << S - 1 >>> 0; y & c; ) c >>>= 1;
      return c ? (y & c - 1) + c : y;
    }
    function ve(y, S, c, e, r) {
      d(!(e % c));
      do
        y[S + (e -= c)] = r;
      while (0 < e);
    }
    function X(y, S, c, e, r) {
      if (d(2328 >= r), 512 >= r) var o = v(512);
      else if ((o = v(r)) == null) return 0;
      return function(h, p, x, A, T, P) {
        var F, N, Z = p, G = 1 << x, V = v(16), W = v(16);
        for (d(T != 0), d(A != null), d(h != null), d(0 < x), N = 0; N < T; ++N) {
          if (15 < A[N]) return 0;
          ++V[A[N]];
        }
        if (V[0] == T) return 0;
        for (W[1] = 0, F = 1; 15 > F; ++F) {
          if (V[F] > 1 << F) return 0;
          W[F + 1] = W[F] + V[F];
        }
        for (N = 0; N < T; ++N) F = A[N], 0 < A[N] && (P[W[F]++] = N);
        if (W[15] == 1) return (A = new re()).g = 0, A.value = P[0], ve(h, Z, 1, G, A), G;
        var ae, oe = -1, de = G - 1, ce = 0, we = 1, Le = 1, ke = 1 << x;
        for (N = 0, F = 1, T = 2; F <= x; ++F, T <<= 1) {
          if (we += Le <<= 1, 0 > (Le -= V[F])) return 0;
          for (; 0 < V[F]; --V[F]) (A = new re()).g = F, A.value = P[N++], ve(h, Z + ce, T, ke, A), ce = me(ce, F);
        }
        for (F = x + 1, T = 2; 15 >= F; ++F, T <<= 1) {
          if (we += Le <<= 1, 0 > (Le -= V[F])) return 0;
          for (; 0 < V[F]; --V[F]) {
            if (A = new re(), (ce & de) != oe) {
              for (Z += ke, ae = 1 << (oe = F) - x; 15 > oe && !(0 >= (ae -= V[oe])); ) ++oe, ae <<= 1;
              G += ke = 1 << (ae = oe - x), h[p + (oe = ce & de)].g = ae + x, h[p + oe].value = Z - p - oe;
            }
            A.g = F - x, A.value = P[N++], ve(h, Z + (ce >> x), T, ke, A), ce = me(ce, F);
          }
        }
        return we != 2 * W[15] - 1 ? 0 : G;
      }(y, S, c, e, r, o);
    }
    function re() {
      this.value = this.g = 0;
    }
    function xe() {
      this.value = this.g = 0;
    }
    function ye() {
      this.G = g(5, re), this.H = v(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = g(Yr, xe);
    }
    function Ve(y, S, c, e) {
      d(y != null), d(S != null), d(2147483648 > e), y.Ca = 254, y.I = 0, y.b = -8, y.Ka = 0, y.oa = S, y.pa = c, y.Jd = S, y.Yc = c + e, y.Zc = 4 <= e ? c + e - 4 + 1 : c, $e(y);
    }
    function He(y, S) {
      for (var c = 0; 0 < S--; ) c |= Ke(y, 128) << S;
      return c;
    }
    function Ze(y, S) {
      var c = He(y, S);
      return Ue(y) ? -c : c;
    }
    function je(y, S, c, e) {
      var r, o = 0;
      for (d(y != null), d(S != null), d(4294967288 > e), y.Sb = e, y.Ra = 0, y.u = 0, y.h = 0, 4 < e && (e = 4), r = 0; r < e; ++r) o += S[c + r] << 8 * r;
      y.Ra = o, y.bb = e, y.oa = S, y.pa = c;
    }
    function Je(y) {
      for (; 8 <= y.u && y.bb < y.Sb; ) y.Ra >>>= 8, y.Ra += y.oa[y.pa + y.bb] << jn - 8 >>> 0, ++y.bb, y.u -= 8;
      be(y) && (y.h = 1, y.u = 0);
    }
    function Qe(y, S) {
      if (d(0 <= S), !y.h && S <= fs) {
        var c = _e(y) & ps[S];
        return y.u += S, Je(y), c;
      }
      return y.h = 1, y.u = 0;
    }
    function nt() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function Q() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function _e(y) {
      return y.Ra >>> (y.u & jn - 1) >>> 0;
    }
    function be(y) {
      return d(y.bb <= y.Sb), y.h || y.bb == y.Sb && y.u > jn;
    }
    function Ce(y, S) {
      y.u = S, y.h = be(y);
    }
    function Oe(y) {
      y.u >= Za && (d(y.u >= Za), Je(y));
    }
    function $e(y) {
      d(y != null && y.oa != null), y.pa < y.Zc ? (y.I = (y.oa[y.pa++] | y.I << 8) >>> 0, y.b += 8) : (d(y != null && y.oa != null), y.pa < y.Yc ? (y.b += 8, y.I = y.oa[y.pa++] | y.I << 8) : y.Ka ? y.b = 0 : (y.I <<= 8, y.b += 8, y.Ka = 1));
    }
    function Ue(y) {
      return He(y, 1);
    }
    function Ke(y, S) {
      var c = y.Ca;
      0 > y.b && $e(y);
      var e = y.b, r = c * S >>> 8, o = (y.I >>> e > r) + 0;
      for (o ? (c -= r, y.I -= r + 1 << e >>> 0) : c = r + 1, e = c, r = 0; 256 <= e; ) r += 8, e >>= 8;
      return e = 7 ^ r + zr[e], y.b -= e, y.Ca = (c << e) - 1, o;
    }
    function rt(y, S, c) {
      y[S + 0] = c >> 24 & 255, y[S + 1] = c >> 16 & 255, y[S + 2] = c >> 8 & 255, y[S + 3] = c >> 0 & 255;
    }
    function ot(y, S) {
      return y[S + 0] << 0 | y[S + 1] << 8;
    }
    function vt(y, S) {
      return ot(y, S) | y[S + 2] << 16;
    }
    function mt(y, S) {
      return ot(y, S) | ot(y, S + 2) << 16;
    }
    function Pt(y, S) {
      var c = 1 << S;
      return d(y != null), d(0 < S), y.X = v(c), y.X == null ? 0 : (y.Mb = 32 - S, y.Xa = S, 1);
    }
    function it(y, S) {
      d(y != null), d(S != null), d(y.Xa == S.Xa), m(S.X, 0, y.X, 0, 1 << S.Xa);
    }
    function Y() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function Kt(y, S, c, e) {
      d(c != null), d(e != null);
      var r = c[0], o = e[0];
      return r == 0 && (r = (y * o + S / 2) / S), o == 0 && (o = (S * r + y / 2) / y), 0 >= r || 0 >= o ? 0 : (c[0] = r, e[0] = o, 1);
    }
    function Rt(y, S) {
      return y + (1 << S) - 1 >>> S;
    }
    function lt(y, S) {
      return ((4278255360 & y) + (4278255360 & S) >>> 0 & 4278255360) + ((16711935 & y) + (16711935 & S) >>> 0 & 16711935) >>> 0;
    }
    function xt(y, S) {
      Ae[S] = function(c, e, r, o, h, p, x) {
        var A;
        for (A = 0; A < h; ++A) {
          var T = Ae[y](p[x + A - 1], r, o + A);
          p[x + A] = lt(c[e + A], T);
        }
      };
    }
    function At() {
      this.ud = this.hd = this.jd = 0;
    }
    function Et(y, S) {
      return ((4278124286 & (y ^ S)) >>> 1) + (y & S) >>> 0;
    }
    function jt(y) {
      return 0 <= y && 256 > y ? y : 0 > y ? 0 : 255 < y ? 255 : void 0;
    }
    function ni(y, S) {
      return jt(y + (y - S + 0.5 >> 1));
    }
    function ii(y, S, c) {
      return Math.abs(S - c) - Math.abs(y - c);
    }
    function yi(y, S, c, e, r, o, h) {
      for (e = o[h - 1], c = 0; c < r; ++c) o[h + c] = e = lt(y[S + c], e);
    }
    function xi(y, S, c, e, r) {
      var o;
      for (o = 0; o < c; ++o) {
        var h = y[S + o], p = h >> 8 & 255, x = 16711935 & (x = (x = 16711935 & h) + ((p << 16) + p));
        e[r + o] = (4278255360 & h) + x >>> 0;
      }
    }
    function pt(y, S) {
      S.jd = y >> 0 & 255, S.hd = y >> 8 & 255, S.ud = y >> 16 & 255;
    }
    function Jt(y, S, c, e, r, o) {
      var h;
      for (h = 0; h < e; ++h) {
        var p = S[c + h], x = p >>> 8, A = p, T = 255 & (T = (T = p >>> 16) + ((y.jd << 24 >> 24) * (x << 24 >> 24) >>> 5));
        A = 255 & (A = (A = A + ((y.hd << 24 >> 24) * (x << 24 >> 24) >>> 5)) + ((y.ud << 24 >> 24) * (T << 24 >> 24) >>> 5)), r[o + h] = (4278255360 & p) + (T << 16) + A;
      }
    }
    function ai(y, S, c, e, r) {
      Ae[S] = function(o, h, p, x, A, T, P, F, N) {
        for (x = P; x < F; ++x) for (P = 0; P < N; ++P) A[T++] = r(p[e(o[h++])]);
      }, Ae[y] = function(o, h, p, x, A, T, P) {
        var F = 8 >> o.b, N = o.Ea, Z = o.K[0], G = o.w;
        if (8 > F) for (o = (1 << o.b) - 1, G = (1 << F) - 1; h < p; ++h) {
          var V, W = 0;
          for (V = 0; V < N; ++V) V & o || (W = e(x[A++])), T[P++] = r(Z[W & G]), W >>= F;
        }
        else Ae["VP8LMapColor" + c](x, A, Z, G, T, P, h, p, N);
      };
    }
    function kt(y, S, c, e, r) {
      for (c = S + c; S < c; ) {
        var o = y[S++];
        e[r++] = o >> 16 & 255, e[r++] = o >> 8 & 255, e[r++] = o >> 0 & 255;
      }
    }
    function Zi(y, S, c, e, r) {
      for (c = S + c; S < c; ) {
        var o = y[S++];
        e[r++] = o >> 16 & 255, e[r++] = o >> 8 & 255, e[r++] = o >> 0 & 255, e[r++] = o >> 24 & 255;
      }
    }
    function ft(y, S, c, e, r) {
      for (c = S + c; S < c; ) {
        var o = (h = y[S++]) >> 16 & 240 | h >> 12 & 15, h = h >> 0 & 240 | h >> 28 & 15;
        e[r++] = o, e[r++] = h;
      }
    }
    function ri(y, S, c, e, r) {
      for (c = S + c; S < c; ) {
        var o = (h = y[S++]) >> 16 & 248 | h >> 13 & 7, h = h >> 5 & 224 | h >> 3 & 31;
        e[r++] = o, e[r++] = h;
      }
    }
    function Lt(y, S, c, e, r) {
      for (c = S + c; S < c; ) {
        var o = y[S++];
        e[r++] = o >> 0 & 255, e[r++] = o >> 8 & 255, e[r++] = o >> 16 & 255;
      }
    }
    function Si(y, S, c, e, r, o) {
      if (o == 0) for (c = S + c; S < c; ) rt(e, ((o = y[S++])[0] >> 24 | o[1] >> 8 & 65280 | o[2] << 8 & 16711680 | o[3] << 24) >>> 0), r += 32;
      else m(e, r, y, S, c);
    }
    function Gi(y, S) {
      Ae[S][0] = Ae[y + "0"], Ae[S][1] = Ae[y + "1"], Ae[S][2] = Ae[y + "2"], Ae[S][3] = Ae[y + "3"], Ae[S][4] = Ae[y + "4"], Ae[S][5] = Ae[y + "5"], Ae[S][6] = Ae[y + "6"], Ae[S][7] = Ae[y + "7"], Ae[S][8] = Ae[y + "8"], Ae[S][9] = Ae[y + "9"], Ae[S][10] = Ae[y + "10"], Ae[S][11] = Ae[y + "11"], Ae[S][12] = Ae[y + "12"], Ae[S][13] = Ae[y + "13"], Ae[S][14] = Ae[y + "0"], Ae[S][15] = Ae[y + "0"];
    }
    function zt(y) {
      return y == bo || y == Us || y == xo || y == nl;
    }
    function cr() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function Ni() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ie() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new cr(), this.f.kb = new Ni(), this.sd = null;
    }
    function ue() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function $() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function B(y) {
      return alert("todo:WebPSamplerProcessPlane"), y.T;
    }
    function j(y, S) {
      var c = y.T, e = S.ba.f.RGBA, r = e.eb, o = e.fb + y.ka * e.A, h = vi[S.ba.S], p = y.y, x = y.O, A = y.f, T = y.N, P = y.ea, F = y.W, N = S.cc, Z = S.dc, G = S.Mc, V = S.Nc, W = y.ka, ae = y.ka + y.T, oe = y.U, de = oe + 1 >> 1;
      for (W == 0 ? h(p, x, null, null, A, T, P, F, A, T, P, F, r, o, null, null, oe) : (h(S.ec, S.fc, p, x, N, Z, G, V, A, T, P, F, r, o - e.A, r, o, oe), ++c); W + 2 < ae; W += 2) N = A, Z = T, G = P, V = F, T += y.Rc, F += y.Rc, o += 2 * e.A, h(p, (x += 2 * y.fa) - y.fa, p, x, N, Z, G, V, A, T, P, F, r, o - e.A, r, o, oe);
      return x += y.fa, y.j + ae < y.o ? (m(S.ec, S.fc, p, x, oe), m(S.cc, S.dc, A, T, de), m(S.Mc, S.Nc, P, F, de), c--) : 1 & ae || h(p, x, null, null, A, T, P, F, A, T, P, F, r, o + e.A, null, null, oe), c;
    }
    function te(y, S, c) {
      var e = y.F, r = [y.J];
      if (e != null) {
        var o = y.U, h = S.ba.S, p = h == vo || h == xo;
        S = S.ba.f.RGBA;
        var x = [0], A = y.ka;
        x[0] = y.T, y.Kb && (A == 0 ? --x[0] : (--A, r[0] -= y.width), y.j + y.ka + y.T == y.o && (x[0] = y.o - y.j - A));
        var T = S.eb;
        A = S.fb + A * S.A, y = Ia(e, r[0], y.width, o, x, T, A + (p ? 0 : 3), S.A), d(c == x), y && zt(h) && Zn(T, A, p, o, x, S.A);
      }
      return 0;
    }
    function ge(y) {
      var S = y.ma, c = S.ba.S, e = 11 > c, r = c == js || c == qs || c == vo || c == rl || c == 12 || zt(c);
      if (S.memory = null, S.Ib = null, S.Jb = null, S.Nd = null, !ca(S.Oa, y, r ? 11 : 12)) return 0;
      if (r && zt(c) && It(), y.da) alert("todo:use_scaling");
      else {
        if (e) {
          if (S.Ib = B, y.Kb) {
            if (c = y.U + 1 >> 1, S.memory = v(y.U + 2 * c), S.memory == null) return 0;
            S.ec = S.memory, S.fc = 0, S.cc = S.ec, S.dc = S.fc + y.U, S.Mc = S.cc, S.Nc = S.dc + c, S.Ib = j, It();
          }
        } else alert("todo:EmitYUV");
        r && (S.Jb = te, e && Ye());
      }
      if (e && !Ji) {
        for (y = 0; 256 > y; ++y) Eo[y] = 89858 * (y - 128) + Ml >> ol, Ou[y] = -22014 * (y - 128) + Ml, zl[y] = -45773 * (y - 128), Nl[y] = 113618 * (y - 128) + Ml >> ol;
        for (y = Zs; y < fu; ++y) S = 76283 * (y - 16) + Ml >> ol, ll[y - Zs] = Mi(S, 255), ul[y - Zs] = Mi(S + 8 >> 4, 15);
        Ji = 1;
      }
      return 1;
    }
    function Me(y) {
      var S = y.ma, c = y.U, e = y.T;
      return d(!(1 & y.ka)), 0 >= c || 0 >= e ? 0 : (c = S.Ib(y, S), S.Jb != null && S.Jb(y, S, c), S.Dc += c, 1);
    }
    function Fe(y) {
      y.ma.memory = null;
    }
    function Ne(y, S, c, e) {
      return Qe(y, 8) != 47 ? 0 : (S[0] = Qe(y, 14) + 1, c[0] = Qe(y, 14) + 1, e[0] = Qe(y, 1), Qe(y, 3) != 0 ? 0 : !y.h);
    }
    function De(y, S) {
      if (4 > y) return y + 1;
      var c = y - 2 >> 1;
      return (2 + (1 & y) << c) + Qe(S, c) + 1;
    }
    function et(y, S) {
      return 120 < S ? S - 120 : 1 <= (c = ((c = Hn[S - 1]) >> 4) * y + (8 - (15 & c))) ? c : 1;
      var c;
    }
    function ut(y, S, c) {
      var e = _e(c), r = y[S += 255 & e].g - 8;
      return 0 < r && (Ce(c, c.u + 8), e = _e(c), S += y[S].value, S += e & (1 << r) - 1), Ce(c, c.u + y[S].g), y[S].value;
    }
    function We(y, S, c) {
      return c.g += y.g, c.value += y.value << S >>> 0, d(8 >= c.g), y.g;
    }
    function gt(y, S, c) {
      var e = y.xc;
      return d((S = e == 0 ? 0 : y.vc[y.md * (c >> e) + (S >> e)]) < y.Wb), y.Ya[S];
    }
    function Mt(y, S, c, e) {
      var r = y.ab, o = y.c * S, h = y.C;
      S = h + S;
      var p = c, x = e;
      for (e = y.Ta, c = y.Ua; 0 < r--; ) {
        var A = y.gc[r], T = h, P = S, F = p, N = x, Z = (x = e, p = c, A.Ea);
        switch (d(T < P), d(P <= A.nc), A.hc) {
          case 2:
            Bs(F, N, (P - T) * Z, x, p);
            break;
          case 0:
            var G = T, V = P, W = x, ae = p, oe = (ke = A).Ea;
            G == 0 && (ms(F, N, null, null, 1, W, ae), yi(F, N + 1, 0, 0, oe - 1, W, ae + 1), N += oe, ae += oe, ++G);
            for (var de = 1 << ke.b, ce = de - 1, we = Rt(oe, ke.b), Le = ke.K, ke = ke.w + (G >> ke.b) * we; G < V; ) {
              var tt = Le, ht = ke, _t = 1;
              for (Ga(F, N, W, ae - oe, 1, W, ae); _t < oe; ) {
                var wt = (_t & ~ce) + de;
                wt > oe && (wt = oe), (0, Di[tt[ht++] >> 8 & 15])(F, N + +_t, W, ae + _t - oe, wt - _t, W, ae + _t), _t = wt;
              }
              N += oe, ae += oe, ++G & ce || (ke += we);
            }
            P != A.nc && m(x, p - Z, x, p + (P - T - 1) * Z, Z);
            break;
          case 1:
            for (Z = F, V = N, oe = (F = A.Ea) - (ae = F & ~(W = (N = 1 << A.b) - 1)), G = Rt(F, A.b), de = A.K, A = A.w + (T >> A.b) * G; T < P; ) {
              for (ce = de, we = A, Le = new At(), ke = V + ae, tt = V + F; V < ke; ) pt(ce[we++], Le), un(Le, Z, V, N, x, p), V += N, p += N;
              V < tt && (pt(ce[we++], Le), un(Le, Z, V, oe, x, p), V += oe, p += oe), ++T & W || (A += G);
            }
            break;
          case 3:
            if (F == x && N == p && 0 < A.b) {
              for (V = x, F = Z = p + (P - T) * Z - (ae = (P - T) * Rt(A.Ea, A.b)), N = x, W = p, G = [], ae = (oe = ae) - 1; 0 <= ae; --ae) G[ae] = N[W + ae];
              for (ae = oe - 1; 0 <= ae; --ae) V[F + ae] = G[ae];
              Jr(A, T, P, x, Z, x, p);
            } else Jr(A, T, P, F, N, x, p);
        }
        p = e, x = c;
      }
      x != c && m(e, c, p, x, o);
    }
    function $t(y, S) {
      var c = y.V, e = y.Ba + y.c * y.C, r = S - y.C;
      if (d(S <= y.l.o), d(16 >= r), 0 < r) {
        var o = y.l, h = y.Ta, p = y.Ua, x = o.width;
        if (Mt(y, r, c, e), r = p = [p], d((c = y.C) < (e = S)), d(o.v < o.va), e > o.o && (e = o.o), c < o.j) {
          var A = o.j - c;
          c = o.j, r[0] += A * x;
        }
        if (c >= e ? c = 0 : (r[0] += 4 * o.v, o.ka = c - o.j, o.U = o.va - o.v, o.T = e - c, c = 1), c) {
          if (p = p[0], 11 > (c = y.ca).S) {
            var T = c.f.RGBA, P = (e = c.S, r = o.U, o = o.T, A = T.eb, T.A), F = o;
            for (T = T.fb + y.Ma * T.A; 0 < F--; ) {
              var N = h, Z = p, G = r, V = A, W = T;
              switch (e) {
                case yo:
                  ha(N, Z, G, V, W);
                  break;
                case js:
                  Ha(N, Z, G, V, W);
                  break;
                case bo:
                  Ha(N, Z, G, V, W), Zn(V, W, 0, G, 1, 0);
                  break;
                case Pl:
                  Wa(N, Z, G, V, W);
                  break;
                case qs:
                  Si(N, Z, G, V, W, 1);
                  break;
                case Us:
                  Si(N, Z, G, V, W, 1), Zn(V, W, 0, G, 1, 0);
                  break;
                case vo:
                  Si(N, Z, G, V, W, 0);
                  break;
                case xo:
                  Si(N, Z, G, V, W, 0), Zn(V, W, 1, G, 1, 0);
                  break;
                case rl:
                  cn(N, Z, G, V, W);
                  break;
                case nl:
                  cn(N, Z, G, V, W), Tr(V, W, G, 1, 0);
                  break;
                case vs:
                  Da(N, Z, G, V, W);
                  break;
                default:
                  d(0);
              }
              p += x, T += P;
            }
            y.Ma += o;
          } else alert("todo:EmitRescaledRowsYUVA");
          d(y.Ma <= c.height);
        }
      }
      y.C = S, d(y.C <= y.i);
    }
    function Qt(y) {
      var S;
      if (0 < y.ua) return 0;
      for (S = 0; S < y.Wb; ++S) {
        var c = y.Ya[S].G, e = y.Ya[S].H;
        if (0 < c[1][e[1] + 0].g || 0 < c[2][e[2] + 0].g || 0 < c[3][e[3] + 0].g) return 0;
      }
      return 1;
    }
    function ei(y, S, c, e, r, o) {
      if (y.Z != 0) {
        var h = y.qd, p = y.rd;
        for (d(La[y.Z] != null); S < c; ++S) La[y.Z](h, p, e, r, e, r, o), h = e, p = r, r += o;
        y.qd = h, y.rd = p;
      }
    }
    function pi(y, S) {
      var c = y.l.ma, e = c.Z == 0 || c.Z == 1 ? y.l.j : y.C;
      if (e = y.C < e ? e : y.C, d(S <= y.l.o), S > e) {
        var r = y.l.width, o = c.ca, h = c.tb + r * e, p = y.V, x = y.Ba + y.c * e, A = y.gc;
        d(y.ab == 1), d(A[0].hc == 3), kl(A[0], e, S, p, x, o, h), ei(c, e, S, o, h, r);
      }
      y.C = y.Ma = S;
    }
    function fi(y, S, c, e, r, o, h) {
      var p = y.$ / e, x = y.$ % e, A = y.m, T = y.s, P = c + y.$, F = P;
      r = c + e * r;
      var N = c + e * o, Z = 280 + T.ua, G = y.Pb ? p : 16777216, V = 0 < T.ua ? T.Wa : null, W = T.wc, ae = P < N ? gt(T, x, p) : null;
      d(y.C < o), d(N <= r);
      var oe = !1;
      e: for (; ; ) {
        for (; oe || P < N; ) {
          var de = 0;
          if (p >= G) {
            var ce = P - c;
            d((G = y).Pb), G.wd = G.m, G.xd = ce, 0 < G.s.ua && it(G.s.Wa, G.s.vb), G = p + lu;
          }
          if (x & W || (ae = gt(T, x, p)), d(ae != null), ae.Qb && (S[P] = ae.qb, oe = !0), !oe) if (Oe(A), ae.jc) {
            de = A, ce = S;
            var we = P, Le = ae.pd[_e(de) & Yr - 1];
            d(ae.jc), 256 > Le.g ? (Ce(de, de.u + Le.g), ce[we] = Le.value, de = 0) : (Ce(de, de.u + Le.g - 256), d(256 <= Le.value), de = Le.value), de == 0 && (oe = !0);
          } else de = ut(ae.G[0], ae.H[0], A);
          if (A.h) break;
          if (oe || 256 > de) {
            if (!oe) if (ae.nd) S[P] = (ae.qb | de << 8) >>> 0;
            else {
              if (Oe(A), oe = ut(ae.G[1], ae.H[1], A), Oe(A), ce = ut(ae.G[2], ae.H[2], A), we = ut(ae.G[3], ae.H[3], A), A.h) break;
              S[P] = (we << 24 | oe << 16 | de << 8 | ce) >>> 0;
            }
            if (oe = !1, ++P, ++x >= e && (x = 0, ++p, h != null && p <= o && !(p % 16) && h(y, p), V != null)) for (; F < P; ) de = S[F++], V.X[(506832829 * de & 4294967295) >>> V.Mb] = de;
          } else if (280 > de) {
            if (de = De(de - 256, A), ce = ut(ae.G[4], ae.H[4], A), Oe(A), ce = et(e, ce = De(ce, A)), A.h) break;
            if (P - c < ce || r - P < de) break e;
            for (we = 0; we < de; ++we) S[P + we] = S[P + we - ce];
            for (P += de, x += de; x >= e; ) x -= e, ++p, h != null && p <= o && !(p % 16) && h(y, p);
            if (d(P <= r), x & W && (ae = gt(T, x, p)), V != null) for (; F < P; ) de = S[F++], V.X[(506832829 * de & 4294967295) >>> V.Mb] = de;
          } else {
            if (!(de < Z)) break e;
            for (oe = de - 280, d(V != null); F < P; ) de = S[F++], V.X[(506832829 * de & 4294967295) >>> V.Mb] = de;
            de = P, d(!(oe >>> (ce = V).Xa)), S[de] = ce.X[oe], oe = !0;
          }
          oe || d(A.h == be(A));
        }
        if (y.Pb && A.h && P < r) d(y.m.h), y.a = 5, y.m = y.wd, y.$ = y.xd, 0 < y.s.ua && it(y.s.vb, y.s.Wa);
        else {
          if (A.h) break e;
          h != null && h(y, p > o ? o : p), y.a = 0, y.$ = P - c;
        }
        return 1;
      }
      return y.a = 3, 0;
    }
    function Wi(y) {
      d(y != null), y.vc = null, y.yc = null, y.Ya = null;
      var S = y.Wa;
      S != null && (S.X = null), y.vb = null, d(y != null);
    }
    function Oi() {
      var y = new Fs();
      return y == null ? null : (y.a = 0, y.xb = Vs, Gi("Predictor", "VP8LPredictors"), Gi("Predictor", "VP8LPredictors_C"), Gi("PredictorAdd", "VP8LPredictorsAdd"), Gi("PredictorAdd", "VP8LPredictorsAdd_C"), Bs = xi, un = Jt, ha = kt, Ha = Zi, cn = ft, Da = ri, Wa = Lt, Ae.VP8LMapColor32b = Ca, Ae.VP8LMapColor8b = tl, y);
    }
    function mi(y, S, c, e, r) {
      var o = 1, h = [y], p = [S], x = e.m, A = e.s, T = null, P = 0;
      e: for (; ; ) {
        if (c) for (; o && Qe(x, 1); ) {
          var F = h, N = p, Z = e, G = 1, V = Z.m, W = Z.gc[Z.ab], ae = Qe(V, 2);
          if (Z.Oc & 1 << ae) o = 0;
          else {
            switch (Z.Oc |= 1 << ae, W.hc = ae, W.Ea = F[0], W.nc = N[0], W.K = [null], ++Z.ab, d(4 >= Z.ab), ae) {
              case 0:
              case 1:
                W.b = Qe(V, 3) + 2, G = mi(Rt(W.Ea, W.b), Rt(W.nc, W.b), 0, Z, W.K), W.K = W.K[0];
                break;
              case 3:
                var oe, de = Qe(V, 8) + 1, ce = 16 < de ? 0 : 4 < de ? 1 : 2 < de ? 2 : 3;
                if (F[0] = Rt(W.Ea, ce), W.b = ce, oe = G = mi(de, 1, 0, Z, W.K)) {
                  var we, Le = de, ke = W, tt = 1 << (8 >> ke.b), ht = v(tt);
                  if (ht == null) oe = 0;
                  else {
                    var _t = ke.K[0], wt = ke.w;
                    for (ht[0] = ke.K[0][0], we = 1; we < 1 * Le; ++we) ht[we] = lt(_t[wt + we], ht[we - 1]);
                    for (; we < 4 * tt; ++we) ht[we] = 0;
                    ke.K[0] = null, ke.K[0] = ht, oe = 1;
                  }
                }
                G = oe;
                break;
              case 2:
                break;
              default:
                d(0);
            }
            o = G;
          }
        }
        if (h = h[0], p = p[0], o && Qe(x, 1) && !(o = 1 <= (P = Qe(x, 4)) && 11 >= P)) {
          e.a = 3;
          break e;
        }
        var bt;
        if (bt = o) t: {
          var yt, St, Zt, Ct = e, Dt = h, Wt = p, di = P, ci = c, gi = Ct.m, Ei = Ct.s, qi = [null], ar = 1, Fi = 0, _r = ka[di];
          i: for (; ; ) {
            if (ci && Qe(gi, 1)) {
              var Ui = Qe(gi, 3) + 2, pr = Rt(Dt, Ui), Cr = Rt(Wt, Ui), dn = pr * Cr;
              if (!mi(pr, Cr, 0, Ct, qi)) break i;
              for (qi = qi[0], Ei.xc = Ui, yt = 0; yt < dn; ++yt) {
                var Ln = qi[yt] >> 8 & 65535;
                qi[yt] = Ln, Ln >= ar && (ar = Ln + 1);
              }
            }
            if (gi.h) break i;
            for (St = 0; 5 > St; ++St) {
              var sr = al[St];
              !St && 0 < di && (sr += 1 << di), Fi < sr && (Fi = sr);
            }
            var xs = g(ar * _r, re), Mn = ar, hl = g(Mn, ye);
            if (hl == null) var To = null;
            else d(65536 >= Mn), To = hl;
            var Qr = v(Fi);
            if (To == null || Qr == null || xs == null) {
              Ct.a = 1;
              break i;
            }
            var pn = xs;
            for (yt = Zt = 0; yt < ar; ++yt) {
              var Br = To[yt], en = Br.G, wr = Br.H, Ur = 0, tn = 1, Li = 0;
              for (St = 0; 5 > St; ++St) {
                sr = al[St], en[St] = pn, wr[St] = Zt, !St && 0 < di && (sr += 1 << di);
                n: {
                  var Ma, ws = sr, Ya = Ct, Co = Qr, Tc = pn, ju = Zt, Na = 0, Ja = Ya.m, Fl = Qe(Ja, 1);
                  if (w(Co, 0, 0, ws), Fl) {
                    var dl = Qe(Ja, 1) + 1, Bl = Qe(Ja, 1), pl = Qe(Ja, Bl == 0 ? 1 : 8);
                    Co[pl] = 1, dl == 2 && (Co[pl = Qe(Ja, 8)] = 1);
                    var Ka = 1;
                  } else {
                    var Do = v(19), mu = Qe(Ja, 4) + 4;
                    if (19 < mu) {
                      Ya.a = 3;
                      var gu = 0;
                      break n;
                    }
                    for (Ma = 0; Ma < mu; ++Ma) Do[zu[Ma]] = Qe(Ja, 3);
                    var qu = void 0, _u = void 0, Uu = Ya, yu = Do, Gs = ws, As = Co, ga = 0, Nn = Uu.m, Cc = 8, Io = g(128, re);
                    r: for (; X(Io, 0, 7, yu, 19); ) {
                      if (Qe(Nn, 1)) {
                        var _d = 2 + 2 * Qe(Nn, 3);
                        if ((qu = 2 + Qe(Nn, _d)) > Gs) break r;
                      } else qu = Gs;
                      for (_u = 0; _u < Gs && qu--; ) {
                        Oe(Nn);
                        var Dc = Io[0 + (127 & _e(Nn))];
                        Ce(Nn, Nn.u + Dc.g);
                        var or = Dc.value;
                        if (16 > or) As[_u++] = or, or != 0 && (Cc = or);
                        else {
                          var Ic = or == 16, kc = or - 16, fl = ou[kc], ko = Qe(Nn, su[kc]) + fl;
                          if (_u + ko > Gs) break r;
                          for (var Vu = Ic ? Cc : 0; 0 < ko--; ) As[_u++] = Vu;
                        }
                      }
                      ga = 1;
                      break r;
                    }
                    ga || (Uu.a = 3), Ka = ga;
                  }
                  (Ka = Ka && !Ja.h) && (Na = X(Tc, ju, 8, Co, ws)), Ka && Na != 0 ? gu = Na : (Ya.a = 3, gu = 0);
                }
                if (gu == 0) break i;
                if (tn && wo[St] == 1 && (tn = pn[Zt].g == 0), Ur += pn[Zt].g, Zt += gu, 3 >= St) {
                  var ml, $u = Qr[0];
                  for (ml = 1; ml < sr; ++ml) Qr[ml] > $u && ($u = Qr[ml]);
                  Li += $u;
                }
              }
              if (Br.nd = tn, Br.Qb = 0, tn && (Br.qb = (en[3][wr[3] + 0].value << 24 | en[1][wr[1] + 0].value << 16 | en[2][wr[2] + 0].value) >>> 0, Ur == 0 && 256 > en[0][wr[0] + 0].value && (Br.Qb = 1, Br.qb += en[0][wr[0] + 0].value << 8)), Br.jc = !Br.Qb && 6 > Li, Br.jc) {
                var Zu, Ss = Br;
                for (Zu = 0; Zu < Yr; ++Zu) {
                  var Po = Zu, Es = Ss.pd[Po], Gu = Ss.G[0][Ss.H[0] + Po];
                  256 <= Gu.value ? (Es.g = Gu.g + 256, Es.value = Gu.value) : (Es.g = 0, Es.value = 0, Po >>= We(Gu, 8, Es), Po >>= We(Ss.G[1][Ss.H[1] + Po], 16, Es), Po >>= We(Ss.G[2][Ss.H[2] + Po], 0, Es), We(Ss.G[3][Ss.H[3] + Po], 24, Es));
                }
              }
            }
            Ei.vc = qi, Ei.Wb = ar, Ei.Ya = To, Ei.yc = xs, bt = 1;
            break t;
          }
          bt = 0;
        }
        if (!(o = bt)) {
          e.a = 3;
          break e;
        }
        if (0 < P) {
          if (A.ua = 1 << P, !Pt(A.Wa, P)) {
            e.a = 1, o = 0;
            break e;
          }
        } else A.ua = 0;
        var vu = e, Pc = h, wh = p, Lo = vu.s, Lc = Lo.xc;
        if (vu.c = Pc, vu.i = wh, Lo.md = Rt(Pc, Lc), Lo.wc = Lc == 0 ? -1 : (1 << Lc) - 1, c) {
          e.xb = So;
          break e;
        }
        if ((T = v(h * p)) == null) {
          e.a = 1, o = 0;
          break e;
        }
        o = (o = fi(e, T, 0, h, p, p, null)) && !x.h;
        break e;
      }
      return o ? (r != null ? r[0] = T : (d(T == null), d(c)), e.$ = 0, c || Wi(A)) : Wi(A), o;
    }
    function Bi(y, S) {
      var c = y.c * y.i, e = c + S + 16 * S;
      return d(y.c <= S), y.V = v(e), y.V == null ? (y.Ta = null, y.Ua = 0, y.a = 1, 0) : (y.Ta = y.V, y.Ua = y.Ba + c + S, 1);
    }
    function Hi(y, S) {
      var c = y.C, e = S - c, r = y.V, o = y.Ba + y.c * c;
      for (d(S <= y.l.o); 0 < e; ) {
        var h = 16 < e ? 16 : e, p = y.l.ma, x = y.l.width, A = x * h, T = p.ca, P = p.tb + x * c, F = y.Ta, N = y.Ua;
        Mt(y, h, r, o), nu(F, N, T, P, A), ei(p, c, c + h, T, P, x), e -= h, r += h * y.c, c += h;
      }
      d(c == S), y.C = y.Ma = S;
    }
    function mr() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function vr() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function kr() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = v(4), this.Lb = v(4);
    }
    function Oa() {
      this.Yb = function() {
        var y = [];
        return function S(c, e, r) {
          for (var o = r[e], h = 0; h < o && (c.push(r.length > e + 1 ? [] : 0), !(r.length < e + 1)); h++) S(c[h], e + 1, r);
        }(y, 0, [3, 11]), y;
      }();
    }
    function ji() {
      this.jb = v(3), this.Wc = s([4, 8], Oa), this.Xc = s([4, 17], Oa);
    }
    function Zo() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new v(4), this.od = new v(4);
    }
    function ss() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Hr() {
      this.Na = this.la = 0;
    }
    function sn() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Go() {
      this.ad = v(384), this.Za = 0, this.Ob = v(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function mn() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new ss()), this.Y = 0, this.ya = Array(new Go()), this.aa = 0, this.l = new Rn();
    }
    function Wr() {
      this.y = v(16), this.f = v(8), this.ea = v(8);
    }
    function os() {
      this.cb = this.a = 0, this.sc = "", this.m = new nt(), this.Od = new mr(), this.Kc = new vr(), this.ed = new Zo(), this.Qa = new kr(), this.Ic = this.$c = this.Aa = 0, this.D = new mn(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = g(8, nt), this.ia = 0, this.pb = g(4, sn), this.Pa = new ji(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Wr()), this.Hd = 0, this.rb = Array(new Hr()), this.sb = 0, this.wa = Array(new ss()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Go()), this.L = this.aa = 0, this.gd = s([4, 2], ss), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Rn() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function br() {
      var y = new os();
      return y != null && (y.a = 0, y.sc = "OK", y.cb = 0, y.Xb = 0, sl || (sl = ks)), y;
    }
    function rr(y, S, c) {
      return y.a == 0 && (y.a = S, y.sc = c, y.cb = 0), 0;
    }
    function gn(y, S, c) {
      return 3 <= c && y[S + 0] == 157 && y[S + 1] == 1 && y[S + 2] == 42;
    }
    function hr(y, S) {
      if (y == null) return 0;
      if (y.a = 0, y.sc = "OK", S == null) return rr(y, 2, "null VP8Io passed to VP8GetHeaders()");
      var c = S.data, e = S.w, r = S.ha;
      if (4 > r) return rr(y, 7, "Truncated header.");
      var o = c[e + 0] | c[e + 1] << 8 | c[e + 2] << 16, h = y.Od;
      if (h.Rb = !(1 & o), h.td = o >> 1 & 7, h.yd = o >> 4 & 1, h.ub = o >> 5, 3 < h.td) return rr(y, 3, "Incorrect keyframe parameters.");
      if (!h.yd) return rr(y, 4, "Frame not displayable.");
      e += 3, r -= 3;
      var p = y.Kc;
      if (h.Rb) {
        if (7 > r) return rr(y, 7, "cannot parse picture header");
        if (!gn(c, e, r)) return rr(y, 3, "Bad code word");
        p.c = 16383 & (c[e + 4] << 8 | c[e + 3]), p.Td = c[e + 4] >> 6, p.i = 16383 & (c[e + 6] << 8 | c[e + 5]), p.Ud = c[e + 6] >> 6, e += 7, r -= 7, y.za = p.c + 15 >> 4, y.Ub = p.i + 15 >> 4, S.width = p.c, S.height = p.i, S.Da = 0, S.j = 0, S.v = 0, S.va = S.width, S.o = S.height, S.da = 0, S.ib = S.width, S.hb = S.height, S.U = S.width, S.T = S.height, w((o = y.Pa).jb, 0, 255, o.jb.length), d((o = y.Qa) != null), o.Cb = 0, o.Bb = 0, o.Fb = 1, w(o.Zb, 0, 0, o.Zb.length), w(o.Lb, 0, 0, o.Lb);
      }
      if (h.ub > r) return rr(y, 7, "bad partition length");
      Ve(o = y.m, c, e, h.ub), e += h.ub, r -= h.ub, h.Rb && (p.Ld = Ue(o), p.Kd = Ue(o)), p = y.Qa;
      var x, A = y.Pa;
      if (d(o != null), d(p != null), p.Cb = Ue(o), p.Cb) {
        if (p.Bb = Ue(o), Ue(o)) {
          for (p.Fb = Ue(o), x = 0; 4 > x; ++x) p.Zb[x] = Ue(o) ? Ze(o, 7) : 0;
          for (x = 0; 4 > x; ++x) p.Lb[x] = Ue(o) ? Ze(o, 6) : 0;
        }
        if (p.Bb) for (x = 0; 3 > x; ++x) A.jb[x] = Ue(o) ? He(o, 8) : 255;
      } else p.Bb = 0;
      if (o.Ka) return rr(y, 3, "cannot parse segment header");
      if ((p = y.ed).zd = Ue(o), p.Tb = He(o, 6), p.wb = He(o, 3), p.Pc = Ue(o), p.Pc && Ue(o)) {
        for (A = 0; 4 > A; ++A) Ue(o) && (p.vd[A] = Ze(o, 6));
        for (A = 0; 4 > A; ++A) Ue(o) && (p.od[A] = Ze(o, 6));
      }
      if (y.L = p.Tb == 0 ? 0 : p.zd ? 1 : 2, o.Ka) return rr(y, 3, "cannot parse filter header");
      var T = r;
      if (r = x = e, e = x + T, p = T, y.Xb = (1 << He(y.m, 2)) - 1, T < 3 * (A = y.Xb)) c = 7;
      else {
        for (x += 3 * A, p -= 3 * A, T = 0; T < A; ++T) {
          var P = c[r + 0] | c[r + 1] << 8 | c[r + 2] << 16;
          P > p && (P = p), Ve(y.Jc[+T], c, x, P), x += P, p -= P, r += 3;
        }
        Ve(y.Jc[+A], c, x, p), c = x < e ? 0 : 5;
      }
      if (c != 0) return rr(y, c, "cannot parse partitions");
      for (c = He(x = y.m, 7), r = Ue(x) ? Ze(x, 4) : 0, e = Ue(x) ? Ze(x, 4) : 0, p = Ue(x) ? Ze(x, 4) : 0, A = Ue(x) ? Ze(x, 4) : 0, x = Ue(x) ? Ze(x, 4) : 0, T = y.Qa, P = 0; 4 > P; ++P) {
        if (T.Cb) {
          var F = T.Zb[P];
          T.Fb || (F += c);
        } else {
          if (0 < P) {
            y.pb[P] = y.pb[0];
            continue;
          }
          F = c;
        }
        var N = y.pb[P];
        N.Sc[0] = In[Mi(F + r, 127)], N.Sc[1] = Xa[Mi(F + 0, 127)], N.Eb[0] = 2 * In[Mi(F + e, 127)], N.Eb[1] = 101581 * Xa[Mi(F + p, 127)] >> 16, 8 > N.Eb[1] && (N.Eb[1] = 8), N.Qc[0] = In[Mi(F + A, 117)], N.Qc[1] = Xa[Mi(F + x, 127)], N.lc = F + x;
      }
      if (!h.Rb) return rr(y, 4, "Not a key frame.");
      for (Ue(o), h = y.Pa, c = 0; 4 > c; ++c) {
        for (r = 0; 8 > r; ++r) for (e = 0; 3 > e; ++e) for (p = 0; 11 > p; ++p) A = Ke(o, Wn[c][r][e][p]) ? He(o, 8) : cu[c][r][e][p], h.Wc[c][r].Yb[e][p] = A;
        for (r = 0; 17 > r; ++r) h.Xc[c][r] = h.Wc[c][Ot[r]];
      }
      return y.kc = Ue(o), y.kc && (y.Bd = He(o, 8)), y.cb = 1;
    }
    function ks(y, S, c, e, r, o, h) {
      var p = S[r].Yb[c];
      for (c = 0; 16 > r; ++r) {
        if (!Ke(y, p[c + 0])) return r;
        for (; !Ke(y, p[c + 1]); ) if (p = S[++r].Yb[0], c = 0, r == 16) return 16;
        var x = S[r + 1].Yb;
        if (Ke(y, p[c + 2])) {
          var A = y, T = 0;
          if (Ke(A, (F = p)[(P = c) + 3])) if (Ke(A, F[P + 6])) {
            for (p = 0, P = 2 * (T = Ke(A, F[P + 8])) + (F = Ke(A, F[P + 9 + T])), T = 0, F = Sc[P]; F[p]; ++p) T += T + Ke(A, F[p]);
            T += 3 + (8 << P);
          } else Ke(A, F[P + 7]) ? (T = 7 + 2 * Ke(A, 165), T += Ke(A, 145)) : T = 5 + Ke(A, 159);
          else T = Ke(A, F[P + 4]) ? 3 + Ke(A, F[P + 5]) : 2;
          p = x[2];
        } else T = 1, p = x[1];
        x = h + Fu[r], 0 > (A = y).b && $e(A);
        var P, F = A.b, N = (P = A.Ca >> 1) - (A.I >> F) >> 31;
        --A.b, A.Ca += N, A.Ca |= 1, A.I -= (P + 1 & N) << F, o[x] = ((T ^ N) - N) * e[(0 < r) + 0];
      }
      return 16;
    }
    function on(y) {
      var S = y.rb[y.sb - 1];
      S.la = 0, S.Na = 0, w(y.zc, 0, 0, y.zc.length), y.ja = 0;
    }
    function Ho(y, S) {
      if (y == null) return 0;
      if (S == null) return rr(y, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!y.cb && !hr(y, S)) return 0;
      if (d(y.cb), S.ac == null || S.ac(S)) {
        S.ob && (y.L = 0);
        var c = bs[y.L];
        if (y.L == 2 ? (y.yb = 0, y.zb = 0) : (y.yb = S.v - c >> 4, y.zb = S.j - c >> 4, 0 > y.yb && (y.yb = 0), 0 > y.zb && (y.zb = 0)), y.Va = S.o + 15 + c >> 4, y.Hb = S.va + 15 + c >> 4, y.Hb > y.za && (y.Hb = y.za), y.Va > y.Ub && (y.Va = y.Ub), 0 < y.L) {
          var e = y.ed;
          for (c = 0; 4 > c; ++c) {
            var r;
            if (y.Qa.Cb) {
              var o = y.Qa.Lb[c];
              y.Qa.Fb || (o += e.Tb);
            } else o = e.Tb;
            for (r = 0; 1 >= r; ++r) {
              var h = y.gd[c][r], p = o;
              if (e.Pc && (p += e.vd[0], r && (p += e.od[0])), 0 < (p = 0 > p ? 0 : 63 < p ? 63 : p)) {
                var x = p;
                0 < e.wb && (x = 4 < e.wb ? x >> 2 : x >> 1) > 9 - e.wb && (x = 9 - e.wb), 1 > x && (x = 1), h.dd = x, h.tc = 2 * p + x, h.ld = 40 <= p ? 2 : 15 <= p ? 1 : 0;
              } else h.tc = 0;
              h.La = r;
            }
          }
        }
        c = 0;
      } else rr(y, 6, "Frame setup failed"), c = y.a;
      if (c = c == 0) {
        if (c) {
          y.$c = 0, 0 < y.Aa || (y.Ic = li);
          e: {
            c = y.Ic, e = 4 * (x = y.za);
            var A = 32 * x, T = x + 1, P = 0 < y.L ? x * (0 < y.Aa ? 2 : 1) : 0, F = (y.Aa == 2 ? 2 : 1) * x;
            if ((h = e + 832 + (r = 3 * (16 * c + bs[y.L]) / 2 * A) + (o = y.Fa != null && 0 < y.Fa.length ? y.Kc.c * y.Kc.i : 0)) != h) c = 0;
            else {
              if (h > y.Vb) {
                if (y.Vb = 0, y.Ec = v(h), y.Fc = 0, y.Ec == null) {
                  c = rr(y, 1, "no memory during frame initialization.");
                  break e;
                }
                y.Vb = h;
              }
              h = y.Ec, p = y.Fc, y.Ac = h, y.Bc = p, p += e, y.Gd = g(A, Wr), y.Hd = 0, y.rb = g(T + 1, Hr), y.sb = 1, y.wa = P ? g(P, ss) : null, y.Y = 0, y.D.Nb = 0, y.D.wa = y.wa, y.D.Y = y.Y, 0 < y.Aa && (y.D.Y += x), d(!0), y.oc = h, y.pc = p, p += 832, y.ya = g(F, Go), y.aa = 0, y.D.ya = y.ya, y.D.aa = y.aa, y.Aa == 2 && (y.D.aa += x), y.R = 16 * x, y.B = 8 * x, x = (A = bs[y.L]) * y.R, A = A / 2 * y.B, y.sa = h, y.ta = p + x, y.qa = y.sa, y.ra = y.ta + 16 * c * y.R + A, y.Ha = y.qa, y.Ia = y.ra + 8 * c * y.B + A, y.$c = 0, p += r, y.mb = o ? h : null, y.nb = o ? p : null, d(p + o <= y.Fc + y.Vb), on(y), w(y.Ac, y.Bc, 0, e), c = 1;
            }
          }
          if (c) {
            if (S.ka = 0, S.y = y.sa, S.O = y.ta, S.f = y.qa, S.N = y.ra, S.ea = y.Ha, S.Vd = y.Ia, S.fa = y.R, S.Rc = y.B, S.F = null, S.J = 0, !_o) {
              for (c = -255; 255 >= c; ++c) au[255 + c] = 0 > c ? -c : c;
              for (c = -1020; 1020 >= c; ++c) gr[1020 + c] = -128 > c ? -128 : 127 < c ? 127 : c;
              for (c = -112; 112 >= c; ++c) Gn[112 + c] = -16 > c ? -16 : 15 < c ? 15 : c;
              for (c = -255; 510 >= c; ++c) vn[255 + c] = 0 > c ? 0 : 255 < c ? 255 : c;
              _o = 1;
            }
            qn = Xo, Rs = Ri, da = eo, Kr = Wo, yn = ja, gs = aa, Un = co, _s = zs, Vn = Il, $n = ho, ys = Dl, hn = cs, pa = po, tr = Jo, Yi = oa, dr = Ii, Er = la, Dn = ru, kn[0] = Tn, kn[1] = Ps, kn[2] = ro, kn[3] = no, kn[4] = Yo, kn[5] = ao, kn[6] = qa, kn[7] = so, kn[8] = tu, kn[9] = Tl, fa[0] = El, fa[1] = us, fa[2] = xa, fa[3] = io, fa[4] = xr, fa[5] = Ms, fa[6] = jr, Pa[0] = wa, Pa[1] = to, Pa[2] = iu, Pa[3] = oo, Pa[4] = Ua, Pa[5] = lo, Pa[6] = Ns, c = 1;
          } else c = 0;
        }
        c && (c = function(N, Z) {
          for (N.M = 0; N.M < N.Va; ++N.M) {
            var G, V = N.Jc[N.M & N.Xb], W = N.m, ae = N;
            for (G = 0; G < ae.za; ++G) {
              var oe = W, de = ae, ce = de.Ac, we = de.Bc + 4 * G, Le = de.zc, ke = de.ya[de.aa + G];
              if (de.Qa.Bb ? ke.$b = Ke(oe, de.Pa.jb[0]) ? 2 + Ke(oe, de.Pa.jb[2]) : Ke(oe, de.Pa.jb[1]) : ke.$b = 0, de.kc && (ke.Ad = Ke(oe, de.Bd)), ke.Za = !Ke(oe, 145) + 0, ke.Za) {
                var tt = ke.Ob, ht = 0;
                for (de = 0; 4 > de; ++de) {
                  var _t, wt = Le[0 + de];
                  for (_t = 0; 4 > _t; ++_t) {
                    wt = Ao[ce[we + _t]][wt];
                    for (var bt = uu[Ke(oe, wt[0])]; 0 < bt; ) bt = uu[2 * bt + Ke(oe, wt[bt])];
                    wt = -bt, ce[we + _t] = wt;
                  }
                  m(tt, ht, ce, we, 4), ht += 4, Le[0 + de] = wt;
                }
              } else wt = Ke(oe, 156) ? Ke(oe, 128) ? 1 : 3 : Ke(oe, 163) ? 2 : 0, ke.Ob[0] = wt, w(ce, we, wt, 4), w(Le, 0, wt, 4);
              ke.Dd = Ke(oe, 142) ? Ke(oe, 114) ? Ke(oe, 183) ? 1 : 3 : 2 : 0;
            }
            if (ae.m.Ka) return rr(N, 7, "Premature end-of-partition0 encountered.");
            for (; N.ja < N.za; ++N.ja) {
              if (ae = V, oe = (W = N).rb[W.sb - 1], ce = W.rb[W.sb + W.ja], G = W.ya[W.aa + W.ja], we = W.kc ? G.Ad : 0) oe.la = ce.la = 0, G.Za || (oe.Na = ce.Na = 0), G.Hc = 0, G.Gc = 0, G.ia = 0;
              else {
                var yt, St;
                if (oe = ce, ce = ae, we = W.Pa.Xc, Le = W.ya[W.aa + W.ja], ke = W.pb[Le.$b], de = Le.ad, tt = 0, ht = W.rb[W.sb - 1], wt = _t = 0, w(de, tt, 0, 384), Le.Za) var Zt = 0, Ct = we[3];
                else {
                  bt = v(16);
                  var Dt = oe.Na + ht.Na;
                  if (Dt = sl(ce, we[1], Dt, ke.Eb, 0, bt, 0), oe.Na = ht.Na = (0 < Dt) + 0, 1 < Dt) qn(bt, 0, de, tt);
                  else {
                    var Wt = bt[0] + 3 >> 3;
                    for (bt = 0; 256 > bt; bt += 16) de[tt + bt] = Wt;
                  }
                  Zt = 1, Ct = we[0];
                }
                var di = 15 & oe.la, ci = 15 & ht.la;
                for (bt = 0; 4 > bt; ++bt) {
                  var gi = 1 & ci;
                  for (Wt = St = 0; 4 > Wt; ++Wt) di = di >> 1 | (gi = (Dt = sl(ce, Ct, Dt = gi + (1 & di), ke.Sc, Zt, de, tt)) > Zt) << 7, St = St << 2 | (3 < Dt ? 3 : 1 < Dt ? 2 : de[tt + 0] != 0), tt += 16;
                  di >>= 4, ci = ci >> 1 | gi << 7, _t = (_t << 8 | St) >>> 0;
                }
                for (Ct = di, Zt = ci >> 4, yt = 0; 4 > yt; yt += 2) {
                  for (St = 0, di = oe.la >> 4 + yt, ci = ht.la >> 4 + yt, bt = 0; 2 > bt; ++bt) {
                    for (gi = 1 & ci, Wt = 0; 2 > Wt; ++Wt) Dt = gi + (1 & di), di = di >> 1 | (gi = 0 < (Dt = sl(ce, we[2], Dt, ke.Qc, 0, de, tt))) << 3, St = St << 2 | (3 < Dt ? 3 : 1 < Dt ? 2 : de[tt + 0] != 0), tt += 16;
                    di >>= 2, ci = ci >> 1 | gi << 5;
                  }
                  wt |= St << 4 * yt, Ct |= di << 4 << yt, Zt |= (240 & ci) << yt;
                }
                oe.la = Ct, ht.la = Zt, Le.Hc = _t, Le.Gc = wt, Le.ia = 43690 & wt ? 0 : ke.ia, we = !(_t | wt);
              }
              if (0 < W.L && (W.wa[W.Y + W.ja] = W.gd[G.$b][G.Za], W.wa[W.Y + W.ja].La |= !we), ae.Ka) return rr(N, 7, "Premature end-of-file encountered.");
            }
            if (on(N), W = Z, ae = 1, G = (V = N).D, oe = 0 < V.L && V.M >= V.zb && V.M <= V.Va, V.Aa == 0) e: {
              if (G.M = V.M, G.uc = oe, $a(V, G), ae = 1, G = (St = V.D).Nb, oe = (wt = bs[V.L]) * V.R, ce = wt / 2 * V.B, bt = 16 * G * V.R, Wt = 8 * G * V.B, we = V.sa, Le = V.ta - oe + bt, ke = V.qa, de = V.ra - ce + Wt, tt = V.Ha, ht = V.Ia - ce + Wt, ci = (di = St.M) == 0, _t = di >= V.Va - 1, V.Aa == 2 && $a(V, St), St.uc) for (gi = (Dt = V).D.M, d(Dt.D.uc), St = Dt.yb; St < Dt.Hb; ++St) {
                Zt = St, Ct = gi;
                var Ei = (qi = (sr = Dt).D).Nb;
                yt = sr.R;
                var qi = qi.wa[qi.Y + Zt], ar = sr.sa, Fi = sr.ta + 16 * Ei * yt + 16 * Zt, _r = qi.dd, Ui = qi.tc;
                if (Ui != 0) if (d(3 <= Ui), sr.L == 1) 0 < Zt && dr(ar, Fi, yt, Ui + 4), qi.La && Dn(ar, Fi, yt, Ui), 0 < Ct && Yi(ar, Fi, yt, Ui + 4), qi.La && Er(ar, Fi, yt, Ui);
                else {
                  var pr = sr.B, Cr = sr.qa, dn = sr.ra + 8 * Ei * pr + 8 * Zt, Ln = sr.Ha, sr = sr.Ia + 8 * Ei * pr + 8 * Zt;
                  Ei = qi.ld, 0 < Zt && (_s(ar, Fi, yt, Ui + 4, _r, Ei), $n(Cr, dn, Ln, sr, pr, Ui + 4, _r, Ei)), qi.La && (hn(ar, Fi, yt, Ui, _r, Ei), tr(Cr, dn, Ln, sr, pr, Ui, _r, Ei)), 0 < Ct && (Un(ar, Fi, yt, Ui + 4, _r, Ei), Vn(Cr, dn, Ln, sr, pr, Ui + 4, _r, Ei)), qi.La && (ys(ar, Fi, yt, Ui, _r, Ei), pa(Cr, dn, Ln, sr, pr, Ui, _r, Ei));
                }
              }
              if (V.ia && alert("todo:DitherRow"), W.put != null) {
                if (St = 16 * di, di = 16 * (di + 1), ci ? (W.y = V.sa, W.O = V.ta + bt, W.f = V.qa, W.N = V.ra + Wt, W.ea = V.Ha, W.W = V.Ia + Wt) : (St -= wt, W.y = we, W.O = Le, W.f = ke, W.N = de, W.ea = tt, W.W = ht), _t || (di -= wt), di > W.o && (di = W.o), W.F = null, W.J = null, V.Fa != null && 0 < V.Fa.length && St < di && (W.J = go(V, W, St, di - St), W.F = V.mb, W.F == null && W.F.length == 0)) {
                  ae = rr(V, 3, "Could not decode alpha data.");
                  break e;
                }
                St < W.j && (wt = W.j - St, St = W.j, d(!(1 & wt)), W.O += V.R * wt, W.N += V.B * (wt >> 1), W.W += V.B * (wt >> 1), W.F != null && (W.J += W.width * wt)), St < di && (W.O += W.v, W.N += W.v >> 1, W.W += W.v >> 1, W.F != null && (W.J += W.v), W.ka = St - W.j, W.U = W.va - W.v, W.T = di - St, ae = W.put(W));
              }
              G + 1 != V.Ic || _t || (m(V.sa, V.ta - oe, we, Le + 16 * V.R, oe), m(V.qa, V.ra - ce, ke, de + 8 * V.B, ce), m(V.Ha, V.Ia - ce, tt, ht + 8 * V.B, ce));
            }
            if (!ae) return rr(N, 6, "Output aborted.");
          }
          return 1;
        }(y, S)), S.bc != null && S.bc(S), c &= 1;
      }
      return c ? (y.cb = 0, c) : 0;
    }
    function Ar(y, S, c, e, r) {
      r = y[S + c + 32 * e] + (r >> 3), y[S + c + 32 * e] = -256 & r ? 0 > r ? 0 : 255 : r;
    }
    function Qs(y, S, c, e, r, o) {
      Ar(y, S, 0, c, e + r), Ar(y, S, 1, c, e + o), Ar(y, S, 2, c, e - o), Ar(y, S, 3, c, e - r);
    }
    function Or(y) {
      return (20091 * y >> 16) + y;
    }
    function na(y, S, c, e) {
      var r, o = 0, h = v(16);
      for (r = 0; 4 > r; ++r) {
        var p = y[S + 0] + y[S + 8], x = y[S + 0] - y[S + 8], A = (35468 * y[S + 4] >> 16) - Or(y[S + 12]), T = Or(y[S + 4]) + (35468 * y[S + 12] >> 16);
        h[o + 0] = p + T, h[o + 1] = x + A, h[o + 2] = x - A, h[o + 3] = p - T, o += 4, S++;
      }
      for (r = o = 0; 4 > r; ++r) p = (y = h[o + 0] + 4) + h[o + 8], x = y - h[o + 8], A = (35468 * h[o + 4] >> 16) - Or(h[o + 12]), Ar(c, e, 0, 0, p + (T = Or(h[o + 4]) + (35468 * h[o + 12] >> 16))), Ar(c, e, 1, 0, x + A), Ar(c, e, 2, 0, x - A), Ar(c, e, 3, 0, p - T), o++, e += 32;
    }
    function aa(y, S, c, e) {
      var r = y[S + 0] + 4, o = 35468 * y[S + 4] >> 16, h = Or(y[S + 4]), p = 35468 * y[S + 1] >> 16;
      Qs(c, e, 0, r + h, y = Or(y[S + 1]), p), Qs(c, e, 1, r + o, y, p), Qs(c, e, 2, r - o, y, p), Qs(c, e, 3, r - h, y, p);
    }
    function Ri(y, S, c, e, r) {
      na(y, S, c, e), r && na(y, S + 16, c, e + 4);
    }
    function eo(y, S, c, e) {
      Rs(y, S + 0, c, e, 1), Rs(y, S + 32, c, e + 128, 1);
    }
    function Wo(y, S, c, e) {
      var r;
      for (y = y[S + 0] + 4, r = 0; 4 > r; ++r) for (S = 0; 4 > S; ++S) Ar(c, e, S, r, y);
    }
    function ja(y, S, c, e) {
      y[S + 0] && Kr(y, S + 0, c, e), y[S + 16] && Kr(y, S + 16, c, e + 4), y[S + 32] && Kr(y, S + 32, c, e + 128), y[S + 48] && Kr(y, S + 48, c, e + 128 + 4);
    }
    function Xo(y, S, c, e) {
      var r, o = v(16);
      for (r = 0; 4 > r; ++r) {
        var h = y[S + 0 + r] + y[S + 12 + r], p = y[S + 4 + r] + y[S + 8 + r], x = y[S + 4 + r] - y[S + 8 + r], A = y[S + 0 + r] - y[S + 12 + r];
        o[0 + r] = h + p, o[8 + r] = h - p, o[4 + r] = A + x, o[12 + r] = A - x;
      }
      for (r = 0; 4 > r; ++r) h = (y = o[0 + 4 * r] + 3) + o[3 + 4 * r], p = o[1 + 4 * r] + o[2 + 4 * r], x = o[1 + 4 * r] - o[2 + 4 * r], A = y - o[3 + 4 * r], c[e + 0] = h + p >> 3, c[e + 16] = A + x >> 3, c[e + 32] = h - p >> 3, c[e + 48] = A - x >> 3, e += 64;
    }
    function ls(y, S, c) {
      var e, r = S - 32, o = Fr, h = 255 - y[r - 1];
      for (e = 0; e < c; ++e) {
        var p, x = o, A = h + y[S - 1];
        for (p = 0; p < c; ++p) y[S + p] = x[A + y[r + p]];
        S += 32;
      }
    }
    function Ps(y, S) {
      ls(y, S, 4);
    }
    function to(y, S) {
      ls(y, S, 8);
    }
    function us(y, S) {
      ls(y, S, 16);
    }
    function xa(y, S) {
      var c;
      for (c = 0; 16 > c; ++c) m(y, S + 32 * c, y, S - 32, 16);
    }
    function io(y, S) {
      var c;
      for (c = 16; 0 < c; --c) w(y, S, y[S - 1], 16), S += 32;
    }
    function Ls(y, S, c) {
      var e;
      for (e = 0; 16 > e; ++e) w(S, c + 32 * e, y, 16);
    }
    function El(y, S) {
      var c, e = 16;
      for (c = 0; 16 > c; ++c) e += y[S - 1 + 32 * c] + y[S + c - 32];
      Ls(e >> 5, y, S);
    }
    function xr(y, S) {
      var c, e = 8;
      for (c = 0; 16 > c; ++c) e += y[S - 1 + 32 * c];
      Ls(e >> 4, y, S);
    }
    function Ms(y, S) {
      var c, e = 8;
      for (c = 0; 16 > c; ++c) e += y[S + c - 32];
      Ls(e >> 4, y, S);
    }
    function jr(y, S) {
      Ls(128, y, S);
    }
    function si(y, S, c) {
      return y + 2 * S + c + 2 >> 2;
    }
    function ro(y, S) {
      var c, e = S - 32;
      for (e = new Uint8Array([si(y[e - 1], y[e + 0], y[e + 1]), si(y[e + 0], y[e + 1], y[e + 2]), si(y[e + 1], y[e + 2], y[e + 3]), si(y[e + 2], y[e + 3], y[e + 4])]), c = 0; 4 > c; ++c) m(y, S + 32 * c, e, 0, e.length);
    }
    function no(y, S) {
      var c = y[S - 1], e = y[S - 1 + 32], r = y[S - 1 + 64], o = y[S - 1 + 96];
      rt(y, S + 0, 16843009 * si(y[S - 1 - 32], c, e)), rt(y, S + 32, 16843009 * si(c, e, r)), rt(y, S + 64, 16843009 * si(e, r, o)), rt(y, S + 96, 16843009 * si(r, o, o));
    }
    function Tn(y, S) {
      var c, e = 4;
      for (c = 0; 4 > c; ++c) e += y[S + c - 32] + y[S - 1 + 32 * c];
      for (e >>= 3, c = 0; 4 > c; ++c) w(y, S + 32 * c, e, 4);
    }
    function Yo(y, S) {
      var c = y[S - 1 + 0], e = y[S - 1 + 32], r = y[S - 1 + 64], o = y[S - 1 - 32], h = y[S + 0 - 32], p = y[S + 1 - 32], x = y[S + 2 - 32], A = y[S + 3 - 32];
      y[S + 0 + 96] = si(e, r, y[S - 1 + 96]), y[S + 1 + 96] = y[S + 0 + 64] = si(c, e, r), y[S + 2 + 96] = y[S + 1 + 64] = y[S + 0 + 32] = si(o, c, e), y[S + 3 + 96] = y[S + 2 + 64] = y[S + 1 + 32] = y[S + 0 + 0] = si(h, o, c), y[S + 3 + 64] = y[S + 2 + 32] = y[S + 1 + 0] = si(p, h, o), y[S + 3 + 32] = y[S + 2 + 0] = si(x, p, h), y[S + 3 + 0] = si(A, x, p);
    }
    function qa(y, S) {
      var c = y[S + 1 - 32], e = y[S + 2 - 32], r = y[S + 3 - 32], o = y[S + 4 - 32], h = y[S + 5 - 32], p = y[S + 6 - 32], x = y[S + 7 - 32];
      y[S + 0 + 0] = si(y[S + 0 - 32], c, e), y[S + 1 + 0] = y[S + 0 + 32] = si(c, e, r), y[S + 2 + 0] = y[S + 1 + 32] = y[S + 0 + 64] = si(e, r, o), y[S + 3 + 0] = y[S + 2 + 32] = y[S + 1 + 64] = y[S + 0 + 96] = si(r, o, h), y[S + 3 + 32] = y[S + 2 + 64] = y[S + 1 + 96] = si(o, h, p), y[S + 3 + 64] = y[S + 2 + 96] = si(h, p, x), y[S + 3 + 96] = si(p, x, x);
    }
    function ao(y, S) {
      var c = y[S - 1 + 0], e = y[S - 1 + 32], r = y[S - 1 + 64], o = y[S - 1 - 32], h = y[S + 0 - 32], p = y[S + 1 - 32], x = y[S + 2 - 32], A = y[S + 3 - 32];
      y[S + 0 + 0] = y[S + 1 + 64] = o + h + 1 >> 1, y[S + 1 + 0] = y[S + 2 + 64] = h + p + 1 >> 1, y[S + 2 + 0] = y[S + 3 + 64] = p + x + 1 >> 1, y[S + 3 + 0] = x + A + 1 >> 1, y[S + 0 + 96] = si(r, e, c), y[S + 0 + 64] = si(e, c, o), y[S + 0 + 32] = y[S + 1 + 96] = si(c, o, h), y[S + 1 + 32] = y[S + 2 + 96] = si(o, h, p), y[S + 2 + 32] = y[S + 3 + 96] = si(h, p, x), y[S + 3 + 32] = si(p, x, A);
    }
    function so(y, S) {
      var c = y[S + 0 - 32], e = y[S + 1 - 32], r = y[S + 2 - 32], o = y[S + 3 - 32], h = y[S + 4 - 32], p = y[S + 5 - 32], x = y[S + 6 - 32], A = y[S + 7 - 32];
      y[S + 0 + 0] = c + e + 1 >> 1, y[S + 1 + 0] = y[S + 0 + 64] = e + r + 1 >> 1, y[S + 2 + 0] = y[S + 1 + 64] = r + o + 1 >> 1, y[S + 3 + 0] = y[S + 2 + 64] = o + h + 1 >> 1, y[S + 0 + 32] = si(c, e, r), y[S + 1 + 32] = y[S + 0 + 96] = si(e, r, o), y[S + 2 + 32] = y[S + 1 + 96] = si(r, o, h), y[S + 3 + 32] = y[S + 2 + 96] = si(o, h, p), y[S + 3 + 64] = si(h, p, x), y[S + 3 + 96] = si(p, x, A);
    }
    function Tl(y, S) {
      var c = y[S - 1 + 0], e = y[S - 1 + 32], r = y[S - 1 + 64], o = y[S - 1 + 96];
      y[S + 0 + 0] = c + e + 1 >> 1, y[S + 2 + 0] = y[S + 0 + 32] = e + r + 1 >> 1, y[S + 2 + 32] = y[S + 0 + 64] = r + o + 1 >> 1, y[S + 1 + 0] = si(c, e, r), y[S + 3 + 0] = y[S + 1 + 32] = si(e, r, o), y[S + 3 + 32] = y[S + 1 + 64] = si(r, o, o), y[S + 3 + 64] = y[S + 2 + 64] = y[S + 0 + 96] = y[S + 1 + 96] = y[S + 2 + 96] = y[S + 3 + 96] = o;
    }
    function tu(y, S) {
      var c = y[S - 1 + 0], e = y[S - 1 + 32], r = y[S - 1 + 64], o = y[S - 1 + 96], h = y[S - 1 - 32], p = y[S + 0 - 32], x = y[S + 1 - 32], A = y[S + 2 - 32];
      y[S + 0 + 0] = y[S + 2 + 32] = c + h + 1 >> 1, y[S + 0 + 32] = y[S + 2 + 64] = e + c + 1 >> 1, y[S + 0 + 64] = y[S + 2 + 96] = r + e + 1 >> 1, y[S + 0 + 96] = o + r + 1 >> 1, y[S + 3 + 0] = si(p, x, A), y[S + 2 + 0] = si(h, p, x), y[S + 1 + 0] = y[S + 3 + 32] = si(c, h, p), y[S + 1 + 32] = y[S + 3 + 64] = si(e, c, h), y[S + 1 + 64] = y[S + 3 + 96] = si(r, e, c), y[S + 1 + 96] = si(o, r, e);
    }
    function iu(y, S) {
      var c;
      for (c = 0; 8 > c; ++c) m(y, S + 32 * c, y, S - 32, 8);
    }
    function oo(y, S) {
      var c;
      for (c = 0; 8 > c; ++c) w(y, S, y[S - 1], 8), S += 32;
    }
    function sa(y, S, c) {
      var e;
      for (e = 0; 8 > e; ++e) w(S, c + 32 * e, y, 8);
    }
    function wa(y, S) {
      var c, e = 8;
      for (c = 0; 8 > c; ++c) e += y[S + c - 32] + y[S - 1 + 32 * c];
      sa(e >> 4, y, S);
    }
    function lo(y, S) {
      var c, e = 4;
      for (c = 0; 8 > c; ++c) e += y[S + c - 32];
      sa(e >> 3, y, S);
    }
    function Ua(y, S) {
      var c, e = 4;
      for (c = 0; 8 > c; ++c) e += y[S - 1 + 32 * c];
      sa(e >> 3, y, S);
    }
    function Ns(y, S) {
      sa(128, y, S);
    }
    function ln(y, S, c) {
      var e = y[S - c], r = y[S + 0], o = 3 * (r - e) + il[1020 + y[S - 2 * c] - y[S + c]], h = Os[112 + (o + 4 >> 3)];
      y[S - c] = Fr[255 + e + Os[112 + (o + 3 >> 3)]], y[S + 0] = Fr[255 + r - h];
    }
    function Cl(y, S, c, e) {
      var r = y[S + 0], o = y[S + c];
      return Pr[255 + y[S - 2 * c] - y[S - c]] > e || Pr[255 + o - r] > e;
    }
    function uo(y, S, c, e) {
      return 4 * Pr[255 + y[S - c] - y[S + 0]] + Pr[255 + y[S - 2 * c] - y[S + c]] <= e;
    }
    function Aa(y, S, c, e, r) {
      var o = y[S - 3 * c], h = y[S - 2 * c], p = y[S - c], x = y[S + 0], A = y[S + c], T = y[S + 2 * c], P = y[S + 3 * c];
      return 4 * Pr[255 + p - x] + Pr[255 + h - A] > e ? 0 : Pr[255 + y[S - 4 * c] - o] <= r && Pr[255 + o - h] <= r && Pr[255 + h - p] <= r && Pr[255 + P - T] <= r && Pr[255 + T - A] <= r && Pr[255 + A - x] <= r;
    }
    function oa(y, S, c, e) {
      var r = 2 * e + 1;
      for (e = 0; 16 > e; ++e) uo(y, S + e, c, r) && ln(y, S + e, c);
    }
    function Ii(y, S, c, e) {
      var r = 2 * e + 1;
      for (e = 0; 16 > e; ++e) uo(y, S + e * c, 1, r) && ln(y, S + e * c, 1);
    }
    function la(y, S, c, e) {
      var r;
      for (r = 3; 0 < r; --r) oa(y, S += 4 * c, c, e);
    }
    function ru(y, S, c, e) {
      var r;
      for (r = 3; 0 < r; --r) Ii(y, S += 4, c, e);
    }
    function Cn(y, S, c, e, r, o, h, p) {
      for (o = 2 * o + 1; 0 < r--; ) {
        if (Aa(y, S, c, o, h)) if (Cl(y, S, c, p)) ln(y, S, c);
        else {
          var x = y, A = S, T = c, P = x[A - 2 * T], F = x[A - T], N = x[A + 0], Z = x[A + T], G = x[A + 2 * T], V = 27 * (ae = il[1020 + 3 * (N - F) + il[1020 + P - Z]]) + 63 >> 7, W = 18 * ae + 63 >> 7, ae = 9 * ae + 63 >> 7;
          x[A - 3 * T] = Fr[255 + x[A - 3 * T] + ae], x[A - 2 * T] = Fr[255 + P + W], x[A - T] = Fr[255 + F + V], x[A + 0] = Fr[255 + N - V], x[A + T] = Fr[255 + Z - W], x[A + 2 * T] = Fr[255 + G - ae];
        }
        S += e;
      }
    }
    function ua(y, S, c, e, r, o, h, p) {
      for (o = 2 * o + 1; 0 < r--; ) {
        if (Aa(y, S, c, o, h)) if (Cl(y, S, c, p)) ln(y, S, c);
        else {
          var x = y, A = S, T = c, P = x[A - T], F = x[A + 0], N = x[A + T], Z = Os[112 + ((G = 3 * (F - P)) + 4 >> 3)], G = Os[112 + (G + 3 >> 3)], V = Z + 1 >> 1;
          x[A - 2 * T] = Fr[255 + x[A - 2 * T] + V], x[A - T] = Fr[255 + P + G], x[A + 0] = Fr[255 + F - Z], x[A + T] = Fr[255 + N - V];
        }
        S += e;
      }
    }
    function co(y, S, c, e, r, o) {
      Cn(y, S, c, 1, 16, e, r, o);
    }
    function zs(y, S, c, e, r, o) {
      Cn(y, S, 1, c, 16, e, r, o);
    }
    function Dl(y, S, c, e, r, o) {
      var h;
      for (h = 3; 0 < h; --h) ua(y, S += 4 * c, c, 1, 16, e, r, o);
    }
    function cs(y, S, c, e, r, o) {
      var h;
      for (h = 3; 0 < h; --h) ua(y, S += 4, 1, c, 16, e, r, o);
    }
    function Il(y, S, c, e, r, o, h, p) {
      Cn(y, S, r, 1, 8, o, h, p), Cn(c, e, r, 1, 8, o, h, p);
    }
    function ho(y, S, c, e, r, o, h, p) {
      Cn(y, S, 1, r, 8, o, h, p), Cn(c, e, 1, r, 8, o, h, p);
    }
    function po(y, S, c, e, r, o, h, p) {
      ua(y, S + 4 * r, r, 1, 8, o, h, p), ua(c, e + 4 * r, r, 1, 8, o, h, p);
    }
    function Jo(y, S, c, e, r, o, h, p) {
      ua(y, S + 4, 1, r, 8, o, h, p), ua(c, e + 4, 1, r, 8, o, h, p);
    }
    function On() {
      this.ba = new ie(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new $(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function fo() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Ko() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function Qo() {
      this.ua = 0, this.Wa = new Y(), this.vb = new Y(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new ye(), this.yc = new re();
    }
    function Fs() {
      this.xb = this.a = 0, this.l = new Rn(), this.ca = new ie(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new Q(), this.Pb = 0, this.wd = new Q(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new Qo(), this.ab = 0, this.gc = g(4, Ko), this.Oc = 0;
    }
    function mo() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Rn(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function Sa(y, S, c, e, r, o, h) {
      for (y = y == null ? 0 : y[S + 0], S = 0; S < h; ++S) r[o + S] = y + c[e + S] & 255, y = r[o + S];
    }
    function el(y, S, c, e, r, o, h) {
      var p;
      if (y == null) Sa(null, null, c, e, r, o, h);
      else for (p = 0; p < h; ++p) r[o + p] = y[S + p] + c[e + p] & 255;
    }
    function hs(y, S, c, e, r, o, h) {
      if (y == null) Sa(null, null, c, e, r, o, h);
      else {
        var p, x = y[S + 0], A = x, T = x;
        for (p = 0; p < h; ++p) A = T + (x = y[S + p]) - A, T = c[e + p] + (-256 & A ? 0 > A ? 0 : 255 : A) & 255, A = x, r[o + p] = T;
      }
    }
    function go(y, S, c, e) {
      var r = S.width, o = S.o;
      if (d(y != null && S != null), 0 > c || 0 >= e || c + e > o) return null;
      if (!y.Cc) {
        if (y.ga == null) {
          var h;
          if (y.ga = new mo(), (h = y.ga == null) || (h = S.width * S.o, d(y.Gb.length == 0), y.Gb = v(h), y.Uc = 0, y.Gb == null ? h = 0 : (y.mb = y.Gb, y.nb = y.Uc, y.rc = null, h = 1), h = !h), !h) {
            h = y.ga;
            var p = y.Fa, x = y.P, A = y.qc, T = y.mb, P = y.nb, F = x + 1, N = A - 1, Z = h.l;
            if (d(p != null && T != null && S != null), La[0] = null, La[1] = Sa, La[2] = el, La[3] = hs, h.ca = T, h.tb = P, h.c = S.width, h.i = S.height, d(0 < h.c && 0 < h.i), 1 >= A) S = 0;
            else if (h.$a = p[x + 0] >> 0 & 3, h.Z = p[x + 0] >> 2 & 3, h.Lc = p[x + 0] >> 4 & 3, x = p[x + 0] >> 6 & 3, 0 > h.$a || 1 < h.$a || 4 <= h.Z || 1 < h.Lc || x) S = 0;
            else if (Z.put = Me, Z.ac = ge, Z.bc = Fe, Z.ma = h, Z.width = S.width, Z.height = S.height, Z.Da = S.Da, Z.v = S.v, Z.va = S.va, Z.j = S.j, Z.o = S.o, h.$a) e: {
              d(h.$a == 1), S = Oi();
              t: for (; ; ) {
                if (S == null) {
                  S = 0;
                  break e;
                }
                if (d(h != null), h.mc = S, S.c = h.c, S.i = h.i, S.l = h.l, S.l.ma = h, S.l.width = h.c, S.l.height = h.i, S.a = 0, je(S.m, p, F, N), !mi(h.c, h.i, 1, S, null) || (S.ab == 1 && S.gc[0].hc == 3 && Qt(S.s) ? (h.ic = 1, p = S.c * S.i, S.Ta = null, S.Ua = 0, S.V = v(p), S.Ba = 0, S.V == null ? (S.a = 1, S = 0) : S = 1) : (h.ic = 0, S = Bi(S, h.c)), !S)) break t;
                S = 1;
                break e;
              }
              h.mc = null, S = 0;
            }
            else S = N >= h.c * h.i;
            h = !S;
          }
          if (h) return null;
          y.ga.Lc != 1 ? y.Ga = 0 : e = o - c;
        }
        d(y.ga != null), d(c + e <= o);
        e: {
          if (S = (p = y.ga).c, o = p.l.o, p.$a == 0) {
            if (F = y.rc, N = y.Vc, Z = y.Fa, x = y.P + 1 + c * S, A = y.mb, T = y.nb + c * S, d(x <= y.P + y.qc), p.Z != 0) for (d(La[p.Z] != null), h = 0; h < e; ++h) La[p.Z](F, N, Z, x, A, T, S), F = A, N = T, T += S, x += S;
            else for (h = 0; h < e; ++h) m(A, T, Z, x, S), F = A, N = T, T += S, x += S;
            y.rc = F, y.Vc = N;
          } else {
            if (d(p.mc != null), S = c + e, d((h = p.mc) != null), d(S <= h.i), h.C >= S) S = 1;
            else if (p.ic || Ye(), p.ic) {
              p = h.V, F = h.Ba, N = h.c;
              var G = h.i, V = (Z = 1, x = h.$ / N, A = h.$ % N, T = h.m, P = h.s, h.$), W = N * G, ae = N * S, oe = P.wc, de = V < ae ? gt(P, A, x) : null;
              d(V <= W), d(S <= G), d(Qt(P));
              t: for (; ; ) {
                for (; !T.h && V < ae; ) {
                  if (A & oe || (de = gt(P, A, x)), d(de != null), Oe(T), 256 > (G = ut(de.G[0], de.H[0], T))) p[F + V] = G, ++V, ++A >= N && (A = 0, ++x <= S && !(x % 16) && pi(h, x));
                  else {
                    if (!(280 > G)) {
                      Z = 0;
                      break t;
                    }
                    G = De(G - 256, T);
                    var ce, we = ut(de.G[4], de.H[4], T);
                    if (Oe(T), !(V >= (we = et(N, we = De(we, T))) && W - V >= G)) {
                      Z = 0;
                      break t;
                    }
                    for (ce = 0; ce < G; ++ce) p[F + V + ce] = p[F + V + ce - we];
                    for (V += G, A += G; A >= N; ) A -= N, ++x <= S && !(x % 16) && pi(h, x);
                    V < ae && A & oe && (de = gt(P, A, x));
                  }
                  d(T.h == be(T));
                }
                pi(h, x > S ? S : x);
                break t;
              }
              !Z || T.h && V < W ? (Z = 0, h.a = T.h ? 5 : 3) : h.$ = V, S = Z;
            } else S = fi(h, h.V, h.Ba, h.c, h.i, S, Hi);
            if (!S) {
              e = 0;
              break e;
            }
          }
          c + e >= o && (y.Cc = 1), e = 1;
        }
        if (!e) return null;
        if (y.Cc && ((e = y.ga) != null && (e.mc = null), y.ga = null, 0 < y.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return y.nb + c * r;
    }
    function I(y, S, c, e, r, o) {
      for (; 0 < r--; ) {
        var h, p = y, x = S + (c ? 1 : 0), A = y, T = S + (c ? 0 : 3);
        for (h = 0; h < e; ++h) {
          var P = A[T + 4 * h];
          P != 255 && (P *= 32897, p[x + 4 * h + 0] = p[x + 4 * h + 0] * P >> 23, p[x + 4 * h + 1] = p[x + 4 * h + 1] * P >> 23, p[x + 4 * h + 2] = p[x + 4 * h + 2] * P >> 23);
        }
        S += o;
      }
    }
    function K(y, S, c, e, r) {
      for (; 0 < e--; ) {
        var o;
        for (o = 0; o < c; ++o) {
          var h = y[S + 2 * o + 0], p = 15 & (A = y[S + 2 * o + 1]), x = 4369 * p, A = (240 & A | A >> 4) * x >> 16;
          y[S + 2 * o + 0] = (240 & h | h >> 4) * x >> 16 & 240 | (15 & h | h << 4) * x >> 16 >> 4 & 15, y[S + 2 * o + 1] = 240 & A | p;
        }
        S += r;
      }
    }
    function Ee(y, S, c, e, r, o, h, p) {
      var x, A, T = 255;
      for (A = 0; A < r; ++A) {
        for (x = 0; x < e; ++x) {
          var P = y[S + x];
          o[h + 4 * x] = P, T &= P;
        }
        S += c, h += p;
      }
      return T != 255;
    }
    function Re(y, S, c, e, r) {
      var o;
      for (o = 0; o < r; ++o) c[e + o] = y[S + o] >> 8;
    }
    function Ye() {
      Zn = I, Tr = K, Ia = Ee, nu = Re;
    }
    function ct(y, S, c) {
      Ae[y] = function(e, r, o, h, p, x, A, T, P, F, N, Z, G, V, W, ae, oe) {
        var de, ce = oe - 1 >> 1, we = p[x + 0] | A[T + 0] << 16, Le = P[F + 0] | N[Z + 0] << 16;
        d(e != null);
        var ke = 3 * we + Le + 131074 >> 2;
        for (S(e[r + 0], 255 & ke, ke >> 16, G, V), o != null && (ke = 3 * Le + we + 131074 >> 2, S(o[h + 0], 255 & ke, ke >> 16, W, ae)), de = 1; de <= ce; ++de) {
          var tt = p[x + de] | A[T + de] << 16, ht = P[F + de] | N[Z + de] << 16, _t = we + tt + Le + ht + 524296, wt = _t + 2 * (tt + Le) >> 3;
          ke = wt + we >> 1, we = (_t = _t + 2 * (we + ht) >> 3) + tt >> 1, S(e[r + 2 * de - 1], 255 & ke, ke >> 16, G, V + (2 * de - 1) * c), S(e[r + 2 * de - 0], 255 & we, we >> 16, G, V + (2 * de - 0) * c), o != null && (ke = _t + Le >> 1, we = wt + ht >> 1, S(o[h + 2 * de - 1], 255 & ke, ke >> 16, W, ae + (2 * de - 1) * c), S(o[h + 2 * de + 0], 255 & we, we >> 16, W, ae + (2 * de + 0) * c)), we = tt, Le = ht;
        }
        1 & oe || (ke = 3 * we + Le + 131074 >> 2, S(e[r + oe - 1], 255 & ke, ke >> 16, G, V + (oe - 1) * c), o != null && (ke = 3 * Le + we + 131074 >> 2, S(o[h + oe - 1], 255 & ke, ke >> 16, W, ae + (oe - 1) * c)));
      };
    }
    function It() {
      vi[yo] = hu, vi[js] = Ll, vi[Pl] = Ec, vi[qs] = Bu, vi[vo] = $s, vi[rl] = du, vi[vs] = pu, vi[bo] = Ll, vi[Us] = Bu, vi[xo] = $s, vi[nl] = du;
    }
    function Ut(y) {
      return y & ~Pn ? 0 > y ? 0 : 255 : y >> Ru;
    }
    function ui(y, S) {
      return Ut((19077 * y >> 8) + (26149 * S >> 8) - 14234);
    }
    function bi(y, S, c) {
      return Ut((19077 * y >> 8) - (6419 * S >> 8) - (13320 * c >> 8) + 8708);
    }
    function Ti(y, S) {
      return Ut((19077 * y >> 8) + (33050 * S >> 8) - 17685);
    }
    function ki(y, S, c, e, r) {
      e[r + 0] = ui(y, c), e[r + 1] = bi(y, S, c), e[r + 2] = Ti(y, S);
    }
    function nr(y, S, c, e, r) {
      e[r + 0] = Ti(y, S), e[r + 1] = bi(y, S, c), e[r + 2] = ui(y, c);
    }
    function Sr(y, S, c, e, r) {
      var o = bi(y, S, c);
      S = o << 3 & 224 | Ti(y, S) >> 3, e[r + 0] = 248 & ui(y, c) | o >> 5, e[r + 1] = S;
    }
    function Ci(y, S, c, e, r) {
      var o = 240 & Ti(y, S) | 15;
      e[r + 0] = 240 & ui(y, c) | bi(y, S, c) >> 4, e[r + 1] = o;
    }
    function Xr(y, S, c, e, r) {
      e[r + 0] = 255, ki(y, S, c, e, r + 1);
    }
    function oi(y, S, c, e, r) {
      nr(y, S, c, e, r), e[r + 3] = 255;
    }
    function _n(y, S, c, e, r) {
      ki(y, S, c, e, r), e[r + 3] = 255;
    }
    function Mi(y, S) {
      return 0 > y ? 0 : y > S ? S : y;
    }
    function zi(y, S, c) {
      Ae[y] = function(e, r, o, h, p, x, A, T, P) {
        for (var F = T + (-2 & P) * c; T != F; ) S(e[r + 0], o[h + 0], p[x + 0], A, T), S(e[r + 1], o[h + 0], p[x + 0], A, T + c), r += 2, ++h, ++x, T += 2 * c;
        1 & P && S(e[r + 0], o[h + 0], p[x + 0], A, T);
      };
    }
    function Ea(y, S, c) {
      return c == 0 ? y == 0 ? S == 0 ? 6 : 5 : S == 0 ? 4 : 0 : c;
    }
    function Va(y, S, c, e, r) {
      switch (y >>> 30) {
        case 3:
          Rs(S, c, e, r, 0);
          break;
        case 2:
          gs(S, c, e, r);
          break;
        case 1:
          Kr(S, c, e, r);
      }
    }
    function $a(y, S) {
      var c, e, r = S.M, o = S.Nb, h = y.oc, p = y.pc + 40, x = y.oc, A = y.pc + 584, T = y.oc, P = y.pc + 600;
      for (c = 0; 16 > c; ++c) h[p + 32 * c - 1] = 129;
      for (c = 0; 8 > c; ++c) x[A + 32 * c - 1] = 129, T[P + 32 * c - 1] = 129;
      for (0 < r ? h[p - 1 - 32] = x[A - 1 - 32] = T[P - 1 - 32] = 129 : (w(h, p - 32 - 1, 127, 21), w(x, A - 32 - 1, 127, 9), w(T, P - 32 - 1, 127, 9)), e = 0; e < y.za; ++e) {
        var F = S.ya[S.aa + e];
        if (0 < e) {
          for (c = -1; 16 > c; ++c) m(h, p + 32 * c - 4, h, p + 32 * c + 12, 4);
          for (c = -1; 8 > c; ++c) m(x, A + 32 * c - 4, x, A + 32 * c + 4, 4), m(T, P + 32 * c - 4, T, P + 32 * c + 4, 4);
        }
        var N = y.Gd, Z = y.Hd + e, G = F.ad, V = F.Hc;
        if (0 < r && (m(h, p - 32, N[Z].y, 0, 16), m(x, A - 32, N[Z].f, 0, 8), m(T, P - 32, N[Z].ea, 0, 8)), F.Za) {
          var W = h, ae = p - 32 + 16;
          for (0 < r && (e >= y.za - 1 ? w(W, ae, N[Z].y[15], 4) : m(W, ae, N[Z + 1].y, 0, 4)), c = 0; 4 > c; c++) W[ae + 128 + c] = W[ae + 256 + c] = W[ae + 384 + c] = W[ae + 0 + c];
          for (c = 0; 16 > c; ++c, V <<= 2) W = h, ae = p + ma[c], kn[F.Ob[c]](W, ae), Va(V, G, 16 * +c, W, ae);
        } else if (W = Ea(e, r, F.Ob[0]), fa[W](h, p), V != 0) for (c = 0; 16 > c; ++c, V <<= 2) Va(V, G, 16 * +c, h, p + ma[c]);
        for (c = F.Gc, W = Ea(e, r, F.Dd), Pa[W](x, A), Pa[W](T, P), V = G, W = x, ae = A, 255 & (F = c >> 0) && (170 & F ? da(V, 256, W, ae) : yn(V, 256, W, ae)), F = T, V = P, 255 & (c >>= 8) && (170 & c ? da(G, 320, F, V) : yn(G, 320, F, V)), r < y.Ub - 1 && (m(N[Z].y, 0, h, p + 480, 16), m(N[Z].f, 0, x, A + 224, 8), m(N[Z].ea, 0, T, P + 224, 8)), c = 8 * o * y.B, N = y.sa, Z = y.ta + 16 * e + 16 * o * y.R, G = y.qa, F = y.ra + 8 * e + c, V = y.Ha, W = y.Ia + 8 * e + c, c = 0; 16 > c; ++c) m(N, Z + c * y.R, h, p + 32 * c, 16);
        for (c = 0; 8 > c; ++c) m(G, F + c * y.B, x, A + 32 * c, 8), m(V, W + c * y.B, T, P + 32 * c, 8);
      }
    }
    function ds(y, S, c, e, r, o, h, p, x) {
      var A = [0], T = [0], P = 0, F = x != null ? x.kd : 0, N = x ?? new fo();
      if (y == null || 12 > c) return 7;
      N.data = y, N.w = S, N.ha = c, S = [S], c = [c], N.gb = [N.gb];
      e: {
        var Z = S, G = c, V = N.gb;
        if (d(y != null), d(G != null), d(V != null), V[0] = 0, 12 <= G[0] && !l(y, Z[0], "RIFF")) {
          if (l(y, Z[0] + 8, "WEBP")) {
            V = 3;
            break e;
          }
          var W = mt(y, Z[0] + 4);
          if (12 > W || 4294967286 < W) {
            V = 3;
            break e;
          }
          if (F && W > G[0] - 8) {
            V = 7;
            break e;
          }
          V[0] = W, Z[0] += 12, G[0] -= 12;
        }
        V = 0;
      }
      if (V != 0) return V;
      for (W = 0 < N.gb[0], c = c[0]; ; ) {
        e: {
          var ae = y;
          G = S, V = c;
          var oe = A, de = T, ce = Z = [0];
          if ((ke = P = [P])[0] = 0, 8 > V[0]) V = 7;
          else {
            if (!l(ae, G[0], "VP8X")) {
              if (mt(ae, G[0] + 4) != 10) {
                V = 3;
                break e;
              }
              if (18 > V[0]) {
                V = 7;
                break e;
              }
              var we = mt(ae, G[0] + 8), Le = 1 + vt(ae, G[0] + 12);
              if (2147483648 <= Le * (ae = 1 + vt(ae, G[0] + 15))) {
                V = 3;
                break e;
              }
              ce != null && (ce[0] = we), oe != null && (oe[0] = Le), de != null && (de[0] = ae), G[0] += 18, V[0] -= 18, ke[0] = 1;
            }
            V = 0;
          }
        }
        if (P = P[0], Z = Z[0], V != 0) return V;
        if (G = !!(2 & Z), !W && P) return 3;
        if (o != null && (o[0] = !!(16 & Z)), h != null && (h[0] = G), p != null && (p[0] = 0), h = A[0], Z = T[0], P && G && x == null) {
          V = 0;
          break;
        }
        if (4 > c) {
          V = 7;
          break;
        }
        if (W && P || !W && !P && !l(y, S[0], "ALPH")) {
          c = [c], N.na = [N.na], N.P = [N.P], N.Sa = [N.Sa];
          e: {
            we = y, V = S, W = c;
            var ke = N.gb;
            oe = N.na, de = N.P, ce = N.Sa, Le = 22, d(we != null), d(W != null), ae = V[0];
            var tt = W[0];
            for (d(oe != null), d(ce != null), oe[0] = null, de[0] = null, ce[0] = 0; ; ) {
              if (V[0] = ae, W[0] = tt, 8 > tt) {
                V = 7;
                break e;
              }
              var ht = mt(we, ae + 4);
              if (4294967286 < ht) {
                V = 3;
                break e;
              }
              var _t = 8 + ht + 1 & -2;
              if (Le += _t, 0 < ke && Le > ke) {
                V = 3;
                break e;
              }
              if (!l(we, ae, "VP8 ") || !l(we, ae, "VP8L")) {
                V = 0;
                break e;
              }
              if (tt[0] < _t) {
                V = 7;
                break e;
              }
              l(we, ae, "ALPH") || (oe[0] = we, de[0] = ae + 8, ce[0] = ht), ae += _t, tt -= _t;
            }
          }
          if (c = c[0], N.na = N.na[0], N.P = N.P[0], N.Sa = N.Sa[0], V != 0) break;
        }
        c = [c], N.Ja = [N.Ja], N.xa = [N.xa];
        e: if (ke = y, V = S, W = c, oe = N.gb[0], de = N.Ja, ce = N.xa, we = V[0], ae = !l(ke, we, "VP8 "), Le = !l(ke, we, "VP8L"), d(ke != null), d(W != null), d(de != null), d(ce != null), 8 > W[0]) V = 7;
        else {
          if (ae || Le) {
            if (ke = mt(ke, we + 4), 12 <= oe && ke > oe - 12) {
              V = 3;
              break e;
            }
            if (F && ke > W[0] - 8) {
              V = 7;
              break e;
            }
            de[0] = ke, V[0] += 8, W[0] -= 8, ce[0] = Le;
          } else ce[0] = 5 <= W[0] && ke[we + 0] == 47 && !(ke[we + 4] >> 5), de[0] = W[0];
          V = 0;
        }
        if (c = c[0], N.Ja = N.Ja[0], N.xa = N.xa[0], S = S[0], V != 0) break;
        if (4294967286 < N.Ja) return 3;
        if (p == null || G || (p[0] = N.xa ? 2 : 1), h = [h], Z = [Z], N.xa) {
          if (5 > c) {
            V = 7;
            break;
          }
          p = h, F = Z, G = o, y == null || 5 > c ? y = 0 : 5 <= c && y[S + 0] == 47 && !(y[S + 4] >> 5) ? (W = [0], ke = [0], oe = [0], je(de = new Q(), y, S, c), Ne(de, W, ke, oe) ? (p != null && (p[0] = W[0]), F != null && (F[0] = ke[0]), G != null && (G[0] = oe[0]), y = 1) : y = 0) : y = 0;
        } else {
          if (10 > c) {
            V = 7;
            break;
          }
          p = Z, y == null || 10 > c || !gn(y, S + 3, c - 3) ? y = 0 : (F = y[S + 0] | y[S + 1] << 8 | y[S + 2] << 16, G = 16383 & (y[S + 7] << 8 | y[S + 6]), y = 16383 & (y[S + 9] << 8 | y[S + 8]), 1 & F || 3 < (F >> 1 & 7) || !(F >> 4 & 1) || F >> 5 >= N.Ja || !G || !y ? y = 0 : (h && (h[0] = G), p && (p[0] = y), y = 1));
        }
        if (!y || (h = h[0], Z = Z[0], P && (A[0] != h || T[0] != Z))) return 3;
        x != null && (x[0] = N, x.offset = S - x.w, d(4294967286 > S - x.w), d(x.offset == x.ha - c));
        break;
      }
      return V == 0 || V == 7 && P && x == null ? (o != null && (o[0] |= N.na != null && 0 < N.na.length), e != null && (e[0] = h), r != null && (r[0] = Z), 0) : V;
    }
    function ca(y, S, c) {
      var e = S.width, r = S.height, o = 0, h = 0, p = e, x = r;
      if (S.Da = y != null && 0 < y.Da, S.Da && (p = y.cd, x = y.bd, o = y.v, h = y.j, 11 > c || (o &= -2, h &= -2), 0 > o || 0 > h || 0 >= p || 0 >= x || o + p > e || h + x > r)) return 0;
      if (S.v = o, S.j = h, S.va = o + p, S.o = h + x, S.U = p, S.T = x, S.da = y != null && 0 < y.da, S.da) {
        if (!Kt(p, x, c = [y.ib], o = [y.hb])) return 0;
        S.ib = c[0], S.hb = o[0];
      }
      return S.ob = y != null && y.ob, S.Kb = y == null || !y.Sd, S.da && (S.ob = S.ib < 3 * e / 4 && S.hb < 3 * r / 4, S.Kb = 0), 1;
    }
    function Ta(y) {
      if (y == null) return 2;
      if (11 > y.S) {
        var S = y.f.RGBA;
        S.fb += (y.height - 1) * S.A, S.A = -S.A;
      } else S = y.f.kb, y = y.height, S.O += (y - 1) * S.fa, S.fa = -S.fa, S.N += (y - 1 >> 1) * S.Ab, S.Ab = -S.Ab, S.W += (y - 1 >> 1) * S.Db, S.Db = -S.Db, S.F != null && (S.J += (y - 1) * S.lb, S.lb = -S.lb);
      return 0;
    }
    function qr(y, S, c, e) {
      if (e == null || 0 >= y || 0 >= S) return 2;
      if (c != null) {
        if (c.Da) {
          var r = c.cd, o = c.bd, h = -2 & c.v, p = -2 & c.j;
          if (0 > h || 0 > p || 0 >= r || 0 >= o || h + r > y || p + o > S) return 2;
          y = r, S = o;
        }
        if (c.da) {
          if (!Kt(y, S, r = [c.ib], o = [c.hb])) return 2;
          y = r[0], S = o[0];
        }
      }
      e.width = y, e.height = S;
      e: {
        var x = e.width, A = e.height;
        if (y = e.S, 0 >= x || 0 >= A || !(y >= yo && 13 > y)) y = 2;
        else {
          if (0 >= e.Rd && e.sd == null) {
            h = o = r = S = 0;
            var T = (p = x * cl[y]) * A;
            if (11 > y || (o = (A + 1) / 2 * (S = (x + 1) / 2), y == 12 && (h = (r = x) * A)), (A = v(T + 2 * o + h)) == null) {
              y = 1;
              break e;
            }
            e.sd = A, 11 > y ? ((x = e.f.RGBA).eb = A, x.fb = 0, x.A = p, x.size = T) : ((x = e.f.kb).y = A, x.O = 0, x.fa = p, x.Fd = T, x.f = A, x.N = 0 + T, x.Ab = S, x.Cd = o, x.ea = A, x.W = 0 + T + o, x.Db = S, x.Ed = o, y == 12 && (x.F = A, x.J = 0 + T + 2 * o), x.Tc = h, x.lb = r);
          }
          if (S = 1, r = e.S, o = e.width, h = e.height, r >= yo && 13 > r) if (11 > r) y = e.f.RGBA, S &= (p = Math.abs(y.A)) * (h - 1) + o <= y.size, S &= p >= o * cl[r], S &= y.eb != null;
          else {
            y = e.f.kb, p = (o + 1) / 2, T = (h + 1) / 2, x = Math.abs(y.fa), A = Math.abs(y.Ab);
            var P = Math.abs(y.Db), F = Math.abs(y.lb), N = F * (h - 1) + o;
            S &= x * (h - 1) + o <= y.Fd, S &= A * (T - 1) + p <= y.Cd, S = (S &= P * (T - 1) + p <= y.Ed) & x >= o & A >= p & P >= p, S &= y.y != null, S &= y.f != null, S &= y.ea != null, r == 12 && (S &= F >= o, S &= N <= y.Tc, S &= y.F != null);
          }
          else S = 0;
          y = S ? 0 : 2;
        }
      }
      return y != 0 || c != null && c.fd && (y = Ta(e)), y;
    }
    var Yr = 64, ps = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], fs = 24, jn = 32, Za = 8, zr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    xt("Predictor0", "PredictorAdd0"), Ae.Predictor0 = function() {
      return 4278190080;
    }, Ae.Predictor1 = function(y) {
      return y;
    }, Ae.Predictor2 = function(y, S, c) {
      return S[c + 0];
    }, Ae.Predictor3 = function(y, S, c) {
      return S[c + 1];
    }, Ae.Predictor4 = function(y, S, c) {
      return S[c - 1];
    }, Ae.Predictor5 = function(y, S, c) {
      return Et(Et(y, S[c + 1]), S[c + 0]);
    }, Ae.Predictor6 = function(y, S, c) {
      return Et(y, S[c - 1]);
    }, Ae.Predictor7 = function(y, S, c) {
      return Et(y, S[c + 0]);
    }, Ae.Predictor8 = function(y, S, c) {
      return Et(S[c - 1], S[c + 0]);
    }, Ae.Predictor9 = function(y, S, c) {
      return Et(S[c + 0], S[c + 1]);
    }, Ae.Predictor10 = function(y, S, c) {
      return Et(Et(y, S[c - 1]), Et(S[c + 0], S[c + 1]));
    }, Ae.Predictor11 = function(y, S, c) {
      var e = S[c + 0];
      return 0 >= ii(e >> 24 & 255, y >> 24 & 255, (S = S[c - 1]) >> 24 & 255) + ii(e >> 16 & 255, y >> 16 & 255, S >> 16 & 255) + ii(e >> 8 & 255, y >> 8 & 255, S >> 8 & 255) + ii(255 & e, 255 & y, 255 & S) ? e : y;
    }, Ae.Predictor12 = function(y, S, c) {
      var e = S[c + 0];
      return (jt((y >> 24 & 255) + (e >> 24 & 255) - ((S = S[c - 1]) >> 24 & 255)) << 24 | jt((y >> 16 & 255) + (e >> 16 & 255) - (S >> 16 & 255)) << 16 | jt((y >> 8 & 255) + (e >> 8 & 255) - (S >> 8 & 255)) << 8 | jt((255 & y) + (255 & e) - (255 & S))) >>> 0;
    }, Ae.Predictor13 = function(y, S, c) {
      var e = S[c - 1];
      return (ni((y = Et(y, S[c + 0])) >> 24 & 255, e >> 24 & 255) << 24 | ni(y >> 16 & 255, e >> 16 & 255) << 16 | ni(y >> 8 & 255, e >> 8 & 255) << 8 | ni(y >> 0 & 255, e >> 0 & 255)) >>> 0;
    };
    var ms = Ae.PredictorAdd0;
    Ae.PredictorAdd1 = yi, xt("Predictor2", "PredictorAdd2"), xt("Predictor3", "PredictorAdd3"), xt("Predictor4", "PredictorAdd4"), xt("Predictor5", "PredictorAdd5"), xt("Predictor6", "PredictorAdd6"), xt("Predictor7", "PredictorAdd7"), xt("Predictor8", "PredictorAdd8"), xt("Predictor9", "PredictorAdd9"), xt("Predictor10", "PredictorAdd10"), xt("Predictor11", "PredictorAdd11"), xt("Predictor12", "PredictorAdd12"), xt("Predictor13", "PredictorAdd13");
    var Ga = Ae.PredictorAdd2;
    ai("ColorIndexInverseTransform", "MapARGB", "32b", function(y) {
      return y >> 8 & 255;
    }, function(y) {
      return y;
    }), ai("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(y) {
      return y;
    }, function(y) {
      return y >> 8 & 255;
    });
    var Bs, Jr = Ae.ColorIndexInverseTransform, Ca = Ae.MapARGB, kl = Ae.VP8LColorIndexInverseTransformAlpha, tl = Ae.MapAlpha, Di = Ae.VP8LPredictorsAdd = [];
    Di.length = 16, (Ae.VP8LPredictors = []).length = 16, (Ae.VP8LPredictorsAdd_C = []).length = 16, (Ae.VP8LPredictors_C = []).length = 16;
    var un, ha, Ha, cn, Da, Wa, qn, Rs, gs, da, Kr, yn, Un, _s, Vn, $n, ys, hn, pa, tr, Yi, dr, Er, Dn, Zn, Tr, Ia, nu, au = v(511), gr = v(2041), Gn = v(225), vn = v(767), _o = 0, il = gr, Os = Gn, Fr = vn, Pr = au, yo = 0, js = 1, Pl = 2, qs = 3, vo = 4, rl = 5, vs = 6, bo = 7, Us = 8, xo = 9, nl = 10, su = [2, 3, 7], ou = [3, 3, 11], al = [280, 256, 256, 256, 40], wo = [0, 1, 1, 1, 0], zu = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Hn = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], ka = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], lu = 8, In = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], Xa = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], sl = null, Sc = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Fu = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], uu = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], cu = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], Ao = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Wn = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Ot = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], fa = [], kn = [], Pa = [], So = 1, Vs = 2, La = [], vi = [];
    ct("UpsampleRgbLinePair", ki, 3), ct("UpsampleBgrLinePair", nr, 3), ct("UpsampleRgbaLinePair", _n, 4), ct("UpsampleBgraLinePair", oi, 4), ct("UpsampleArgbLinePair", Xr, 4), ct("UpsampleRgba4444LinePair", Ci, 2), ct("UpsampleRgb565LinePair", Sr, 2);
    var hu = Ae.UpsampleRgbLinePair, Ec = Ae.UpsampleBgrLinePair, Ll = Ae.UpsampleRgbaLinePair, Bu = Ae.UpsampleBgraLinePair, $s = Ae.UpsampleArgbLinePair, du = Ae.UpsampleRgba4444LinePair, pu = Ae.UpsampleRgb565LinePair, ol = 16, Ml = 1 << ol - 1, Zs = -227, fu = 482, Ru = 6, Pn = (256 << Ru) - 1, Ji = 0, Eo = v(256), Nl = v(256), zl = v(256), Ou = v(256), ll = v(fu - Zs), ul = v(fu - Zs);
    zi("YuvToRgbRow", ki, 3), zi("YuvToBgrRow", nr, 3), zi("YuvToRgbaRow", _n, 4), zi("YuvToBgraRow", oi, 4), zi("YuvToArgbRow", Xr, 4), zi("YuvToRgba4444Row", Ci, 2), zi("YuvToRgb565Row", Sr, 2);
    var ma = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], bs = [0, 2, 8], Gt = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], li = 1;
    this.WebPDecodeRGBA = function(y, S, c, e, r) {
      var o = js, h = new On(), p = new ie();
      h.ba = p, p.S = o, p.width = [p.width], p.height = [p.height];
      var x = p.width, A = p.height, T = new ue();
      if (T == null || y == null) var P = 2;
      else d(T != null), P = ds(y, S, c, T.width, T.height, T.Pd, T.Qd, T.format, null);
      if (P != 0 ? x = 0 : (x != null && (x[0] = T.width[0]), A != null && (A[0] = T.height[0]), x = 1), x) {
        p.width = p.width[0], p.height = p.height[0], e != null && (e[0] = p.width), r != null && (r[0] = p.height);
        e: {
          if (e = new Rn(), (r = new fo()).data = y, r.w = S, r.ha = c, r.kd = 1, S = [0], d(r != null), ((y = ds(r.data, r.w, r.ha, null, null, null, S, null, r)) == 0 || y == 7) && S[0] && (y = 4), (S = y) == 0) {
            if (d(h != null), e.data = r.data, e.w = r.w + r.offset, e.ha = r.ha - r.offset, e.put = Me, e.ac = ge, e.bc = Fe, e.ma = h, r.xa) {
              if ((y = Oi()) == null) {
                h = 1;
                break e;
              }
              if (function(F, N) {
                var Z = [0], G = [0], V = [0];
                t: for (; ; ) {
                  if (F == null) return 0;
                  if (N == null) return F.a = 2, 0;
                  if (F.l = N, F.a = 0, je(F.m, N.data, N.w, N.ha), !Ne(F.m, Z, G, V)) {
                    F.a = 3;
                    break t;
                  }
                  if (F.xb = Vs, N.width = Z[0], N.height = G[0], !mi(Z[0], G[0], 1, F, null)) break t;
                  return 1;
                }
                return d(F.a != 0), 0;
              }(y, e)) {
                if (e = (S = qr(e.width, e.height, h.Oa, h.ba)) == 0) {
                  t: {
                    e = y;
                    i: for (; ; ) {
                      if (e == null) {
                        e = 0;
                        break t;
                      }
                      if (d(e.s.yc != null), d(e.s.Ya != null), d(0 < e.s.Wb), d((c = e.l) != null), d((r = c.ma) != null), e.xb != 0) {
                        if (e.ca = r.ba, e.tb = r.tb, d(e.ca != null), !ca(r.Oa, c, qs)) {
                          e.a = 2;
                          break i;
                        }
                        if (!Bi(e, c.width) || c.da) break i;
                        if ((c.da || zt(e.ca.S)) && Ye(), 11 > e.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), e.ca.f.kb.F != null && Ye()), e.Pb && 0 < e.s.ua && e.s.vb.X == null && !Pt(e.s.vb, e.s.Wa.Xa)) {
                          e.a = 1;
                          break i;
                        }
                        e.xb = 0;
                      }
                      if (!fi(e, e.V, e.Ba, e.c, e.i, c.o, $t)) break i;
                      r.Dc = e.Ma, e = 1;
                      break t;
                    }
                    d(e.a != 0), e = 0;
                  }
                  e = !e;
                }
                e && (S = y.a);
              } else S = y.a;
            } else {
              if ((y = new br()) == null) {
                h = 1;
                break e;
              }
              if (y.Fa = r.na, y.P = r.P, y.qc = r.Sa, hr(y, e)) {
                if ((S = qr(e.width, e.height, h.Oa, h.ba)) == 0) {
                  if (y.Aa = 0, c = h.Oa, d((r = y) != null), c != null) {
                    if (0 < (x = 0 > (x = c.Md) ? 0 : 100 < x ? 255 : 255 * x / 100)) {
                      for (A = T = 0; 4 > A; ++A) 12 > (P = r.pb[A]).lc && (P.ia = x * Gt[0 > P.lc ? 0 : P.lc] >> 3), T |= P.ia;
                      T && (alert("todo:VP8InitRandom"), r.ia = 1);
                    }
                    r.Ga = c.Id, 100 < r.Ga ? r.Ga = 100 : 0 > r.Ga && (r.Ga = 0);
                  }
                  Ho(y, e) || (S = y.a);
                }
              } else S = y.a;
            }
            S == 0 && h.Oa != null && h.Oa.fd && (S = Ta(h.ba));
          }
          h = S;
        }
        o = h != 0 ? null : 11 > o ? p.f.RGBA.eb : p.f.kb.y;
      } else o = null;
      return o;
    };
    var cl = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function k(Ae, me) {
    for (var ve = "", X = 0; X < 4; X++) ve += String.fromCharCode(Ae[me++]);
    return ve;
  }
  function M(Ae, me) {
    return (Ae[me + 0] << 0 | Ae[me + 1] << 8 | Ae[me + 2] << 16) >>> 0;
  }
  function q(Ae, me) {
    return (Ae[me + 0] << 0 | Ae[me + 1] << 8 | Ae[me + 2] << 16 | Ae[me + 3] << 24) >>> 0;
  }
  new D();
  var O = [0], z = [0], pe = [], le = new D(), se = a, ee = function(Ae, me) {
    var ve = {}, X = 0, re = !1, xe = 0, ye = 0;
    if (ve.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(_e, be, Ce, Oe) {
      for (var $e = 0; $e < Oe; $e++) if (_e[be + $e] != Ce.charCodeAt($e)) return !0;
      return !1;
    }(Ae, me, "RIFF", 4)) {
      var Ve, He;
      for (q(Ae, me += 4), me += 8; me < Ae.length; ) {
        var Ze = k(Ae, me), je = q(Ae, me += 4);
        me += 4;
        var Je = je + (1 & je);
        switch (Ze) {
          case "VP8 ":
          case "VP8L":
            ve.frames[X] === void 0 && (ve.frames[X] = {}), (Q = ve.frames[X]).src_off = re ? ye : me - 8, Q.src_size = xe + je + 8, X++, re && (re = !1, xe = 0, ye = 0);
            break;
          case "VP8X":
            (Q = ve.header = {}).feature_flags = Ae[me];
            var Qe = me + 4;
            Q.canvas_width = 1 + M(Ae, Qe), Qe += 3, Q.canvas_height = 1 + M(Ae, Qe), Qe += 3;
            break;
          case "ALPH":
            re = !0, xe = Je + 8, ye = me - 8;
            break;
          case "ANIM":
            (Q = ve.header).bgcolor = q(Ae, me), Qe = me + 4, Q.loop_count = (Ve = Ae)[(He = Qe) + 0] << 0 | Ve[He + 1] << 8, Qe += 2;
            break;
          case "ANMF":
            var nt, Q;
            (Q = ve.frames[X] = {}).offset_x = 2 * M(Ae, me), me += 3, Q.offset_y = 2 * M(Ae, me), me += 3, Q.width = 1 + M(Ae, me), me += 3, Q.height = 1 + M(Ae, me), me += 3, Q.duration = M(Ae, me), me += 3, nt = Ae[me++], Q.dispose = 1 & nt, Q.blend = nt >> 1 & 1;
        }
        Ze != "ANMF" && (me += Je);
      }
      return ve;
    }
  }(se, 0);
  ee.response = se, ee.rgbaoutput = !0, ee.dataurl = !1;
  var fe = ee.header ? ee.header : null, Te = ee.frames ? ee.frames : null;
  if (fe) {
    fe.loop_counter = fe.loop_count, O = [fe.canvas_height], z = [fe.canvas_width];
    for (var ze = 0; ze < Te.length && Te[ze].blend != 0; ze++) ;
  }
  var qe = Te[0], at = le.WebPDecodeRGBA(se, qe.src_off, qe.src_size, z, O);
  qe.rgba = at, qe.imgwidth = z[0], qe.imgheight = O[0];
  for (var Ie = 0; Ie < z[0] * O[0] * 4; Ie++) pe[Ie] = at[Ie];
  return this.width = z, this.height = O, this.data = pe, this;
}
(function(a) {
  var d = function() {
    return typeof Vp == "function";
  }, l = function(O, z, pe, le) {
    var se = 4, ee = g;
    switch (le) {
      case a.image_compression.FAST:
        se = 1, ee = v;
        break;
      case a.image_compression.MEDIUM:
        se = 6, ee = s;
        break;
      case a.image_compression.SLOW:
        se = 9, ee = D;
    }
    O = m(O, z, pe, ee);
    var fe = Vp(O, { level: se });
    return a.__addimage__.arrayBufferToBinaryString(fe);
  }, m = function(O, z, pe, le) {
    for (var se, ee, fe, Te = O.length / z, ze = new Uint8Array(O.length + Te), qe = M(), at = 0; at < Te; at += 1) {
      if (fe = at * z, se = O.subarray(fe, fe + z), le) ze.set(le(se, pe, ee), fe + at);
      else {
        for (var Ie, Ae = qe.length, me = []; Ie < Ae; Ie += 1) me[Ie] = qe[Ie](se, pe, ee);
        var ve = q(me.concat());
        ze.set(me[ve], fe + at);
      }
      ee = se;
    }
    return ze;
  }, w = function(O) {
    var z = Array.apply([], O);
    return z.unshift(0), z;
  }, v = function(O, z) {
    var pe, le = [], se = O.length;
    le[0] = 1;
    for (var ee = 0; ee < se; ee += 1) pe = O[ee - z] || 0, le[ee + 1] = O[ee] - pe + 256 & 255;
    return le;
  }, g = function(O, z, pe) {
    var le, se = [], ee = O.length;
    se[0] = 2;
    for (var fe = 0; fe < ee; fe += 1) le = pe && pe[fe] || 0, se[fe + 1] = O[fe] - le + 256 & 255;
    return se;
  }, s = function(O, z, pe) {
    var le, se, ee = [], fe = O.length;
    ee[0] = 3;
    for (var Te = 0; Te < fe; Te += 1) le = O[Te - z] || 0, se = pe && pe[Te] || 0, ee[Te + 1] = O[Te] + 256 - (le + se >>> 1) & 255;
    return ee;
  }, D = function(O, z, pe) {
    var le, se, ee, fe, Te = [], ze = O.length;
    Te[0] = 4;
    for (var qe = 0; qe < ze; qe += 1) le = O[qe - z] || 0, se = pe && pe[qe] || 0, ee = pe && pe[qe - z] || 0, fe = k(le, se, ee), Te[qe + 1] = O[qe] - fe + 256 & 255;
    return Te;
  }, k = function(O, z, pe) {
    if (O === z && z === pe) return O;
    var le = Math.abs(z - pe), se = Math.abs(O - pe), ee = Math.abs(O + z - pe - pe);
    return le <= se && le <= ee ? O : se <= ee ? z : pe;
  }, M = function() {
    return [w, v, g, s, D];
  }, q = function(O) {
    var z = O.map(function(pe) {
      return pe.reduce(function(le, se) {
        return le + Math.abs(se);
      }, 0);
    });
    return z.indexOf(Math.min.apply(null, z));
  };
  a.processPNG = function(O, z, pe, le) {
    var se, ee, fe, Te, ze, qe, at, Ie, Ae, me, ve, X, re, xe, ye, Ve = this.decode.FLATE_DECODE, He = "";
    if (this.__addimage__.isArrayBuffer(O) && (O = new Uint8Array(O)), this.__addimage__.isArrayBufferView(O)) {
      if (O = (fe = new Mb(O)).imgData, ee = fe.bits, se = fe.colorSpace, ze = fe.colors, [4, 6].indexOf(fe.colorType) !== -1) {
        if (fe.bits === 8) {
          Ae = (Ie = fe.pixelBitlength == 32 ? new Uint32Array(fe.decodePixels().buffer) : fe.pixelBitlength == 16 ? new Uint16Array(fe.decodePixels().buffer) : new Uint8Array(fe.decodePixels().buffer)).length, ve = new Uint8Array(Ae * fe.colors), me = new Uint8Array(Ae);
          var Ze, je = fe.pixelBitlength - fe.bits;
          for (xe = 0, ye = 0; xe < Ae; xe++) {
            for (re = Ie[xe], Ze = 0; Ze < je; ) ve[ye++] = re >>> Ze & 255, Ze += fe.bits;
            me[xe] = re >>> Ze & 255;
          }
        }
        if (fe.bits === 16) {
          Ae = (Ie = new Uint32Array(fe.decodePixels().buffer)).length, ve = new Uint8Array(Ae * (32 / fe.pixelBitlength) * fe.colors), me = new Uint8Array(Ae * (32 / fe.pixelBitlength)), X = fe.colors > 1, xe = 0, ye = 0;
          for (var Je = 0; xe < Ae; ) re = Ie[xe++], ve[ye++] = re >>> 0 & 255, X && (ve[ye++] = re >>> 16 & 255, re = Ie[xe++], ve[ye++] = re >>> 0 & 255), me[Je++] = re >>> 16 & 255;
          ee = 8;
        }
        le !== a.image_compression.NONE && d() ? (O = l(ve, fe.width * fe.colors, fe.colors, le), at = l(me, fe.width, 1, le)) : (O = ve, at = me, Ve = void 0);
      }
      if (fe.colorType === 3 && (se = this.color_spaces.INDEXED, qe = fe.palette, fe.transparency.indexed)) {
        var Qe = fe.transparency.indexed, nt = 0;
        for (xe = 0, Ae = Qe.length; xe < Ae; ++xe) nt += Qe[xe];
        if ((nt /= 255) === Ae - 1 && Qe.indexOf(0) !== -1) Te = [Qe.indexOf(0)];
        else if (nt !== Ae) {
          for (Ie = fe.decodePixels(), me = new Uint8Array(Ie.length), xe = 0, Ae = Ie.length; xe < Ae; xe++) me[xe] = Qe[Ie[xe]];
          at = l(me, fe.width, 1);
        }
      }
      var Q = function(_e) {
        var be;
        switch (_e) {
          case a.image_compression.FAST:
            be = 11;
            break;
          case a.image_compression.MEDIUM:
            be = 13;
            break;
          case a.image_compression.SLOW:
            be = 14;
            break;
          default:
            be = 12;
        }
        return be;
      }(le);
      return Ve === this.decode.FLATE_DECODE && (He = "/Predictor " + Q + " "), He += "/Colors " + ze + " /BitsPerComponent " + ee + " /Columns " + fe.width, (this.__addimage__.isArrayBuffer(O) || this.__addimage__.isArrayBufferView(O)) && (O = this.__addimage__.arrayBufferToBinaryString(O)), (at && this.__addimage__.isArrayBuffer(at) || this.__addimage__.isArrayBufferView(at)) && (at = this.__addimage__.arrayBufferToBinaryString(at)), { alias: pe, data: O, index: z, filter: Ve, decodeParameters: He, transparency: Te, palette: qe, sMask: at, predictor: Q, width: fe.width, height: fe.height, bitsPerComponent: ee, colorSpace: se };
    }
  };
})(wi.API), function(a) {
  a.processGIF89A = function(d, l, m, w) {
    var v = new Nb(d), g = v.width, s = v.height, D = [];
    v.decodeAndBlitFrameRGBA(0, D);
    var k = { data: D, width: g, height: s }, M = new Ap(100).encode(k, 100);
    return a.processJPEG.call(this, M, l, m, w);
  }, a.processGIF87A = a.processGIF89A;
}(wi.API), Ys.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var a = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(a);
    for (var d = 0; d < a; d++) {
      var l = this.datav.getUint8(this.pos++, !0), m = this.datav.getUint8(this.pos++, !0), w = this.datav.getUint8(this.pos++, !0), v = this.datav.getUint8(this.pos++, !0);
      this.palette[d] = { red: w, green: m, blue: l, quad: v };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, Ys.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var a = "bit" + this.bitPP, d = this.width * this.height * 4;
    this.data = new Uint8Array(d), this[a]();
  } catch (l) {
    yr.log("bit decode error:" + l);
  }
}, Ys.prototype.bit1 = function() {
  var a, d = Math.ceil(this.width / 8), l = d % 4;
  for (a = this.height - 1; a >= 0; a--) {
    for (var m = this.bottom_up ? a : this.height - 1 - a, w = 0; w < d; w++) for (var v = this.datav.getUint8(this.pos++, !0), g = m * this.width * 4 + 8 * w * 4, s = 0; s < 8 && 8 * w + s < this.width; s++) {
      var D = this.palette[v >> 7 - s & 1];
      this.data[g + 4 * s] = D.blue, this.data[g + 4 * s + 1] = D.green, this.data[g + 4 * s + 2] = D.red, this.data[g + 4 * s + 3] = 255;
    }
    l !== 0 && (this.pos += 4 - l);
  }
}, Ys.prototype.bit4 = function() {
  for (var a = Math.ceil(this.width / 2), d = a % 4, l = this.height - 1; l >= 0; l--) {
    for (var m = this.bottom_up ? l : this.height - 1 - l, w = 0; w < a; w++) {
      var v = this.datav.getUint8(this.pos++, !0), g = m * this.width * 4 + 2 * w * 4, s = v >> 4, D = 15 & v, k = this.palette[s];
      if (this.data[g] = k.blue, this.data[g + 1] = k.green, this.data[g + 2] = k.red, this.data[g + 3] = 255, 2 * w + 1 >= this.width) break;
      k = this.palette[D], this.data[g + 4] = k.blue, this.data[g + 4 + 1] = k.green, this.data[g + 4 + 2] = k.red, this.data[g + 4 + 3] = 255;
    }
    d !== 0 && (this.pos += 4 - d);
  }
}, Ys.prototype.bit8 = function() {
  for (var a = this.width % 4, d = this.height - 1; d >= 0; d--) {
    for (var l = this.bottom_up ? d : this.height - 1 - d, m = 0; m < this.width; m++) {
      var w = this.datav.getUint8(this.pos++, !0), v = l * this.width * 4 + 4 * m;
      if (w < this.palette.length) {
        var g = this.palette[w];
        this.data[v] = g.red, this.data[v + 1] = g.green, this.data[v + 2] = g.blue, this.data[v + 3] = 255;
      } else this.data[v] = 255, this.data[v + 1] = 255, this.data[v + 2] = 255, this.data[v + 3] = 255;
    }
    a !== 0 && (this.pos += 4 - a);
  }
}, Ys.prototype.bit15 = function() {
  for (var a = this.width % 3, d = parseInt("11111", 2), l = this.height - 1; l >= 0; l--) {
    for (var m = this.bottom_up ? l : this.height - 1 - l, w = 0; w < this.width; w++) {
      var v = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var g = (v & d) / d * 255 | 0, s = (v >> 5 & d) / d * 255 | 0, D = (v >> 10 & d) / d * 255 | 0, k = v >> 15 ? 255 : 0, M = m * this.width * 4 + 4 * w;
      this.data[M] = D, this.data[M + 1] = s, this.data[M + 2] = g, this.data[M + 3] = k;
    }
    this.pos += a;
  }
}, Ys.prototype.bit16 = function() {
  for (var a = this.width % 3, d = parseInt("11111", 2), l = parseInt("111111", 2), m = this.height - 1; m >= 0; m--) {
    for (var w = this.bottom_up ? m : this.height - 1 - m, v = 0; v < this.width; v++) {
      var g = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var s = (g & d) / d * 255 | 0, D = (g >> 5 & l) / l * 255 | 0, k = (g >> 11) / d * 255 | 0, M = w * this.width * 4 + 4 * v;
      this.data[M] = k, this.data[M + 1] = D, this.data[M + 2] = s, this.data[M + 3] = 255;
    }
    this.pos += a;
  }
}, Ys.prototype.bit24 = function() {
  for (var a = this.height - 1; a >= 0; a--) {
    for (var d = this.bottom_up ? a : this.height - 1 - a, l = 0; l < this.width; l++) {
      var m = this.datav.getUint8(this.pos++, !0), w = this.datav.getUint8(this.pos++, !0), v = this.datav.getUint8(this.pos++, !0), g = d * this.width * 4 + 4 * l;
      this.data[g] = v, this.data[g + 1] = w, this.data[g + 2] = m, this.data[g + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, Ys.prototype.bit32 = function() {
  for (var a = this.height - 1; a >= 0; a--) for (var d = this.bottom_up ? a : this.height - 1 - a, l = 0; l < this.width; l++) {
    var m = this.datav.getUint8(this.pos++, !0), w = this.datav.getUint8(this.pos++, !0), v = this.datav.getUint8(this.pos++, !0), g = this.datav.getUint8(this.pos++, !0), s = d * this.width * 4 + 4 * l;
    this.data[s] = v, this.data[s + 1] = w, this.data[s + 2] = m, this.data[s + 3] = g;
  }
}, Ys.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(a) {
  a.processBMP = function(d, l, m, w) {
    var v = new Ys(d, !1), g = v.width, s = v.height, D = { data: v.getData(), width: g, height: s }, k = new Ap(100).encode(D, 100);
    return a.processJPEG.call(this, k, l, m, w);
  };
}(wi.API), $0.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(a) {
  a.processWEBP = function(d, l, m, w) {
    var v = new $0(d), g = v.width, s = v.height, D = { data: v.getData(), width: g, height: s }, k = new Ap(100).encode(D, 100);
    return a.processJPEG.call(this, k, l, m, w);
  };
}(wi.API), wi.API.processRGBA = function(a, d, l) {
  for (var m = a.data, w = m.length, v = new Uint8Array(w / 4 * 3), g = new Uint8Array(w / 4), s = 0, D = 0, k = 0; k < w; k += 4) {
    var M = m[k], q = m[k + 1], O = m[k + 2], z = m[k + 3];
    v[s++] = M, v[s++] = q, v[s++] = O, g[D++] = z;
  }
  var pe = this.__addimage__.arrayBufferToBinaryString(v);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(g), data: pe, index: d, alias: l, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: a.width, height: a.height };
}, wi.API.setLanguage = function(a) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[a] !== void 0 && (this.internal.languageSettings.languageCode = a, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, sc = wi.API, Xh = sc.getCharWidthsArray = function(a, d) {
  var l, m, w = (d = d || {}).font || this.internal.getFont(), v = d.fontSize || this.internal.getFontSize(), g = d.charSpace || this.internal.getCharSpace(), s = d.widths ? d.widths : w.metadata.Unicode.widths, D = s.fof ? s.fof : 1, k = d.kerning ? d.kerning : w.metadata.Unicode.kerning, M = k.fof ? k.fof : 1, q = d.doKerning !== !1, O = 0, z = a.length, pe = 0, le = s[0] || D, se = [];
  for (l = 0; l < z; l++) m = a.charCodeAt(l), typeof w.metadata.widthOfString == "function" ? se.push((w.metadata.widthOfGlyph(w.metadata.characterToGlyph(m)) + g * (1e3 / v) || 0) / 1e3) : (O = q && ur(k[m]) === "object" && !isNaN(parseInt(k[m][pe], 10)) ? k[m][pe] / M : 0, se.push((s[m] || le) / D + O)), pe = m;
  return se;
}, j0 = sc.getStringUnitWidth = function(a, d) {
  var l = (d = d || {}).fontSize || this.internal.getFontSize(), m = d.font || this.internal.getFont(), w = d.charSpace || this.internal.getCharSpace();
  return sc.processArabic && (a = sc.processArabic(a)), typeof m.metadata.widthOfString == "function" ? m.metadata.widthOfString(a, l, w) / l : Xh.apply(this, arguments).reduce(function(v, g) {
    return v + g;
  }, 0);
}, q0 = function(a, d, l, m) {
  for (var w = [], v = 0, g = a.length, s = 0; v !== g && s + d[v] < l; ) s += d[v], v++;
  w.push(a.slice(0, v));
  var D = v;
  for (s = 0; v !== g; ) s + d[v] > m && (w.push(a.slice(D, v)), s = 0, D = v), s += d[v], v++;
  return D !== v && w.push(a.slice(D, v)), w;
}, U0 = function(a, d, l) {
  l || (l = {});
  var m, w, v, g, s, D, k, M = [], q = [M], O = l.textIndent || 0, z = 0, pe = 0, le = a.split(" "), se = Xh.apply(this, [" ", l])[0];
  if (D = l.lineIndent === -1 ? le[0].length + 2 : l.lineIndent || 0) {
    var ee = Array(D).join(" "), fe = [];
    le.map(function(ze) {
      (ze = ze.split(/\s*\n/)).length > 1 ? fe = fe.concat(ze.map(function(qe, at) {
        return (at && qe.length ? `
` : "") + qe;
      })) : fe.push(ze[0]);
    }), le = fe, D = j0.apply(this, [ee, l]);
  }
  for (v = 0, g = le.length; v < g; v++) {
    var Te = 0;
    if (m = le[v], D && m[0] == `
` && (m = m.substr(1), Te = 1), O + z + (pe = (w = Xh.apply(this, [m, l])).reduce(function(ze, qe) {
      return ze + qe;
    }, 0)) > d || Te) {
      if (pe > d) {
        for (s = q0.apply(this, [m, w, d - (O + z), d]), M.push(s.shift()), M = [s.pop()]; s.length; ) q.push([s.shift()]);
        pe = w.slice(m.length - (M[0] ? M[0].length : 0)).reduce(function(ze, qe) {
          return ze + qe;
        }, 0);
      } else M = [m];
      q.push(M), O = pe + D, z = se;
    } else M.push(m), O += z + pe, z = se;
  }
  return k = D ? function(ze, qe) {
    return (qe ? ee : "") + ze.join(" ");
  } : function(ze) {
    return ze.join(" ");
  }, q.map(k);
}, sc.splitTextToSize = function(a, d, l) {
  var m, w = (l = l || {}).fontSize || this.internal.getFontSize(), v = (function(M) {
    if (M.widths && M.kerning) return { widths: M.widths, kerning: M.kerning };
    var q = this.internal.getFont(M.fontName, M.fontStyle);
    return q.metadata.Unicode ? { widths: q.metadata.Unicode.widths || { 0: 1 }, kerning: q.metadata.Unicode.kerning || {} } : { font: q.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, l);
  m = Array.isArray(a) ? a : String(a).split(/\r?\n/);
  var g = 1 * this.internal.scaleFactor * d / w;
  v.textIndent = l.textIndent ? 1 * l.textIndent * this.internal.scaleFactor / w : 0, v.lineIndent = l.lineIndent;
  var s, D, k = [];
  for (s = 0, D = m.length; s < D; s++) k = k.concat(U0.apply(this, [m[s], g, v]));
  return k;
}, function(a) {
  a.__fontmetrics__ = a.__fontmetrics__ || {};
  for (var d = "klmnopqrstuvwxyz", l = {}, m = {}, w = 0; w < d.length; w++) l[d[w]] = "0123456789abcdef"[w], m["0123456789abcdef"[w]] = d[w];
  var v = function(q) {
    return "0x" + parseInt(q, 10).toString(16);
  }, g = a.__fontmetrics__.compress = function(q) {
    var O, z, pe, le, se = ["{"];
    for (var ee in q) {
      if (O = q[ee], isNaN(parseInt(ee, 10)) ? z = "'" + ee + "'" : (ee = parseInt(ee, 10), z = (z = v(ee).slice(2)).slice(0, -1) + m[z.slice(-1)]), typeof O == "number") O < 0 ? (pe = v(O).slice(3), le = "-") : (pe = v(O).slice(2), le = ""), pe = le + pe.slice(0, -1) + m[pe.slice(-1)];
      else {
        if (ur(O) !== "object") throw new Error("Don't know what to do with value type " + ur(O) + ".");
        pe = g(O);
      }
      se.push(z + pe);
    }
    return se.push("}"), se.join("");
  }, s = a.__fontmetrics__.uncompress = function(q) {
    if (typeof q != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var O, z, pe, le, se = {}, ee = 1, fe = se, Te = [], ze = "", qe = "", at = q.length - 1, Ie = 1; Ie < at; Ie += 1) (le = q[Ie]) == "'" ? O ? (pe = O.join(""), O = void 0) : O = [] : O ? O.push(le) : le == "{" ? (Te.push([fe, pe]), fe = {}, pe = void 0) : le == "}" ? ((z = Te.pop())[0][z[1]] = fe, pe = void 0, fe = z[0]) : le == "-" ? ee = -1 : pe === void 0 ? l.hasOwnProperty(le) ? (ze += l[le], pe = parseInt(ze, 16) * ee, ee = 1, ze = "") : ze += le : l.hasOwnProperty(le) ? (qe += l[le], fe[pe] = parseInt(qe, 16) * ee, ee = 1, pe = void 0, qe = "") : qe += le;
    return se;
  }, D = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: s("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, k = { Unicode: { Courier: D, "Courier-Bold": D, "Courier-BoldOblique": D, "Courier-Oblique": D, Helvetica: D, "Helvetica-Bold": D, "Helvetica-BoldOblique": D, "Helvetica-Oblique": D, "Times-Roman": D, "Times-Bold": D, "Times-BoldItalic": D, "Times-Italic": D } }, M = { Unicode: { "Courier-Oblique": s("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": s("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": s("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: s("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": s("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": s("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: s("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: s("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": s("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: s("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": s("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": s("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": s("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": s("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  a.events.push(["addFont", function(q) {
    var O = q.font, z = M.Unicode[O.postScriptName];
    z && (O.metadata.Unicode = {}, O.metadata.Unicode.widths = z.widths, O.metadata.Unicode.kerning = z.kerning);
    var pe = k.Unicode[O.postScriptName];
    pe && (O.metadata.Unicode.encoding = pe, O.encoding = pe.codePages[0]);
  }]);
}(wi.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(a) {
  var d = function(l) {
    for (var m = l.length, w = new Uint8Array(m), v = 0; v < m; v++) w[v] = l.charCodeAt(v);
    return w;
  };
  a.API.events.push(["addFont", function(l) {
    var m = void 0, w = l.font, v = l.instance;
    if (!w.isStandardFont) {
      if (v === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + w.postScriptName + "').");
      if (typeof (m = v.existsFileInVFS(w.postScriptName) === !1 ? v.loadFile(w.postScriptName) : v.getFileFromVFS(w.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + w.postScriptName + "').");
      (function(g, s) {
        s = /^\x00\x01\x00\x00/.test(s) ? d(s) : d(oh(s)), g.metadata = a.API.TTFFont.open(s), g.metadata.Unicode = g.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, g.metadata.glyIdsUsed = [0];
      })(w, m);
    }
  }]);
}(wi), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(a) {
  function d() {
    return (Ai.canvg ? Promise.resolve(Ai.canvg) : import("./index.es-DoMiftKY-wPbZZyE5.js")).catch(function(l) {
      return Promise.reject(new Error("Could not load canvg: " + l));
    }).then(function(l) {
      return l.default ? l.default : l;
    });
  }
  wi.API.addSvgAsImage = function(l, m, w, v, g, s, D, k) {
    if (isNaN(m) || isNaN(w)) throw yr.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(v) || isNaN(g)) throw yr.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var M = document.createElement("canvas");
    M.width = v, M.height = g;
    var q = M.getContext("2d");
    q.fillStyle = "#fff", q.fillRect(0, 0, M.width, M.height);
    var O = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, z = this;
    return d().then(function(pe) {
      return pe.fromString(q, l, O);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(pe) {
      return pe.render(O);
    }).then(function() {
      z.addImage(M.toDataURL("image/jpeg", 1), m, w, v, g, D, k);
    });
  };
}(), wi.API.putTotalPages = function(a) {
  var d, l = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (d = new RegExp(a, "g"), l = this.internal.getNumberOfPages()) : (d = new RegExp(this.pdfEscape16(a, this.internal.getFont()), "g"), l = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var m = 1; m <= this.internal.getNumberOfPages(); m++) for (var w = 0; w < this.internal.pages[m].length; w++) this.internal.pages[m][w] = this.internal.pages[m][w].replace(d, l);
  return this;
}, wi.API.viewerPreferences = function(a, d) {
  var l;
  a = a || {}, d = d || !1;
  var m, w, v, g = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, s = Object.keys(g), D = [], k = 0, M = 0, q = 0;
  function O(pe, le) {
    var se, ee = !1;
    for (se = 0; se < pe.length; se += 1) pe[se] === le && (ee = !0);
    return ee;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(g)), this.internal.viewerpreferences.isSubscribed = !1), l = this.internal.viewerpreferences.configuration, a === "reset" || d === !0) {
    var z = s.length;
    for (q = 0; q < z; q += 1) l[s[q]].value = l[s[q]].defaultValue, l[s[q]].explicitSet = !1;
  }
  if (ur(a) === "object") {
    for (w in a) if (v = a[w], O(s, w) && v !== void 0) {
      if (l[w].type === "boolean" && typeof v == "boolean") l[w].value = v;
      else if (l[w].type === "name" && O(l[w].valueSet, v)) l[w].value = v;
      else if (l[w].type === "integer" && Number.isInteger(v)) l[w].value = v;
      else if (l[w].type === "array") {
        for (k = 0; k < v.length; k += 1) if (m = !0, v[k].length === 1 && typeof v[k][0] == "number") D.push(String(v[k] - 1));
        else if (v[k].length > 1) {
          for (M = 0; M < v[k].length; M += 1) typeof v[k][M] != "number" && (m = !1);
          m === !0 && D.push([v[k][0] - 1, v[k][1] - 1].join(" "));
        }
        l[w].value = "[" + D.join(" ") + "]";
      } else l[w].value = l[w].defaultValue;
      l[w].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var pe, le = [];
    for (pe in l) l[pe].explicitSet === !0 && (l[pe].type === "name" ? le.push("/" + pe + " /" + l[pe].value) : le.push("/" + pe + " " + l[pe].value));
    le.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + le.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = l, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(a) {
  var d = function() {
    var m = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', w = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), v = unescape(encodeURIComponent(m)), g = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), s = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), D = unescape(encodeURIComponent("</x:xmpmeta>")), k = v.length + g.length + s.length + w.length + D.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + k + " >>"), this.internal.write("stream"), this.internal.write(w + v + g + s + D), this.internal.write("endstream"), this.internal.write("endobj");
  }, l = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  a.addMetadata = function(m, w) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: m, namespaceuri: w || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", l), this.internal.events.subscribe("postPutResources", d)), this;
  };
}(wi.API), function(a) {
  var d = a.API, l = d.pdfEscape16 = function(v, g) {
    for (var s, D = g.metadata.Unicode.widths, k = ["", "0", "00", "000", "0000"], M = [""], q = 0, O = v.length; q < O; ++q) {
      if (s = g.metadata.characterToGlyph(v.charCodeAt(q)), g.metadata.glyIdsUsed.push(s), g.metadata.toUnicode[s] = v.charCodeAt(q), D.indexOf(s) == -1 && (D.push(s), D.push([parseInt(g.metadata.widthOfGlyph(s), 10)])), s == "0") return M.join("");
      s = s.toString(16), M.push(k[4 - s.length], s);
    }
    return M.join("");
  }, m = function(v) {
    var g, s, D, k, M, q, O;
    for (M = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, D = [], q = 0, O = (s = Object.keys(v).sort(function(z, pe) {
      return z - pe;
    })).length; q < O; q++) g = s[q], D.length >= 100 && (M += `
` + D.length + ` beginbfchar
` + D.join(`
`) + `
endbfchar`, D = []), v[g] !== void 0 && v[g] !== null && typeof v[g].toString == "function" && (k = ("0000" + v[g].toString(16)).slice(-4), g = ("0000" + (+g).toString(16)).slice(-4), D.push("<" + g + "><" + k + ">"));
    return D.length && (M += `
` + D.length + ` beginbfchar
` + D.join(`
`) + `
endbfchar
`), M += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  d.events.push(["putFont", function(v) {
    (function(g) {
      var s = g.font, D = g.out, k = g.newObject, M = g.putStream;
      if (s.metadata instanceof a.API.TTFFont && s.encoding === "Identity-H") {
        for (var q = s.metadata.Unicode.widths, O = s.metadata.subset.encode(s.metadata.glyIdsUsed, 1), z = "", pe = 0; pe < O.length; pe++) z += String.fromCharCode(O[pe]);
        var le = k();
        M({ data: z, addLength1: !0, objectId: le }), D("endobj");
        var se = k();
        M({ data: m(s.metadata.toUnicode), addLength1: !0, objectId: se }), D("endobj");
        var ee = k();
        D("<<"), D("/Type /FontDescriptor"), D("/FontName /" + lc(s.fontName)), D("/FontFile2 " + le + " 0 R"), D("/FontBBox " + a.API.PDFObject.convert(s.metadata.bbox)), D("/Flags " + s.metadata.flags), D("/StemV " + s.metadata.stemV), D("/ItalicAngle " + s.metadata.italicAngle), D("/Ascent " + s.metadata.ascender), D("/Descent " + s.metadata.decender), D("/CapHeight " + s.metadata.capHeight), D(">>"), D("endobj");
        var fe = k();
        D("<<"), D("/Type /Font"), D("/BaseFont /" + lc(s.fontName)), D("/FontDescriptor " + ee + " 0 R"), D("/W " + a.API.PDFObject.convert(q)), D("/CIDToGIDMap /Identity"), D("/DW 1000"), D("/Subtype /CIDFontType2"), D("/CIDSystemInfo"), D("<<"), D("/Supplement 0"), D("/Registry (Adobe)"), D("/Ordering (" + s.encoding + ")"), D(">>"), D(">>"), D("endobj"), s.objectNumber = k(), D("<<"), D("/Type /Font"), D("/Subtype /Type0"), D("/ToUnicode " + se + " 0 R"), D("/BaseFont /" + lc(s.fontName)), D("/Encoding /" + s.encoding), D("/DescendantFonts [" + fe + " 0 R]"), D(">>"), D("endobj"), s.isAlreadyPutted = !0;
      }
    })(v);
  }]), d.events.push(["putFont", function(v) {
    (function(g) {
      var s = g.font, D = g.out, k = g.newObject, M = g.putStream;
      if (s.metadata instanceof a.API.TTFFont && s.encoding === "WinAnsiEncoding") {
        for (var q = s.metadata.rawData, O = "", z = 0; z < q.length; z++) O += String.fromCharCode(q[z]);
        var pe = k();
        M({ data: O, addLength1: !0, objectId: pe }), D("endobj");
        var le = k();
        M({ data: m(s.metadata.toUnicode), addLength1: !0, objectId: le }), D("endobj");
        var se = k();
        D("<<"), D("/Descent " + s.metadata.decender), D("/CapHeight " + s.metadata.capHeight), D("/StemV " + s.metadata.stemV), D("/Type /FontDescriptor"), D("/FontFile2 " + pe + " 0 R"), D("/Flags 96"), D("/FontBBox " + a.API.PDFObject.convert(s.metadata.bbox)), D("/FontName /" + lc(s.fontName)), D("/ItalicAngle " + s.metadata.italicAngle), D("/Ascent " + s.metadata.ascender), D(">>"), D("endobj"), s.objectNumber = k();
        for (var ee = 0; ee < s.metadata.hmtx.widths.length; ee++) s.metadata.hmtx.widths[ee] = parseInt(s.metadata.hmtx.widths[ee] * (1e3 / s.metadata.head.unitsPerEm));
        D("<</Subtype/TrueType/Type/Font/ToUnicode " + le + " 0 R/BaseFont/" + lc(s.fontName) + "/FontDescriptor " + se + " 0 R/Encoding/" + s.encoding + " /FirstChar 29 /LastChar 255 /Widths " + a.API.PDFObject.convert(s.metadata.hmtx.widths) + ">>"), D("endobj"), s.isAlreadyPutted = !0;
      }
    })(v);
  }]);
  var w = function(v) {
    var g, s = v.text || "", D = v.x, k = v.y, M = v.options || {}, q = v.mutex || {}, O = q.pdfEscape, z = q.activeFontKey, pe = q.fonts, le = z, se = "", ee = 0, fe = "", Te = pe[le].encoding;
    if (pe[le].encoding !== "Identity-H") return { text: s, x: D, y: k, options: M, mutex: q };
    for (fe = s, le = z, Array.isArray(s) && (fe = s[0]), ee = 0; ee < fe.length; ee += 1) pe[le].metadata.hasOwnProperty("cmap") && (g = pe[le].metadata.cmap.unicode.codeMap[fe[ee].charCodeAt(0)]), g || fe[ee].charCodeAt(0) < 256 && pe[le].metadata.hasOwnProperty("Unicode") ? se += fe[ee] : se += "";
    var ze = "";
    return parseInt(le.slice(1)) < 14 || Te === "WinAnsiEncoding" ? ze = O(se, le).split("").map(function(qe) {
      return qe.charCodeAt(0).toString(16);
    }).join("") : Te === "Identity-H" && (ze = l(se, pe[le])), q.isHex = !0, { text: ze, x: D, y: k, options: M, mutex: q };
  };
  d.events.push(["postProcessText", function(v) {
    var g = v.text || "", s = [], D = { text: g, x: v.x, y: v.y, options: v.options, mutex: v.mutex };
    if (Array.isArray(g)) {
      var k = 0;
      for (k = 0; k < g.length; k += 1) Array.isArray(g[k]) && g[k].length === 3 ? s.push([w(Object.assign({}, D, { text: g[k][0] })).text, g[k][1], g[k][2]]) : s.push(w(Object.assign({}, D, { text: g[k] })).text);
      v.text = s;
    } else v.text = w(Object.assign({}, D, { text: g })).text;
  }]);
}(wi), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(a) {
  var d = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  a.existsFileInVFS = function(l) {
    return d.call(this), this.internal.vFS[l] !== void 0;
  }, a.addFileToVFS = function(l, m) {
    return d.call(this), this.internal.vFS[l] = m, this;
  }, a.getFileFromVFS = function(l) {
    return d.call(this), this.internal.vFS[l] !== void 0 ? this.internal.vFS[l] : null;
  };
}(wi.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(a) {
  a.__bidiEngine__ = a.prototype.__bidiEngine__ = function(m) {
    var w, v, g, s, D, k, M, q = d, O = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], z = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], pe = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, le = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, se = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], ee = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), fe = !1, Te = 0;
    this.__bidiEngine__ = {};
    var ze = function(X) {
      var re = X.charCodeAt(), xe = re >> 8, ye = le[xe];
      return ye !== void 0 ? q[256 * ye + (255 & re)] : xe === 252 || xe === 253 ? "AL" : ee.test(xe) ? "L" : xe === 8 ? "R" : "N";
    }, qe = function(X) {
      for (var re, xe = 0; xe < X.length; xe++) {
        if ((re = ze(X.charAt(xe))) === "L") return !1;
        if (re === "R") return !0;
      }
      return !1;
    }, at = function(X, re, xe, ye) {
      var Ve, He, Ze, je, Je = re[ye];
      switch (Je) {
        case "L":
        case "R":
          fe = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          fe && (Je = "AN");
          break;
        case "AL":
          fe = !0, Je = "R";
          break;
        case "WS":
          Je = "N";
          break;
        case "CS":
          ye < 1 || ye + 1 >= re.length || (Ve = xe[ye - 1]) !== "EN" && Ve !== "AN" || (He = re[ye + 1]) !== "EN" && He !== "AN" ? Je = "N" : fe && (He = "AN"), Je = He === Ve ? He : "N";
          break;
        case "ES":
          Je = (Ve = ye > 0 ? xe[ye - 1] : "B") === "EN" && ye + 1 < re.length && re[ye + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (ye > 0 && xe[ye - 1] === "EN") {
            Je = "EN";
            break;
          }
          if (fe) {
            Je = "N";
            break;
          }
          for (Ze = ye + 1, je = re.length; Ze < je && re[Ze] === "ET"; ) Ze++;
          Je = Ze < je && re[Ze] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (g && !s) {
            for (je = re.length, Ze = ye + 1; Ze < je && re[Ze] === "NSM"; ) Ze++;
            if (Ze < je) {
              var Qe = X[ye], nt = Qe >= 1425 && Qe <= 2303 || Qe === 64286;
              if (Ve = re[Ze], nt && (Ve === "R" || Ve === "AL")) {
                Je = "R";
                break;
              }
            }
          }
          Je = ye < 1 || (Ve = re[ye - 1]) === "B" ? "N" : xe[ye - 1];
          break;
        case "B":
          fe = !1, w = !0, Je = Te;
          break;
        case "S":
          v = !0, Je = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          fe = !1;
          break;
        case "BN":
          Je = "N";
      }
      return Je;
    }, Ie = function(X, re, xe) {
      var ye = X.split("");
      return xe && Ae(ye, xe, { hiLevel: Te }), ye.reverse(), re && re.reverse(), ye.join("");
    }, Ae = function(X, re, xe) {
      var ye, Ve, He, Ze, je, Je = -1, Qe = X.length, nt = 0, Q = [], _e = Te ? z : O, be = [];
      for (fe = !1, w = !1, v = !1, Ve = 0; Ve < Qe; Ve++) be[Ve] = ze(X[Ve]);
      for (He = 0; He < Qe; He++) {
        if (je = nt, Q[He] = at(X, be, Q, He), ye = 240 & (nt = _e[je][pe[Q[He]]]), nt &= 15, re[He] = Ze = _e[nt][5], ye > 0) if (ye === 16) {
          for (Ve = Je; Ve < He; Ve++) re[Ve] = 1;
          Je = -1;
        } else Je = -1;
        if (_e[nt][6]) Je === -1 && (Je = He);
        else if (Je > -1) {
          for (Ve = Je; Ve < He; Ve++) re[Ve] = Ze;
          Je = -1;
        }
        be[He] === "B" && (re[He] = 0), xe.hiLevel |= Ze;
      }
      v && function(Ce, Oe, $e) {
        for (var Ue = 0; Ue < $e; Ue++) if (Ce[Ue] === "S") {
          Oe[Ue] = Te;
          for (var Ke = Ue - 1; Ke >= 0 && Ce[Ke] === "WS"; Ke--) Oe[Ke] = Te;
        }
      }(be, re, Qe);
    }, me = function(X, re, xe, ye, Ve) {
      if (!(Ve.hiLevel < X)) {
        if (X === 1 && Te === 1 && !w) return re.reverse(), void (xe && xe.reverse());
        for (var He, Ze, je, Je, Qe = re.length, nt = 0; nt < Qe; ) {
          if (ye[nt] >= X) {
            for (je = nt + 1; je < Qe && ye[je] >= X; ) je++;
            for (Je = nt, Ze = je - 1; Je < Ze; Je++, Ze--) He = re[Je], re[Je] = re[Ze], re[Ze] = He, xe && (He = xe[Je], xe[Je] = xe[Ze], xe[Ze] = He);
            nt = je;
          }
          nt++;
        }
      }
    }, ve = function(X, re, xe) {
      var ye = X.split(""), Ve = { hiLevel: Te };
      return xe || (xe = []), Ae(ye, xe, Ve), function(He, Ze, je) {
        if (je.hiLevel !== 0 && M) for (var Je, Qe = 0; Qe < He.length; Qe++) Ze[Qe] === 1 && (Je = se.indexOf(He[Qe])) >= 0 && (He[Qe] = se[Je + 1]);
      }(ye, xe, Ve), me(2, ye, re, xe, Ve), me(1, ye, re, xe, Ve), ye.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(X, re, xe) {
      if (function(Ve, He) {
        if (He) for (var Ze = 0; Ze < Ve.length; Ze++) He[Ze] = Ze;
        s === void 0 && (s = qe(Ve)), k === void 0 && (k = qe(Ve));
      }(X, re), g || !D || k) if (g && D && s ^ k) Te = s ? 1 : 0, X = Ie(X, re, xe);
      else if (!g && D && k) Te = s ? 1 : 0, X = ve(X, re, xe), X = Ie(X, re);
      else if (!g || s || D || k) {
        if (g && !D && s ^ k) X = Ie(X, re), s ? (Te = 0, X = ve(X, re, xe)) : (Te = 1, X = ve(X, re, xe), X = Ie(X, re));
        else if (g && s && !D && k) Te = 1, X = ve(X, re, xe), X = Ie(X, re);
        else if (!g && !D && s ^ k) {
          var ye = M;
          s ? (Te = 1, X = ve(X, re, xe), Te = 0, M = !1, X = ve(X, re, xe), M = ye) : (Te = 0, X = ve(X, re, xe), X = Ie(X, re), Te = 1, M = !1, X = ve(X, re, xe), M = ye, X = Ie(X, re));
        }
      } else Te = 0, X = ve(X, re, xe);
      else Te = s ? 1 : 0, X = ve(X, re, xe);
      return X;
    }, this.__bidiEngine__.setOptions = function(X) {
      X && (g = X.isInputVisual, D = X.isOutputVisual, s = X.isInputRtl, k = X.isOutputRtl, M = X.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(m), this.__bidiEngine__;
  };
  var d = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], l = new a.__bidiEngine__({ isInputVisual: !0 });
  a.API.events.push(["postProcessText", function(m) {
    var w = m.text, v = (m.x, m.y, m.options || {}), g = (m.mutex, v.lang, []);
    if (v.isInputVisual = typeof v.isInputVisual != "boolean" || v.isInputVisual, l.setOptions(v), Object.prototype.toString.call(w) === "[object Array]") {
      var s = 0;
      for (g = [], s = 0; s < w.length; s += 1) Object.prototype.toString.call(w[s]) === "[object Array]" ? g.push([l.doBidiReorder(w[s][0]), w[s][1], w[s][2]]) : g.push([l.doBidiReorder(w[s])]);
      m.text = g;
    } else m.text = l.doBidiReorder(w);
    l.setOptions({ isInputVisual: !0 });
  }]);
}(wi), wi.API.TTFFont = function() {
  function a(d) {
    var l;
    if (this.rawData = d, l = this.contents = new eu(d), this.contents.pos = 4, l.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    l.pos = 0, this.parse(), this.subset = new Xb(this), this.registerTTF();
  }
  return a.open = function(d) {
    return new a(d);
  }, a.prototype.parse = function() {
    return this.directory = new zb(this.contents), this.head = new Bb(this), this.name = new Ub(this), this.cmap = new Kg(this), this.toUnicode = {}, this.hhea = new Rb(this), this.maxp = new Vb(this), this.hmtx = new $b(this), this.post = new jb(this), this.os2 = new Ob(this), this.loca = new Wb(this), this.glyf = new Zb(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, a.prototype.registerTTF = function() {
    var d, l, m, w, v;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var g, s, D, k;
      for (k = [], g = 0, s = (D = this.bbox).length; g < s; g++) d = D[g], k.push(Math.round(d * this.scaleFactor));
      return k;
    }).call(this), this.stemV = 0, this.post.exists ? (m = 255 & (w = this.post.italic_angle), 32768 & (l = w >> 16) && (l = -(1 + (65535 ^ l))), this.italicAngle = +(l + "." + m)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (v = this.familyClass) === 1 || v === 2 || v === 3 || v === 4 || v === 5 || v === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, a.prototype.characterToGlyph = function(d) {
    var l;
    return ((l = this.cmap.unicode) != null ? l.codeMap[d] : void 0) || 0;
  }, a.prototype.widthOfGlyph = function(d) {
    var l;
    return l = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(d).advance * l;
  }, a.prototype.widthOfString = function(d, l, m) {
    var w, v, g, s;
    for (g = 0, v = 0, s = (d = "" + d).length; 0 <= s ? v < s : v > s; v = 0 <= s ? ++v : --v) w = d.charCodeAt(v), g += this.widthOfGlyph(this.characterToGlyph(w)) + m * (1e3 / l) || 0;
    return g * (l / 1e3);
  }, a.prototype.lineHeight = function(d, l) {
    var m;
    return l == null && (l = !1), m = l ? this.lineGap : 0, (this.ascender + m - this.decender) / 1e3 * d;
  }, a;
}();
var Ks, eu = function() {
  function a(d) {
    this.data = d ?? [], this.pos = 0, this.length = this.data.length;
  }
  return a.prototype.readByte = function() {
    return this.data[this.pos++];
  }, a.prototype.writeByte = function(d) {
    return this.data[this.pos++] = d;
  }, a.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, a.prototype.writeUInt32 = function(d) {
    return this.writeByte(d >>> 24 & 255), this.writeByte(d >> 16 & 255), this.writeByte(d >> 8 & 255), this.writeByte(255 & d);
  }, a.prototype.readInt32 = function() {
    var d;
    return (d = this.readUInt32()) >= 2147483648 ? d - 4294967296 : d;
  }, a.prototype.writeInt32 = function(d) {
    return d < 0 && (d += 4294967296), this.writeUInt32(d);
  }, a.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, a.prototype.writeUInt16 = function(d) {
    return this.writeByte(d >> 8 & 255), this.writeByte(255 & d);
  }, a.prototype.readInt16 = function() {
    var d;
    return (d = this.readUInt16()) >= 32768 ? d - 65536 : d;
  }, a.prototype.writeInt16 = function(d) {
    return d < 0 && (d += 65536), this.writeUInt16(d);
  }, a.prototype.readString = function(d) {
    var l, m;
    for (m = [], l = 0; 0 <= d ? l < d : l > d; l = 0 <= d ? ++l : --l) m[l] = String.fromCharCode(this.readByte());
    return m.join("");
  }, a.prototype.writeString = function(d) {
    var l, m, w;
    for (w = [], l = 0, m = d.length; 0 <= m ? l < m : l > m; l = 0 <= m ? ++l : --l) w.push(this.writeByte(d.charCodeAt(l)));
    return w;
  }, a.prototype.readShort = function() {
    return this.readInt16();
  }, a.prototype.writeShort = function(d) {
    return this.writeInt16(d);
  }, a.prototype.readLongLong = function() {
    var d, l, m, w, v, g, s, D;
    return d = this.readByte(), l = this.readByte(), m = this.readByte(), w = this.readByte(), v = this.readByte(), g = this.readByte(), s = this.readByte(), D = this.readByte(), 128 & d ? -1 * (72057594037927940 * (255 ^ d) + 281474976710656 * (255 ^ l) + 1099511627776 * (255 ^ m) + 4294967296 * (255 ^ w) + 16777216 * (255 ^ v) + 65536 * (255 ^ g) + 256 * (255 ^ s) + (255 ^ D) + 1) : 72057594037927940 * d + 281474976710656 * l + 1099511627776 * m + 4294967296 * w + 16777216 * v + 65536 * g + 256 * s + D;
  }, a.prototype.writeLongLong = function(d) {
    var l, m;
    return l = Math.floor(d / 4294967296), m = 4294967295 & d, this.writeByte(l >> 24 & 255), this.writeByte(l >> 16 & 255), this.writeByte(l >> 8 & 255), this.writeByte(255 & l), this.writeByte(m >> 24 & 255), this.writeByte(m >> 16 & 255), this.writeByte(m >> 8 & 255), this.writeByte(255 & m);
  }, a.prototype.readInt = function() {
    return this.readInt32();
  }, a.prototype.writeInt = function(d) {
    return this.writeInt32(d);
  }, a.prototype.read = function(d) {
    var l, m;
    for (l = [], m = 0; 0 <= d ? m < d : m > d; m = 0 <= d ? ++m : --m) l.push(this.readByte());
    return l;
  }, a.prototype.write = function(d) {
    var l, m, w, v;
    for (v = [], m = 0, w = d.length; m < w; m++) l = d[m], v.push(this.writeByte(l));
    return v;
  }, a;
}(), zb = function() {
  var a;
  function d(l) {
    var m, w, v;
    for (this.scalarType = l.readInt(), this.tableCount = l.readShort(), this.searchRange = l.readShort(), this.entrySelector = l.readShort(), this.rangeShift = l.readShort(), this.tables = {}, w = 0, v = this.tableCount; 0 <= v ? w < v : w > v; w = 0 <= v ? ++w : --w) m = { tag: l.readString(4), checksum: l.readInt(), offset: l.readInt(), length: l.readInt() }, this.tables[m.tag] = m;
  }
  return d.prototype.encode = function(l) {
    var m, w, v, g, s, D, k, M, q, O, z, pe, le;
    for (le in z = Object.keys(l).length, D = Math.log(2), q = 16 * Math.floor(Math.log(z) / D), g = Math.floor(q / D), M = 16 * z - q, (w = new eu()).writeInt(this.scalarType), w.writeShort(z), w.writeShort(q), w.writeShort(g), w.writeShort(M), v = 16 * z, k = w.pos + v, s = null, pe = [], l) for (O = l[le], w.writeString(le), w.writeInt(a(O)), w.writeInt(k), w.writeInt(O.length), pe = pe.concat(O), le === "head" && (s = k), k += O.length; k % 4; ) pe.push(0), k++;
    return w.write(pe), m = 2981146554 - a(w.data), w.pos = s + 8, w.writeUInt32(m), w.data;
  }, a = function(l) {
    var m, w, v, g;
    for (l = Qg.call(l); l.length % 4; ) l.push(0);
    for (v = new eu(l), w = 0, m = 0, g = l.length; m < g; m = m += 4) w += v.readUInt32();
    return 4294967295 & w;
  }, d;
}(), Fb = {}.hasOwnProperty, $o = function(a, d) {
  for (var l in d) Fb.call(d, l) && (a[l] = d[l]);
  function m() {
    this.constructor = a;
  }
  return m.prototype = d.prototype, a.prototype = new m(), a.__super__ = d.prototype, a;
};
Ks = function() {
  function a(d) {
    var l;
    this.file = d, l = this.file.directory.tables[this.tag], this.exists = !!l, l && (this.offset = l.offset, this.length = l.length, this.parse(this.file.contents));
  }
  return a.prototype.parse = function() {
  }, a.prototype.encode = function() {
  }, a.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, a;
}();
var Bb = function(a) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return $o(d, Ks), d.prototype.tag = "head", d.prototype.parse = function(l) {
    return l.pos = this.offset, this.version = l.readInt(), this.revision = l.readInt(), this.checkSumAdjustment = l.readInt(), this.magicNumber = l.readInt(), this.flags = l.readShort(), this.unitsPerEm = l.readShort(), this.created = l.readLongLong(), this.modified = l.readLongLong(), this.xMin = l.readShort(), this.yMin = l.readShort(), this.xMax = l.readShort(), this.yMax = l.readShort(), this.macStyle = l.readShort(), this.lowestRecPPEM = l.readShort(), this.fontDirectionHint = l.readShort(), this.indexToLocFormat = l.readShort(), this.glyphDataFormat = l.readShort();
  }, d.prototype.encode = function(l) {
    var m;
    return (m = new eu()).writeInt(this.version), m.writeInt(this.revision), m.writeInt(this.checkSumAdjustment), m.writeInt(this.magicNumber), m.writeShort(this.flags), m.writeShort(this.unitsPerEm), m.writeLongLong(this.created), m.writeLongLong(this.modified), m.writeShort(this.xMin), m.writeShort(this.yMin), m.writeShort(this.xMax), m.writeShort(this.yMax), m.writeShort(this.macStyle), m.writeShort(this.lowestRecPPEM), m.writeShort(this.fontDirectionHint), m.writeShort(l), m.writeShort(this.glyphDataFormat), m.data;
  }, d;
}(), Z0 = function() {
  function a(d, l) {
    var m, w, v, g, s, D, k, M, q, O, z, pe, le, se, ee, fe, Te;
    switch (this.platformID = d.readUInt16(), this.encodingID = d.readShort(), this.offset = l + d.readInt(), q = d.pos, d.pos = this.offset, this.format = d.readUInt16(), this.length = d.readUInt16(), this.language = d.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (D = 0; D < 256; ++D) this.codeMap[D] = d.readByte();
        break;
      case 4:
        for (z = d.readUInt16(), O = z / 2, d.pos += 6, v = function() {
          var ze, qe;
          for (qe = [], D = ze = 0; 0 <= O ? ze < O : ze > O; D = 0 <= O ? ++ze : --ze) qe.push(d.readUInt16());
          return qe;
        }(), d.pos += 2, le = function() {
          var ze, qe;
          for (qe = [], D = ze = 0; 0 <= O ? ze < O : ze > O; D = 0 <= O ? ++ze : --ze) qe.push(d.readUInt16());
          return qe;
        }(), k = function() {
          var ze, qe;
          for (qe = [], D = ze = 0; 0 <= O ? ze < O : ze > O; D = 0 <= O ? ++ze : --ze) qe.push(d.readUInt16());
          return qe;
        }(), M = function() {
          var ze, qe;
          for (qe = [], D = ze = 0; 0 <= O ? ze < O : ze > O; D = 0 <= O ? ++ze : --ze) qe.push(d.readUInt16());
          return qe;
        }(), w = (this.length - d.pos + this.offset) / 2, s = function() {
          var ze, qe;
          for (qe = [], D = ze = 0; 0 <= w ? ze < w : ze > w; D = 0 <= w ? ++ze : --ze) qe.push(d.readUInt16());
          return qe;
        }(), D = ee = 0, Te = v.length; ee < Te; D = ++ee) for (se = v[D], m = fe = pe = le[D]; pe <= se ? fe <= se : fe >= se; m = pe <= se ? ++fe : --fe) M[D] === 0 ? g = m + k[D] : (g = s[M[D] / 2 + (m - pe) - (O - D)] || 0) !== 0 && (g += k[D]), this.codeMap[m] = 65535 & g;
    }
    d.pos = q;
  }
  return a.encode = function(d, l) {
    var m, w, v, g, s, D, k, M, q, O, z, pe, le, se, ee, fe, Te, ze, qe, at, Ie, Ae, me, ve, X, re, xe, ye, Ve, He, Ze, je, Je, Qe, nt, Q, _e, be, Ce, Oe, $e, Ue, Ke, rt, ot, vt;
    switch (ye = new eu(), g = Object.keys(d).sort(function(mt, Pt) {
      return mt - Pt;
    }), l) {
      case "macroman":
        for (le = 0, se = function() {
          var mt = [];
          for (pe = 0; pe < 256; ++pe) mt.push(0);
          return mt;
        }(), fe = { 0: 0 }, v = {}, Ve = 0, Je = g.length; Ve < Je; Ve++) fe[Ke = d[w = g[Ve]]] == null && (fe[Ke] = ++le), v[w] = { old: d[w], new: fe[d[w]] }, se[w] = fe[d[w]];
        return ye.writeUInt16(1), ye.writeUInt16(0), ye.writeUInt32(12), ye.writeUInt16(0), ye.writeUInt16(262), ye.writeUInt16(0), ye.write(se), { charMap: v, subtable: ye.data, maxGlyphID: le + 1 };
      case "unicode":
        for (re = [], q = [], Te = 0, fe = {}, m = {}, ee = k = null, He = 0, Qe = g.length; He < Qe; He++) fe[qe = d[w = g[He]]] == null && (fe[qe] = ++Te), m[w] = { old: qe, new: fe[qe] }, s = fe[qe] - w, ee != null && s === k || (ee && q.push(ee), re.push(w), k = s), ee = w;
        for (ee && q.push(ee), q.push(65535), re.push(65535), ve = 2 * (me = re.length), Ae = 2 * Math.pow(Math.log(me) / Math.LN2, 2), O = Math.log(Ae / 2) / Math.LN2, Ie = 2 * me - Ae, D = [], at = [], z = [], pe = Ze = 0, nt = re.length; Ze < nt; pe = ++Ze) {
          if (X = re[pe], M = q[pe], X === 65535) {
            D.push(0), at.push(0);
            break;
          }
          if (X - (xe = m[X].new) >= 32768) for (D.push(0), at.push(2 * (z.length + me - pe)), w = je = X; X <= M ? je <= M : je >= M; w = X <= M ? ++je : --je) z.push(m[w].new);
          else D.push(xe - X), at.push(0);
        }
        for (ye.writeUInt16(3), ye.writeUInt16(1), ye.writeUInt32(12), ye.writeUInt16(4), ye.writeUInt16(16 + 8 * me + 2 * z.length), ye.writeUInt16(0), ye.writeUInt16(ve), ye.writeUInt16(Ae), ye.writeUInt16(O), ye.writeUInt16(Ie), $e = 0, Q = q.length; $e < Q; $e++) w = q[$e], ye.writeUInt16(w);
        for (ye.writeUInt16(0), Ue = 0, _e = re.length; Ue < _e; Ue++) w = re[Ue], ye.writeUInt16(w);
        for (rt = 0, be = D.length; rt < be; rt++) s = D[rt], ye.writeUInt16(s);
        for (ot = 0, Ce = at.length; ot < Ce; ot++) ze = at[ot], ye.writeUInt16(ze);
        for (vt = 0, Oe = z.length; vt < Oe; vt++) le = z[vt], ye.writeUInt16(le);
        return { charMap: m, subtable: ye.data, maxGlyphID: Te + 1 };
    }
  }, a;
}(), Kg = function(a) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return $o(d, Ks), d.prototype.tag = "cmap", d.prototype.parse = function(l) {
    var m, w, v;
    for (l.pos = this.offset, this.version = l.readUInt16(), v = l.readUInt16(), this.tables = [], this.unicode = null, w = 0; 0 <= v ? w < v : w > v; w = 0 <= v ? ++w : --w) m = new Z0(l, this.offset), this.tables.push(m), m.isUnicode && this.unicode == null && (this.unicode = m);
    return !0;
  }, d.encode = function(l, m) {
    var w, v;
    return m == null && (m = "macroman"), w = Z0.encode(l, m), (v = new eu()).writeUInt16(0), v.writeUInt16(1), w.table = v.data.concat(w.subtable), w;
  }, d;
}(), Rb = function(a) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return $o(d, Ks), d.prototype.tag = "hhea", d.prototype.parse = function(l) {
    return l.pos = this.offset, this.version = l.readInt(), this.ascender = l.readShort(), this.decender = l.readShort(), this.lineGap = l.readShort(), this.advanceWidthMax = l.readShort(), this.minLeftSideBearing = l.readShort(), this.minRightSideBearing = l.readShort(), this.xMaxExtent = l.readShort(), this.caretSlopeRise = l.readShort(), this.caretSlopeRun = l.readShort(), this.caretOffset = l.readShort(), l.pos += 8, this.metricDataFormat = l.readShort(), this.numberOfMetrics = l.readUInt16();
  }, d;
}(), Ob = function(a) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return $o(d, Ks), d.prototype.tag = "OS/2", d.prototype.parse = function(l) {
    if (l.pos = this.offset, this.version = l.readUInt16(), this.averageCharWidth = l.readShort(), this.weightClass = l.readUInt16(), this.widthClass = l.readUInt16(), this.type = l.readShort(), this.ySubscriptXSize = l.readShort(), this.ySubscriptYSize = l.readShort(), this.ySubscriptXOffset = l.readShort(), this.ySubscriptYOffset = l.readShort(), this.ySuperscriptXSize = l.readShort(), this.ySuperscriptYSize = l.readShort(), this.ySuperscriptXOffset = l.readShort(), this.ySuperscriptYOffset = l.readShort(), this.yStrikeoutSize = l.readShort(), this.yStrikeoutPosition = l.readShort(), this.familyClass = l.readShort(), this.panose = function() {
      var m, w;
      for (w = [], m = 0; m < 10; ++m) w.push(l.readByte());
      return w;
    }(), this.charRange = function() {
      var m, w;
      for (w = [], m = 0; m < 4; ++m) w.push(l.readInt());
      return w;
    }(), this.vendorID = l.readString(4), this.selection = l.readShort(), this.firstCharIndex = l.readShort(), this.lastCharIndex = l.readShort(), this.version > 0 && (this.ascent = l.readShort(), this.descent = l.readShort(), this.lineGap = l.readShort(), this.winAscent = l.readShort(), this.winDescent = l.readShort(), this.codePageRange = function() {
      var m, w;
      for (w = [], m = 0; m < 2; m = ++m) w.push(l.readInt());
      return w;
    }(), this.version > 1)) return this.xHeight = l.readShort(), this.capHeight = l.readShort(), this.defaultChar = l.readShort(), this.breakChar = l.readShort(), this.maxContext = l.readShort();
  }, d;
}(), jb = function(a) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return $o(d, Ks), d.prototype.tag = "post", d.prototype.parse = function(l) {
    var m, w, v;
    switch (l.pos = this.offset, this.format = l.readInt(), this.italicAngle = l.readInt(), this.underlinePosition = l.readShort(), this.underlineThickness = l.readShort(), this.isFixedPitch = l.readInt(), this.minMemType42 = l.readInt(), this.maxMemType42 = l.readInt(), this.minMemType1 = l.readInt(), this.maxMemType1 = l.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var g;
        for (w = l.readUInt16(), this.glyphNameIndex = [], g = 0; 0 <= w ? g < w : g > w; g = 0 <= w ? ++g : --g) this.glyphNameIndex.push(l.readUInt16());
        for (this.names = [], v = []; l.pos < this.offset + this.length; ) m = l.readByte(), v.push(this.names.push(l.readString(m)));
        return v;
      case 151552:
        return w = l.readUInt16(), this.offsets = l.read(w);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var s, D, k;
          for (k = [], g = s = 0, D = this.file.maxp.numGlyphs; 0 <= D ? s < D : s > D; g = 0 <= D ? ++s : --s) k.push(l.readUInt32());
          return k;
        }).call(this);
    }
  }, d;
}(), qb = function(a, d) {
  this.raw = a, this.length = a.length, this.platformID = d.platformID, this.encodingID = d.encodingID, this.languageID = d.languageID;
}, Ub = function(a) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return $o(d, Ks), d.prototype.tag = "name", d.prototype.parse = function(l) {
    var m, w, v, g, s, D, k, M, q, O, z;
    for (l.pos = this.offset, l.readShort(), m = l.readShort(), D = l.readShort(), w = [], g = 0; 0 <= m ? g < m : g > m; g = 0 <= m ? ++g : --g) w.push({ platformID: l.readShort(), encodingID: l.readShort(), languageID: l.readShort(), nameID: l.readShort(), length: l.readShort(), offset: this.offset + D + l.readShort() });
    for (k = {}, g = q = 0, O = w.length; q < O; g = ++q) v = w[g], l.pos = v.offset, M = l.readString(v.length), s = new qb(M, v), k[z = v.nameID] == null && (k[z] = []), k[v.nameID].push(s);
    this.strings = k, this.copyright = k[0], this.fontFamily = k[1], this.fontSubfamily = k[2], this.uniqueSubfamily = k[3], this.fontName = k[4], this.version = k[5];
    try {
      this.postscriptName = k[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = k[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = k[7], this.manufacturer = k[8], this.designer = k[9], this.description = k[10], this.vendorUrl = k[11], this.designerUrl = k[12], this.license = k[13], this.licenseUrl = k[14], this.preferredFamily = k[15], this.preferredSubfamily = k[17], this.compatibleFull = k[18], this.sampleText = k[19];
  }, d;
}(), Vb = function(a) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return $o(d, Ks), d.prototype.tag = "maxp", d.prototype.parse = function(l) {
    return l.pos = this.offset, this.version = l.readInt(), this.numGlyphs = l.readUInt16(), this.maxPoints = l.readUInt16(), this.maxContours = l.readUInt16(), this.maxCompositePoints = l.readUInt16(), this.maxComponentContours = l.readUInt16(), this.maxZones = l.readUInt16(), this.maxTwilightPoints = l.readUInt16(), this.maxStorage = l.readUInt16(), this.maxFunctionDefs = l.readUInt16(), this.maxInstructionDefs = l.readUInt16(), this.maxStackElements = l.readUInt16(), this.maxSizeOfInstructions = l.readUInt16(), this.maxComponentElements = l.readUInt16(), this.maxComponentDepth = l.readUInt16();
  }, d;
}(), $b = function(a) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return $o(d, Ks), d.prototype.tag = "hmtx", d.prototype.parse = function(l) {
    var m, w, v, g, s, D, k;
    for (l.pos = this.offset, this.metrics = [], m = 0, D = this.file.hhea.numberOfMetrics; 0 <= D ? m < D : m > D; m = 0 <= D ? ++m : --m) this.metrics.push({ advance: l.readUInt16(), lsb: l.readInt16() });
    for (v = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var M, q;
      for (q = [], m = M = 0; 0 <= v ? M < v : M > v; m = 0 <= v ? ++M : --M) q.push(l.readInt16());
      return q;
    }(), this.widths = (function() {
      var M, q, O, z;
      for (z = [], M = 0, q = (O = this.metrics).length; M < q; M++) g = O[M], z.push(g.advance);
      return z;
    }).call(this), w = this.widths[this.widths.length - 1], k = [], m = s = 0; 0 <= v ? s < v : s > v; m = 0 <= v ? ++s : --s) k.push(this.widths.push(w));
    return k;
  }, d.prototype.forGlyph = function(l) {
    return l in this.metrics ? this.metrics[l] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[l - this.metrics.length] };
  }, d;
}(), Qg = [].slice, Zb = function(a) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return $o(d, Ks), d.prototype.tag = "glyf", d.prototype.parse = function() {
    return this.cache = {};
  }, d.prototype.glyphFor = function(l) {
    var m, w, v, g, s, D, k, M, q, O;
    return l in this.cache ? this.cache[l] : (g = this.file.loca, m = this.file.contents, w = g.indexOf(l), (v = g.lengthOf(l)) === 0 ? this.cache[l] = null : (m.pos = this.offset + w, s = (D = new eu(m.read(v))).readShort(), M = D.readShort(), O = D.readShort(), k = D.readShort(), q = D.readShort(), this.cache[l] = s === -1 ? new Hb(D, M, O, k, q) : new Gb(D, s, M, O, k, q), this.cache[l]));
  }, d.prototype.encode = function(l, m, w) {
    var v, g, s, D, k;
    for (s = [], g = [], D = 0, k = m.length; D < k; D++) v = l[m[D]], g.push(s.length), v && (s = s.concat(v.encode(w)));
    return g.push(s.length), { table: s, offsets: g };
  }, d;
}(), Gb = function() {
  function a(d, l, m, w, v, g) {
    this.raw = d, this.numberOfContours = l, this.xMin = m, this.yMin = w, this.xMax = v, this.yMax = g, this.compound = !1;
  }
  return a.prototype.encode = function() {
    return this.raw.data;
  }, a;
}(), Hb = function() {
  function a(d, l, m, w, v) {
    var g, s;
    for (this.raw = d, this.xMin = l, this.yMin = m, this.xMax = w, this.yMax = v, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], g = this.raw; s = g.readShort(), this.glyphOffsets.push(g.pos), this.glyphIDs.push(g.readUInt16()), 32 & s; ) g.pos += 1 & s ? 4 : 2, 128 & s ? g.pos += 8 : 64 & s ? g.pos += 4 : 8 & s && (g.pos += 2);
  }
  return a.prototype.encode = function() {
    var d, l, m;
    for (l = new eu(Qg.call(this.raw.data)), d = 0, m = this.glyphIDs.length; d < m; ++d) l.pos = this.glyphOffsets[d];
    return l.data;
  }, a;
}(), Wb = function(a) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return $o(d, Ks), d.prototype.tag = "loca", d.prototype.parse = function(l) {
    var m, w;
    return l.pos = this.offset, m = this.file.head.indexToLocFormat, this.offsets = m === 0 ? (function() {
      var v, g;
      for (g = [], w = 0, v = this.length; w < v; w += 2) g.push(2 * l.readUInt16());
      return g;
    }).call(this) : (function() {
      var v, g;
      for (g = [], w = 0, v = this.length; w < v; w += 4) g.push(l.readUInt32());
      return g;
    }).call(this);
  }, d.prototype.indexOf = function(l) {
    return this.offsets[l];
  }, d.prototype.lengthOf = function(l) {
    return this.offsets[l + 1] - this.offsets[l];
  }, d.prototype.encode = function(l, m) {
    for (var w = new Uint32Array(this.offsets.length), v = 0, g = 0, s = 0; s < w.length; ++s) if (w[s] = v, g < m.length && m[g] == s) {
      ++g, w[s] = v;
      var D = this.offsets[s], k = this.offsets[s + 1] - D;
      k > 0 && (v += k);
    }
    for (var M = new Array(4 * w.length), q = 0; q < w.length; ++q) M[4 * q + 3] = 255 & w[q], M[4 * q + 2] = (65280 & w[q]) >> 8, M[4 * q + 1] = (16711680 & w[q]) >> 16, M[4 * q] = (4278190080 & w[q]) >> 24;
    return M;
  }, d;
}(), Xb = function() {
  function a(d) {
    this.font = d, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return a.prototype.generateCmap = function() {
    var d, l, m, w, v;
    for (l in w = this.font.cmap.tables[0].codeMap, d = {}, v = this.subset) m = v[l], d[l] = w[m];
    return d;
  }, a.prototype.glyphsFor = function(d) {
    var l, m, w, v, g, s, D;
    for (w = {}, g = 0, s = d.length; g < s; g++) w[v = d[g]] = this.font.glyf.glyphFor(v);
    for (v in l = [], w) (m = w[v]) != null && m.compound && l.push.apply(l, m.glyphIDs);
    if (l.length > 0) for (v in D = this.glyphsFor(l)) m = D[v], w[v] = m;
    return w;
  }, a.prototype.encode = function(d, l) {
    var m, w, v, g, s, D, k, M, q, O, z, pe, le, se, ee;
    for (w in m = Kg.encode(this.generateCmap(), "unicode"), g = this.glyphsFor(d), z = { 0: 0 }, ee = m.charMap) z[(D = ee[w]).old] = D.new;
    for (pe in O = m.maxGlyphID, g) pe in z || (z[pe] = O++);
    return M = function(fe) {
      var Te, ze;
      for (Te in ze = {}, fe) ze[fe[Te]] = Te;
      return ze;
    }(z), q = Object.keys(M).sort(function(fe, Te) {
      return fe - Te;
    }), le = function() {
      var fe, Te, ze;
      for (ze = [], fe = 0, Te = q.length; fe < Te; fe++) s = q[fe], ze.push(M[s]);
      return ze;
    }(), v = this.font.glyf.encode(g, le, z), k = this.font.loca.encode(v.offsets, le), se = { cmap: this.font.cmap.raw(), glyf: v.table, loca: k, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(l) }, this.font.os2.exists && (se["OS/2"] = this.font.os2.raw()), this.font.directory.encode(se);
  }, a;
}();
wi.API.PDFObject = function() {
  var a;
  function d() {
  }
  return a = function(l, m) {
    return (Array(m + 1).join("0") + l).slice(-m);
  }, d.convert = function(l) {
    var m, w, v, g;
    if (Array.isArray(l)) return "[" + function() {
      var s, D, k;
      for (k = [], s = 0, D = l.length; s < D; s++) m = l[s], k.push(d.convert(m));
      return k;
    }().join(" ") + "]";
    if (typeof l == "string") return "/" + l;
    if (l != null && l.isString) return "(" + l + ")";
    if (l instanceof Date) return "(D:" + a(l.getUTCFullYear(), 4) + a(l.getUTCMonth(), 2) + a(l.getUTCDate(), 2) + a(l.getUTCHours(), 2) + a(l.getUTCMinutes(), 2) + a(l.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(l) === "[object Object]") {
      for (w in v = ["<<"], l) g = l[w], v.push("/" + w + " " + d.convert(g));
      return v.push(">>"), v.join(`
`);
    }
    return "" + l;
  }, d;
}();
const sf = {
  "circle-radius": 8,
  "circle-color": "red",
  "circle-stroke-width": 1,
  "circle-stroke-color": "black"
}, ld = {
  style: {
    textSize: 16,
    textHaloColor: "#FFFFFF",
    textHaloWidth: 0.8,
    textColor: "#000000",
    fallbackTextFont: ["Open Sans Regular"]
  },
  visibility: "visible",
  position: "bottom-right"
}, ud = {
  image: '<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="none" stroke="white" stroke-width="1.5"/><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="#000000" fill-rule="evenodd"></path></svg>',
  imageName: "gl-export-north-icon",
  imageSizeFraction: 0.05,
  visibility: "visible",
  position: "top-right"
};
class Yb {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(d, l = Iu.A4, m = 300, w = Sl.PNG, v = yc.mm, g = "map", s = "maplibregl-marker", D = sf, k = "maplibregl-ctrl-attrib-inner", M = ld, q = ud) {
    Xi(this, "map"), Xi(this, "width"), Xi(this, "height"), Xi(this, "dpi"), Xi(this, "format"), Xi(this, "unit"), Xi(this, "fileName"), Xi(this, "markerClassName"), Xi(this, "markerCirclePaint"), Xi(this, "attributionClassName"), Xi(this, "attributionOptions"), Xi(this, "northIconOptions"), this.map = d, this.width = l[0], this.height = l[1], this.dpi = m, this.format = w, this.unit = v, this.fileName = g, this.markerClassName = s, this.markerCirclePaint = D, this.attributionClassName = k, this.attributionOptions = M, this.northIconOptions = q;
  }
  renderMapPost(d) {
    return d;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(d) {
    const l = this.getMarkers();
    for (let m = 0; m < l.length; m++) {
      const w = l.item(m);
      if (!w) continue;
      const v = w.getAttribute("style");
      if (!v) continue;
      const g = /translate\(([^,]+)px,\s*([^,]+)px\)/, s = v.match(g);
      if (!s) continue;
      const D = parseInt(s[1]), k = parseInt(s[2]), M = this.map.unproject([D, k]), q = `point${m}`;
      d.addSource(q, {
        type: "geojson",
        data: {
          type: "Point",
          coordinates: [M.lng, M.lat]
        }
      }), d.addLayer({
        id: q,
        source: q,
        type: "circle",
        paint: this.markerCirclePaint
      });
    }
    return d;
  }
  /**
   * Generate and download Map image
   */
  generate() {
    const d = this;
    JsLoadingOverlay.show({
      overlayBackgroundColor: "#5D5959",
      overlayOpacity: "0.6",
      spinnerIcon: "ball-spin",
      spinnerColor: "#2400FD",
      spinnerSize: "2x",
      overlayIDName: "overlay",
      spinnerIDName: "spinner",
      offsetX: 0,
      offsetY: 0,
      containerID: null,
      lockScroll: !1,
      overlayZIndex: 9998,
      spinnerZIndex: 9999
    });
    const l = window.devicePixelRatio;
    Object.defineProperty(window, "devicePixelRatio", {
      get() {
        return d.dpi / 96;
      }
    });
    const m = document.createElement("div");
    m.className = "hidden-map", document.body.appendChild(m);
    const w = document.createElement("div");
    w.style.width = this.toPixels(this.width), w.style.height = this.toPixels(this.height), m.appendChild(w);
    const v = this.map.getStyle();
    if (v && v.sources) {
      const s = v.sources;
      Object.keys(s).forEach((D) => {
        const k = s[D];
        Object.keys(k).forEach((M) => {
          k[M] || delete k[M];
        });
      });
    }
    let g = this.getRenderedMap(w, v);
    g.on("load", () => {
      this.addNorthIconToMap(g).then(() => {
        g.once("idle", () => {
          this.addAttributions(g) ? g.once("idle", () => {
            g = this.renderMapPost(g), this.getMarkers().length === 0 ? this.exportImage(g, m, l) : (g = this.renderMarkers(g), g.once("idle", () => {
              this.exportImage(g, m, l);
            }));
          }) : (g = this.renderMapPost(g), this.getMarkers().length === 0 ? this.exportImage(g, m, l) : (g = this.renderMarkers(g), g.once("idle", () => {
            this.exportImage(g, m, l);
          })));
        });
      });
    });
  }
  stripHtml(d) {
    const l = document.createElement("div");
    return l.innerHTML = d, l.textContent || l.innerText || "";
  }
  /**
   * Get icon width against exported map size by using fraction rate
   * @param renderMap Map object
   * @param fraction adjust icon size by using this fraction rate. Default is 8%
   * @returns Icon width calculated
   */
  getIconWidth(d, l) {
    const m = d.getContainer(), w = parseInt(m.style.width.replace("px", ""));
    return parseInt(`${w * l}`);
  }
  /**
   * Get element position's pixel values based on selected position setting
   * @param renderMap Map object
   * @param position Position of element inserted
   * @param offset Offset value to adjust position
   * @returns Pixels [width, height]
   */
  getElementPosition(d, l, m = 0) {
    const w = d.getContainer();
    let v = 0, g = 0;
    switch (l) {
      case "top-left":
        v = 0 + m, g = 0 + m;
        break;
      case "top-right":
        v = parseInt(w.style.width.replace("px", "")) - m, g = 0 + m;
        break;
      case "bottom-left":
        v = 0 + m, g = parseInt(w.style.height.replace("px", "")) - m;
        break;
      case "bottom-right":
        v = parseInt(w.style.width.replace("px", "")) - m, g = parseInt(w.style.height.replace("px", "")) - m;
        break;
    }
    return [v, g];
  }
  /**
   * Add North Icon SVG to map object
   * @param renderMap Map object
   * @returns void
   */
  addNorthIconImage(d) {
    const l = this.getIconWidth(d, this.northIconOptions.imageSizeFraction ?? 0.08);
    return new Promise((m) => {
      const w = new Image(l, l);
      w.onload = () => {
        this.northIconOptions.imageName && d.addImage(this.northIconOptions.imageName, w), m();
      };
      function v(g) {
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(g);
      }
      this.northIconOptions.image && (w.src = v(this.northIconOptions.image));
    });
  }
  /**
   * Add North Icon Symbol layer to renderMap object
   * @param renderMap Map object
   * @returns
   */
  addNorthIconToMap(d) {
    let l = this.northIconOptions.visibility ?? "visible";
    return d.getZoom() < 2 && this.width > this.height && (l = "none"), new Promise((m) => {
      this.addNorthIconImage(d).then(() => {
        const w = this.getIconWidth(
          d,
          this.northIconOptions.imageSizeFraction ?? 0.08
        ) * 0.8, v = this.getElementPosition(
          d,
          this.northIconOptions.position ?? "top-right",
          w
        ), g = d.unproject(v), s = this.northIconOptions.imageName ?? "gl-export-north-icon";
        d.addSource(s, {
          type: "geojson",
          data: {
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: [g.lng, g.lat]
            },
            properties: {}
          }
        }), d.addLayer({
          id: s,
          source: s,
          type: "symbol",
          layout: {
            "icon-image": s,
            "icon-size": 1,
            "icon-rotate": d.getBearing() * -1,
            "icon-allow-overlap": !0,
            "icon-ignore-placement": !0,
            visibility: l
          },
          paint: {}
        }), m();
      });
    });
  }
  addAttributions(d) {
    var l;
    if (!this.map.getStyle().glyphs) return !1;
    const m = d.getContainer(), w = this.attributionOptions.position ?? "bottom-right", v = this.getElementPosition(d, w, 5), g = v[0], s = d.unproject(v), D = m.getElementsByClassName(this.attributionClassName), k = [];
    if ((D == null ? void 0 : D.length) > 0) {
      const se = D.item(0);
      if (se)
        for (let ee = 0; ee < se.children.length; ee++) {
          const fe = se.children.item(ee);
          fe && k.push(this.stripHtml(fe.outerHTML));
        }
    } else {
      const se = this.map.getStyle().sources;
      Object.keys(se).forEach((ee) => {
        const fe = se[ee];
        if ("attribution" in fe) {
          const Te = fe.attribution;
          k.push(this.stripHtml(Te));
        }
      });
    }
    if (k.length === 0) return !1;
    const M = k.join(" | "), q = "attribution";
    d.addSource(q, {
      type: "geojson",
      data: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [s.lng, s.lat]
        },
        properties: {
          attribution: M
        }
      }
    });
    const O = this.map.getStyle().layers.filter(
      (se) => se.type === "symbol" && se.layout && "text-font" in se.layout
    ), z = O.length > 0 && O[0].layout ? O[0].layout["text-font"] : (l = this.attributionOptions.style) == null ? void 0 : l.fallbackTextFont;
    let pe = this.attributionOptions.visibility ?? "visible";
    d.getZoom() < 2 && this.width > this.height && (pe = "none");
    const le = this.attributionOptions.style;
    return d.addLayer({
      id: q,
      source: q,
      type: "symbol",
      layout: {
        "text-field": ["get", "attribution"],
        "text-font": z,
        "text-max-width": parseInt(`${g / le.textSize}`),
        "text-anchor": w,
        "text-justify": ["top-right", "bottom-right"].includes(w) ? "right" : "left",
        "text-size": le.textSize,
        "text-allow-overlap": !0,
        visibility: pe
      },
      paint: {
        "text-halo-color": le.textHaloColor,
        "text-halo-width": le.textHaloWidth,
        "text-color": le.textColor
      }
    }), !0;
  }
  exportImage(d, l, m) {
    var w;
    const v = d.getCanvas(), g = `${this.fileName}.${this.format}`;
    switch (this.format) {
      case Sl.PNG:
        this.toPNG(v, g);
        break;
      case Sl.JPEG:
        this.toJPEG(v, g);
        break;
      case Sl.PDF:
        this.toPDF(d, g);
        break;
      case Sl.SVG:
        this.toSVG(v, g);
        break;
      default:
        console.error(`Invalid file format: ${this.format}`);
        break;
    }
    d.remove(), (w = l.parentNode) == null || w.removeChild(l), Object.defineProperty(window, "devicePixelRatio", {
      get() {
        return m;
      }
    }), l.remove(), JsLoadingOverlay.hide();
  }
  /**
   * Convert canvas to PNG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toPNG(d, l) {
    const m = document.createElement("a");
    m.href = d.toDataURL(), m.download = l, m.click(), m.remove();
  }
  /**
   * Convert canvas to JPEG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toJPEG(d, l) {
    const m = d.toDataURL("image/jpeg", 0.85), w = document.createElement("a");
    w.href = m, w.download = l, w.click(), w.remove();
  }
  /**
   * Convert Map object to PDF
   * @param map Map object
   * @param fileName file name
   */
  toPDF(d, l) {
    const m = d.getCanvas(), w = new wi({
      orientation: this.width > this.height ? "l" : "p",
      unit: this.unit,
      compress: !0,
      format: [this.width, this.height]
    });
    w.addImage(
      m.toDataURL("image/png"),
      "png",
      0,
      0,
      this.width,
      this.height,
      void 0,
      "FAST"
    );
    const { lng: v, lat: g } = d.getCenter();
    w.setProperties({
      title: d.getStyle().name,
      subject: `center: [${v}, ${g}], zoom: ${d.getZoom()}`,
      creator: "Mapbox GL Export Plugin",
      author: "(c)Mapbox, (c)OpenStreetMap"
    }), w.save(l);
  }
  /**
   * Convert canvas to SVG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toSVG(d, l) {
    const m = d.toDataURL("image/png"), w = Number(this.toPixels(this.width, this.dpi).replace("px", "")), v = Number(this.toPixels(this.height, this.dpi).replace("px", "")), g = `
    <svg xmlns="http://www.w3.org/2000/svg" 
      xmlns:xlink="http://www.w3.org/1999/xlink" 
      version="1.1" 
      width="${w}" 
      height="${v}" 
      viewBox="0 0 ${w} ${v}" 
      xml:space="preserve">
        <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
      xlink:href="${m}" width="${w}" height="${v}"></image>
    </svg>`, s = document.createElement("a");
    s.href = `data:application/xml,${encodeURIComponent(g)}`, s.download = l, s.click(), s.remove();
  }
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(d, l = 96) {
    return this.unit === yc.mm && (l /= 25.4), `${l * d}px`;
  }
}
class Jb extends Yb {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(d, l = Iu.A4, m = 300, w = Sl.PNG, v = yc.mm, g = "map", s = sf, D = ld, k = ud) {
    super(
      d,
      l,
      m,
      w,
      v,
      g,
      "maplibregl-marker",
      s,
      "maplibregl-ctrl-attrib-inner",
      D,
      k
    );
  }
  getRenderedMap(d, l) {
    const m = new bc.Map({
      container: d,
      style: l,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transfrom request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (m.setMaxPitch(85), m.setPitch(this.map.getPitch()));
    const w = (this.map.style.imageManager || {}).images || [];
    return Object.keys(w).forEach((v) => {
      w[v].data && m.addImage(v, w[v].data);
    }), m;
  }
  renderMapPost(d) {
    const l = this.map.getTerrain();
    return l && d.setTerrain({
      source: l.source,
      exaggeration: l.exaggeration
    }), d;
  }
}
class Kb {
  constructor(d) {
    Xi(this, "controlContainer"), Xi(this, "exportContainer"), Xi(this, "crosshair"), Xi(this, "printableArea"), Xi(this, "map"), Xi(this, "exportButton"), Xi(this, "options", {
      PageSize: Iu.A4,
      PageOrientation: rh.Landscape,
      Format: Sl.PDF,
      DPI: Bp[300],
      Crosshair: !1,
      PrintableArea: !1,
      Local: "en",
      AllowedSizes: Object.keys(Iu),
      Filename: "map",
      markerCirclePaint: sf,
      attributionOptions: ld,
      northIconOptions: ud
    }), Xi(this, "MAPLIB_CSS_PREFIX", "maplibregl"), d && (d.attributionOptions = Object.assign(
      ld,
      d.attributionOptions
    ), d.northIconOptions = Object.assign(ud, d.northIconOptions), this.options = Object.assign(this.options, d)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const d = this.options.Local ?? "en";
    return Qv(d);
  }
  onAdd(d) {
    var l;
    this.map = d, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const m = document.createElement("TABLE");
    m.className = "print-table";
    const w = {};
    (l = this.options.AllowedSizes) == null || l.forEach((M) => {
      Iu[M] && (w[M] = Iu[M]);
    });
    const v = this.createSelection(
      w,
      this.getTranslation().PageSize,
      "page-size",
      this.options.PageSize,
      (M, q) => JSON.stringify(M[q])
    );
    m.appendChild(v);
    const g = this.createSelection(
      rh,
      this.getTranslation().PageOrientation,
      "page-orientation",
      this.options.PageOrientation,
      (M, q) => M[q]
    );
    m.appendChild(g);
    const s = this.createSelection(
      Sl,
      this.getTranslation().Format,
      "format-type",
      this.options.Format,
      (M, q) => M[q]
    );
    m.appendChild(s);
    const D = this.createSelection(
      Bp,
      this.getTranslation().DPI,
      "dpi-type",
      this.options.DPI,
      (M, q) => M[q]
    );
    m.appendChild(D), this.exportContainer.appendChild(m);
    const k = document.createElement("button");
    return k.type = "button", k.textContent = this.getTranslation().Generate, k.classList.add("generate-button"), k.addEventListener("click", () => {
      const M = document.getElementById("mapbox-gl-export-page-size"), q = document.getElementById("mapbox-gl-export-page-orientation"), O = document.getElementById("mapbox-gl-export-format-type"), z = document.getElementById("mapbox-gl-export-dpi-type"), pe = q.value;
      let le = JSON.parse(M.value);
      pe === rh.Portrait && (le = le.reverse()), this.generateMap(
        d,
        le,
        Number(z.value),
        O.value,
        yc.mm,
        this.options.Filename
      );
    }), this.exportContainer.appendChild(k), this.controlContainer;
  }
  generateMap(d, l, m, w, v, g) {
    new Jb(
      d,
      l,
      m,
      w,
      v,
      g,
      this.options.markerCirclePaint,
      this.options.attributionOptions,
      this.options.northIconOptions
    ).generate();
  }
  createSelection(d, l, m, w, v) {
    const g = document.createElement("label");
    g.textContent = l;
    const s = document.createElement("select");
    s.setAttribute("id", `mapbox-gl-export-${m}`), s.style.width = "100%", Object.keys(d).forEach((q) => {
      const O = document.createElement("option");
      O.setAttribute("value", v(d, q)), O.appendChild(document.createTextNode(q)), O.setAttribute("name", m), w === d[q] && (O.selected = !0), s.appendChild(O);
    }), s.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const D = document.createElement("TR"), k = document.createElement("TD"), M = document.createElement("TD");
    return k.appendChild(g), M.appendChild(s), D.appendChild(k), D.appendChild(M), D;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(d) {
    this.controlContainer && !this.controlContainer.contains(d.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(d) {
    this.options.Crosshair === !0 && (d === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new Rv(this.map), this.crosshair.create()));
  }
  togglePrintableArea(d) {
    this.options.PrintableArea === !0 && (d === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new Ov(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0)
      return;
    const d = document.getElementById("mapbox-gl-export-page-size"), l = document.getElementById("mapbox-gl-export-page-orientation").value;
    let m = JSON.parse(d.value);
    l === rh.Portrait && (m = m.reverse()), this.printableArea.updateArea(m[0], m[1]);
  }
}
var e1 = { exports: {} }, Qc = {}, xl = {}, Au = {}, G0;
function gd() {
  if (G0) return Au;
  G0 = 1;
  function a(v, g, s) {
    if (s === void 0 && (s = Array.prototype), v && typeof s.find == "function")
      return s.find.call(v, g);
    for (var D = 0; D < v.length; D++)
      if (Object.prototype.hasOwnProperty.call(v, D)) {
        var k = v[D];
        if (g.call(void 0, k, D, v))
          return k;
      }
  }
  function d(v, g) {
    return g === void 0 && (g = Object), g && typeof g.freeze == "function" ? g.freeze(v) : v;
  }
  function l(v, g) {
    if (v === null || typeof v != "object")
      throw new TypeError("target is not an object");
    for (var s in g)
      Object.prototype.hasOwnProperty.call(g, s) && (v[s] = g[s]);
    return v;
  }
  var m = d({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see DOMParser.SupportedType.isHTML
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * Helper method to check a mime type if it indicates an HTML document
     *
     * @param {string} [value]
     * @returns {boolean}
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
    isHTML: function(v) {
      return v === m.HTML;
    },
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/html`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  }), w = d({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * Checks if `uri` equals `NAMESPACE.HTML`.
     *
     * @param {string} [uri]
     *
     * @see NAMESPACE.HTML
     */
    isHTML: function(v) {
      return v === w.HTML;
    },
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  return Au.assign = l, Au.find = a, Au.freeze = d, Au.MIME_TYPE = m, Au.NAMESPACE = w, Au;
}
var H0;
function t1() {
  if (H0) return xl;
  H0 = 1;
  var a = gd(), d = a.find, l = a.NAMESPACE;
  function m(ie) {
    return ie !== "";
  }
  function w(ie) {
    return ie ? ie.split(/[\t\n\f\r ]+/).filter(m) : [];
  }
  function v(ie, ue) {
    return ie.hasOwnProperty(ue) || (ie[ue] = !0), ie;
  }
  function g(ie) {
    if (!ie) return [];
    var ue = w(ie);
    return Object.keys(ue.reduce(v, {}));
  }
  function s(ie) {
    return function(ue) {
      return ie && ie.indexOf(ue) !== -1;
    };
  }
  function D(ie, ue) {
    for (var $ in ie)
      Object.prototype.hasOwnProperty.call(ie, $) && (ue[$] = ie[$]);
  }
  function k(ie, ue) {
    var $ = ie.prototype;
    if (!($ instanceof ue)) {
      let B = function() {
      };
      B.prototype = ue.prototype, B = new B(), D($, B), ie.prototype = $ = B;
    }
    $.constructor != ie && (typeof ie != "function" && console.error("unknown Class:" + ie), $.constructor = ie);
  }
  var M = {}, q = M.ELEMENT_NODE = 1, O = M.ATTRIBUTE_NODE = 2, z = M.TEXT_NODE = 3, pe = M.CDATA_SECTION_NODE = 4, le = M.ENTITY_REFERENCE_NODE = 5, se = M.ENTITY_NODE = 6, ee = M.PROCESSING_INSTRUCTION_NODE = 7, fe = M.COMMENT_NODE = 8, Te = M.DOCUMENT_NODE = 9, ze = M.DOCUMENT_TYPE_NODE = 10, qe = M.DOCUMENT_FRAGMENT_NODE = 11, at = M.NOTATION_NODE = 12, Ie = {}, Ae = {};
  Ie.INDEX_SIZE_ERR = (Ae[1] = "Index size error", 1), Ie.DOMSTRING_SIZE_ERR = (Ae[2] = "DOMString size error", 2);
  var me = Ie.HIERARCHY_REQUEST_ERR = (Ae[3] = "Hierarchy request error", 3);
  Ie.WRONG_DOCUMENT_ERR = (Ae[4] = "Wrong document", 4), Ie.INVALID_CHARACTER_ERR = (Ae[5] = "Invalid character", 5), Ie.NO_DATA_ALLOWED_ERR = (Ae[6] = "No data allowed", 6), Ie.NO_MODIFICATION_ALLOWED_ERR = (Ae[7] = "No modification allowed", 7);
  var ve = Ie.NOT_FOUND_ERR = (Ae[8] = "Not found", 8);
  Ie.NOT_SUPPORTED_ERR = (Ae[9] = "Not supported", 9);
  var X = Ie.INUSE_ATTRIBUTE_ERR = (Ae[10] = "Attribute in use", 10);
  Ie.INVALID_STATE_ERR = (Ae[11] = "Invalid state", 11), Ie.SYNTAX_ERR = (Ae[12] = "Syntax error", 12), Ie.INVALID_MODIFICATION_ERR = (Ae[13] = "Invalid modification", 13), Ie.NAMESPACE_ERR = (Ae[14] = "Invalid namespace", 14), Ie.INVALID_ACCESS_ERR = (Ae[15] = "Invalid access", 15);
  function re(ie, ue) {
    if (ue instanceof Error)
      var $ = ue;
    else
      $ = this, Error.call(this, Ae[ie]), this.message = Ae[ie], Error.captureStackTrace && Error.captureStackTrace(this, re);
    return $.code = ie, ue && (this.message = this.message + ": " + ue), $;
  }
  re.prototype = Error.prototype, D(Ie, re);
  function xe() {
  }
  xe.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
     * @standard level1
     */
    length: 0,
    /**
     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
     * @standard level1
     * @param index  unsigned long
     *   Index into the collection.
     * @return Node
     * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
     */
    item: function(ie) {
      return ie >= 0 && ie < this.length ? this[ie] : null;
    },
    toString: function(ie, ue) {
      for (var $ = [], B = 0; B < this.length; B++)
        Gi(this[B], $, ie, ue);
      return $.join("");
    },
    /**
     * @private
     * @param {function (Node):boolean} predicate
     * @returns {Node[]}
     */
    filter: function(ie) {
      return Array.prototype.filter.call(this, ie);
    },
    /**
     * @private
     * @param {Node} item
     * @returns {number}
     */
    indexOf: function(ie) {
      return Array.prototype.indexOf.call(this, ie);
    }
  };
  function ye(ie, ue) {
    this._node = ie, this._refresh = ue, Ve(this);
  }
  function Ve(ie) {
    var ue = ie._node._inc || ie._node.ownerDocument._inc;
    if (ie._inc !== ue) {
      var $ = ie._refresh(ie._node);
      if (Ni(ie, "length", $.length), !ie.$$length || $.length < ie.$$length)
        for (var B = $.length; B in ie; B++)
          Object.prototype.hasOwnProperty.call(ie, B) && delete ie[B];
      D($, ie), ie._inc = ue;
    }
  }
  ye.prototype.item = function(ie) {
    return Ve(this), this[ie] || null;
  }, k(ye, xe);
  function He() {
  }
  function Ze(ie, ue) {
    for (var $ = ie.length; $--; )
      if (ie[$] === ue)
        return $;
  }
  function je(ie, ue, $, B) {
    if (B ? ue[Ze(ue, B)] = $ : ue[ue.length++] = $, ie) {
      $.ownerElement = ie;
      var j = ie.ownerDocument;
      j && (B && Oe(j, ie, B), Ce(j, ie, $));
    }
  }
  function Je(ie, ue, $) {
    var B = Ze(ue, $);
    if (B >= 0) {
      for (var j = ue.length - 1; B < j; )
        ue[B] = ue[++B];
      if (ue.length = j, ie) {
        var te = ie.ownerDocument;
        te && (Oe(te, ie, $), $.ownerElement = null);
      }
    } else
      throw new re(ve, new Error(ie.tagName + "@" + $));
  }
  He.prototype = {
    length: 0,
    item: xe.prototype.item,
    getNamedItem: function(ie) {
      for (var ue = this.length; ue--; ) {
        var $ = this[ue];
        if ($.nodeName == ie)
          return $;
      }
    },
    setNamedItem: function(ie) {
      var ue = ie.ownerElement;
      if (ue && ue != this._ownerElement)
        throw new re(X);
      var $ = this.getNamedItem(ie.nodeName);
      return je(this._ownerElement, this, ie, $), $;
    },
    /* returns Node */
    setNamedItemNS: function(ie) {
      var ue = ie.ownerElement, $;
      if (ue && ue != this._ownerElement)
        throw new re(X);
      return $ = this.getNamedItemNS(ie.namespaceURI, ie.localName), je(this._ownerElement, this, ie, $), $;
    },
    /* returns Node */
    removeNamedItem: function(ie) {
      var ue = this.getNamedItem(ie);
      return Je(this._ownerElement, this, ue), ue;
    },
    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
    //for level2
    removeNamedItemNS: function(ie, ue) {
      var $ = this.getNamedItemNS(ie, ue);
      return Je(this._ownerElement, this, $), $;
    },
    getNamedItemNS: function(ie, ue) {
      for (var $ = this.length; $--; ) {
        var B = this[$];
        if (B.localName == ue && B.namespaceURI == ie)
          return B;
      }
      return null;
    }
  };
  function Qe() {
  }
  Qe.prototype = {
    /**
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
     * The different implementations fairly diverged in what kind of features were reported.
     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
     *
     * @deprecated It is deprecated and modern browsers return true in all cases.
     *
     * @param {string} feature
     * @param {string} [version]
     * @returns {boolean} always true
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     */
    hasFeature: function(ie, ue) {
      return !0;
    },
    /**
     * Creates an XML Document object of the specified type with its document element.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string|null} namespaceURI
     * @param {string} qualifiedName
     * @param {DocumentType=null} doctype
     * @returns {Document}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocument: function(ie, ue, $) {
      var B = new be();
      if (B.implementation = this, B.childNodes = new xe(), B.doctype = $ || null, $ && B.appendChild($), ue) {
        var j = B.createElementNS(ie, ue);
        B.appendChild(j);
      }
      return B;
    },
    /**
     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
     *
     * __This behavior is slightly different from the in the specs__:
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string} qualifiedName
     * @param {string} [publicId]
     * @param {string} [systemId]
     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
     * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocumentType: function(ie, ue, $) {
      var B = new xi();
      return B.name = ie, B.nodeName = ie, B.publicId = ue || "", B.systemId = $ || "", B;
    }
  };
  function nt() {
  }
  nt.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    // Modified in DOM Level 2:
    insertBefore: function(ie, ue) {
      return lt(this, ie, ue);
    },
    replaceChild: function(ie, ue) {
      lt(this, ie, ue, Rt), ue && this.removeChild(ue);
    },
    removeChild: function(ie) {
      return Ue(this, ie);
    },
    appendChild: function(ie) {
      return this.insertBefore(ie, null);
    },
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    cloneNode: function(ie) {
      return cr(this.ownerDocument || this, this, ie);
    },
    // Modified in DOM Level 2:
    normalize: function() {
      for (var ie = this.firstChild; ie; ) {
        var ue = ie.nextSibling;
        ue && ue.nodeType == z && ie.nodeType == z ? (this.removeChild(ue), ie.appendData(ue.data)) : (ie.normalize(), ie = ue);
      }
    },
    // Introduced in DOM Level 2:
    isSupported: function(ie, ue) {
      return this.ownerDocument.implementation.hasFeature(ie, ue);
    },
    // Introduced in DOM Level 2:
    hasAttributes: function() {
      return this.attributes.length > 0;
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
     *
     * @param {string | null} namespaceURI
     * @returns {string | null}
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     */
    lookupPrefix: function(ie) {
      for (var ue = this; ue; ) {
        var $ = ue._nsMap;
        if ($) {
          for (var B in $)
            if (Object.prototype.hasOwnProperty.call($, B) && $[B] === ie)
              return B;
        }
        ue = ue.nodeType == O ? ue.ownerDocument : ue.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI: function(ie) {
      for (var ue = this; ue; ) {
        var $ = ue._nsMap;
        if ($ && Object.prototype.hasOwnProperty.call($, ie))
          return $[ie];
        ue = ue.nodeType == O ? ue.ownerDocument : ue.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace: function(ie) {
      var ue = this.lookupPrefix(ie);
      return ue == null;
    }
  };
  function Q(ie) {
    return ie == "<" && "&lt;" || ie == ">" && "&gt;" || ie == "&" && "&amp;" || ie == '"' && "&quot;" || "&#" + ie.charCodeAt() + ";";
  }
  D(M, nt), D(M, nt.prototype);
  function _e(ie, ue) {
    if (ue(ie))
      return !0;
    if (ie = ie.firstChild)
      do
        if (_e(ie, ue))
          return !0;
      while (ie = ie.nextSibling);
  }
  function be() {
    this.ownerDocument = this;
  }
  function Ce(ie, ue, $) {
    ie && ie._inc++;
    var B = $.namespaceURI;
    B === l.XMLNS && (ue._nsMap[$.prefix ? $.localName : ""] = $.value);
  }
  function Oe(ie, ue, $, B) {
    ie && ie._inc++;
    var j = $.namespaceURI;
    j === l.XMLNS && delete ue._nsMap[$.prefix ? $.localName : ""];
  }
  function $e(ie, ue, $) {
    if (ie && ie._inc) {
      ie._inc++;
      var B = ue.childNodes;
      if ($)
        B[B.length++] = $;
      else {
        for (var j = ue.firstChild, te = 0; j; )
          B[te++] = j, j = j.nextSibling;
        B.length = te, delete B[B.length];
      }
    }
  }
  function Ue(ie, ue) {
    var $ = ue.previousSibling, B = ue.nextSibling;
    return $ ? $.nextSibling = B : ie.firstChild = B, B ? B.previousSibling = $ : ie.lastChild = $, ue.parentNode = null, ue.previousSibling = null, ue.nextSibling = null, $e(ie.ownerDocument, ie), ue;
  }
  function Ke(ie) {
    return ie && (ie.nodeType === nt.DOCUMENT_NODE || ie.nodeType === nt.DOCUMENT_FRAGMENT_NODE || ie.nodeType === nt.ELEMENT_NODE);
  }
  function rt(ie) {
    return ie && (vt(ie) || mt(ie) || ot(ie) || ie.nodeType === nt.DOCUMENT_FRAGMENT_NODE || ie.nodeType === nt.COMMENT_NODE || ie.nodeType === nt.PROCESSING_INSTRUCTION_NODE);
  }
  function ot(ie) {
    return ie && ie.nodeType === nt.DOCUMENT_TYPE_NODE;
  }
  function vt(ie) {
    return ie && ie.nodeType === nt.ELEMENT_NODE;
  }
  function mt(ie) {
    return ie && ie.nodeType === nt.TEXT_NODE;
  }
  function Pt(ie, ue) {
    var $ = ie.childNodes || [];
    if (d($, vt) || ot(ue))
      return !1;
    var B = d($, ot);
    return !(ue && B && $.indexOf(B) > $.indexOf(ue));
  }
  function it(ie, ue) {
    var $ = ie.childNodes || [];
    function B(te) {
      return vt(te) && te !== ue;
    }
    if (d($, B))
      return !1;
    var j = d($, ot);
    return !(ue && j && $.indexOf(j) > $.indexOf(ue));
  }
  function Y(ie, ue, $) {
    if (!Ke(ie))
      throw new re(me, "Unexpected parent node type " + ie.nodeType);
    if ($ && $.parentNode !== ie)
      throw new re(ve, "child not in parent");
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !rt(ue) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      ot(ue) && ie.nodeType !== nt.DOCUMENT_NODE
    )
      throw new re(
        me,
        "Unexpected node type " + ue.nodeType + " for parent node type " + ie.nodeType
      );
  }
  function Kt(ie, ue, $) {
    var B = ie.childNodes || [], j = ue.childNodes || [];
    if (ue.nodeType === nt.DOCUMENT_FRAGMENT_NODE) {
      var te = j.filter(vt);
      if (te.length > 1 || d(j, mt))
        throw new re(me, "More than one element or text in fragment");
      if (te.length === 1 && !Pt(ie, $))
        throw new re(me, "Element in fragment can not be inserted before doctype");
    }
    if (vt(ue) && !Pt(ie, $))
      throw new re(me, "Only one element can be added and only after doctype");
    if (ot(ue)) {
      if (d(B, ot))
        throw new re(me, "Only one doctype is allowed");
      var ge = d(B, vt);
      if ($ && B.indexOf(ge) < B.indexOf($))
        throw new re(me, "Doctype can only be inserted before an element");
      if (!$ && ge)
        throw new re(me, "Doctype can not be appended since element is present");
    }
  }
  function Rt(ie, ue, $) {
    var B = ie.childNodes || [], j = ue.childNodes || [];
    if (ue.nodeType === nt.DOCUMENT_FRAGMENT_NODE) {
      var te = j.filter(vt);
      if (te.length > 1 || d(j, mt))
        throw new re(me, "More than one element or text in fragment");
      if (te.length === 1 && !it(ie, $))
        throw new re(me, "Element in fragment can not be inserted before doctype");
    }
    if (vt(ue) && !it(ie, $))
      throw new re(me, "Only one element can be added and only after doctype");
    if (ot(ue)) {
      if (d(B, function(Fe) {
        return ot(Fe) && Fe !== $;
      }))
        throw new re(me, "Only one doctype is allowed");
      var ge = d(B, vt);
      if ($ && B.indexOf(ge) < B.indexOf($))
        throw new re(me, "Doctype can only be inserted before an element");
    }
  }
  function lt(ie, ue, $, B) {
    Y(ie, ue, $), ie.nodeType === nt.DOCUMENT_NODE && (B || Kt)(ie, ue, $);
    var j = ue.parentNode;
    if (j && j.removeChild(ue), ue.nodeType === qe) {
      var te = ue.firstChild;
      if (te == null)
        return ue;
      var ge = ue.lastChild;
    } else
      te = ge = ue;
    var Me = $ ? $.previousSibling : ie.lastChild;
    te.previousSibling = Me, ge.nextSibling = $, Me ? Me.nextSibling = te : ie.firstChild = te, $ == null ? ie.lastChild = ge : $.previousSibling = ge;
    do
      te.parentNode = ie;
    while (te !== ge && (te = te.nextSibling));
    return $e(ie.ownerDocument || ie, ie), ue.nodeType == qe && (ue.firstChild = ue.lastChild = null), ue;
  }
  function xt(ie, ue) {
    return ue.parentNode && ue.parentNode.removeChild(ue), ue.parentNode = ie, ue.previousSibling = ie.lastChild, ue.nextSibling = null, ue.previousSibling ? ue.previousSibling.nextSibling = ue : ie.firstChild = ue, ie.lastChild = ue, $e(ie.ownerDocument, ie, ue), ue;
  }
  be.prototype = {
    //implementation : null,
    nodeName: "#document",
    nodeType: Te,
    /**
     * The DocumentType node of the document.
     *
     * @readonly
     * @type DocumentType
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(ie, ue) {
      if (ie.nodeType == qe) {
        for (var $ = ie.firstChild; $; ) {
          var B = $.nextSibling;
          this.insertBefore($, ue), $ = B;
        }
        return ie;
      }
      return lt(this, ie, ue), ie.ownerDocument = this, this.documentElement === null && ie.nodeType === q && (this.documentElement = ie), ie;
    },
    removeChild: function(ie) {
      return this.documentElement == ie && (this.documentElement = null), Ue(this, ie);
    },
    replaceChild: function(ie, ue) {
      lt(this, ie, ue, Rt), ie.ownerDocument = this, ue && this.removeChild(ue), vt(ie) && (this.documentElement = ie);
    },
    // Introduced in DOM Level 2:
    importNode: function(ie, ue) {
      return zt(this, ie, ue);
    },
    // Introduced in DOM Level 2:
    getElementById: function(ie) {
      var ue = null;
      return _e(this.documentElement, function($) {
        if ($.nodeType == q && $.getAttribute("id") == ie)
          return ue = $, !0;
      }), ue;
    },
    /**
     * The `getElementsByClassName` method of `Document` interface returns an array-like object
     * of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
     *
     *
     * Warning: This is a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(ie) {
      var ue = g(ie);
      return new ye(this, function($) {
        var B = [];
        return ue.length > 0 && _e($.documentElement, function(j) {
          if (j !== $ && j.nodeType === q) {
            var te = j.getAttribute("class");
            if (te) {
              var ge = ie === te;
              if (!ge) {
                var Me = g(te);
                ge = ue.every(s(Me));
              }
              ge && B.push(j);
            }
          }
        }), B;
      });
    },
    //document factory method:
    createElement: function(ie) {
      var ue = new At();
      ue.ownerDocument = this, ue.nodeName = ie, ue.tagName = ie, ue.localName = ie, ue.childNodes = new xe();
      var $ = ue.attributes = new He();
      return $._ownerElement = ue, ue;
    },
    createDocumentFragment: function() {
      var ie = new kt();
      return ie.ownerDocument = this, ie.childNodes = new xe(), ie;
    },
    createTextNode: function(ie) {
      var ue = new ni();
      return ue.ownerDocument = this, ue.appendData(ie), ue;
    },
    createComment: function(ie) {
      var ue = new ii();
      return ue.ownerDocument = this, ue.appendData(ie), ue;
    },
    createCDATASection: function(ie) {
      var ue = new yi();
      return ue.ownerDocument = this, ue.appendData(ie), ue;
    },
    createProcessingInstruction: function(ie, ue) {
      var $ = new Zi();
      return $.ownerDocument = this, $.tagName = $.nodeName = $.target = ie, $.nodeValue = $.data = ue, $;
    },
    createAttribute: function(ie) {
      var ue = new Et();
      return ue.ownerDocument = this, ue.name = ie, ue.nodeName = ie, ue.localName = ie, ue.specified = !0, ue;
    },
    createEntityReference: function(ie) {
      var ue = new ai();
      return ue.ownerDocument = this, ue.nodeName = ie, ue;
    },
    // Introduced in DOM Level 2:
    createElementNS: function(ie, ue) {
      var $ = new At(), B = ue.split(":"), j = $.attributes = new He();
      return $.childNodes = new xe(), $.ownerDocument = this, $.nodeName = ue, $.tagName = ue, $.namespaceURI = ie, B.length == 2 ? ($.prefix = B[0], $.localName = B[1]) : $.localName = ue, j._ownerElement = $, $;
    },
    // Introduced in DOM Level 2:
    createAttributeNS: function(ie, ue) {
      var $ = new Et(), B = ue.split(":");
      return $.ownerDocument = this, $.nodeName = ue, $.name = ue, $.namespaceURI = ie, $.specified = !0, B.length == 2 ? ($.prefix = B[0], $.localName = B[1]) : $.localName = ue, $;
    }
  }, k(be, nt);
  function At() {
    this._nsMap = {};
  }
  At.prototype = {
    nodeType: q,
    hasAttribute: function(ie) {
      return this.getAttributeNode(ie) != null;
    },
    getAttribute: function(ie) {
      var ue = this.getAttributeNode(ie);
      return ue && ue.value || "";
    },
    getAttributeNode: function(ie) {
      return this.attributes.getNamedItem(ie);
    },
    setAttribute: function(ie, ue) {
      var $ = this.ownerDocument.createAttribute(ie);
      $.value = $.nodeValue = "" + ue, this.setAttributeNode($);
    },
    removeAttribute: function(ie) {
      var ue = this.getAttributeNode(ie);
      ue && this.removeAttributeNode(ue);
    },
    //four real opeartion method
    appendChild: function(ie) {
      return ie.nodeType === qe ? this.insertBefore(ie, null) : xt(this, ie);
    },
    setAttributeNode: function(ie) {
      return this.attributes.setNamedItem(ie);
    },
    setAttributeNodeNS: function(ie) {
      return this.attributes.setNamedItemNS(ie);
    },
    removeAttributeNode: function(ie) {
      return this.attributes.removeNamedItem(ie.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(ie, ue) {
      var $ = this.getAttributeNodeNS(ie, ue);
      $ && this.removeAttributeNode($);
    },
    hasAttributeNS: function(ie, ue) {
      return this.getAttributeNodeNS(ie, ue) != null;
    },
    getAttributeNS: function(ie, ue) {
      var $ = this.getAttributeNodeNS(ie, ue);
      return $ && $.value || "";
    },
    setAttributeNS: function(ie, ue, $) {
      var B = this.ownerDocument.createAttributeNS(ie, ue);
      B.value = B.nodeValue = "" + $, this.setAttributeNode(B);
    },
    getAttributeNodeNS: function(ie, ue) {
      return this.attributes.getNamedItemNS(ie, ue);
    },
    getElementsByTagName: function(ie) {
      return new ye(this, function(ue) {
        var $ = [];
        return _e(ue, function(B) {
          B !== ue && B.nodeType == q && (ie === "*" || B.tagName == ie) && $.push(B);
        }), $;
      });
    },
    getElementsByTagNameNS: function(ie, ue) {
      return new ye(this, function($) {
        var B = [];
        return _e($, function(j) {
          j !== $ && j.nodeType === q && (ie === "*" || j.namespaceURI === ie) && (ue === "*" || j.localName == ue) && B.push(j);
        }), B;
      });
    }
  }, be.prototype.getElementsByTagName = At.prototype.getElementsByTagName, be.prototype.getElementsByTagNameNS = At.prototype.getElementsByTagNameNS, k(At, nt);
  function Et() {
  }
  Et.prototype.nodeType = O, k(Et, nt);
  function jt() {
  }
  jt.prototype = {
    data: "",
    substringData: function(ie, ue) {
      return this.data.substring(ie, ie + ue);
    },
    appendData: function(ie) {
      ie = this.data + ie, this.nodeValue = this.data = ie, this.length = ie.length;
    },
    insertData: function(ie, ue) {
      this.replaceData(ie, 0, ue);
    },
    appendChild: function(ie) {
      throw new Error(Ae[me]);
    },
    deleteData: function(ie, ue) {
      this.replaceData(ie, ue, "");
    },
    replaceData: function(ie, ue, $) {
      var B = this.data.substring(0, ie), j = this.data.substring(ie + ue);
      $ = B + $ + j, this.nodeValue = this.data = $, this.length = $.length;
    }
  }, k(jt, nt);
  function ni() {
  }
  ni.prototype = {
    nodeName: "#text",
    nodeType: z,
    splitText: function(ie) {
      var ue = this.data, $ = ue.substring(ie);
      ue = ue.substring(0, ie), this.data = this.nodeValue = ue, this.length = ue.length;
      var B = this.ownerDocument.createTextNode($);
      return this.parentNode && this.parentNode.insertBefore(B, this.nextSibling), B;
    }
  }, k(ni, jt);
  function ii() {
  }
  ii.prototype = {
    nodeName: "#comment",
    nodeType: fe
  }, k(ii, jt);
  function yi() {
  }
  yi.prototype = {
    nodeName: "#cdata-section",
    nodeType: pe
  }, k(yi, jt);
  function xi() {
  }
  xi.prototype.nodeType = ze, k(xi, nt);
  function pt() {
  }
  pt.prototype.nodeType = at, k(pt, nt);
  function Jt() {
  }
  Jt.prototype.nodeType = se, k(Jt, nt);
  function ai() {
  }
  ai.prototype.nodeType = le, k(ai, nt);
  function kt() {
  }
  kt.prototype.nodeName = "#document-fragment", kt.prototype.nodeType = qe, k(kt, nt);
  function Zi() {
  }
  Zi.prototype.nodeType = ee, k(Zi, nt);
  function ft() {
  }
  ft.prototype.serializeToString = function(ie, ue, $) {
    return ri.call(ie, ue, $);
  }, nt.prototype.toString = ri;
  function ri(ie, ue) {
    var $ = [], B = this.nodeType == 9 && this.documentElement || this, j = B.prefix, te = B.namespaceURI;
    if (te && j == null) {
      var j = B.lookupPrefix(te);
      if (j == null)
        var ge = [
          { namespace: te, prefix: null }
          //{namespace:uri,prefix:''}
        ];
    }
    return Gi(this, $, ie, ue, ge), $.join("");
  }
  function Lt(ie, ue, $) {
    var B = ie.prefix || "", j = ie.namespaceURI;
    if (!j || B === "xml" && j === l.XML || j === l.XMLNS)
      return !1;
    for (var te = $.length; te--; ) {
      var ge = $[te];
      if (ge.prefix === B)
        return ge.namespace !== j;
    }
    return !0;
  }
  function Si(ie, ue, $) {
    ie.push(" ", ue, '="', $.replace(/[<>&"\t\n\r]/g, Q), '"');
  }
  function Gi(ie, ue, $, B, j) {
    if (j || (j = []), B)
      if (ie = B(ie), ie) {
        if (typeof ie == "string") {
          ue.push(ie);
          return;
        }
      } else
        return;
    switch (ie.nodeType) {
      case q:
        var te = ie.attributes, ge = te.length, Qt = ie.firstChild, Me = ie.tagName;
        $ = l.isHTML(ie.namespaceURI) || $;
        var Fe = Me;
        if (!$ && !ie.prefix && ie.namespaceURI) {
          for (var Ne, De = 0; De < te.length; De++)
            if (te.item(De).name === "xmlns") {
              Ne = te.item(De).value;
              break;
            }
          if (!Ne)
            for (var et = j.length - 1; et >= 0; et--) {
              var ut = j[et];
              if (ut.prefix === "" && ut.namespace === ie.namespaceURI) {
                Ne = ut.namespace;
                break;
              }
            }
          if (Ne !== ie.namespaceURI)
            for (var et = j.length - 1; et >= 0; et--) {
              var ut = j[et];
              if (ut.namespace === ie.namespaceURI) {
                ut.prefix && (Fe = ut.prefix + ":" + Me);
                break;
              }
            }
        }
        ue.push("<", Fe);
        for (var We = 0; We < ge; We++) {
          var gt = te.item(We);
          gt.prefix == "xmlns" ? j.push({ prefix: gt.localName, namespace: gt.value }) : gt.nodeName == "xmlns" && j.push({ prefix: "", namespace: gt.value });
        }
        for (var We = 0; We < ge; We++) {
          var gt = te.item(We);
          if (Lt(gt, $, j)) {
            var Mt = gt.prefix || "", $t = gt.namespaceURI;
            Si(ue, Mt ? "xmlns:" + Mt : "xmlns", $t), j.push({ prefix: Mt, namespace: $t });
          }
          Gi(gt, ue, $, B, j);
        }
        if (Me === Fe && Lt(ie, $, j)) {
          var Mt = ie.prefix || "", $t = ie.namespaceURI;
          Si(ue, Mt ? "xmlns:" + Mt : "xmlns", $t), j.push({ prefix: Mt, namespace: $t });
        }
        if (Qt || $ && !/^(?:meta|link|img|br|hr|input)$/i.test(Me)) {
          if (ue.push(">"), $ && /^script$/i.test(Me))
            for (; Qt; )
              Qt.data ? ue.push(Qt.data) : Gi(Qt, ue, $, B, j.slice()), Qt = Qt.nextSibling;
          else
            for (; Qt; )
              Gi(Qt, ue, $, B, j.slice()), Qt = Qt.nextSibling;
          ue.push("</", Fe, ">");
        } else
          ue.push("/>");
        return;
      case Te:
      case qe:
        for (var Qt = ie.firstChild; Qt; )
          Gi(Qt, ue, $, B, j.slice()), Qt = Qt.nextSibling;
        return;
      case O:
        return Si(ue, ie.name, ie.value);
      case z:
        return ue.push(
          ie.data.replace(/[<&>]/g, Q)
        );
      case pe:
        return ue.push("<![CDATA[", ie.data, "]]>");
      case fe:
        return ue.push("<!--", ie.data, "-->");
      case ze:
        var ei = ie.publicId, pi = ie.systemId;
        if (ue.push("<!DOCTYPE ", ie.name), ei)
          ue.push(" PUBLIC ", ei), pi && pi != "." && ue.push(" ", pi), ue.push(">");
        else if (pi && pi != ".")
          ue.push(" SYSTEM ", pi, ">");
        else {
          var fi = ie.internalSubset;
          fi && ue.push(" [", fi, "]"), ue.push(">");
        }
        return;
      case ee:
        return ue.push("<?", ie.target, " ", ie.data, "?>");
      case le:
        return ue.push("&", ie.nodeName, ";");
      default:
        ue.push("??", ie.nodeName);
    }
  }
  function zt(ie, ue, $) {
    var B;
    switch (ue.nodeType) {
      case q:
        B = ue.cloneNode(!1), B.ownerDocument = ie;
      case qe:
        break;
      case O:
        $ = !0;
        break;
    }
    if (B || (B = ue.cloneNode(!1)), B.ownerDocument = ie, B.parentNode = null, $)
      for (var j = ue.firstChild; j; )
        B.appendChild(zt(ie, j, $)), j = j.nextSibling;
    return B;
  }
  function cr(ie, ue, $) {
    var B = new ue.constructor();
    for (var j in ue)
      if (Object.prototype.hasOwnProperty.call(ue, j)) {
        var te = ue[j];
        typeof te != "object" && te != B[j] && (B[j] = te);
      }
    switch (ue.childNodes && (B.childNodes = new xe()), B.ownerDocument = ie, B.nodeType) {
      case q:
        var ge = ue.attributes, Me = B.attributes = new He(), Fe = ge.length;
        Me._ownerElement = B;
        for (var Ne = 0; Ne < Fe; Ne++)
          B.setAttributeNode(cr(ie, ge.item(Ne), !0));
        break;
      case O:
        $ = !0;
    }
    if ($)
      for (var De = ue.firstChild; De; )
        B.appendChild(cr(ie, De, $)), De = De.nextSibling;
    return B;
  }
  function Ni(ie, ue, $) {
    ie[ue] = $;
  }
  try {
    if (Object.defineProperty) {
      let ie = function(ue) {
        switch (ue.nodeType) {
          case q:
          case qe:
            var $ = [];
            for (ue = ue.firstChild; ue; )
              ue.nodeType !== 7 && ue.nodeType !== 8 && $.push(ie(ue)), ue = ue.nextSibling;
            return $.join("");
          default:
            return ue.nodeValue;
        }
      };
      Object.defineProperty(ye.prototype, "length", {
        get: function() {
          return Ve(this), this.$$length;
        }
      }), Object.defineProperty(nt.prototype, "textContent", {
        get: function() {
          return ie(this);
        },
        set: function(ue) {
          switch (this.nodeType) {
            case q:
            case qe:
              for (; this.firstChild; )
                this.removeChild(this.firstChild);
              (ue || String(ue)) && this.appendChild(this.ownerDocument.createTextNode(ue));
              break;
            default:
              this.data = ue, this.value = ue, this.nodeValue = ue;
          }
        }
      }), Ni = function(ue, $, B) {
        ue["$$" + $] = B;
      };
    }
  } catch {
  }
  return xl.DocumentType = xi, xl.DOMException = re, xl.DOMImplementation = Qe, xl.Element = At, xl.Node = nt, xl.NodeList = xe, xl.XMLSerializer = ft, xl;
}
var eh = {}, Sp = {}, W0;
function Qb() {
  return W0 || (W0 = 1, function(a) {
    var d = gd().freeze;
    a.XML_ENTITIES = d({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    }), a.HTML_ENTITIES = d({
      Aacute: "",
      aacute: "",
      Abreve: "",
      abreve: "",
      ac: "",
      acd: "",
      acE: "",
      Acirc: "",
      acirc: "",
      acute: "",
      Acy: "",
      acy: "",
      AElig: "",
      aelig: "",
      af: "",
      Afr: "",
      afr: "",
      Agrave: "",
      agrave: "",
      alefsym: "",
      aleph: "",
      Alpha: "",
      alpha: "",
      Amacr: "",
      amacr: "",
      amalg: "",
      AMP: "&",
      amp: "&",
      And: "",
      and: "",
      andand: "",
      andd: "",
      andslope: "",
      andv: "",
      ang: "",
      ange: "",
      angle: "",
      angmsd: "",
      angmsdaa: "",
      angmsdab: "",
      angmsdac: "",
      angmsdad: "",
      angmsdae: "",
      angmsdaf: "",
      angmsdag: "",
      angmsdah: "",
      angrt: "",
      angrtvb: "",
      angrtvbd: "",
      angsph: "",
      angst: "",
      angzarr: "",
      Aogon: "",
      aogon: "",
      Aopf: "",
      aopf: "",
      ap: "",
      apacir: "",
      apE: "",
      ape: "",
      apid: "",
      apos: "'",
      ApplyFunction: "",
      approx: "",
      approxeq: "",
      Aring: "",
      aring: "",
      Ascr: "",
      ascr: "",
      Assign: "",
      ast: "*",
      asymp: "",
      asympeq: "",
      Atilde: "",
      atilde: "",
      Auml: "",
      auml: "",
      awconint: "",
      awint: "",
      backcong: "",
      backepsilon: "",
      backprime: "",
      backsim: "",
      backsimeq: "",
      Backslash: "",
      Barv: "",
      barvee: "",
      Barwed: "",
      barwed: "",
      barwedge: "",
      bbrk: "",
      bbrktbrk: "",
      bcong: "",
      Bcy: "",
      bcy: "",
      bdquo: "",
      becaus: "",
      Because: "",
      because: "",
      bemptyv: "",
      bepsi: "",
      bernou: "",
      Bernoullis: "",
      Beta: "",
      beta: "",
      beth: "",
      between: "",
      Bfr: "",
      bfr: "",
      bigcap: "",
      bigcirc: "",
      bigcup: "",
      bigodot: "",
      bigoplus: "",
      bigotimes: "",
      bigsqcup: "",
      bigstar: "",
      bigtriangledown: "",
      bigtriangleup: "",
      biguplus: "",
      bigvee: "",
      bigwedge: "",
      bkarow: "",
      blacklozenge: "",
      blacksquare: "",
      blacktriangle: "",
      blacktriangledown: "",
      blacktriangleleft: "",
      blacktriangleright: "",
      blank: "",
      blk12: "",
      blk14: "",
      blk34: "",
      block: "",
      bne: "=",
      bnequiv: "",
      bNot: "",
      bnot: "",
      Bopf: "",
      bopf: "",
      bot: "",
      bottom: "",
      bowtie: "",
      boxbox: "",
      boxDL: "",
      boxDl: "",
      boxdL: "",
      boxdl: "",
      boxDR: "",
      boxDr: "",
      boxdR: "",
      boxdr: "",
      boxH: "",
      boxh: "",
      boxHD: "",
      boxHd: "",
      boxhD: "",
      boxhd: "",
      boxHU: "",
      boxHu: "",
      boxhU: "",
      boxhu: "",
      boxminus: "",
      boxplus: "",
      boxtimes: "",
      boxUL: "",
      boxUl: "",
      boxuL: "",
      boxul: "",
      boxUR: "",
      boxUr: "",
      boxuR: "",
      boxur: "",
      boxV: "",
      boxv: "",
      boxVH: "",
      boxVh: "",
      boxvH: "",
      boxvh: "",
      boxVL: "",
      boxVl: "",
      boxvL: "",
      boxvl: "",
      boxVR: "",
      boxVr: "",
      boxvR: "",
      boxvr: "",
      bprime: "",
      Breve: "",
      breve: "",
      brvbar: "",
      Bscr: "",
      bscr: "",
      bsemi: "",
      bsim: "",
      bsime: "",
      bsol: "\\",
      bsolb: "",
      bsolhsub: "",
      bull: "",
      bullet: "",
      bump: "",
      bumpE: "",
      bumpe: "",
      Bumpeq: "",
      bumpeq: "",
      Cacute: "",
      cacute: "",
      Cap: "",
      cap: "",
      capand: "",
      capbrcup: "",
      capcap: "",
      capcup: "",
      capdot: "",
      CapitalDifferentialD: "",
      caps: "",
      caret: "",
      caron: "",
      Cayleys: "",
      ccaps: "",
      Ccaron: "",
      ccaron: "",
      Ccedil: "",
      ccedil: "",
      Ccirc: "",
      ccirc: "",
      Cconint: "",
      ccups: "",
      ccupssm: "",
      Cdot: "",
      cdot: "",
      cedil: "",
      Cedilla: "",
      cemptyv: "",
      cent: "",
      CenterDot: "",
      centerdot: "",
      Cfr: "",
      cfr: "",
      CHcy: "",
      chcy: "",
      check: "",
      checkmark: "",
      Chi: "",
      chi: "",
      cir: "",
      circ: "",
      circeq: "",
      circlearrowleft: "",
      circlearrowright: "",
      circledast: "",
      circledcirc: "",
      circleddash: "",
      CircleDot: "",
      circledR: "",
      circledS: "",
      CircleMinus: "",
      CirclePlus: "",
      CircleTimes: "",
      cirE: "",
      cire: "",
      cirfnint: "",
      cirmid: "",
      cirscir: "",
      ClockwiseContourIntegral: "",
      CloseCurlyDoubleQuote: "",
      CloseCurlyQuote: "",
      clubs: "",
      clubsuit: "",
      Colon: "",
      colon: ":",
      Colone: "",
      colone: "",
      coloneq: "",
      comma: ",",
      commat: "@",
      comp: "",
      compfn: "",
      complement: "",
      complexes: "",
      cong: "",
      congdot: "",
      Congruent: "",
      Conint: "",
      conint: "",
      ContourIntegral: "",
      Copf: "",
      copf: "",
      coprod: "",
      Coproduct: "",
      COPY: "",
      copy: "",
      copysr: "",
      CounterClockwiseContourIntegral: "",
      crarr: "",
      Cross: "",
      cross: "",
      Cscr: "",
      cscr: "",
      csub: "",
      csube: "",
      csup: "",
      csupe: "",
      ctdot: "",
      cudarrl: "",
      cudarrr: "",
      cuepr: "",
      cuesc: "",
      cularr: "",
      cularrp: "",
      Cup: "",
      cup: "",
      cupbrcap: "",
      CupCap: "",
      cupcap: "",
      cupcup: "",
      cupdot: "",
      cupor: "",
      cups: "",
      curarr: "",
      curarrm: "",
      curlyeqprec: "",
      curlyeqsucc: "",
      curlyvee: "",
      curlywedge: "",
      curren: "",
      curvearrowleft: "",
      curvearrowright: "",
      cuvee: "",
      cuwed: "",
      cwconint: "",
      cwint: "",
      cylcty: "",
      Dagger: "",
      dagger: "",
      daleth: "",
      Darr: "",
      dArr: "",
      darr: "",
      dash: "",
      Dashv: "",
      dashv: "",
      dbkarow: "",
      dblac: "",
      Dcaron: "",
      dcaron: "",
      Dcy: "",
      dcy: "",
      DD: "",
      dd: "",
      ddagger: "",
      ddarr: "",
      DDotrahd: "",
      ddotseq: "",
      deg: "",
      Del: "",
      Delta: "",
      delta: "",
      demptyv: "",
      dfisht: "",
      Dfr: "",
      dfr: "",
      dHar: "",
      dharl: "",
      dharr: "",
      DiacriticalAcute: "",
      DiacriticalDot: "",
      DiacriticalDoubleAcute: "",
      DiacriticalGrave: "`",
      DiacriticalTilde: "",
      diam: "",
      Diamond: "",
      diamond: "",
      diamondsuit: "",
      diams: "",
      die: "",
      DifferentialD: "",
      digamma: "",
      disin: "",
      div: "",
      divide: "",
      divideontimes: "",
      divonx: "",
      DJcy: "",
      djcy: "",
      dlcorn: "",
      dlcrop: "",
      dollar: "$",
      Dopf: "",
      dopf: "",
      Dot: "",
      dot: "",
      DotDot: "",
      doteq: "",
      doteqdot: "",
      DotEqual: "",
      dotminus: "",
      dotplus: "",
      dotsquare: "",
      doublebarwedge: "",
      DoubleContourIntegral: "",
      DoubleDot: "",
      DoubleDownArrow: "",
      DoubleLeftArrow: "",
      DoubleLeftRightArrow: "",
      DoubleLeftTee: "",
      DoubleLongLeftArrow: "",
      DoubleLongLeftRightArrow: "",
      DoubleLongRightArrow: "",
      DoubleRightArrow: "",
      DoubleRightTee: "",
      DoubleUpArrow: "",
      DoubleUpDownArrow: "",
      DoubleVerticalBar: "",
      DownArrow: "",
      Downarrow: "",
      downarrow: "",
      DownArrowBar: "",
      DownArrowUpArrow: "",
      DownBreve: "",
      downdownarrows: "",
      downharpoonleft: "",
      downharpoonright: "",
      DownLeftRightVector: "",
      DownLeftTeeVector: "",
      DownLeftVector: "",
      DownLeftVectorBar: "",
      DownRightTeeVector: "",
      DownRightVector: "",
      DownRightVectorBar: "",
      DownTee: "",
      DownTeeArrow: "",
      drbkarow: "",
      drcorn: "",
      drcrop: "",
      Dscr: "",
      dscr: "",
      DScy: "",
      dscy: "",
      dsol: "",
      Dstrok: "",
      dstrok: "",
      dtdot: "",
      dtri: "",
      dtrif: "",
      duarr: "",
      duhar: "",
      dwangle: "",
      DZcy: "",
      dzcy: "",
      dzigrarr: "",
      Eacute: "",
      eacute: "",
      easter: "",
      Ecaron: "",
      ecaron: "",
      ecir: "",
      Ecirc: "",
      ecirc: "",
      ecolon: "",
      Ecy: "",
      ecy: "",
      eDDot: "",
      Edot: "",
      eDot: "",
      edot: "",
      ee: "",
      efDot: "",
      Efr: "",
      efr: "",
      eg: "",
      Egrave: "",
      egrave: "",
      egs: "",
      egsdot: "",
      el: "",
      Element: "",
      elinters: "",
      ell: "",
      els: "",
      elsdot: "",
      Emacr: "",
      emacr: "",
      empty: "",
      emptyset: "",
      EmptySmallSquare: "",
      emptyv: "",
      EmptyVerySmallSquare: "",
      emsp: "",
      emsp13: "",
      emsp14: "",
      ENG: "",
      eng: "",
      ensp: "",
      Eogon: "",
      eogon: "",
      Eopf: "",
      eopf: "",
      epar: "",
      eparsl: "",
      eplus: "",
      epsi: "",
      Epsilon: "",
      epsilon: "",
      epsiv: "",
      eqcirc: "",
      eqcolon: "",
      eqsim: "",
      eqslantgtr: "",
      eqslantless: "",
      Equal: "",
      equals: "=",
      EqualTilde: "",
      equest: "",
      Equilibrium: "",
      equiv: "",
      equivDD: "",
      eqvparsl: "",
      erarr: "",
      erDot: "",
      Escr: "",
      escr: "",
      esdot: "",
      Esim: "",
      esim: "",
      Eta: "",
      eta: "",
      ETH: "",
      eth: "",
      Euml: "",
      euml: "",
      euro: "",
      excl: "!",
      exist: "",
      Exists: "",
      expectation: "",
      ExponentialE: "",
      exponentiale: "",
      fallingdotseq: "",
      Fcy: "",
      fcy: "",
      female: "",
      ffilig: "",
      fflig: "",
      ffllig: "",
      Ffr: "",
      ffr: "",
      filig: "",
      FilledSmallSquare: "",
      FilledVerySmallSquare: "",
      fjlig: "fj",
      flat: "",
      fllig: "",
      fltns: "",
      fnof: "",
      Fopf: "",
      fopf: "",
      ForAll: "",
      forall: "",
      fork: "",
      forkv: "",
      Fouriertrf: "",
      fpartint: "",
      frac12: "",
      frac13: "",
      frac14: "",
      frac15: "",
      frac16: "",
      frac18: "",
      frac23: "",
      frac25: "",
      frac34: "",
      frac35: "",
      frac38: "",
      frac45: "",
      frac56: "",
      frac58: "",
      frac78: "",
      frasl: "",
      frown: "",
      Fscr: "",
      fscr: "",
      gacute: "",
      Gamma: "",
      gamma: "",
      Gammad: "",
      gammad: "",
      gap: "",
      Gbreve: "",
      gbreve: "",
      Gcedil: "",
      Gcirc: "",
      gcirc: "",
      Gcy: "",
      gcy: "",
      Gdot: "",
      gdot: "",
      gE: "",
      ge: "",
      gEl: "",
      gel: "",
      geq: "",
      geqq: "",
      geqslant: "",
      ges: "",
      gescc: "",
      gesdot: "",
      gesdoto: "",
      gesdotol: "",
      gesl: "",
      gesles: "",
      Gfr: "",
      gfr: "",
      Gg: "",
      gg: "",
      ggg: "",
      gimel: "",
      GJcy: "",
      gjcy: "",
      gl: "",
      gla: "",
      glE: "",
      glj: "",
      gnap: "",
      gnapprox: "",
      gnE: "",
      gne: "",
      gneq: "",
      gneqq: "",
      gnsim: "",
      Gopf: "",
      gopf: "",
      grave: "`",
      GreaterEqual: "",
      GreaterEqualLess: "",
      GreaterFullEqual: "",
      GreaterGreater: "",
      GreaterLess: "",
      GreaterSlantEqual: "",
      GreaterTilde: "",
      Gscr: "",
      gscr: "",
      gsim: "",
      gsime: "",
      gsiml: "",
      Gt: "",
      GT: ">",
      gt: ">",
      gtcc: "",
      gtcir: "",
      gtdot: "",
      gtlPar: "",
      gtquest: "",
      gtrapprox: "",
      gtrarr: "",
      gtrdot: "",
      gtreqless: "",
      gtreqqless: "",
      gtrless: "",
      gtrsim: "",
      gvertneqq: "",
      gvnE: "",
      Hacek: "",
      hairsp: "",
      half: "",
      hamilt: "",
      HARDcy: "",
      hardcy: "",
      hArr: "",
      harr: "",
      harrcir: "",
      harrw: "",
      Hat: "^",
      hbar: "",
      Hcirc: "",
      hcirc: "",
      hearts: "",
      heartsuit: "",
      hellip: "",
      hercon: "",
      Hfr: "",
      hfr: "",
      HilbertSpace: "",
      hksearow: "",
      hkswarow: "",
      hoarr: "",
      homtht: "",
      hookleftarrow: "",
      hookrightarrow: "",
      Hopf: "",
      hopf: "",
      horbar: "",
      HorizontalLine: "",
      Hscr: "",
      hscr: "",
      hslash: "",
      Hstrok: "",
      hstrok: "",
      HumpDownHump: "",
      HumpEqual: "",
      hybull: "",
      hyphen: "",
      Iacute: "",
      iacute: "",
      ic: "",
      Icirc: "",
      icirc: "",
      Icy: "",
      icy: "",
      Idot: "",
      IEcy: "",
      iecy: "",
      iexcl: "",
      iff: "",
      Ifr: "",
      ifr: "",
      Igrave: "",
      igrave: "",
      ii: "",
      iiiint: "",
      iiint: "",
      iinfin: "",
      iiota: "",
      IJlig: "",
      ijlig: "",
      Im: "",
      Imacr: "",
      imacr: "",
      image: "",
      ImaginaryI: "",
      imagline: "",
      imagpart: "",
      imath: "",
      imof: "",
      imped: "",
      Implies: "",
      in: "",
      incare: "",
      infin: "",
      infintie: "",
      inodot: "",
      Int: "",
      int: "",
      intcal: "",
      integers: "",
      Integral: "",
      intercal: "",
      Intersection: "",
      intlarhk: "",
      intprod: "",
      InvisibleComma: "",
      InvisibleTimes: "",
      IOcy: "",
      iocy: "",
      Iogon: "",
      iogon: "",
      Iopf: "",
      iopf: "",
      Iota: "",
      iota: "",
      iprod: "",
      iquest: "",
      Iscr: "",
      iscr: "",
      isin: "",
      isindot: "",
      isinE: "",
      isins: "",
      isinsv: "",
      isinv: "",
      it: "",
      Itilde: "",
      itilde: "",
      Iukcy: "",
      iukcy: "",
      Iuml: "",
      iuml: "",
      Jcirc: "",
      jcirc: "",
      Jcy: "",
      jcy: "",
      Jfr: "",
      jfr: "",
      jmath: "",
      Jopf: "",
      jopf: "",
      Jscr: "",
      jscr: "",
      Jsercy: "",
      jsercy: "",
      Jukcy: "",
      jukcy: "",
      Kappa: "",
      kappa: "",
      kappav: "",
      Kcedil: "",
      kcedil: "",
      Kcy: "",
      kcy: "",
      Kfr: "",
      kfr: "",
      kgreen: "",
      KHcy: "",
      khcy: "",
      KJcy: "",
      kjcy: "",
      Kopf: "",
      kopf: "",
      Kscr: "",
      kscr: "",
      lAarr: "",
      Lacute: "",
      lacute: "",
      laemptyv: "",
      lagran: "",
      Lambda: "",
      lambda: "",
      Lang: "",
      lang: "",
      langd: "",
      langle: "",
      lap: "",
      Laplacetrf: "",
      laquo: "",
      Larr: "",
      lArr: "",
      larr: "",
      larrb: "",
      larrbfs: "",
      larrfs: "",
      larrhk: "",
      larrlp: "",
      larrpl: "",
      larrsim: "",
      larrtl: "",
      lat: "",
      lAtail: "",
      latail: "",
      late: "",
      lates: "",
      lBarr: "",
      lbarr: "",
      lbbrk: "",
      lbrace: "{",
      lbrack: "[",
      lbrke: "",
      lbrksld: "",
      lbrkslu: "",
      Lcaron: "",
      lcaron: "",
      Lcedil: "",
      lcedil: "",
      lceil: "",
      lcub: "{",
      Lcy: "",
      lcy: "",
      ldca: "",
      ldquo: "",
      ldquor: "",
      ldrdhar: "",
      ldrushar: "",
      ldsh: "",
      lE: "",
      le: "",
      LeftAngleBracket: "",
      LeftArrow: "",
      Leftarrow: "",
      leftarrow: "",
      LeftArrowBar: "",
      LeftArrowRightArrow: "",
      leftarrowtail: "",
      LeftCeiling: "",
      LeftDoubleBracket: "",
      LeftDownTeeVector: "",
      LeftDownVector: "",
      LeftDownVectorBar: "",
      LeftFloor: "",
      leftharpoondown: "",
      leftharpoonup: "",
      leftleftarrows: "",
      LeftRightArrow: "",
      Leftrightarrow: "",
      leftrightarrow: "",
      leftrightarrows: "",
      leftrightharpoons: "",
      leftrightsquigarrow: "",
      LeftRightVector: "",
      LeftTee: "",
      LeftTeeArrow: "",
      LeftTeeVector: "",
      leftthreetimes: "",
      LeftTriangle: "",
      LeftTriangleBar: "",
      LeftTriangleEqual: "",
      LeftUpDownVector: "",
      LeftUpTeeVector: "",
      LeftUpVector: "",
      LeftUpVectorBar: "",
      LeftVector: "",
      LeftVectorBar: "",
      lEg: "",
      leg: "",
      leq: "",
      leqq: "",
      leqslant: "",
      les: "",
      lescc: "",
      lesdot: "",
      lesdoto: "",
      lesdotor: "",
      lesg: "",
      lesges: "",
      lessapprox: "",
      lessdot: "",
      lesseqgtr: "",
      lesseqqgtr: "",
      LessEqualGreater: "",
      LessFullEqual: "",
      LessGreater: "",
      lessgtr: "",
      LessLess: "",
      lesssim: "",
      LessSlantEqual: "",
      LessTilde: "",
      lfisht: "",
      lfloor: "",
      Lfr: "",
      lfr: "",
      lg: "",
      lgE: "",
      lHar: "",
      lhard: "",
      lharu: "",
      lharul: "",
      lhblk: "",
      LJcy: "",
      ljcy: "",
      Ll: "",
      ll: "",
      llarr: "",
      llcorner: "",
      Lleftarrow: "",
      llhard: "",
      lltri: "",
      Lmidot: "",
      lmidot: "",
      lmoust: "",
      lmoustache: "",
      lnap: "",
      lnapprox: "",
      lnE: "",
      lne: "",
      lneq: "",
      lneqq: "",
      lnsim: "",
      loang: "",
      loarr: "",
      lobrk: "",
      LongLeftArrow: "",
      Longleftarrow: "",
      longleftarrow: "",
      LongLeftRightArrow: "",
      Longleftrightarrow: "",
      longleftrightarrow: "",
      longmapsto: "",
      LongRightArrow: "",
      Longrightarrow: "",
      longrightarrow: "",
      looparrowleft: "",
      looparrowright: "",
      lopar: "",
      Lopf: "",
      lopf: "",
      loplus: "",
      lotimes: "",
      lowast: "",
      lowbar: "_",
      LowerLeftArrow: "",
      LowerRightArrow: "",
      loz: "",
      lozenge: "",
      lozf: "",
      lpar: "(",
      lparlt: "",
      lrarr: "",
      lrcorner: "",
      lrhar: "",
      lrhard: "",
      lrm: "",
      lrtri: "",
      lsaquo: "",
      Lscr: "",
      lscr: "",
      Lsh: "",
      lsh: "",
      lsim: "",
      lsime: "",
      lsimg: "",
      lsqb: "[",
      lsquo: "",
      lsquor: "",
      Lstrok: "",
      lstrok: "",
      Lt: "",
      LT: "<",
      lt: "<",
      ltcc: "",
      ltcir: "",
      ltdot: "",
      lthree: "",
      ltimes: "",
      ltlarr: "",
      ltquest: "",
      ltri: "",
      ltrie: "",
      ltrif: "",
      ltrPar: "",
      lurdshar: "",
      luruhar: "",
      lvertneqq: "",
      lvnE: "",
      macr: "",
      male: "",
      malt: "",
      maltese: "",
      Map: "",
      map: "",
      mapsto: "",
      mapstodown: "",
      mapstoleft: "",
      mapstoup: "",
      marker: "",
      mcomma: "",
      Mcy: "",
      mcy: "",
      mdash: "",
      mDDot: "",
      measuredangle: "",
      MediumSpace: "",
      Mellintrf: "",
      Mfr: "",
      mfr: "",
      mho: "",
      micro: "",
      mid: "",
      midast: "*",
      midcir: "",
      middot: "",
      minus: "",
      minusb: "",
      minusd: "",
      minusdu: "",
      MinusPlus: "",
      mlcp: "",
      mldr: "",
      mnplus: "",
      models: "",
      Mopf: "",
      mopf: "",
      mp: "",
      Mscr: "",
      mscr: "",
      mstpos: "",
      Mu: "",
      mu: "",
      multimap: "",
      mumap: "",
      nabla: "",
      Nacute: "",
      nacute: "",
      nang: "",
      nap: "",
      napE: "",
      napid: "",
      napos: "",
      napprox: "",
      natur: "",
      natural: "",
      naturals: "",
      nbsp: "",
      nbump: "",
      nbumpe: "",
      ncap: "",
      Ncaron: "",
      ncaron: "",
      Ncedil: "",
      ncedil: "",
      ncong: "",
      ncongdot: "",
      ncup: "",
      Ncy: "",
      ncy: "",
      ndash: "",
      ne: "",
      nearhk: "",
      neArr: "",
      nearr: "",
      nearrow: "",
      nedot: "",
      NegativeMediumSpace: "",
      NegativeThickSpace: "",
      NegativeThinSpace: "",
      NegativeVeryThinSpace: "",
      nequiv: "",
      nesear: "",
      nesim: "",
      NestedGreaterGreater: "",
      NestedLessLess: "",
      NewLine: `
`,
      nexist: "",
      nexists: "",
      Nfr: "",
      nfr: "",
      ngE: "",
      nge: "",
      ngeq: "",
      ngeqq: "",
      ngeqslant: "",
      nges: "",
      nGg: "",
      ngsim: "",
      nGt: "",
      ngt: "",
      ngtr: "",
      nGtv: "",
      nhArr: "",
      nharr: "",
      nhpar: "",
      ni: "",
      nis: "",
      nisd: "",
      niv: "",
      NJcy: "",
      njcy: "",
      nlArr: "",
      nlarr: "",
      nldr: "",
      nlE: "",
      nle: "",
      nLeftarrow: "",
      nleftarrow: "",
      nLeftrightarrow: "",
      nleftrightarrow: "",
      nleq: "",
      nleqq: "",
      nleqslant: "",
      nles: "",
      nless: "",
      nLl: "",
      nlsim: "",
      nLt: "",
      nlt: "",
      nltri: "",
      nltrie: "",
      nLtv: "",
      nmid: "",
      NoBreak: "",
      NonBreakingSpace: "",
      Nopf: "",
      nopf: "",
      Not: "",
      not: "",
      NotCongruent: "",
      NotCupCap: "",
      NotDoubleVerticalBar: "",
      NotElement: "",
      NotEqual: "",
      NotEqualTilde: "",
      NotExists: "",
      NotGreater: "",
      NotGreaterEqual: "",
      NotGreaterFullEqual: "",
      NotGreaterGreater: "",
      NotGreaterLess: "",
      NotGreaterSlantEqual: "",
      NotGreaterTilde: "",
      NotHumpDownHump: "",
      NotHumpEqual: "",
      notin: "",
      notindot: "",
      notinE: "",
      notinva: "",
      notinvb: "",
      notinvc: "",
      NotLeftTriangle: "",
      NotLeftTriangleBar: "",
      NotLeftTriangleEqual: "",
      NotLess: "",
      NotLessEqual: "",
      NotLessGreater: "",
      NotLessLess: "",
      NotLessSlantEqual: "",
      NotLessTilde: "",
      NotNestedGreaterGreater: "",
      NotNestedLessLess: "",
      notni: "",
      notniva: "",
      notnivb: "",
      notnivc: "",
      NotPrecedes: "",
      NotPrecedesEqual: "",
      NotPrecedesSlantEqual: "",
      NotReverseElement: "",
      NotRightTriangle: "",
      NotRightTriangleBar: "",
      NotRightTriangleEqual: "",
      NotSquareSubset: "",
      NotSquareSubsetEqual: "",
      NotSquareSuperset: "",
      NotSquareSupersetEqual: "",
      NotSubset: "",
      NotSubsetEqual: "",
      NotSucceeds: "",
      NotSucceedsEqual: "",
      NotSucceedsSlantEqual: "",
      NotSucceedsTilde: "",
      NotSuperset: "",
      NotSupersetEqual: "",
      NotTilde: "",
      NotTildeEqual: "",
      NotTildeFullEqual: "",
      NotTildeTilde: "",
      NotVerticalBar: "",
      npar: "",
      nparallel: "",
      nparsl: "",
      npart: "",
      npolint: "",
      npr: "",
      nprcue: "",
      npre: "",
      nprec: "",
      npreceq: "",
      nrArr: "",
      nrarr: "",
      nrarrc: "",
      nrarrw: "",
      nRightarrow: "",
      nrightarrow: "",
      nrtri: "",
      nrtrie: "",
      nsc: "",
      nsccue: "",
      nsce: "",
      Nscr: "",
      nscr: "",
      nshortmid: "",
      nshortparallel: "",
      nsim: "",
      nsime: "",
      nsimeq: "",
      nsmid: "",
      nspar: "",
      nsqsube: "",
      nsqsupe: "",
      nsub: "",
      nsubE: "",
      nsube: "",
      nsubset: "",
      nsubseteq: "",
      nsubseteqq: "",
      nsucc: "",
      nsucceq: "",
      nsup: "",
      nsupE: "",
      nsupe: "",
      nsupset: "",
      nsupseteq: "",
      nsupseteqq: "",
      ntgl: "",
      Ntilde: "",
      ntilde: "",
      ntlg: "",
      ntriangleleft: "",
      ntrianglelefteq: "",
      ntriangleright: "",
      ntrianglerighteq: "",
      Nu: "",
      nu: "",
      num: "#",
      numero: "",
      numsp: "",
      nvap: "",
      nVDash: "",
      nVdash: "",
      nvDash: "",
      nvdash: "",
      nvge: "",
      nvgt: ">",
      nvHarr: "",
      nvinfin: "",
      nvlArr: "",
      nvle: "",
      nvlt: "<",
      nvltrie: "",
      nvrArr: "",
      nvrtrie: "",
      nvsim: "",
      nwarhk: "",
      nwArr: "",
      nwarr: "",
      nwarrow: "",
      nwnear: "",
      Oacute: "",
      oacute: "",
      oast: "",
      ocir: "",
      Ocirc: "",
      ocirc: "",
      Ocy: "",
      ocy: "",
      odash: "",
      Odblac: "",
      odblac: "",
      odiv: "",
      odot: "",
      odsold: "",
      OElig: "",
      oelig: "",
      ofcir: "",
      Ofr: "",
      ofr: "",
      ogon: "",
      Ograve: "",
      ograve: "",
      ogt: "",
      ohbar: "",
      ohm: "",
      oint: "",
      olarr: "",
      olcir: "",
      olcross: "",
      oline: "",
      olt: "",
      Omacr: "",
      omacr: "",
      Omega: "",
      omega: "",
      Omicron: "",
      omicron: "",
      omid: "",
      ominus: "",
      Oopf: "",
      oopf: "",
      opar: "",
      OpenCurlyDoubleQuote: "",
      OpenCurlyQuote: "",
      operp: "",
      oplus: "",
      Or: "",
      or: "",
      orarr: "",
      ord: "",
      order: "",
      orderof: "",
      ordf: "",
      ordm: "",
      origof: "",
      oror: "",
      orslope: "",
      orv: "",
      oS: "",
      Oscr: "",
      oscr: "",
      Oslash: "",
      oslash: "",
      osol: "",
      Otilde: "",
      otilde: "",
      Otimes: "",
      otimes: "",
      otimesas: "",
      Ouml: "",
      ouml: "",
      ovbar: "",
      OverBar: "",
      OverBrace: "",
      OverBracket: "",
      OverParenthesis: "",
      par: "",
      para: "",
      parallel: "",
      parsim: "",
      parsl: "",
      part: "",
      PartialD: "",
      Pcy: "",
      pcy: "",
      percnt: "%",
      period: ".",
      permil: "",
      perp: "",
      pertenk: "",
      Pfr: "",
      pfr: "",
      Phi: "",
      phi: "",
      phiv: "",
      phmmat: "",
      phone: "",
      Pi: "",
      pi: "",
      pitchfork: "",
      piv: "",
      planck: "",
      planckh: "",
      plankv: "",
      plus: "+",
      plusacir: "",
      plusb: "",
      pluscir: "",
      plusdo: "",
      plusdu: "",
      pluse: "",
      PlusMinus: "",
      plusmn: "",
      plussim: "",
      plustwo: "",
      pm: "",
      Poincareplane: "",
      pointint: "",
      Popf: "",
      popf: "",
      pound: "",
      Pr: "",
      pr: "",
      prap: "",
      prcue: "",
      prE: "",
      pre: "",
      prec: "",
      precapprox: "",
      preccurlyeq: "",
      Precedes: "",
      PrecedesEqual: "",
      PrecedesSlantEqual: "",
      PrecedesTilde: "",
      preceq: "",
      precnapprox: "",
      precneqq: "",
      precnsim: "",
      precsim: "",
      Prime: "",
      prime: "",
      primes: "",
      prnap: "",
      prnE: "",
      prnsim: "",
      prod: "",
      Product: "",
      profalar: "",
      profline: "",
      profsurf: "",
      prop: "",
      Proportion: "",
      Proportional: "",
      propto: "",
      prsim: "",
      prurel: "",
      Pscr: "",
      pscr: "",
      Psi: "",
      psi: "",
      puncsp: "",
      Qfr: "",
      qfr: "",
      qint: "",
      Qopf: "",
      qopf: "",
      qprime: "",
      Qscr: "",
      qscr: "",
      quaternions: "",
      quatint: "",
      quest: "?",
      questeq: "",
      QUOT: '"',
      quot: '"',
      rAarr: "",
      race: "",
      Racute: "",
      racute: "",
      radic: "",
      raemptyv: "",
      Rang: "",
      rang: "",
      rangd: "",
      range: "",
      rangle: "",
      raquo: "",
      Rarr: "",
      rArr: "",
      rarr: "",
      rarrap: "",
      rarrb: "",
      rarrbfs: "",
      rarrc: "",
      rarrfs: "",
      rarrhk: "",
      rarrlp: "",
      rarrpl: "",
      rarrsim: "",
      Rarrtl: "",
      rarrtl: "",
      rarrw: "",
      rAtail: "",
      ratail: "",
      ratio: "",
      rationals: "",
      RBarr: "",
      rBarr: "",
      rbarr: "",
      rbbrk: "",
      rbrace: "}",
      rbrack: "]",
      rbrke: "",
      rbrksld: "",
      rbrkslu: "",
      Rcaron: "",
      rcaron: "",
      Rcedil: "",
      rcedil: "",
      rceil: "",
      rcub: "}",
      Rcy: "",
      rcy: "",
      rdca: "",
      rdldhar: "",
      rdquo: "",
      rdquor: "",
      rdsh: "",
      Re: "",
      real: "",
      realine: "",
      realpart: "",
      reals: "",
      rect: "",
      REG: "",
      reg: "",
      ReverseElement: "",
      ReverseEquilibrium: "",
      ReverseUpEquilibrium: "",
      rfisht: "",
      rfloor: "",
      Rfr: "",
      rfr: "",
      rHar: "",
      rhard: "",
      rharu: "",
      rharul: "",
      Rho: "",
      rho: "",
      rhov: "",
      RightAngleBracket: "",
      RightArrow: "",
      Rightarrow: "",
      rightarrow: "",
      RightArrowBar: "",
      RightArrowLeftArrow: "",
      rightarrowtail: "",
      RightCeiling: "",
      RightDoubleBracket: "",
      RightDownTeeVector: "",
      RightDownVector: "",
      RightDownVectorBar: "",
      RightFloor: "",
      rightharpoondown: "",
      rightharpoonup: "",
      rightleftarrows: "",
      rightleftharpoons: "",
      rightrightarrows: "",
      rightsquigarrow: "",
      RightTee: "",
      RightTeeArrow: "",
      RightTeeVector: "",
      rightthreetimes: "",
      RightTriangle: "",
      RightTriangleBar: "",
      RightTriangleEqual: "",
      RightUpDownVector: "",
      RightUpTeeVector: "",
      RightUpVector: "",
      RightUpVectorBar: "",
      RightVector: "",
      RightVectorBar: "",
      ring: "",
      risingdotseq: "",
      rlarr: "",
      rlhar: "",
      rlm: "",
      rmoust: "",
      rmoustache: "",
      rnmid: "",
      roang: "",
      roarr: "",
      robrk: "",
      ropar: "",
      Ropf: "",
      ropf: "",
      roplus: "",
      rotimes: "",
      RoundImplies: "",
      rpar: ")",
      rpargt: "",
      rppolint: "",
      rrarr: "",
      Rrightarrow: "",
      rsaquo: "",
      Rscr: "",
      rscr: "",
      Rsh: "",
      rsh: "",
      rsqb: "]",
      rsquo: "",
      rsquor: "",
      rthree: "",
      rtimes: "",
      rtri: "",
      rtrie: "",
      rtrif: "",
      rtriltri: "",
      RuleDelayed: "",
      ruluhar: "",
      rx: "",
      Sacute: "",
      sacute: "",
      sbquo: "",
      Sc: "",
      sc: "",
      scap: "",
      Scaron: "",
      scaron: "",
      sccue: "",
      scE: "",
      sce: "",
      Scedil: "",
      scedil: "",
      Scirc: "",
      scirc: "",
      scnap: "",
      scnE: "",
      scnsim: "",
      scpolint: "",
      scsim: "",
      Scy: "",
      scy: "",
      sdot: "",
      sdotb: "",
      sdote: "",
      searhk: "",
      seArr: "",
      searr: "",
      searrow: "",
      sect: "",
      semi: ";",
      seswar: "",
      setminus: "",
      setmn: "",
      sext: "",
      Sfr: "",
      sfr: "",
      sfrown: "",
      sharp: "",
      SHCHcy: "",
      shchcy: "",
      SHcy: "",
      shcy: "",
      ShortDownArrow: "",
      ShortLeftArrow: "",
      shortmid: "",
      shortparallel: "",
      ShortRightArrow: "",
      ShortUpArrow: "",
      shy: "",
      Sigma: "",
      sigma: "",
      sigmaf: "",
      sigmav: "",
      sim: "",
      simdot: "",
      sime: "",
      simeq: "",
      simg: "",
      simgE: "",
      siml: "",
      simlE: "",
      simne: "",
      simplus: "",
      simrarr: "",
      slarr: "",
      SmallCircle: "",
      smallsetminus: "",
      smashp: "",
      smeparsl: "",
      smid: "",
      smile: "",
      smt: "",
      smte: "",
      smtes: "",
      SOFTcy: "",
      softcy: "",
      sol: "/",
      solb: "",
      solbar: "",
      Sopf: "",
      sopf: "",
      spades: "",
      spadesuit: "",
      spar: "",
      sqcap: "",
      sqcaps: "",
      sqcup: "",
      sqcups: "",
      Sqrt: "",
      sqsub: "",
      sqsube: "",
      sqsubset: "",
      sqsubseteq: "",
      sqsup: "",
      sqsupe: "",
      sqsupset: "",
      sqsupseteq: "",
      squ: "",
      Square: "",
      square: "",
      SquareIntersection: "",
      SquareSubset: "",
      SquareSubsetEqual: "",
      SquareSuperset: "",
      SquareSupersetEqual: "",
      SquareUnion: "",
      squarf: "",
      squf: "",
      srarr: "",
      Sscr: "",
      sscr: "",
      ssetmn: "",
      ssmile: "",
      sstarf: "",
      Star: "",
      star: "",
      starf: "",
      straightepsilon: "",
      straightphi: "",
      strns: "",
      Sub: "",
      sub: "",
      subdot: "",
      subE: "",
      sube: "",
      subedot: "",
      submult: "",
      subnE: "",
      subne: "",
      subplus: "",
      subrarr: "",
      Subset: "",
      subset: "",
      subseteq: "",
      subseteqq: "",
      SubsetEqual: "",
      subsetneq: "",
      subsetneqq: "",
      subsim: "",
      subsub: "",
      subsup: "",
      succ: "",
      succapprox: "",
      succcurlyeq: "",
      Succeeds: "",
      SucceedsEqual: "",
      SucceedsSlantEqual: "",
      SucceedsTilde: "",
      succeq: "",
      succnapprox: "",
      succneqq: "",
      succnsim: "",
      succsim: "",
      SuchThat: "",
      Sum: "",
      sum: "",
      sung: "",
      Sup: "",
      sup: "",
      sup1: "",
      sup2: "",
      sup3: "",
      supdot: "",
      supdsub: "",
      supE: "",
      supe: "",
      supedot: "",
      Superset: "",
      SupersetEqual: "",
      suphsol: "",
      suphsub: "",
      suplarr: "",
      supmult: "",
      supnE: "",
      supne: "",
      supplus: "",
      Supset: "",
      supset: "",
      supseteq: "",
      supseteqq: "",
      supsetneq: "",
      supsetneqq: "",
      supsim: "",
      supsub: "",
      supsup: "",
      swarhk: "",
      swArr: "",
      swarr: "",
      swarrow: "",
      swnwar: "",
      szlig: "",
      Tab: "	",
      target: "",
      Tau: "",
      tau: "",
      tbrk: "",
      Tcaron: "",
      tcaron: "",
      Tcedil: "",
      tcedil: "",
      Tcy: "",
      tcy: "",
      tdot: "",
      telrec: "",
      Tfr: "",
      tfr: "",
      there4: "",
      Therefore: "",
      therefore: "",
      Theta: "",
      theta: "",
      thetasym: "",
      thetav: "",
      thickapprox: "",
      thicksim: "",
      ThickSpace: "",
      thinsp: "",
      ThinSpace: "",
      thkap: "",
      thksim: "",
      THORN: "",
      thorn: "",
      Tilde: "",
      tilde: "",
      TildeEqual: "",
      TildeFullEqual: "",
      TildeTilde: "",
      times: "",
      timesb: "",
      timesbar: "",
      timesd: "",
      tint: "",
      toea: "",
      top: "",
      topbot: "",
      topcir: "",
      Topf: "",
      topf: "",
      topfork: "",
      tosa: "",
      tprime: "",
      TRADE: "",
      trade: "",
      triangle: "",
      triangledown: "",
      triangleleft: "",
      trianglelefteq: "",
      triangleq: "",
      triangleright: "",
      trianglerighteq: "",
      tridot: "",
      trie: "",
      triminus: "",
      TripleDot: "",
      triplus: "",
      trisb: "",
      tritime: "",
      trpezium: "",
      Tscr: "",
      tscr: "",
      TScy: "",
      tscy: "",
      TSHcy: "",
      tshcy: "",
      Tstrok: "",
      tstrok: "",
      twixt: "",
      twoheadleftarrow: "",
      twoheadrightarrow: "",
      Uacute: "",
      uacute: "",
      Uarr: "",
      uArr: "",
      uarr: "",
      Uarrocir: "",
      Ubrcy: "",
      ubrcy: "",
      Ubreve: "",
      ubreve: "",
      Ucirc: "",
      ucirc: "",
      Ucy: "",
      ucy: "",
      udarr: "",
      Udblac: "",
      udblac: "",
      udhar: "",
      ufisht: "",
      Ufr: "",
      ufr: "",
      Ugrave: "",
      ugrave: "",
      uHar: "",
      uharl: "",
      uharr: "",
      uhblk: "",
      ulcorn: "",
      ulcorner: "",
      ulcrop: "",
      ultri: "",
      Umacr: "",
      umacr: "",
      uml: "",
      UnderBar: "_",
      UnderBrace: "",
      UnderBracket: "",
      UnderParenthesis: "",
      Union: "",
      UnionPlus: "",
      Uogon: "",
      uogon: "",
      Uopf: "",
      uopf: "",
      UpArrow: "",
      Uparrow: "",
      uparrow: "",
      UpArrowBar: "",
      UpArrowDownArrow: "",
      UpDownArrow: "",
      Updownarrow: "",
      updownarrow: "",
      UpEquilibrium: "",
      upharpoonleft: "",
      upharpoonright: "",
      uplus: "",
      UpperLeftArrow: "",
      UpperRightArrow: "",
      Upsi: "",
      upsi: "",
      upsih: "",
      Upsilon: "",
      upsilon: "",
      UpTee: "",
      UpTeeArrow: "",
      upuparrows: "",
      urcorn: "",
      urcorner: "",
      urcrop: "",
      Uring: "",
      uring: "",
      urtri: "",
      Uscr: "",
      uscr: "",
      utdot: "",
      Utilde: "",
      utilde: "",
      utri: "",
      utrif: "",
      uuarr: "",
      Uuml: "",
      uuml: "",
      uwangle: "",
      vangrt: "",
      varepsilon: "",
      varkappa: "",
      varnothing: "",
      varphi: "",
      varpi: "",
      varpropto: "",
      vArr: "",
      varr: "",
      varrho: "",
      varsigma: "",
      varsubsetneq: "",
      varsubsetneqq: "",
      varsupsetneq: "",
      varsupsetneqq: "",
      vartheta: "",
      vartriangleleft: "",
      vartriangleright: "",
      Vbar: "",
      vBar: "",
      vBarv: "",
      Vcy: "",
      vcy: "",
      VDash: "",
      Vdash: "",
      vDash: "",
      vdash: "",
      Vdashl: "",
      Vee: "",
      vee: "",
      veebar: "",
      veeeq: "",
      vellip: "",
      Verbar: "",
      verbar: "|",
      Vert: "",
      vert: "|",
      VerticalBar: "",
      VerticalLine: "|",
      VerticalSeparator: "",
      VerticalTilde: "",
      VeryThinSpace: "",
      Vfr: "",
      vfr: "",
      vltri: "",
      vnsub: "",
      vnsup: "",
      Vopf: "",
      vopf: "",
      vprop: "",
      vrtri: "",
      Vscr: "",
      vscr: "",
      vsubnE: "",
      vsubne: "",
      vsupnE: "",
      vsupne: "",
      Vvdash: "",
      vzigzag: "",
      Wcirc: "",
      wcirc: "",
      wedbar: "",
      Wedge: "",
      wedge: "",
      wedgeq: "",
      weierp: "",
      Wfr: "",
      wfr: "",
      Wopf: "",
      wopf: "",
      wp: "",
      wr: "",
      wreath: "",
      Wscr: "",
      wscr: "",
      xcap: "",
      xcirc: "",
      xcup: "",
      xdtri: "",
      Xfr: "",
      xfr: "",
      xhArr: "",
      xharr: "",
      Xi: "",
      xi: "",
      xlArr: "",
      xlarr: "",
      xmap: "",
      xnis: "",
      xodot: "",
      Xopf: "",
      xopf: "",
      xoplus: "",
      xotime: "",
      xrArr: "",
      xrarr: "",
      Xscr: "",
      xscr: "",
      xsqcup: "",
      xuplus: "",
      xutri: "",
      xvee: "",
      xwedge: "",
      Yacute: "",
      yacute: "",
      YAcy: "",
      yacy: "",
      Ycirc: "",
      ycirc: "",
      Ycy: "",
      ycy: "",
      yen: "",
      Yfr: "",
      yfr: "",
      YIcy: "",
      yicy: "",
      Yopf: "",
      yopf: "",
      Yscr: "",
      yscr: "",
      YUcy: "",
      yucy: "",
      Yuml: "",
      yuml: "",
      Zacute: "",
      zacute: "",
      Zcaron: "",
      zcaron: "",
      Zcy: "",
      zcy: "",
      Zdot: "",
      zdot: "",
      zeetrf: "",
      ZeroWidthSpace: "",
      Zeta: "",
      zeta: "",
      Zfr: "",
      zfr: "",
      ZHcy: "",
      zhcy: "",
      zigrarr: "",
      Zopf: "",
      zopf: "",
      Zscr: "",
      zscr: "",
      zwj: "",
      zwnj: ""
    }), a.entityMap = a.HTML_ENTITIES;
  }(Sp)), Sp;
}
var Yh = {}, X0;
function ex() {
  if (X0) return Yh;
  X0 = 1;
  var a = gd().NAMESPACE, d = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, l = new RegExp("[\\-\\.0-9" + d.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), m = new RegExp("^" + d.source + l.source + "*(?::" + d.source + l.source + "*)?$"), w = 0, v = 1, g = 2, s = 3, D = 4, k = 5, M = 6, q = 7;
  function O(me, ve) {
    this.message = me, this.locator = ve, Error.captureStackTrace && Error.captureStackTrace(this, O);
  }
  O.prototype = new Error(), O.prototype.name = O.name;
  function z() {
  }
  z.prototype = {
    parse: function(me, ve, X) {
      var re = this.domBuilder;
      re.startDocument(), ze(ve, ve = {}), pe(
        me,
        ve,
        X,
        re,
        this.errorHandler
      ), re.endDocument();
    }
  };
  function pe(me, ve, X, re, xe) {
    function ye(At) {
      if (At > 65535) {
        At -= 65536;
        var Et = 55296 + (At >> 10), jt = 56320 + (At & 1023);
        return String.fromCharCode(Et, jt);
      } else
        return String.fromCharCode(At);
    }
    function Ve(At) {
      var Et = At.slice(1, -1);
      return Object.hasOwnProperty.call(X, Et) ? X[Et] : Et.charAt(0) === "#" ? ye(parseInt(Et.substr(1).replace("x", "0x"))) : (xe.error("entity not found:" + At), At);
    }
    function He(At) {
      if (At > be) {
        var Et = me.substring(be, At).replace(/&#?\w+;/g, Ve);
        nt && Ze(be), re.characters(Et, 0, At - be), be = At;
      }
    }
    function Ze(At, Et) {
      for (; At >= Je && (Et = Qe.exec(me)); )
        je = Et.index, Je = je + Et[0].length, nt.lineNumber++;
      nt.columnNumber = At - je + 1;
    }
    for (var je = 0, Je = 0, Qe = /.*(?:\r\n?|\n)|.*$/g, nt = re.locator, Q = [{ currentNSMap: ve }], _e = {}, be = 0; ; ) {
      try {
        var Ce = me.indexOf("<", be);
        if (Ce < 0) {
          if (!me.substr(be).match(/^\s*$/)) {
            var Oe = re.doc, $e = Oe.createTextNode(me.substr(be));
            Oe.appendChild($e), re.currentElement = $e;
          }
          return;
        }
        switch (Ce > be && He(Ce), me.charAt(Ce + 1)) {
          case "/":
            var Y = me.indexOf(">", Ce + 3), Ue = me.substring(Ce + 2, Y).replace(/[ \t\n\r]+$/g, ""), Ke = Q.pop();
            Y < 0 ? (Ue = me.substring(Ce + 2).replace(/[\s<].*/, ""), xe.error("end tag name: " + Ue + " is not complete:" + Ke.tagName), Y = Ce + 1 + Ue.length) : Ue.match(/\s</) && (Ue = Ue.replace(/[\s<].*/, ""), xe.error("end tag name: " + Ue + " maybe not complete"), Y = Ce + 1 + Ue.length);
            var rt = Ke.localNSMap, ot = Ke.tagName == Ue, vt = ot || Ke.tagName && Ke.tagName.toLowerCase() == Ue.toLowerCase();
            if (vt) {
              if (re.endElement(Ke.uri, Ke.localName, Ue), rt)
                for (var mt in rt)
                  Object.prototype.hasOwnProperty.call(rt, mt) && re.endPrefixMapping(mt);
              ot || xe.fatalError("end tag name: " + Ue + " is not match the current start tagName:" + Ke.tagName);
            } else
              Q.push(Ke);
            Y++;
            break;
          case "?":
            nt && Ze(Ce), Y = at(me, Ce, re);
            break;
          case "!":
            nt && Ze(Ce), Y = qe(me, Ce, re, xe);
            break;
          default:
            nt && Ze(Ce);
            var Pt = new Ie(), it = Q[Q.length - 1].currentNSMap, Y = se(me, Ce, Pt, it, Ve, xe), Kt = Pt.length;
            if (!Pt.closed && Te(me, Y, Pt.tagName, _e) && (Pt.closed = !0, X.nbsp || xe.warning("unclosed xml attribute")), nt && Kt) {
              for (var Rt = le(nt, {}), lt = 0; lt < Kt; lt++) {
                var xt = Pt[lt];
                Ze(xt.offset), xt.locator = le(nt, {});
              }
              re.locator = Rt, ee(Pt, re, it) && Q.push(Pt), re.locator = nt;
            } else
              ee(Pt, re, it) && Q.push(Pt);
            a.isHTML(Pt.uri) && !Pt.closed ? Y = fe(me, Y, Pt.tagName, Ve, re) : Y++;
        }
      } catch (At) {
        if (At instanceof O)
          throw At;
        xe.error("element parse error: " + At), Y = -1;
      }
      Y > be ? be = Y : He(Math.max(Ce, be) + 1);
    }
  }
  function le(me, ve) {
    return ve.lineNumber = me.lineNumber, ve.columnNumber = me.columnNumber, ve;
  }
  function se(me, ve, X, re, xe, ye) {
    function Ve(nt, Q, _e) {
      X.attributeNames.hasOwnProperty(nt) && ye.fatalError("Attribute " + nt + " redefined"), X.addValue(
        nt,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        Q.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, xe),
        _e
      );
    }
    for (var He, Ze, je = ++ve, Je = w; ; ) {
      var Qe = me.charAt(je);
      switch (Qe) {
        case "=":
          if (Je === v)
            He = me.slice(ve, je), Je = s;
          else if (Je === g)
            Je = s;
          else
            throw new Error("attribute equal must after attrName");
          break;
        case "'":
        case '"':
          if (Je === s || Je === v)
            if (Je === v && (ye.warning('attribute value must after "="'), He = me.slice(ve, je)), ve = je + 1, je = me.indexOf(Qe, ve), je > 0)
              Ze = me.slice(ve, je), Ve(He, Ze, ve - 1), Je = k;
            else
              throw new Error("attribute value no end '" + Qe + "' match");
          else if (Je == D)
            Ze = me.slice(ve, je), Ve(He, Ze, ve), ye.warning('attribute "' + He + '" missed start quot(' + Qe + ")!!"), ve = je + 1, Je = k;
          else
            throw new Error('attribute value must after "="');
          break;
        case "/":
          switch (Je) {
            case w:
              X.setTagName(me.slice(ve, je));
            case k:
            case M:
            case q:
              Je = q, X.closed = !0;
            case D:
            case v:
              break;
            case g:
              X.closed = !0;
              break;
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          return ye.error("unexpected end of input"), Je == w && X.setTagName(me.slice(ve, je)), je;
        case ">":
          switch (Je) {
            case w:
              X.setTagName(me.slice(ve, je));
            case k:
            case M:
            case q:
              break;
            case D:
            case v:
              Ze = me.slice(ve, je), Ze.slice(-1) === "/" && (X.closed = !0, Ze = Ze.slice(0, -1));
            case g:
              Je === g && (Ze = He), Je == D ? (ye.warning('attribute "' + Ze + '" missed quot(")!'), Ve(He, Ze, ve)) : ((!a.isHTML(re[""]) || !Ze.match(/^(?:disabled|checked|selected)$/i)) && ye.warning('attribute "' + Ze + '" missed value!! "' + Ze + '" instead!!'), Ve(Ze, Ze, ve));
              break;
            case s:
              throw new Error("attribute value missed!!");
          }
          return je;
        case "":
          Qe = " ";
        default:
          if (Qe <= " ")
            switch (Je) {
              case w:
                X.setTagName(me.slice(ve, je)), Je = M;
                break;
              case v:
                He = me.slice(ve, je), Je = g;
                break;
              case D:
                var Ze = me.slice(ve, je);
                ye.warning('attribute "' + Ze + '" missed quot(")!!'), Ve(He, Ze, ve);
              case k:
                Je = M;
                break;
            }
          else
            switch (Je) {
              case g:
                X.tagName, (!a.isHTML(re[""]) || !He.match(/^(?:disabled|checked|selected)$/i)) && ye.warning('attribute "' + He + '" missed value!! "' + He + '" instead2!!'), Ve(He, He, ve), ve = je, Je = v;
                break;
              case k:
                ye.warning('attribute space is required"' + He + '"!!');
              case M:
                Je = v, ve = je;
                break;
              case s:
                Je = D, ve = je;
                break;
              case q:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
      }
      je++;
    }
  }
  function ee(me, ve, X) {
    for (var re = me.tagName, xe = null, Qe = me.length; Qe--; ) {
      var ye = me[Qe], Ve = ye.qName, He = ye.value, nt = Ve.indexOf(":");
      if (nt > 0)
        var Ze = ye.prefix = Ve.slice(0, nt), je = Ve.slice(nt + 1), Je = Ze === "xmlns" && je;
      else
        je = Ve, Ze = null, Je = Ve === "xmlns" && "";
      ye.localName = je, Je !== !1 && (xe == null && (xe = {}, ze(X, X = {})), X[Je] = xe[Je] = He, ye.uri = a.XMLNS, ve.startPrefixMapping(Je, He));
    }
    for (var Qe = me.length; Qe--; ) {
      ye = me[Qe];
      var Ze = ye.prefix;
      Ze && (Ze === "xml" && (ye.uri = a.XML), Ze !== "xmlns" && (ye.uri = X[Ze || ""]));
    }
    var nt = re.indexOf(":");
    nt > 0 ? (Ze = me.prefix = re.slice(0, nt), je = me.localName = re.slice(nt + 1)) : (Ze = null, je = me.localName = re);
    var Q = me.uri = X[Ze || ""];
    if (ve.startElement(Q, je, re, me), me.closed) {
      if (ve.endElement(Q, je, re), xe)
        for (Ze in xe)
          Object.prototype.hasOwnProperty.call(xe, Ze) && ve.endPrefixMapping(Ze);
    } else
      return me.currentNSMap = X, me.localNSMap = xe, !0;
  }
  function fe(me, ve, X, re, xe) {
    if (/^(?:script|textarea)$/i.test(X)) {
      var ye = me.indexOf("</" + X + ">", ve), Ve = me.substring(ve + 1, ye);
      if (/[&<]/.test(Ve))
        return /^script$/i.test(X) ? (xe.characters(Ve, 0, Ve.length), ye) : (Ve = Ve.replace(/&#?\w+;/g, re), xe.characters(Ve, 0, Ve.length), ye);
    }
    return ve + 1;
  }
  function Te(me, ve, X, re) {
    var xe = re[X];
    return xe == null && (xe = me.lastIndexOf("</" + X + ">"), xe < ve && (xe = me.lastIndexOf("</" + X)), re[X] = xe), xe < ve;
  }
  function ze(me, ve) {
    for (var X in me)
      Object.prototype.hasOwnProperty.call(me, X) && (ve[X] = me[X]);
  }
  function qe(me, ve, X, re) {
    var xe = me.charAt(ve + 2);
    switch (xe) {
      case "-":
        if (me.charAt(ve + 3) === "-") {
          var ye = me.indexOf("-->", ve + 4);
          return ye > ve ? (X.comment(me, ve + 4, ye - ve - 4), ye + 3) : (re.error("Unclosed comment"), -1);
        } else
          return -1;
      default:
        if (me.substr(ve + 3, 6) == "CDATA[") {
          var ye = me.indexOf("]]>", ve + 9);
          return X.startCDATA(), X.characters(me, ve + 9, ye - ve - 9), X.endCDATA(), ye + 3;
        }
        var Ve = Ae(me, ve), He = Ve.length;
        if (He > 1 && /!doctype/i.test(Ve[0][0])) {
          var Ze = Ve[1][0], je = !1, Je = !1;
          He > 3 && (/^public$/i.test(Ve[2][0]) ? (je = Ve[3][0], Je = He > 4 && Ve[4][0]) : /^system$/i.test(Ve[2][0]) && (Je = Ve[3][0]));
          var Qe = Ve[He - 1];
          return X.startDTD(Ze, je, Je), X.endDTD(), Qe.index + Qe[0].length;
        }
    }
    return -1;
  }
  function at(me, ve, X) {
    var re = me.indexOf("?>", ve);
    if (re) {
      var xe = me.substring(ve, re).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
      return xe ? (xe[0].length, X.processingInstruction(xe[1], xe[2]), re + 2) : -1;
    }
    return -1;
  }
  function Ie() {
    this.attributeNames = {};
  }
  Ie.prototype = {
    setTagName: function(me) {
      if (!m.test(me))
        throw new Error("invalid tagName:" + me);
      this.tagName = me;
    },
    addValue: function(me, ve, X) {
      if (!m.test(me))
        throw new Error("invalid attribute:" + me);
      this.attributeNames[me] = this.length, this[this.length++] = { qName: me, value: ve, offset: X };
    },
    length: 0,
    getLocalName: function(me) {
      return this[me].localName;
    },
    getLocator: function(me) {
      return this[me].locator;
    },
    getQName: function(me) {
      return this[me].qName;
    },
    getURI: function(me) {
      return this[me].uri;
    },
    getValue: function(me) {
      return this[me].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  };
  function Ae(me, ve) {
    var X, re = [], xe = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
    for (xe.lastIndex = ve, xe.exec(me); X = xe.exec(me); )
      if (re.push(X), X[1]) return re;
  }
  return Yh.XMLReader = z, Yh.ParseError = O, Yh;
}
var Y0;
function tx() {
  if (Y0) return eh;
  Y0 = 1;
  var a = gd(), d = t1(), l = Qb(), m = ex(), w = d.DOMImplementation, v = a.NAMESPACE, g = m.ParseError, s = m.XMLReader;
  function D(se) {
    return se.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`);
  }
  function k(se) {
    this.options = se || { locator: {} };
  }
  k.prototype.parseFromString = function(se, ee) {
    var fe = this.options, Te = new s(), ze = fe.domBuilder || new q(), qe = fe.errorHandler, at = fe.locator, Ie = fe.xmlns || {}, Ae = /\/x?html?$/.test(ee), me = Ae ? l.HTML_ENTITIES : l.XML_ENTITIES;
    at && ze.setDocumentLocator(at), Te.errorHandler = M(qe, ze, at), Te.domBuilder = fe.domBuilder || ze, Ae && (Ie[""] = v.HTML), Ie.xml = Ie.xml || v.XML;
    var ve = fe.normalizeLineEndings || D;
    return se && typeof se == "string" ? Te.parse(
      ve(se),
      Ie,
      me
    ) : Te.errorHandler.error("invalid doc source"), ze.doc;
  };
  function M(se, ee, fe) {
    if (!se) {
      if (ee instanceof q)
        return ee;
      se = ee;
    }
    var Te = {}, ze = se instanceof Function;
    fe = fe || {};
    function qe(at) {
      var Ie = se[at];
      !Ie && ze && (Ie = se.length == 2 ? function(Ae) {
        se(at, Ae);
      } : se), Te[at] = Ie && function(Ae) {
        Ie("[xmldom " + at + "]	" + Ae + z(fe));
      } || function() {
      };
    }
    return qe("warning"), qe("error"), qe("fatalError"), Te;
  }
  function q() {
    this.cdata = !1;
  }
  function O(se, ee) {
    ee.lineNumber = se.lineNumber, ee.columnNumber = se.columnNumber;
  }
  q.prototype = {
    startDocument: function() {
      this.doc = new w().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
    },
    startElement: function(se, ee, fe, Te) {
      var ze = this.doc, qe = ze.createElementNS(se, fe || ee), at = Te.length;
      le(this, qe), this.currentElement = qe, this.locator && O(this.locator, qe);
      for (var Ie = 0; Ie < at; Ie++) {
        var se = Te.getURI(Ie), Ae = Te.getValue(Ie), fe = Te.getQName(Ie), me = ze.createAttributeNS(se, fe);
        this.locator && O(Te.getLocator(Ie), me), me.value = me.nodeValue = Ae, qe.setAttributeNode(me);
      }
    },
    endElement: function(se, ee, fe) {
      var Te = this.currentElement;
      Te.tagName, this.currentElement = Te.parentNode;
    },
    startPrefixMapping: function(se, ee) {
    },
    endPrefixMapping: function(se) {
    },
    processingInstruction: function(se, ee) {
      var fe = this.doc.createProcessingInstruction(se, ee);
      this.locator && O(this.locator, fe), le(this, fe);
    },
    ignorableWhitespace: function(se, ee, fe) {
    },
    characters: function(se, ee, fe) {
      if (se = pe.apply(this, arguments), se) {
        if (this.cdata)
          var Te = this.doc.createCDATASection(se);
        else
          var Te = this.doc.createTextNode(se);
        this.currentElement ? this.currentElement.appendChild(Te) : /^\s*$/.test(se) && this.doc.appendChild(Te), this.locator && O(this.locator, Te);
      }
    },
    skippedEntity: function(se) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    setDocumentLocator: function(se) {
      (this.locator = se) && (se.lineNumber = 0);
    },
    //LexicalHandler
    comment: function(se, ee, fe) {
      se = pe.apply(this, arguments);
      var Te = this.doc.createComment(se);
      this.locator && O(this.locator, Te), le(this, Te);
    },
    startCDATA: function() {
      this.cdata = !0;
    },
    endCDATA: function() {
      this.cdata = !1;
    },
    startDTD: function(se, ee, fe) {
      var Te = this.doc.implementation;
      if (Te && Te.createDocumentType) {
        var ze = Te.createDocumentType(se, ee, fe);
        this.locator && O(this.locator, ze), le(this, ze), this.doc.doctype = ze;
      }
    },
    /**
     * @see org.xml.sax.ErrorHandler
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(se) {
      console.warn("[xmldom warning]	" + se, z(this.locator));
    },
    error: function(se) {
      console.error("[xmldom error]	" + se, z(this.locator));
    },
    fatalError: function(se) {
      throw new g(se, this.locator);
    }
  };
  function z(se) {
    if (se)
      return `
@` + (se.systemId || "") + "#[line:" + se.lineNumber + ",col:" + se.columnNumber + "]";
  }
  function pe(se, ee, fe) {
    return typeof se == "string" ? se.substr(ee, fe) : se.length >= ee + fe || ee ? new java.lang.String(se, ee, fe) + "" : se;
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(se) {
    q.prototype[se] = function() {
      return null;
    };
  });
  function le(se, ee) {
    se.currentElement ? se.currentElement.appendChild(ee) : se.doc.appendChild(ee);
  }
  return eh.__DOMHandler = q, eh.normalizeLineEndings = D, eh.DOMParser = k, eh;
}
var J0;
function ix() {
  if (J0) return Qc;
  J0 = 1;
  var a = t1();
  return Qc.DOMImplementation = a.DOMImplementation, Qc.XMLSerializer = a.XMLSerializer, Qc.DOMParser = tx().DOMParser, Qc;
}
(function(a, d) {
  var l = function() {
    var m = /\s*/g, w = /^\s*|\s*$/g, v = /\s+/;
    function g(me) {
      if (!me || !me.length) return 0;
      for (var ve = 0, X = 0; ve < me.length; ve++)
        X = (X << 5) - X + me.charCodeAt(ve) | 0;
      return X;
    }
    function s(me, ve) {
      return me.getElementsByTagName(ve);
    }
    function D(me, ve) {
      return me.getAttribute(ve);
    }
    function k(me, ve) {
      return parseFloat(D(me, ve));
    }
    function M(me, ve) {
      var X = s(me, ve);
      return X.length ? X[0] : null;
    }
    function q(me) {
      return me.normalize && me.normalize(), me;
    }
    function O(me) {
      for (var ve = 0, X = []; ve < me.length; ve++)
        X[ve] = parseFloat(me[ve]);
      return X;
    }
    function z(me) {
      return me && q(me), me && me.textContent || "";
    }
    function pe(me, ve) {
      var X = {}, re, xe;
      for (xe = 0; xe < ve.length; xe++)
        re = M(me, ve[xe]), re && (X[ve[xe]] = z(re));
      return X;
    }
    function le(me, ve) {
      for (var X in ve) me[X] = ve[X];
    }
    function se(me) {
      return O(me.replace(m, "").split(","));
    }
    function ee(me) {
      for (var ve = me.replace(w, "").split(v), X = [], re = 0; re < ve.length; re++)
        X.push(se(ve[re]));
      return X;
    }
    function fe(me) {
      var ve = [k(me, "lon"), k(me, "lat")], X = M(me, "ele"), re = M(me, "gpxtpx:hr") || M(me, "hr"), xe = M(me, "time"), ye;
      return X && (ye = parseFloat(z(X)), isNaN(ye) || ve.push(ye)), {
        coordinates: ve,
        time: xe ? z(xe) : null,
        heartRate: re ? parseFloat(z(re)) : null
      };
    }
    function Te() {
      return {
        type: "FeatureCollection",
        features: []
      };
    }
    var ze;
    if (typeof XMLSerializer < "u")
      ze = new XMLSerializer();
    else {
      var qe = typeof process == "object" && !process.browser, at = typeof Titanium == "object";
      if (qe || at)
        ze = new (ix()).XMLSerializer();
      else
        throw new Error("Unable to initialize serializer");
    }
    function Ie(me) {
      return me.xml !== void 0 ? me.xml : ze.serializeToString(me);
    }
    var Ae = {
      kml: function(me) {
        for (var ve = Te(), X = {}, re = {}, xe = {}, ye = ["Polygon", "LineString", "Point", "Track", "gx:Track"], Ve = s(me, "Placemark"), He = s(me, "Style"), Ze = s(me, "StyleMap"), je = 0; je < He.length; je++) {
          var Je = g(Ie(He[je])).toString(16);
          X["#" + D(He[je], "id")] = Je, re[Je] = He[je];
        }
        for (var Qe = 0; Qe < Ze.length; Qe++) {
          X["#" + D(Ze[Qe], "id")] = g(Ie(Ze[Qe])).toString(16);
          for (var nt = s(Ze[Qe], "Pair"), Q = {}, _e = 0; _e < nt.length; _e++)
            Q[z(M(nt[_e], "key"))] = z(M(nt[_e], "styleUrl"));
          xe["#" + D(Ze[Qe], "id")] = Q;
        }
        for (var be = 0; be < Ve.length; be++)
          ve.features = ve.features.concat(Ke(Ve[be]));
        function Ce(rt) {
          var ot, vt;
          return rt = rt || "", rt.substr(0, 1) === "#" && (rt = rt.substr(1)), (rt.length === 6 || rt.length === 3) && (ot = rt), rt.length === 8 && (vt = parseInt(rt.substr(0, 2), 16) / 255, ot = "#" + rt.substr(6, 2) + rt.substr(4, 2) + rt.substr(2, 2)), [ot, isNaN(vt) ? void 0 : vt];
        }
        function Oe(rt) {
          return O(rt.split(" "));
        }
        function $e(rt) {
          var ot = s(rt, "coord"), vt = [], mt = [];
          ot.length === 0 && (ot = s(rt, "gx:coord"));
          for (var Pt = 0; Pt < ot.length; Pt++) vt.push(Oe(z(ot[Pt])));
          for (var it = s(rt, "when"), Y = 0; Y < it.length; Y++) mt.push(z(it[Y]));
          return {
            coords: vt,
            times: mt
          };
        }
        function Ue(rt) {
          var ot, vt, mt, Pt, it, Y = [], Kt = [];
          if (M(rt, "MultiGeometry"))
            return Ue(M(rt, "MultiGeometry"));
          if (M(rt, "MultiTrack"))
            return Ue(M(rt, "MultiTrack"));
          if (M(rt, "gx:MultiTrack"))
            return Ue(M(rt, "gx:MultiTrack"));
          for (mt = 0; mt < ye.length; mt++)
            if (vt = s(rt, ye[mt]), vt) {
              for (Pt = 0; Pt < vt.length; Pt++)
                if (ot = vt[Pt], ye[mt] === "Point")
                  Y.push({
                    type: "Point",
                    coordinates: se(z(M(ot, "coordinates")))
                  });
                else if (ye[mt] === "LineString")
                  Y.push({
                    type: "LineString",
                    coordinates: ee(z(M(ot, "coordinates")))
                  });
                else if (ye[mt] === "Polygon") {
                  var Rt = s(ot, "LinearRing"), lt = [];
                  for (it = 0; it < Rt.length; it++)
                    lt.push(ee(z(M(Rt[it], "coordinates"))));
                  Y.push({
                    type: "Polygon",
                    coordinates: lt
                  });
                } else if (ye[mt] === "Track" || ye[mt] === "gx:Track") {
                  var xt = $e(ot);
                  Y.push({
                    type: "LineString",
                    coordinates: xt.coords
                  }), xt.times.length && Kt.push(xt.times);
                }
            }
          return {
            geoms: Y,
            coordTimes: Kt
          };
        }
        function Ke(rt) {
          var ot = Ue(rt), vt, mt = {}, Pt = z(M(rt, "name")), it = z(M(rt, "address")), Y = z(M(rt, "styleUrl")), Kt = z(M(rt, "description")), Rt = M(rt, "TimeSpan"), lt = M(rt, "TimeStamp"), xt = M(rt, "ExtendedData"), At = M(rt, "LineStyle"), Et = M(rt, "PolyStyle"), jt = M(rt, "visibility");
          if (!ot.geoms.length) return [];
          if (Pt && (mt.name = Pt), it && (mt.address = it), Y) {
            Y[0] !== "#" && (Y = "#" + Y), mt.styleUrl = Y, X[Y] && (mt.styleHash = X[Y]), xe[Y] && (mt.styleMapHash = xe[Y], mt.styleHash = X[xe[Y].normal]);
            var ni = re[mt.styleHash];
            if (ni) {
              At || (At = M(ni, "LineStyle")), Et || (Et = M(ni, "PolyStyle"));
              var ii = M(ni, "IconStyle");
              if (ii) {
                var yi = M(ii, "Icon");
                if (yi) {
                  var xi = z(M(yi, "href"));
                  xi && (mt.icon = xi);
                }
              }
            }
          }
          if (Kt && (mt.description = Kt), Rt) {
            var pt = z(M(Rt, "begin")), Jt = z(M(Rt, "end"));
            mt.timespan = { begin: pt, end: Jt };
          }
          if (lt && (mt.timestamp = z(M(lt, "when"))), At) {
            var ai = Ce(z(M(At, "color"))), kt = ai[0], Zi = ai[1], ft = parseFloat(z(M(At, "width")));
            kt && (mt.stroke = kt), isNaN(Zi) || (mt["stroke-opacity"] = Zi), isNaN(ft) || (mt["stroke-width"] = ft);
          }
          if (Et) {
            var ri = Ce(z(M(Et, "color"))), Lt = ri[0], Si = ri[1], Gi = z(M(Et, "fill")), zt = z(M(Et, "outline"));
            Lt && (mt.fill = Lt), isNaN(Si) || (mt["fill-opacity"] = Si), Gi && (mt["fill-opacity"] = Gi === "1" ? mt["fill-opacity"] || 1 : 0), zt && (mt["stroke-opacity"] = zt === "1" ? mt["stroke-opacity"] || 1 : 0);
          }
          if (xt) {
            var cr = s(xt, "Data"), Ni = s(xt, "SimpleData");
            for (vt = 0; vt < cr.length; vt++)
              mt[cr[vt].getAttribute("name")] = z(M(cr[vt], "value"));
            for (vt = 0; vt < Ni.length; vt++)
              mt[Ni[vt].getAttribute("name")] = z(Ni[vt]);
          }
          jt && (mt.visibility = z(jt)), ot.coordTimes.length && (mt.coordTimes = ot.coordTimes.length === 1 ? ot.coordTimes[0] : ot.coordTimes);
          var ie = {
            type: "Feature",
            geometry: ot.geoms.length === 1 ? ot.geoms[0] : {
              type: "GeometryCollection",
              geometries: ot.geoms
            },
            properties: mt
          };
          return D(rt, "id") && (ie.id = D(rt, "id")), [ie];
        }
        return ve;
      },
      gpx: function(me) {
        var ve, X = s(me, "trk"), re = s(me, "rte"), xe = s(me, "wpt"), ye = Te(), Ve;
        for (ve = 0; ve < X.length; ve++)
          Ve = je(X[ve]), Ve && ye.features.push(Ve);
        for (ve = 0; ve < re.length; ve++)
          Ve = Je(re[ve]), Ve && ye.features.push(Ve);
        for (ve = 0; ve < xe.length; ve++)
          ye.features.push(Qe(xe[ve]));
        function He(_e, be) {
          for (var Ce = 0; Ce < be; Ce++)
            _e.push(null);
          return _e;
        }
        function Ze(_e, be) {
          var Ce = s(_e, be), Oe = [], $e = [], Ue = [], Ke = Ce.length;
          if (Ke < 2) return {};
          for (var rt = 0; rt < Ke; rt++) {
            var ot = fe(Ce[rt]);
            Oe.push(ot.coordinates), ot.time && $e.push(ot.time), (ot.heartRate || Ue.length) && (Ue.length || He(Ue, rt), Ue.push(ot.heartRate || null));
          }
          return {
            line: Oe,
            times: $e,
            heartRates: Ue
          };
        }
        function je(_e) {
          for (var be = s(_e, "trkseg"), Ce = [], Oe = [], $e = [], Ue, Ke = 0; Ke < be.length; Ke++)
            if (Ue = Ze(be[Ke], "trkpt"), Ue && (Ue.line && Ce.push(Ue.line), Ue.times && Ue.times.length && Oe.push(Ue.times), $e.length || Ue.heartRates && Ue.heartRates.length)) {
              if (!$e.length)
                for (var rt = 0; rt < Ke; rt++)
                  $e.push(He([], Ce[rt].length));
              Ue.heartRates && Ue.heartRates.length ? $e.push(Ue.heartRates) : $e.push(He([], Ue.line.length || 0));
            }
          if (Ce.length !== 0) {
            var ot = Q(_e);
            return le(ot, nt(M(_e, "extensions"))), Oe.length && (ot.coordTimes = Ce.length === 1 ? Oe[0] : Oe), $e.length && (ot.heartRates = Ce.length === 1 ? $e[0] : $e), {
              type: "Feature",
              properties: ot,
              geometry: {
                type: Ce.length === 1 ? "LineString" : "MultiLineString",
                coordinates: Ce.length === 1 ? Ce[0] : Ce
              }
            };
          }
        }
        function Je(_e) {
          var be = Ze(_e, "rtept");
          if (be.line) {
            var Ce = Q(_e);
            le(Ce, nt(M(_e, "extensions")));
            var Oe = {
              type: "Feature",
              properties: Ce,
              geometry: {
                type: "LineString",
                coordinates: be.line
              }
            };
            return Oe;
          }
        }
        function Qe(_e) {
          var be = Q(_e);
          return le(be, pe(_e, ["sym"])), {
            type: "Feature",
            properties: be,
            geometry: {
              type: "Point",
              coordinates: fe(_e).coordinates
            }
          };
        }
        function nt(_e) {
          var be = {};
          if (_e) {
            var Ce = M(_e, "line");
            if (Ce) {
              var Oe = z(M(Ce, "color")), $e = parseFloat(z(M(Ce, "opacity"))), Ue = parseFloat(z(M(Ce, "width")));
              Oe && (be.stroke = Oe), isNaN($e) || (be["stroke-opacity"] = $e), isNaN(Ue) || (be["stroke-width"] = Ue * 96 / 25.4);
            }
          }
          return be;
        }
        function Q(_e) {
          var be = pe(_e, ["name", "cmt", "desc", "type", "time", "keywords"]), Ce = s(_e, "link");
          Ce.length && (be.links = []);
          for (var Oe = 0, $e; Oe < Ce.length; Oe++)
            $e = { href: D(Ce[Oe], "href") }, le($e, pe(Ce[Oe], ["text", "type"])), be.links.push($e);
          return be;
        }
        return ye;
      }
    };
    return Ae;
  }();
  a.exports = l;
})(e1);
var rx = e1.exports;
const nx = zv(bc.addProtocol, {
  tileUrl: "https://tiles.gsj.jp/tiles/elev/mixed/{z}/{y}/{x}.png",
  maxzoom: 17,
  attribution: '<a href="https://gbank.gsj.jp/seamless/elev/"></a>'
}), vc = new bc.Map({
  container: "map",
  center: [139.767125, 35.681236],
  zoom: 10,
  pitch: 70,
  maplibreLogo: !0,
  style: {
    version: 8,
    sources: {
      terrain: nx,
      pale: {
        type: "raster",
        tiles: ["https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png"],
        tileSize: 256,
        attribution: "(https://maps.gsi.go.jp/development/ichiran.html)"
      },
      photo: {
        type: "raster",
        tiles: ["https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg"],
        tileSize: 256,
        attribution: "(https://maps.gsi.go.jp/development/ichiran.html)"
      }
    },
    terrain: {
      source: "terrain",
      exaggeration: 1.2
    },
    layers: [
      {
        id: "pale",
        type: "raster",
        source: "pale",
        layout: {
          visibility: "none"
        }
      },
      {
        id: "photo",
        type: "raster",
        source: "photo"
      }
    ]
  }
  // style: 'https://gsi-cyberjapan.github.io/gsivectortile-mapbox-gl-js/std.json',
});
vc.addControl(
  new bc.NavigationControl({
    visualizePitch: !0,
    showZoom: !0,
    showCompass: !0
  }),
  "bottom-right"
);
vc.addControl(
  new bc.ScaleControl()
);
vc.addControl(
  new bc.TerrainControl({
    source: "terrain",
    exaggeration: 1
  })
);
const ax = new Kb({
  PageSize: Iu.A4,
  PageOrientation: rh.Landscape,
  Format: Sl.PNG,
  DPI: Bp[400],
  Crosshair: !1,
  PrintableArea: !0,
  Local: "ja",
  Filename: "terrain"
});
vc.addControl(ax, "top-right");
function sx(a) {
  Array.from(a.target.files).forEach((l) => {
    console.log({ file: l });
    const m = new FileReader();
    m.onload = function(w) {
      let v = w.target.result;
      console.log({ str: v });
      let g;
      if (l.name.endsWith(".kml")) {
        let D = new DOMParser().parseFromString(v, "text/xml");
        console.log({ kml: D }), g = rx.kml(D);
      } else
        g = JSON.parse(v);
      console.log({ geoJSONcontent: g });
      const s = (/* @__PURE__ */ new Date()).getTime();
      vc.addSource("uploaded" + s, {
        type: "geojson",
        data: g
      }), vc.addLayer({
        id: "uploaded" + s,
        type: "line",
        source: "uploaded" + s,
        layout: {
          "line-join": "round",
          "line-cap": "round"
        },
        paint: {
          "line-color": "red",
          "line-width": 3
        }
      });
    }, m.readAsText(l, "UTF-8");
  });
}
document.getElementById("file").addEventListener("change", sx, !1);
export {
  ur as p
};
